<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Dispatching Operations of Tagged Types</TITLE>
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    DIV.paranum {position: absolute; font-family: Arial, Helvetica, sans-serif; left: 0.5em; top: auto}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    DIV.Normal {font-family: "Times New Roman", Times, serif; margin-bottom: 0.6em}
    DIV.Wide {font-family: "Times New Roman", Times, serif; margin-top: 0.6em; margin-bottom: 0.6em}
    DIV.Annotations {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-bottom: 0.6em}
    DIV.WideAnnotations {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-top: 0.6em; margin-bottom: 0.6em}
    DIV.Index {font-family: "Times New Roman", Times, serif}
    DIV.SyntaxSummary {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-bottom: 0.4em}
    DIV.Notes {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-bottom: 0.6em}
    DIV.NotesHeader {font-family: "Times New Roman", Times, serif; margin-left: 2.0em}
    DIV.SyntaxIndented {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-bottom: 0.4em}
    DIV.Indented {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-bottom: 0.6em}
    DIV.CodeIndented {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-bottom: 0.6em}
    DIV.SmallIndented {font-family: "Times New Roman", Times, serif; margin-left:  10.0em; margin-bottom: 0.6em}
    DIV.SmallCodeIndented {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-bottom: 0.6em}
    DIV.Examples {font-family: "Courier New", monospace; margin-left: 2.0em; margin-bottom: 0.6em}
    DIV.SmallExamples {font-family: "Courier New", monospace; font-size: 80%; margin-left: 7.5em; margin-bottom: 0.6em}
    DIV.IndentedExamples {font-family: "Courier New", monospace; margin-left: 8.0em; margin-bottom: 0.6em}
    DIV.SmallIndentedExamples {font-family: "Courier New", monospace; font-size: 80%; margin-left:  15.0em; margin-bottom: 0.6em}
    UL.Bulleted {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.SmallBulleted {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.NestedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-right: 4.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.SmallNestedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-right: 8.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.IndentedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-right: 8.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.CodeIndentedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.CodeIndentedNestedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-right: 8.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.SyntaxIndentedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-right: 4.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.NotesBulleted {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-right: 4.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.NotesNestedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    DL.Hanging {font-family: "Times New Roman", Times, serif; margin-top: 0em; margin-bottom: 0.6em}
    DD.Hanging {margin-left: 6.0em}
    DL.IndentedHanging {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-top: 0em; margin-bottom: 0.6em}
    DD.IndentedHanging {margin-left: 2.0em}
    DL.HangingInBulleted {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    DD.HangingInBulleted {margin-left: 4.0em}
    DL.SmallHanging {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-top: 0em; margin-bottom: 0.6em}
    DD.SmallHanging {margin-left: 7.5em}
    DL.SmallIndentedHanging {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-top: 0em; margin-bottom: 0.6em}
    DD.SmallIndentedHanging {margin-left: 2.0em}
    DL.SmallHangingInBulleted {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    DD.SmallHangingInBulleted {margin-left: 5.0em}
    DL.Enumerated {font-family: "Times New Roman", Times, serif; margin-right: 0.0em; margin-top: 0em; margin-bottom: 0.5em}
    DD.Enumerated {margin-left: 2.0em}
    DL.SmallEnumerated {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-right: 4.0em; margin-top: 0em; margin-bottom: 0.5em}
    DD.SmallEnumerated {margin-left: 2.5em}
    DL.NestedEnumerated {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    DL.SmallNestedEnumerated {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">
<P><A HREF="AA-TOC.html">Contents</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-0-29.html">Index</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-SRCH.html">Search</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-3-9-1.html">Previous</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-3-9-3.html">Next</A></P>
<HR>
<H1> 3.9.2 Dispatching Operations of Tagged Types</H1>
<DIV Class="Paranum"><FONT SIZE=-2>1</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>dispatching operation</I>
[distributed]}</FONT> <A NAME="I2092"></A><FONT SIZE="-1">{<I>dispatching
call (on a dispatching operation)</I>}</FONT> <A NAME="I2093"></A><FONT SIZE="-1">{<I>nondispatching
call (on a dispatching operation)</I>}</FONT> <A NAME="I2094"></A><FONT SIZE="-1">{<I>statically
determined tag</I>}</FONT> <A NAME="I2095"></A><FONT SIZE="-1">{<I>dynamically
determined tag</I>}</FONT> <A NAME="I2096"></A><FONT SIZE="-1">{<I>polymorphism</I>}</FONT>
<A NAME="I2097"></A><FONT SIZE="-1">{<I>run-time polymorphism</I>}</FONT>
<A NAME="I2098"></A><FONT SIZE="-1">{<I>controlling tag (for a call on
a dispatching operation)</I>}</FONT> <A NAME="I2099"></A>The primitive
subprograms of a tagged type are called <I>dispatching operations</I>.
[A dispatching operation can be called using a statically determined
<I>controlling</I> tag, in which case the body to be executed is determined
at compile time. Alternatively, the controlling tag can be dynamically
determined, in which case the call <I>dispatches</I> to a body that is
determined at run time;] such a call is termed a <I>dispatching call</I>.
[As explained below, the properties of the operands and the context of
a particular call on a dispatching operation determine how the controlling
tag is determined, and hence whether or not the call is a dispatching
call. Run-time polymorphism is achieved when a dispatching operation
is called by a dispatching call.] <FONT SIZE="-1">{<I>object-oriented
programming (OOP): See dispatching operations of tagged types</I>}</FONT>
<A NAME="I2100"></A><FONT SIZE="-1">{<I>OOP (object-oriented programming):
See dispatching operations of tagged types</I>}</FONT> <A NAME="I2101"></A><FONT SIZE="-1">{<I>message:
See dispatching call</I>}</FONT> <A NAME="I2102"></A><FONT SIZE="-1">{<I>method:
See dispatching subprogram</I>}</FONT> <A NAME="I2103"></A><FONT SIZE="-1">{<I>virtual
function: See dispatching subprogram</I>}</FONT> <A NAME="I2104"></A></DIV>

<H4 ALIGN=CENTER>Language Design Principles</H4>
<DIV Class="Paranum"><FONT SIZE=-2>1.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">The controlling tag determination
rules are analogous to the overload resolution rules, except they deal
with run-time type identification (tags) rather than compile-time type
resolution. As with overload resolution, controlling tag determination
may depend on operands or result context. </FONT></DIV>

<H4 ALIGN=CENTER>Static Semantics</H4>
<DIV Class="Paranum"><FONT SIZE=-2>2</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>call on a dispatching operation</I>}</FONT>
<A NAME="I2105"></A><FONT SIZE="-1">{<I>dispatching operation</I>}</FONT>
<A NAME="I2106"></A>A <I>call on a dispatching operation</I> is a call
whose <FONT FACE="Arial, Helvetica">name</FONT> or <FONT FACE="Arial, Helvetica">prefix</FONT>
denotes the declaration of a primitive subprogram of a tagged type, that
is, a dispatching operation. <FONT SIZE="-1">{<I>controlling operand</I>}</FONT>
<A NAME="I2107"></A>A <I>controlling operand</I> in a call on a dispatching
operation of a tagged type <I>T</I> is one whose corresponding formal
parameter is of type <I>T</I> or is of an anonymous access type with
designated type <I>T</I>; <FONT SIZE="-1">{<I>controlling formal parameter</I>}</FONT>
<A NAME="I2108"></A>the corresponding formal parameter is called a <I>controlling
formal parameter</I>. If the controlling formal parameter is an access
parameter, the controlling operand is the object designated by the actual
parameter, rather than the actual parameter itself. <FONT SIZE="-1">{<I>controlling
result</I>}</FONT> <A NAME="I2109"></A>If the call is to a (primitive)
function with result type <I>T</I>, then the call has a <I>controlling
result</I> -- the context of the call can control the dispatching. </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>2.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>This definition
implies that a call through the dereference of an access-to-subprogram
value is never considered a call on a dispatching operation. Note also
that if the <FONT FACE="Arial, Helvetica">prefix</FONT> denotes a <FONT FACE="Arial, Helvetica">renaming_declaration</FONT>,
the place where the renaming occurs determines whether it is primitive;
the thing being renamed is irrelevant. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>3</FONT></DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;&nbsp;&nbsp;A <FONT FACE="Arial, Helvetica">name</FONT>
or expression of a tagged type is either <I>statically</I> tagged, <I>dynamically</I>
tagged, or <I>tag indeterminate</I>, according to whether, when used
as a controlling operand, the tag that controls dispatching is determined
statically by the operand's (specific) type, dynamically by its tag at
run time, or from context. A <FONT FACE="Arial, Helvetica">qualified_expression</FONT>
or parenthesized expression is statically, dynamically, or indeterminately
tagged according to its operand. For other kinds of <FONT FACE="Arial, Helvetica">name</FONT>s
and expressions, this is determined as follows: </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>4</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC><FONT SIZE="-1">{<I>statically tagged</I>}</FONT>
<A NAME="I2110"></A>The <FONT FACE="Arial, Helvetica">name</FONT> or
expression is <I>statically tagged</I> if it is of a specific tagged
type and, if it is a call with a controlling result, it has at least
one statically tagged controlling operand; </LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>4.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Discussion: </B>It is illegal
to have both statically tagged and dynamically tagged controlling operands
in the same call -- see below.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>5</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC><FONT SIZE="-1">{<I>dynamically tagged</I>}</FONT>
<A NAME="I2111"></A>The <FONT FACE="Arial, Helvetica">name</FONT> or
expression is <I>dynamically tagged</I> if it is of a class-wide type,
or it is a call with a controlling result and at least one dynamically
tagged controlling operand;</LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>6</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC><FONT SIZE="-1">{<I>tag indeterminate</I>}</FONT>
<A NAME="I2112"></A>The <FONT FACE="Arial, Helvetica">name</FONT> or
expression is <I>tag indeterminate</I> if it is a call with a controlling
result, all of whose controlling operands (if any) are tag indeterminate.
</LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>7/1</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I><A HREF="defect1.html#8652/0010">8652/0010</A></I>}
[A <FONT FACE="Arial, Helvetica">type_conversion</FONT> is statically
or dynamically tagged according to whether the type determined by the
<FONT FACE="Arial, Helvetica">subtype_mark</FONT> is specific or class-wide,
respectively.] <U>For an object that is designated by an expression whose
expected type is an anonymous access-to-specific tagged type, the object
is dynamically tagged if the expression, ignoring enclosing parentheses,
is of the form X'Access, where X is of a class-wide type, or is of the
form <B>new</B> T'(...), where T denotes a class-wide subtype. Otherwise,
the object</U> <S>For a controlling operand that is designated by an
actual parameter, the controlling operand</S> is statically or dynamically
tagged according to whether the designated type <U>of the type of the
expression</U> <S>of the actual parameter</S> is specific or class-wide,
respectively. </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>7.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>A <FONT FACE="Arial, Helvetica">type_conversion</FONT>
is never tag indeterminate, even if its operand is. A designated object
is never tag indeterminate.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>7.a.1/1</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">{<I><A HREF="defect1.html#8652/0010">8652/0010</A></I>}
<U>Allocators and access attributes of specific types can be used as
the controlling parameters of dispatching calls.</U>  </FONT></DIV>

<H4 ALIGN=CENTER>Legality Rules</H4>
<DIV Class="Paranum"><FONT SIZE=-2>8</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;A call on a dispatching operation shall not have
both dynamically tagged and statically tagged controlling operands. </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>8.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Reason: </B>This restriction
is intended to minimize confusion between whether the dynamically tagged
operands are implicitly converted to, or tag checked against the specific
type of the statically tagged operand(s). </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>9/1</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I><A HREF="defect1.html#8652/0010">8652/0010</A></I>}
If the expected type for an expression or <FONT FACE="Arial, Helvetica">name</FONT>
is some specific tagged type, then the expression or <FONT FACE="Arial, Helvetica">name</FONT>
shall not be dynamically tagged unless it is a controlling operand in
a call on a dispatching operation. Similarly, if the expected type for
an expression is an anonymous access-to-specific tagged type, then the
<U>object designated by the expression shall not be dynamically tagged
unless it is</U> <S>expression shall not be of an access-to-class-wide
type unless it designates</S> a controlling operand in a call on a dispatching
operation. </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>9.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Reason: </B>This prevents
implicit &quot;truncation&quot; of a dynamically-tagged value to the
specific type of the target object/formal. An explicit conversion is
required to request this truncation. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>9.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>This rule
applies to all expressions or <FONT FACE="Arial, Helvetica">name</FONT>s
with a specific expected type, not just those that are actual parameters
to a dispatching call. This rule does not apply to a membership test
whose <FONT FACE="Arial, Helvetica">expression</FONT> is class-wide,
since any type that covers the tested type is explicitly allowed. See
<A HREF="AA-4-5-2.html">4.5.2</A>. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>10/1</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I><A HREF="defect1.html#8652/0011">8652/0011</A></I>}
In the declaration of a dispatching operation of a tagged type, everywhere
a subtype of the tagged type appears as a subtype of the profile (see
<A HREF="AA-6-1.html">6.1</A>), it shall statically match the first subtype
of the tagged type. <FONT SIZE="-1">{<I>statically matching (required)</I>
[partial]}</FONT> <A NAME="I2113"></A>If the dispatching operation overrides
an inherited subprogram, it shall be subtype conformant with the inherited
subprogram. <FONT SIZE="-1">{<I>subtype conformance (required)</I>}</FONT>
<A NAME="I2114"></A><U>The convention of an inherited or overriding dispatching
operation is the convention of the corresponding primitive operation
of the parent type. An explicitly declared</U> <S>A</S> dispatching operation
shall not be of convention Intrinsic.<S> If a dispatching operation overrides
the predefined equals operator, then it shall be of convention Ada [(either
explicitly or by default -- see <A HREF="AA-6-3-1.html">6.3.1</A>)].</S>
</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>10.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Reason: </B>These rules ensure
that constraint checks can be performed by the caller in a dispatching
call, and parameter passing conventions match up properly. A special
rule on aggregates prevents values of a tagged type from being created
that are outside of its first subtype. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>11</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;The <FONT FACE="Arial, Helvetica">default_expression</FONT>
for a controlling formal parameter of a dispatching operation shall be
tag indeterminate. A controlling formal parameter that is an access parameter
shall not have a <FONT FACE="Arial, Helvetica">default_expression</FONT>.
</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>11.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Reason: </B>The first part
ensures that the <FONT FACE="Arial, Helvetica">default_expression</FONT>
always produces the &quot;correct&quot; tag when called with or without
dispatching, or when inherited by a descendant. If it were statically
tagged, the default would be useless for a dispatching call; if it were
dynamically tagged, the default would be useless for a nondispatching
call.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>11.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">The second part is consistent
with the first part, since designated objects are never tag-indeterminate.
</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>12</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;A given subprogram shall not be a dispatching
operation of two or more distinct tagged types. </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>12.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Reason: </B>This restriction
minimizes confusion since multiple dispatching is not provided. The normal
solution is to replace all but one of the tagged types with their class-wide
types. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>12.a.1/1</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>{<I><A HREF="defect2.html#8652/0098">8652/0098</A></I>}
<U>This restriction applies even if the partial view (see <A HREF="AA-7-3.html">7.3</A>)
of one or both of the types is untagged. This follows from the definition
of dispatching operation: the operation is a dispatching operation anywhere
the full views of the (tagged) types are visible.</U>  </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>13</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;The explicit declaration of a primitive subprogram
of a tagged type shall occur before the type is frozen (see <A HREF="AA-13-14.html">13.14</A>).
[For example, new dispatching operations cannot be added after objects
or values of the type exist, nor after deriving a record extension from
it, nor after a body.]</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>13.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Reason: </B>This rule is
needed because (1) we don't want people dispatching to things that haven't
been declared yet, and (2) we want to allow tagged type descriptors to
be static (allocated statically, and initialized to link-time-known symbols).
Suppose T2 inherits primitive P from T1, and then overrides P. Suppose
P is called <I>before</I> the declaration of the overriding P. What should
it dispatch to? If the answer is the new P, we've violated the first
principle above. If the answer is the old P, we've violated the second
principle. (A call to the new one necessarily raises Program_Error, but
that's beside the point.)</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>13.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">Note that a call upon a dispatching
operation of type <I>T</I> will freeze <I>T</I>.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>13.c</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">We considered applying this
rule to all derived types, for uniformity. However, that would be upward
incompatible, so we rejected the idea. As in Ada 83, for an untagged
type, the above call upon P will call the old P (which is arguably confusing).
</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>13.d</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Implementation Note: </B>Because
of this rule, the type descriptor can be created (presumably containing
linker symbols pointing at the not-yet-compiled bodies) at the first
freezing point of the type. It also prevents, for a tagged type declared
in a <FONT FACE="Arial, Helvetica">package_specification</FONT>, overriding
in the body or by a child subprogram. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>13.e</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>A consequence
is that for a <FONT FACE="Arial, Helvetica">derived_type_declaration</FONT>
in a <FONT FACE="Arial, Helvetica">declarative_part</FONT>, only the
first primitive subprogram can be declared by a <FONT FACE="Arial, Helvetica">subprogram_body</FONT>.
</FONT></DIV>

<H4 ALIGN=CENTER>Dynamic Semantics</H4>
<DIV Class="Paranum"><FONT SIZE=-2>14</FONT></DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>execution
(call on a dispatching operation)</I> [partial]}</FONT> <A NAME="I2115"></A><FONT SIZE="-1">{<I>controlling
tag value</I>}</FONT> <A NAME="I2116"></A>For the execution of a call
on a dispatching operation of a type <I>T</I>, the <I>controlling tag
value</I> determines which subprogram body is executed. The controlling
tag value is defined as follows: </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>15</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC><FONT SIZE="-1">{<I>statically determined
tag</I> [partial]}</FONT> <A NAME="I2117"></A>If one or more controlling
operands are statically tagged, then the controlling tag value is <I>statically
determined</I> to be the tag of <I>T</I>.</LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>16</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC>If one or more controlling operands
are dynamically tagged, then the controlling tag value is not statically
determined, but is rather determined by the tags of the controlling operands.
<FONT SIZE="-1">{<I>Tag_Check</I> [partial]}</FONT> <A NAME="I2118"></A><FONT SIZE="-1">{<I>check,
language-defined (Tag_Check)</I>}</FONT> <A NAME="I2119"></A>If there
is more than one dynamically tagged controlling operand, a check is made
that they all have the same tag. <FONT SIZE="-1">{<I>Constraint_Error
(raised by failure of run-time check)</I>}</FONT> <A NAME="I2120"></A>If
this check fails, Constraint_Error is raised unless the call is a <FONT FACE="Arial, Helvetica">function_call</FONT>
whose <FONT FACE="Arial, Helvetica">name</FONT> denotes the declaration
of an equality operator (predefined or user defined) that returns Boolean,
in which case the result of the call is defined to indicate inequality,
and no <FONT FACE="Arial, Helvetica">subprogram_body</FONT> is executed.
This check is performed prior to evaluating any tag-indeterminate controlling
operands. </LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>16.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Reason: </B>Tag mismatch
is considered an error (except for &quot;=&quot; and &quot;/=&quot;)
since the corresponding primitive subprograms in each specific type expect
all controlling operands to be of the same type. For tag mismatch with
an equality operator, rather than raising an exception, &quot;=&quot;
returns False and &quot;/=&quot; returns True. No equality operator is
actually invoked, since there is no common tag value to control the dispatch.
Equality is a special case to be consistent with the existing Ada 83
principle that equality comparisons, even between objects with different
constraints, never raise Constraint_Error. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>17</FONT></DIV>
<UL Class="Bulleted" Style="margin-bottom: 0.3em"><LI TYPE=DISC>If all
of the controlling operands are tag-indeterminate, then: </LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>18</FONT></DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>If the call has a controlling
result and is itself a (possibly parenthesized or qualified) controlling
operand of an enclosing call on a dispatching operation of type <I>T</I>,
then its controlling tag value is determined by the controlling tag value
of this enclosing call;</LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>19</FONT></DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC><FONT SIZE="-1">{<I>statically
determined tag</I> [partial]}</FONT> <A NAME="I2121"></A>Otherwise, the
controlling tag value is statically determined to be the tag of type
<I>T</I>. </LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>19.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>This includes
the cases of a tag-indeterminate procedure call, and a tag-indeterminate
<FONT FACE="Arial, Helvetica">function_call</FONT> that is used to initialize
a class-wide formal parameter or class-wide object. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>20</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;For the execution of a call on a dispatching
operation, the body executed is the one for the corresponding primitive
subprogram of the specific type identified by the controlling tag value.
The body for an explicitly declared dispatching operation is the corresponding
explicit body for the subprogram. The body for an implicitly declared
dispatching operation that is overridden is the body for the overriding
subprogram, [even if the overriding occurs in a private part.] The body
for an inherited dispatching operation that is not overridden is the
body of the corresponding subprogram of the parent or ancestor type.
</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>20.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>To be honest: </B>In the
unusual case in which a dispatching subprogram is explicitly declared
(overridden) by a body (with no preceding <FONT FACE="Arial, Helvetica">subprogram_declaration</FONT>),
the body for that dispatching subprogram is that body; that is, the ``corresponding
explicit body'' in the above rule is the body itself. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>20.b</FONT></DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><FONT SIZE="-1"><B>Reason:
</B>The wording of the above rule is intended to ensure that the same
body is executed for a given tag, whether that tag is determined statically
or dynamically. For a type declared in a package, it doesn't matter whether
a given subprogram is overridden in the visible part or the private part,
and it doesn't matter whether the call is inside or outside the package.
For example: </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>20.c</FONT></DIV>
<DIV Class="SmallExamples"><TT><B>package</B>&nbsp;P1&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T1&nbsp;<B>is</B>&nbsp;<B>tagged</B>&nbsp;<B>null</B>&nbsp;<B>record</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Op_A(Arg&nbsp;:&nbsp;<B>in</B>&nbsp;T1);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Op_B(Arg&nbsp;:&nbsp;<B>in</B>&nbsp;T1);<BR>
<B>end</B>&nbsp;P1;</TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>20.d</FONT></DIV>
<DIV Class="SmallExamples"><TT><B>with</B>&nbsp;P1;&nbsp;<B>use</B>&nbsp;P1;<BR>
<B>package</B>&nbsp;P2&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T2&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;T1&nbsp;<B>with</B>&nbsp;<B>null</B>&nbsp;<B>record</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Op_A(Param&nbsp;:&nbsp;<B>in</B>&nbsp;T2);<BR>
<B>private</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Op_B(Param&nbsp;:&nbsp;<B>in</B>&nbsp;T2);<BR>
<B>end</B>&nbsp;P2;</TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>20.e/1</FONT></DIV>
<DIV Class="SmallExamples"><TT><B>with</B>&nbsp;P1;&nbsp;<B>with</B>&nbsp;P2;<BR>
<B>procedure</B>&nbsp;Main&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;:&nbsp;<U>P2.</U> T2;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Y&nbsp;:&nbsp;<U>P1.</U> T1'Class&nbsp;:=&nbsp;X;<BR>
<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;P2.Op_A(Param&nbsp;=&gt;&nbsp;X);&nbsp;--<I>&nbsp;Nondispatching&nbsp;call<U>&nbsp;to&nbsp;a&nbsp;dispatching&nbsp;operation</U> .</I><BR>
&nbsp;&nbsp;&nbsp;&nbsp;P1.Op_A(Arg&nbsp;=&gt;&nbsp;Y);&nbsp;--<I>&nbsp;Dispatching&nbsp;call.</I><BR>
&nbsp;&nbsp;&nbsp;&nbsp;P2.Op_B(Arg&nbsp;=&gt;&nbsp;X);&nbsp;--<I>&nbsp;Nondispatching&nbsp;call<U>&nbsp;to&nbsp;a&nbsp;dispatching&nbsp;operation</U> .</I><BR>
&nbsp;&nbsp;&nbsp;&nbsp;P1.Op_B(Arg&nbsp;=&gt;&nbsp;Y);&nbsp;--<I>&nbsp;Dispatching&nbsp;call.</I><BR>
<B>end</B>&nbsp;Main;</TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>20.f</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">The two calls to Op_A both execute
the body of Op_A that has to occur in the body of package P2. Similarly,
the two calls to Op_B both execute the body of Op_B that has to occur
in the body of package P2, even though Op_B is overridden in the private
part of P2. Note, however, that the formal parameter names are different
for P2.Op_A versus P2.Op_B. The overriding declaration for P2.Op_B is
not visible in Main, so the name in the call actually denotes the implicit
declaration of Op_B inherited from T1.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>20.g</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">If a call occurs in the program
text before an overriding, which can happen only if the call is part
of a default expression, the overriding will still take effect for that
call.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>20.h</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Implementation Note: </B>Even
when a tag is not <I>statically determined</I>, a compiler might still
be able to figure it out and thereby avoid the overhead of run-time dispatching.</FONT></DIV>
<DIV Class="NotesHeader"><FONT SIZE="-1">NOTES</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>21</FONT></DIV>
<DIV Class="Notes"><FONT SIZE="-1">70&nbsp;&nbsp;The body to be executed
for a call on a dispatching operation is determined by the tag; it does
not matter whether that tag is determined statically or dynamically,
and it does not matter whether the subprogram's declaration is visible
at the place of the call.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>22</FONT></DIV>
<DIV Class="Notes"><FONT SIZE="-1">71&nbsp;&nbsp;This subclause covers
calls on primitive subprograms of a tagged type. Rules for tagged type
membership tests are described in <A HREF="AA-4-5-2.html">4.5.2</A>.
Controlling tag determination for an <FONT FACE="Arial, Helvetica">assignment_statement</FONT>
is described in <A HREF="AA-5-2.html">5.2</A>.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>23</FONT></DIV>
<DIV Class="Notes"><FONT SIZE="-1">72&nbsp;&nbsp;A dispatching call can
dispatch to a body whose declaration is not visible at the place of the
call.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>24</FONT></DIV>
<DIV Class="Notes"><FONT SIZE="-1">73&nbsp;&nbsp;A call through an access-to-subprogram
value is never a dispatching call, even if the access value designates
a dispatching operation. Similarly a call whose <FONT FACE="Arial, Helvetica">prefix</FONT>
denotes a <FONT FACE="Arial, Helvetica">subprogram_renaming_declaration</FONT>
cannot be a dispatching call unless the renaming itself is the declaration
of a primitive subprogram. </FONT></DIV>

<H4 ALIGN=CENTER>Extensions to Ada 83</H4>
<DIV Class="Paranum"><FONT SIZE=-2>24.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">{<I>extensions to Ada 83</I>}
<A NAME="I2122"></A>The concept of dispatching operations is new. </FONT></DIV>

<HR>
<P><A HREF="AA-TOC.html">Contents</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-0-29.html">Index</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-SRCH.html">Search</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-3-9-1.html">Previous</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-3-9-3.html">Next</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-TTL.html">Legal</A></P>
</BODY>
</HTML>
