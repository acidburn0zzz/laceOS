<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Completion and Finalization</TITLE>
    <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    H4.centered {text-align: center}
    SPAN.swiss {font-family: Arial, Helvetica, sans-serif; font-size: 92%}
    SPAN.roman {font-family: "Times New Roman", Times, serif}
    DIV.paranum {float: left; font-family: Arial, Helvetica, sans-serif; font-size: 64%; width: 2.8em; margin-left: -0.4em; margin-right: -3.0em; margin-top: 0.2em}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    SPAN.insert1 {text-decoration: underline; color: rgb(0,51,51) }
    SPAN.delete1 {text-decoration: line-through; color: rgb(0,51,51) }
    SPAN.insert2 {text-decoration: underline; color: rgb(0,102,0) }
    SPAN.delete2 {text-decoration: line-through; color: rgb(0,102,0) }
    DIV.Normal {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.2em; margin-bottom: 0.6em}
    DIV.Annotations {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 6.2em; margin-bottom: 0.6em}
    DIV.Notes {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em; margin-bottom: 0.6em}
    DIV.NotesHeader {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em}
    DIV.SmallExamples {font-family: "Courier New", monospace; font-size: 72%; line-height: 122%; margin-left: 9.6em; margin-bottom: 0.6em}
    UL.Bulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.SmallBulleted {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 8.7em; margin-right: 2.5em; margin-top: 0em; margin-bottom: 0.5em}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#000080" VLINK="#330033" ALINK="#0000FF">
<DIV><B><SPAN Style="font-size:200%; color: rgb(0,51,153)">Annotated</SPAN><SPAN Style="font-size:200%; color: rgb(0,0,102)">&nbsp;Ada Reference Manual</SPAN></B> &mdash; <A HREF="AA-TTL.html"><B>Legal Information</B></A></DIV>
<DIV Style="margin-top: 0.6em; margin-bottom: 0.0em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-7-6.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-8.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<HR>
<H1>7.6.1 Completion and Finalization</H1>
<DIV Class="paranum">1</DIV>
<DIV Class="Normal">[This subclause defines <I>completion</I> and <I>leaving</I> 
of the execution of constructs and entities. A <I>master</I> is the execution 
of a construct that includes finalization of local objects after it is 
complete (and after waiting for any local tasks &mdash; see <A HREF="AA-9-3.html">9.3</A>), 
but before leaving. Other constructs and entities are left immediately 
upon completion. <SPAN STYLE="font-size: 80%">{<I>cleanup: See finalization</I>}</SPAN> 
<A NAME="I3656"></A><SPAN STYLE="font-size: 80%">{<I>destructor: See 
finalization</I>}</SPAN> <A NAME="I3657"></A>]</DIV>

<H4 Class="centered">Dynamic Semantics</H4>
<DIV Class="paranum">2/2</DIV>
<DIV Class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10318.TXT">AI95-00318-02</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>completion and leaving (completed and 
left)</I>}</SPAN> <A NAME="I3658"></A><SPAN STYLE="font-size: 80%">{<I>completion 
(run-time concept)</I>}</SPAN> <A NAME="I3659"></A>The execution of a 
construct or entity is <I>complete</I> when the end of that execution 
has been reached, or when a transfer of control (see <A HREF="AA-5-1.html">5.1</A>) 
causes it to be abandoned. <SPAN STYLE="font-size: 80%">{<I>normal completion</I>}</SPAN> 
<A NAME="I3660"></A><SPAN STYLE="font-size: 80%">{<I>completion (normal)</I>}</SPAN> 
<A NAME="I3661"></A><SPAN STYLE="font-size: 80%">{<I>abnormal completion</I>}</SPAN> 
<A NAME="I3662"></A><SPAN STYLE="font-size: 80%">{<I>completion (abnormal)</I>}</SPAN> 
<A NAME="I3663"></A>Completion due to reaching the end of execution, 
or due to the transfer of control of an <SPAN class="insert2"><SPAN Class="swiss"><A HREF="AA-5-7.html#S0146">exit_statement</A></SPAN>, 
return statement, <SPAN Class="swiss"><A HREF="AA-5-8.html#S0147">goto_statement</A></SPAN></SPAN><SPAN class="delete2"><SPAN Class="swiss">&nbsp;exit_</SPAN>, 
<SPAN Class="swiss">return_</SPAN>, <SPAN Class="swiss">goto_</SPAN></SPAN>, 
or <SPAN Class="swiss"><A HREF="AA-9-5-4.html#S0208">requeue_statement</A></SPAN> 
or of the selection of a <SPAN Class="swiss"><A HREF="AA-9-7-1.html#S0218">terminate_alternative</A></SPAN> 
is <I>normal completion</I>. Completion is <I>abnormal</I> otherwise 
[&mdash; when control is transferred out of a construct due to abort 
or the raising of an exception].&nbsp;</DIV>
<DIV Class="paranum">2.a</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>Don't confuse the run-time 
concept of completion with the compile-time concept of completion defined 
in <A HREF="AA-3-11-1.html">3.11.1</A>.&nbsp;</DIV>
<DIV Class="paranum">3/2</DIV>
<DIV Class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00162.TXT">AI95-00162-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00416.TXT">AI95-00416-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>leaving</I>}</SPAN> <A NAME="I3664"></A><SPAN STYLE="font-size: 80%">{<I>left</I>}</SPAN> 
<A NAME="I3665"></A>After execution of a construct or entity is complete, 
it is <I>left</I>, meaning that execution continues with the next action, 
as defined for the execution that is taking place. <SPAN STYLE="font-size: 80%">{<I>master</I>}</SPAN> 
<A NAME="I3666"></A>Leaving an execution happens immediately after its 
completion, except in the case of a <I>master</I>: the execution of a 
<SPAN class="insert2">body other than a <SPAN Class="swiss"><A HREF="AA-7-2.html#S0175">package_body</A></SPAN>; 
the execution of a <SPAN Class="swiss"><A HREF="AA-5-1.html#S0131">statement</A></SPAN>; 
or the evaluation of an <SPAN Class="swiss"><A HREF="AA-4-4.html#S0115">expression</A></SPAN>, 
<SPAN Class="swiss"><A HREF="AA-6-4.html#S0164">function_call</A></SPAN>, 
or <SPAN Class="swiss"><A HREF="AA-3-5.html#S0037">range</A></SPAN> that 
is not part of an enclosing <SPAN Class="swiss"><A HREF="AA-4-4.html#S0115">expression</A></SPAN>, 
<SPAN Class="swiss"><A HREF="AA-6-4.html#S0164">function_call</A></SPAN>, 
<SPAN Class="swiss"><A HREF="AA-3-5.html#S0037">range</A></SPAN>, or 
<SPAN Class="swiss"><A HREF="AA-5-1.html#S0132">simple_statement</A></SPAN> 
other than a <SPAN Class="swiss"><A HREF="AA-6-5.html#S0168">simple_return_statement</A></SPAN></SPAN><SPAN class="delete2"><SPAN Class="swiss"><A HREF="AA-9-1.html#S0192">&nbsp;task_body</A></SPAN>, 
a <SPAN Class="swiss"><A HREF="AA-5-6.html#S0145">block_statement</A></SPAN>, 
a <SPAN Class="swiss"><A HREF="AA-6-3.html#S0162">subprogram_body</A></SPAN>, 
an <SPAN Class="swiss"><A HREF="AA-9-5-2.html#S0203">entry_body</A></SPAN>, 
or an <SPAN Class="swiss"><A HREF="AA-9-5-2.html#S0201">accept_statement</A></SPAN></SPAN>. 
A master is finalized after it is complete, and before it is left.</DIV>
<DIV Class="paranum">3.a/2</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00162.TXT">AI95-00162-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00416.TXT">AI95-00416-01</A></I>} 
<SPAN class="insert2"><SPAN Class="swiss"><A HREF="AA-4-4.html#S0115">Expression</A></SPAN>s 
and <SPAN Class="swiss"><A HREF="AA-5-1.html#S0131">statement</A></SPAN>s 
are masters so that objects created by subprogram calls (in <SPAN Class="swiss"><A HREF="AA-4-3.html#S0104">aggregate</A></SPAN>s, 
<SPAN Class="swiss"><A HREF="AA-4-8.html#S0129">allocator</A></SPAN>s 
for anonymous access-to-object types, and so on) are finalized and have 
their tasks awaited before the <SPAN Class="swiss"><A HREF="AA-4-4.html#S0115">expression</A></SPAN>s 
or <SPAN Class="swiss"><A HREF="AA-5-1.html#S0131">statement</A></SPAN>s 
are left. Note that <SPAN Class="swiss"><A HREF="AA-4-4.html#S0115">expression</A></SPAN>s 
like the <SPAN Class="swiss"><A HREF="AA-5-3.html#S0139">condition</A></SPAN> 
of an <SPAN Class="swiss"><A HREF="AA-5-3.html#S0138">if_statement</A></SPAN> 
are masters, because they are not enclosed by a <SPAN Class="swiss"><A HREF="AA-5-1.html#S0132">simple_statement</A></SPAN>. 
Similarly, a <SPAN Class="swiss"><A HREF="AA-6-4.html#S0164">function_call</A></SPAN> 
which is renamed is a master, as it is not in a <SPAN Class="swiss"><A HREF="AA-5-1.html#S0132">simple_statement</A></SPAN>.</SPAN><SPAN class="delete2">&nbsp;Note 
that although an <SPAN Class="swiss"><A HREF="AA-9-5-2.html#S0201">accept_statement</A></SPAN> 
has no <SPAN Class="swiss"><A HREF="AA-3-11.html#S0086">declarative_part</A></SPAN>, 
it can call functions and evaluate <SPAN Class="swiss"><A HREF="AA-4-3.html#S0104">aggregate</A></SPAN>s, 
possibly causing anonymous controlled objects to be created, and we don't 
want those objects to escape outside the rendezvous.</SPAN></DIV>
<DIV Class="paranum">3.b/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00416.TXT">AI95-00416-01</A></I>} 
<SPAN class="insert2">We have to include <SPAN Class="swiss"><A HREF="AA-6-4.html#S0164">function_call</A></SPAN>s 
in the contexts that do not cause masters to occur so that <SPAN Class="swiss"><A HREF="AA-4-4.html#S0115">expression</A></SPAN>s 
contained in a <SPAN Class="swiss"><A HREF="AA-6-4.html#S0164">function_call</A></SPAN> 
(that is not part of an <SPAN Class="swiss"><A HREF="AA-4-4.html#S0115">expression</A></SPAN> 
or <SPAN Class="swiss"><A HREF="AA-5-1.html#S0132">simple_statement</A></SPAN>) 
do not individually become masters. We certainly do not want the parameter 
<SPAN Class="swiss"><A HREF="AA-4-4.html#S0115">expression</A></SPAN>s 
of a <SPAN Class="swiss"><A HREF="AA-6-4.html#S0164">function_call</A></SPAN> 
to be separate masters, as they would then be finalized before the function 
is called.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">3.c/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Ramification:&nbsp;</B></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00416.TXT">AI95-00416-01</A></I>} 
<SPAN class="insert2">The fact that a <SPAN Class="swiss"><A HREF="AA-6-4.html#S0164">function_call</A></SPAN> 
is a master does not change the accessibility of the return object denoted 
by the <SPAN Class="swiss"><A HREF="AA-6-4.html#S0164">function_call</A></SPAN>; 
that depends on the use of the <SPAN Class="swiss"><A HREF="AA-6-4.html#S0164">function_call</A></SPAN>. 
The <SPAN Class="swiss"><A HREF="AA-6-4.html#S0164">function_call</A></SPAN> 
is the master of any short-lived entities (such as <SPAN Class="swiss"><A HREF="AA-4-3.html#S0104">aggregate</A></SPAN>s 
used as parameters of types with task or controlled parts).</SPAN>&nbsp;</DIV>
<DIV Class="paranum">4</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>finalization (of 
a master)</I>}</SPAN> <A NAME="I3667"></A>For the <I>finalization</I> 
of a master, dependent tasks are first awaited, as explained in <A HREF="AA-9-3.html">9.3</A>. 
Then each object whose accessibility level is the same as that of the 
master is finalized if the object was successfully initialized and still 
exists. [These actions are performed whether the master is left by reaching 
the last statement or via a transfer of control.] When a transfer of 
control causes completion of an execution, each included master is finalized 
in order, from innermost outward.&nbsp;</DIV>
<DIV Class="paranum">4.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>As explained in <A HREF="AA-3-10-2.html">3.10.2</A>, 
the set of objects with the same accessibility level as that of the master 
includes objects declared immediately within the master, objects declared 
in nested packages, objects created by <SPAN Class="swiss"><A HREF="AA-4-8.html#S0129">allocator</A></SPAN>s 
(if the ultimate ancestor access type is declared in one of those places) 
and subcomponents of all of these things. If an object was already finalized 
by Unchecked_Deallocation, then it is not finalized again when the master 
is left.</DIV>
<DIV Class="paranum">4.b</DIV>
<DIV Class="Annotations">Note that any object whose accessibility level 
is deeper than that of the master would no longer exist; those objects 
would have been finalized by some inner master. Thus, after leaving a 
master, the only objects yet to be finalized are those whose accessibility 
level is less deep than that of the master.</DIV>
<DIV Class="paranum">4.c</DIV>
<DIV Class="Annotations"><B>To be honest:&nbsp;</B>Subcomponents of objects 
due to be finalized are not finalized by the finalization of the master; 
they are finalized by the finalization of the containing object.&nbsp;</DIV>
<DIV Class="paranum">4.d</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>We need to finalize subcomponents 
of objects even if the containing object is not going to get finalized 
because it was not fully initialized. But if the containing object is 
finalized, we don't want to require repeated finalization of the subcomponents, 
as might normally be implied by the recursion in finalization of a master 
and the recursion in finalization of an object.&nbsp;</DIV>
<DIV Class="paranum">4.e</DIV>
<DIV Class="Annotations"><B>To be honest:&nbsp;</B>Formally, completion and 
leaving refer to executions of constructs or entities. However, the standard 
sometimes (informally) refers to the constructs or entities whose executions 
are being completed. Thus, for example, &ldquo;the subprogram call or 
task is complete&rdquo; really means &ldquo;<I>the execution of</I> the 
subprogram call or task is complete.&rdquo;&nbsp;</DIV>
<DIV Class="paranum">5</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em"><SPAN STYLE="font-size: 80%">{<I>finalization 
(of an object)</I> [distributed]}</SPAN> <A NAME="I3668"></A>For the 
<I>finalization</I> of an object:&nbsp;</DIV>
<DIV Class="paranum">6</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>If the object is of an elementary 
type, finalization has no effect;</LI></UL>
<DIV Class="paranum">7</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>If the object is of a controlled type, 
the Finalize procedure is called;</LI></UL>
<DIV Class="paranum">8</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>If the object is of a protected type, 
the actions defined in <A HREF="AA-9-4.html">9.4</A> are performed;</LI></UL>
<DIV Class="paranum">9/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00416.TXT">AI95-00416-01</A></I>} 
If the object is of a composite type, then after performing the above 
actions, if any, every component of the object is finalized in an arbitrary 
order, except as follows: if the object has a component with an access 
discriminant constrained by a per-object expression, this component is 
finalized before any components that do not have such discriminants; 
for an object with several components with such a discriminant, they 
are finalized in the reverse of the order of their <SPAN Class="swiss"><A HREF="AA-3-8.html#S0070">component_declaration</A></SPAN>s<SPAN class="insert2">;</SPAN><SPAN class="delete2">.</SPAN> 
</LI></UL>
<DIV Class="paranum">9.a</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>This allows the finalization 
of a component with an access discriminant to refer to other components 
of the enclosing object prior to their being finalized.&nbsp;</DIV>
<DIV Class="paranum">9.1/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00416.TXT">AI95-00416-01</A></I>} 
<SPAN class="insert2">If the object has coextensions (see <A HREF="AA-3-10-2.html">3.10.2</A>), 
each coextension is finalized after the object whose access discriminant 
designates it.</SPAN></LI></UL>
<DIV Class="paranum">10</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>execution (instance 
of Unchecked_Deallocation)</I> [partial]}</SPAN> <A NAME="I3669"></A>Immediately 
before an instance of Unchecked_Deallocation reclaims the storage of 
an object, the object is finalized. [If an instance of Unchecked_Deallocation 
is never applied to an object created by an <SPAN Class="swiss"><A HREF="AA-4-8.html#S0129">allocator</A></SPAN>, 
the object will still exist when the corresponding master completes, 
and it will be finalized then.]</DIV>
<DIV Class="paranum">11/2</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00280.TXT">AI95-00280-01</A></I>} 
The order in which the finalization of a master performs finalization 
of objects is as follows: Objects created by declarations in the master 
are finalized in the reverse order of their creation. For objects that 
were created by <SPAN Class="swiss"><A HREF="AA-4-8.html#S0129">allocator</A></SPAN>s 
for an access type whose ultimate ancestor is declared in the master, 
this rule is applied as though each such object that still exists had 
been created in an arbitrary order at the first freezing point (see <A HREF="AA-13-14.html">13.14</A>) 
of the ultimate ancestor type<SPAN class="insert2">; the finalization 
of these objects is called the <I>finalization of the collection</I><SPAN STYLE="font-size: 80%">{<I>finalization 
of the collection</I>}</SPAN> <A NAME="I3670"></A><SPAN STYLE="font-size: 80%">{<I>collection 
(finalization of)</I>}</SPAN> <A NAME="I3671"></A></SPAN>.<SPAN class="insert2">&nbsp;After the finalization of a master is complete, the objects finalized 
as part of its finalization cease to <I>exist</I>, as do any types and 
subtypes defined and created within the master.<SPAN STYLE="font-size: 80%">{<I>exist 
(cease to)</I> [partial]}</SPAN> <A NAME="I3672"></A><SPAN STYLE="font-size: 80%">{<I>cease 
to exist (object)</I> [partial]}</SPAN> <A NAME="I3673"></A><SPAN STYLE="font-size: 80%">{<I>cease 
to exist (type)</I>}</SPAN> <A NAME="I3674"></A></SPAN></DIV>
<DIV Class="paranum">11.a</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>Note that we talk about the type 
of the <SPAN Class="swiss"><A HREF="AA-4-8.html#S0129">allocator</A></SPAN> 
here. There may be access values of a (general) access type pointing 
at objects created by <SPAN Class="swiss"><A HREF="AA-4-8.html#S0129">allocator</A></SPAN>s 
for some other type; these are not finalized at this point.</DIV>
<DIV Class="paranum">11.b</DIV>
<DIV Class="Annotations">The freezing point of the ultimate ancestor 
access type is chosen because before that point, pool elements cannot 
be created, and after that point, access values designating (parts of) 
the pool elements can be created. This is also the point after which 
the pool object cannot have been declared. We don't want to finalize 
the pool elements until after anything finalizing objects that contain 
access values designating them. Nor do we want to finalize pool elements 
after finalizing the pool object itself.&nbsp;</DIV>
<DIV Class="paranum">11.c</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>Finalization of allocated 
objects is done according to the (ultimate ancestor) <SPAN Class="swiss"><A HREF="AA-4-8.html#S0129">allocator</A></SPAN> 
type, not according to the storage pool in which they are allocated. 
Pool finalization might reclaim storage (see <A HREF="AA-13-11.html">13.11</A>, 
&ldquo;<A HREF="AA-13-11.html">Storage Management</A>&rdquo;), but has 
nothing (directly) to do with finalization of the pool elements.</DIV>
<DIV Class="paranum">11.d</DIV>
<DIV Class="Annotations">Note that finalization is done only for objects 
that still exist; if an instance of Unchecked_Deallocation has already 
gotten rid of a given pool element, that pool element will not be finalized 
when the master is left.</DIV>
<DIV Class="paranum">11.e</DIV>
<DIV Class="Annotations">Note that a deferred constant declaration does 
not create the constant; the full constant declaration creates it. Therefore, 
the order of finalization depends on where the full constant declaration 
occurs, not the deferred constant declaration.</DIV>
<DIV Class="paranum">11.f</DIV>
<DIV Class="Annotations">An imported object is not created by its declaration. 
It is neither initialized nor finalized.&nbsp;</DIV>
<DIV Class="paranum">11.g</DIV>
<DIV Class="Annotations"><B>Implementation Note:&nbsp;</B>An implementation 
has to ensure that the storage for an object is not reclaimed when references 
to the object are still possible (unless, of course, the user explicitly 
requests reclamation via an instance of Unchecked_Deallocation). This 
implies, in general, that objects cannot be deallocated one by one as 
they are finalized; a subsequent finalization might reference an object 
that has been finalized, and that object had better be in its (well-defined) 
finalized state.&nbsp;</DIV>
<DIV Class="paranum">12/2</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00256.TXT">AI95-00256-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>execution (assignment_statement)</I> 
[partial]}</SPAN> <A NAME="I3675"></A>The target of an <SPAN class="insert2"><SPAN Class="swiss"><A HREF="AA-5-2.html#S0137">assignment_statement</A></SPAN></SPAN><SPAN class="delete2">&nbsp;assignment 
statement</SPAN> is finalized before copying in the new value, as explained 
in <A HREF="AA-7-6.html">7.6</A>.</DIV>
<DIV Class="paranum">13/2</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="defect1.html#8652/0021">8652/0021</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00182.TXT">AI95-00182-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00162.TXT">AI95-00162-01</A></I>} 
<SPAN class="insert2">The master of an object is the master enclosing 
its creation whose accessibility level (see <A HREF="AA-3-10-2.html">3.10.2</A>) 
is equal to that of the object.</SPAN><SPAN class="delete2"></SPAN><SPAN class="insert1"><SPAN class="delete2">&nbsp;If 
the <I>object_</I><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
in an <SPAN Class="swiss"><A HREF="AA-8-5-1.html#S0183">object_renaming_declaration</A></SPAN>, 
or the actual parameter for a generic formal <B>in out</B> parameter 
in a <SPAN Class="swiss"><A HREF="AA-12-3.html#S0257">generic_instantiation</A></SPAN>, 
denotes any part of an anonymous object created by a function call, the 
anonymous object is not finalized until after it is no longer accessible 
via any name. Otherwise, an</SPAN></SPAN><SPAN class="delete2"></SPAN><SPAN class="delete1">&nbsp;The</SPAN><SPAN class="delete2">&nbsp;anonymous object</SPAN><SPAN class="delete1">s</SPAN><SPAN class="delete2">&nbsp;created by&nbsp;</SPAN><SPAN class="insert1"><SPAN class="delete2">a&nbsp;</SPAN></SPAN><SPAN class="delete2">function 
</SPAN><SPAN class="insert1"><SPAN class="delete2">call or</SPAN></SPAN><SPAN class="delete2"></SPAN><SPAN class="delete1">&nbsp;calls 
and</SPAN><SPAN class="delete2">&nbsp;by&nbsp;</SPAN><SPAN class="insert1"><SPAN class="delete2">an 
</SPAN></SPAN><SPAN class="delete2"><SPAN Class="swiss"><A HREF="AA-4-3.html#S0104">aggregate</A></SPAN></SPAN><SPAN class="insert1"><SPAN class="delete2">&nbsp;is</SPAN></SPAN><SPAN class="delete2"></SPAN><SPAN class="delete1">&nbsp;s 
are</SPAN><SPAN class="delete2">&nbsp;finalized no later than the end of the 
innermost enclosing <SPAN Class="swiss"><A HREF="AA-3-11.html#S0087">declarative_item</A></SPAN> 
or <SPAN Class="swiss"><A HREF="AA-5-1.html#S0131">statement</A></SPAN>; 
if that is a <SPAN Class="swiss"><A HREF="AA-5-1.html#S0133">compound_statement</A></SPAN>, 
</SPAN><SPAN class="insert1"><SPAN class="delete2">the object is</SPAN></SPAN><SPAN class="delete2"></SPAN><SPAN class="delete1">&nbsp;they 
are</SPAN><SPAN class="delete2">&nbsp;finalized before starting the execution 
of any <SPAN Class="swiss"><A HREF="AA-5-1.html#S0131">statement</A></SPAN> 
within the <SPAN Class="swiss"><A HREF="AA-5-1.html#S0133">compound_statement</A></SPAN>.</SPAN> 
</DIV>
<DIV Class="paranum">13.a/2</DIV>
<DIV Class="Annotations"><SPAN STYLE="font-size: 80%"><I>This paragraph 
was deleted.</I></SPAN><SPAN class="delete2"><B>To be honest:&nbsp;</B></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00162.TXT">AI95-00162-01</A></I>} 
<SPAN class="delete2">This is not to be construed as permission to call 
Finalize asynchronously with respect to normal user code. For example,</SPAN> 
</DIV>
<DIV Class="paranum">13.b/2</DIV>
<DIV Class="SmallExamples"><SPAN STYLE="font-size: 80%"><I>This paragraph 
was deleted.</I></SPAN><SPAN class="delete2"><B>declare</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;:&nbsp;Some_Controlled_Type&nbsp;:=&nbsp;F(G(...));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;The&nbsp;anonymous&nbsp;objects&nbsp;created&nbsp;for&nbsp;F&nbsp;and&nbsp;G&nbsp;are&nbsp;finalized</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;no&nbsp;later&nbsp;than&nbsp;this&nbsp;point.</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;Y&nbsp;:&nbsp;...<BR>
<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;...<BR>
<B>end</B>;</SPAN></DIV>
<DIV Class="paranum">13.c/2</DIV>
<DIV Class="Annotations"><SPAN STYLE="font-size: 80%"><I>This paragraph 
was deleted.</I></SPAN><SPAN class="delete2">The anonymous object for 
G should not be finalized at some random point in the middle of the body 
of F, because F might manipulate the same data structures as the Finalize 
operation, resulting in erroneous access to shared variables.</SPAN> 
</DIV>
<DIV Class="paranum">13.d/2</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00162.TXT">AI95-00162-01</A></I>} 
<SPAN class="insert2">This effectively imports all of the special rules 
for the accessibility level of renames, <SPAN Class="swiss"><A HREF="AA-4-8.html#S0129">allocator</A></SPAN>s, 
and so on, and applies them to determine where objects created in them 
are finalized. For instance, the master of a rename of a subprogram is 
that of the renamed subprogram.</SPAN><SPAN class="delete2">&nbsp;It might 
be quite inconvenient for the implementation to defer finalization of 
the anonymous object for G until after copying the value of F into X, 
especially if the size of the result is not known at the call site.</SPAN> 
</DIV>
<DIV Class="paranum">13.1/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="defect1.html#8652/0023">8652/0023</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00169.TXT">AI95-00169-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00162.TXT">AI95-00162-01</A></I>} 
<SPAN class="insert2">In the case of an <SPAN Class="swiss"><A HREF="AA-4-4.html#S0115">expression</A></SPAN> 
that is a master, finalization of any (anonymous) objects occurs as the 
final part of evaluation of the <SPAN Class="swiss"><A HREF="AA-4-4.html#S0115">expression</A></SPAN>.</SPAN><SPAN class="delete2"></SPAN><SPAN class="insert1"><SPAN class="delete2">&nbsp;If 
a transfer of control or raising of an exception occurs prior to performing 
a finalization of an anonymous object, the anonymous object is finalized 
as part of the finalizations due to be performed for the object's innermost 
enclosing master.</SPAN></SPAN><SPAN class="delete2"></SPAN></DIV>

<H4 Class="centered">Bounded (Run-Time) Errors</H4>
<DIV Class="paranum">14/1</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;{<I><A HREF="defect1.html#8652/0023">8652/0023</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00169.TXT">AI95-00169-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>bounded error (cause)</I> [partial]}</SPAN> 
<A NAME="I3676"></A>It is a bounded error for a call on Finalize or Adjust 
<SPAN class="insert1">that occurs as part of object finalization or assignment 
</SPAN>to propagate an exception. The possible consequences depend on 
what action invoked the Finalize or Adjust operation:&nbsp;</DIV>
<DIV Class="paranum">14.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>It is not a bounded error 
for Initialize to propagate an exception. If Initialize propagates an 
exception, then no further calls on Initialize are performed, and those 
components that have already been initialized (either explicitly or by 
default) are finalized in the usual way.</DIV>
<DIV Class="paranum">14.a.1/1</DIV>
<DIV Class="Annotations">{<I><A HREF="defect1.html#8652/0023">8652/0023</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00169.TXT">AI95-00169-01</A></I>} 
<SPAN class="insert1">It also is not a bounded error for an explicit 
call to Finalize or Adjust to propagate an exception. We do not want 
implementations to have to treat explicit calls to these routines specially.</SPAN> 
</DIV>
<DIV Class="paranum">15</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN STYLE="font-size: 80%">{<I>Program_Error 
(raised by failure of run-time check)</I>}</SPAN> <A NAME="I3677"></A>For 
a Finalize invoked as part of an <SPAN Class="swiss"><A HREF="AA-5-2.html#S0137">assignment_statement</A></SPAN>, 
Program_Error is raised at that point.</LI></UL>
<DIV Class="paranum">16/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="defect1.html#8652/0024">8652/0024</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00193.TXT">AI95-00193-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00256.TXT">AI95-00256-01</A></I>} 
<SPAN class="insert1">For an Adjust invoked as part of&nbsp;</SPAN><SPAN class="insert2">assignment 
operations other than those invoked as part of an <SPAN Class="swiss"><A HREF="AA-5-2.html#S0137">assignment_statement</A></SPAN></SPAN><SPAN class="insert1"></SPAN><SPAN class="insert1"><SPAN class="delete2">&nbsp;the 
initialization of a controlled object</SPAN></SPAN><SPAN class="insert1">, 
other adjustments due to be performed might or might not be performed, 
and then Program_Error is raised. During its propagation, finalization 
might or might not be applied to objects whose Adjust failed.</SPAN> 
<SPAN STYLE="font-size: 80%">{<I>Program_Error (raised by failure of 
run-time check)</I>}</SPAN> <A NAME="I3678"></A>For an Adjust invoked 
as part of an <SPAN class="insert2"><SPAN Class="swiss"><A HREF="AA-5-2.html#S0137">assignment_statement</A></SPAN></SPAN><SPAN class="delete2">&nbsp;assignment 
</SPAN><SPAN class="insert1"><SPAN class="delete2">statement</SPAN></SPAN><SPAN class="delete2"></SPAN><SPAN class="delete1">&nbsp;operation</SPAN><SPAN class="delete2"></SPAN>, 
any other adjustments due to be performed are performed, and then Program_Error 
is raised.&nbsp;</LI></UL>
<DIV Class="paranum">16.a/2</DIV>
<DIV Class="Annotations"><SPAN class="insert1"><B>Reason:&nbsp;</B></SPAN>{<I><A HREF="defect1.html#8652/0024">8652/0024</A></I>} 
<SPAN class="insert1"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00193.TXT">AI95-00193-01</A></I>} 
<SPAN class="insert1"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00256.TXT">AI95-00256-01</A></I>} 
<SPAN class="insert1">In the case of assignments that are part of initialization, 
there is no need to complete all adjustments if one propagates an exception, 
as the object will immediately be finalized. So long as a subcomponent 
is not going to be finalized, it need not be adjusted, even if it is 
initialized as part of an enclosing composite assignment operation for 
which some adjustments are performed. However, there is no harm in an 
implementation making additional Adjust calls (as long as any additional 
components that are adjusted are also finalized), so we allow the implementation 
flexibility here. On the other hand, for an&nbsp;</SPAN><SPAN class="insert2"><SPAN Class="swiss"><A HREF="AA-5-2.html#S0137">assignment_statement</A></SPAN></SPAN><SPAN class="insert1"></SPAN><SPAN class="insert1"><SPAN class="delete2">&nbsp;assignment 
statement</SPAN></SPAN><SPAN class="insert1">, it is important that all 
adjustments be performed, even if one fails, because all controlled subcomponents 
are going to be finalized.</SPAN><SPAN class="insert2">&nbsp;Other kinds of 
assignment are more like initialization than <SPAN Class="swiss"><A HREF="AA-5-2.html#S0137">assignment_statement</A></SPAN>s, 
so we include them as well in the permission.</SPAN><SPAN class="insert1"></SPAN> 
</DIV>
<DIV Class="paranum">16.a.1/1</DIV>
<DIV Class="Annotations"><SPAN class="insert1"><B>Ramification:&nbsp;</B></SPAN>{<I><A HREF="defect1.html#8652/0024">8652/0024</A></I>} 
<SPAN class="insert1"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00193.TXT">AI95-00193-01</A></I>} 
<SPAN class="insert1">Even if an Adjust invoked as part of the initialization 
of a controlled object propagates an exception, objects whose initialization 
(including any Adjust or Initialize calls) successfully completed will 
be finalized. The permission above only applies to objects whose Adjust 
failed. Objects for which Adjust was never even invoked must not be finalized.</SPAN> 
</DIV>
<DIV Class="paranum">17</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN STYLE="font-size: 80%">{<I>Program_Error 
(raised by failure of run-time check)</I>}</SPAN> <A NAME="I3679"></A>For 
a Finalize invoked as part of a call on an instance of Unchecked_Deallocation, 
any other finalizations due to be performed are performed, and then Program_Error 
is raised.&nbsp;</LI></UL>
<DIV Class="paranum">17.a.1/1</DIV>
<DIV Class="Annotations"><SPAN class="insert1"><B>Discussion:&nbsp;</B></SPAN>{<I><A HREF="defect2.html#8652/0104">8652/0104</A></I>} 
<SPAN class="insert1"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00179.TXT">AI95-00179-01</A></I>} 
<SPAN class="insert1">The standard does not specify if storage is recovered 
in this case. If storage is not recovered (and the object continues to 
exist), Finalize may be called on the object again (when the <SPAN Class="swiss"><A HREF="AA-4-8.html#S0129">allocator</A></SPAN>'s 
master is finalized).</SPAN>&nbsp;</DIV>
<DIV Class="paranum">17.1/1</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="defect1.html#8652/0023">8652/0023</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00169.TXT">AI95-00169-01</A></I>} 
<SPAN class="insert1"><SPAN STYLE="font-size: 80%">{<I>Program_Error 
(raised by failure of run-time check)</I>}</SPAN> <A NAME="I3680"></A>For 
a Finalize invoked as part of the finalization of the anonymous object 
created by a function call or <SPAN Class="swiss"><A HREF="AA-4-3.html#S0104">aggregate</A></SPAN>, 
any other finalizations due to be performed are performed, and then Program_Error 
is raised.</SPAN></LI></UL>
<DIV Class="paranum">17.2/1</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="defect1.html#8652/0023">8652/0023</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00169.TXT">AI95-00169-01</A></I>} 
<SPAN class="insert1"><SPAN STYLE="font-size: 80%">{<I>Program_Error 
(raised by failure of run-time check)</I>}</SPAN> <A NAME="I3681"></A>For 
a Finalize invoked due to reaching the end of the execution of a master, 
any other finalizations associated with the master are performed, and 
Program_Error is raised immediately after leaving the master.</SPAN></LI></UL>
<DIV Class="paranum">18/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10318.TXT">AI95-00318-02</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>Program_Error (raised by failure of 
run-time check)</I>}</SPAN> <A NAME="I3682"></A>For a Finalize invoked 
by the transfer of control of an <SPAN class="insert2"><SPAN Class="swiss"><A HREF="AA-5-7.html#S0146">exit_statement</A></SPAN>, 
return statement, <SPAN Class="swiss"><A HREF="AA-5-8.html#S0147">goto_statement</A></SPAN></SPAN><SPAN class="delete2"><SPAN Class="swiss">&nbsp;exit_</SPAN>, 
<SPAN Class="swiss">return_</SPAN>, <SPAN Class="swiss">goto_</SPAN></SPAN>, 
or <SPAN Class="swiss"><A HREF="AA-9-5-4.html#S0208">requeue_statement</A></SPAN>, 
Program_Error is raised no earlier than after the finalization of the 
master being finalized when the exception occurred, and no later than 
the point where normal execution would have continued. Any other finalizations 
due to be performed up to that point are performed before raising Program_Error. 
</LI></UL>
<DIV Class="paranum">18.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>For example, upon leaving 
a <SPAN Class="swiss"><A HREF="AA-5-6.html#S0145">block_statement</A></SPAN> 
due to a <SPAN Class="swiss"><A HREF="AA-5-8.html#S0147">goto_statement</A></SPAN>, 
the Program_Error would be raised at the point of the target statement 
denoted by the label, or else in some more dynamically nested place, 
but not so nested as to allow an <SPAN Class="swiss"><A HREF="AA-11-2.html#S0248">exception_handler</A></SPAN> 
that has visibility upon the finalized object to handle it. For example, 
</DIV>
<DIV Class="paranum">18.b</DIV>
<DIV Class="SmallExamples"><B>procedure</B>&nbsp;Main&nbsp;<B>is</B><BR>
<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;The_Label&gt;&gt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Outer_Block_Statement&nbsp;:&nbsp;<B>declare</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;:&nbsp;Some_Controlled_Type;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Inner_Block_Statement&nbsp;:&nbsp;<B>declare</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y&nbsp;:&nbsp;Some_Controlled_Type;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Z&nbsp;:&nbsp;Some_Controlled_Type;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>goto</B>&nbsp;The_Label;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>exception</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>when</B>&nbsp;Program_Error&nbsp;=&gt;&nbsp;...&nbsp;--<SPAN Class="roman"><I>&nbsp;Handler&nbsp;number&nbsp;1.</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>end</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>exception</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>when</B>&nbsp;Program_Error&nbsp;=&gt;&nbsp;...&nbsp;--<SPAN Class="roman"><I>&nbsp;Handler&nbsp;number&nbsp;2.</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>end</B>;<BR>
<B>exception</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>when</B>&nbsp;Program_Error&nbsp;=&gt;&nbsp;...&nbsp;--<SPAN Class="roman"><I>&nbsp;Handler&nbsp;number&nbsp;3.</I></SPAN><BR>
<B>end</B>&nbsp;Main;</DIV>
<DIV Class="paranum">18.c</DIV>
<DIV Class="Annotations">The <SPAN Class="swiss"><A HREF="AA-5-8.html#S0147">goto_statement</A></SPAN> 
will first cause Finalize(Y) to be called. Suppose that Finalize(Y) propagates 
an exception. Program_Error will be raised after leaving Inner_Block_Statement, 
but before leaving Main. Thus, handler number 1 cannot handle this Program_Error; 
it will be handled either by handler number 2 or handler number 3. If 
it is handled by handler number 2, then Finalize(Z) will be done before 
executing the handler. If it is handled by handler number 3, then Finalize(Z) 
and Finalize(X) will both be done before executing the handler.&nbsp;</DIV>
<DIV Class="paranum">19</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>For a Finalize invoked by a transfer 
of control that is due to raising an exception, any other finalizations 
due to be performed for the same master are performed; Program_Error 
is raised immediately after leaving the master.&nbsp;</LI></UL>
<DIV Class="paranum">19.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>If, in the above example, 
the <SPAN Class="swiss"><A HREF="AA-5-8.html#S0147">goto_statement</A></SPAN> 
were replaced by a <SPAN Class="swiss"><A HREF="AA-11-3.html#S0251">raise_statement</A></SPAN>, 
then the Program_Error would be handled by handler number 2, and Finalize(Z) 
would be done before executing the handler.&nbsp;</DIV>
<DIV Class="paranum">19.b</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>We considered treating this case 
in the same way as the others, but that would render certain <SPAN Class="swiss"><A HREF="AA-11-2.html#S0248">exception_handler</A></SPAN>s 
useless. For example, suppose the only <SPAN Class="swiss"><A HREF="AA-11-2.html#S0248">exception_handler</A></SPAN> 
is one for <B>others</B> in the main subprogram. If some deeply nested 
call raises an exception, causing some Finalize operation to be called, 
which then raises an exception, then normal execution &ldquo;would have 
continued&rdquo; at the beginning of the <SPAN Class="swiss"><A HREF="AA-11-2.html#S0248">exception_handler</A></SPAN>. 
Raising Program_Error at that point would cause that handler's code to 
be skipped. One would need two nested <SPAN Class="swiss"><A HREF="AA-11-2.html#S0248">exception_handler</A></SPAN>s 
to be sure of catching such cases!</DIV>
<DIV Class="paranum">19.c</DIV>
<DIV Class="Annotations">On the other hand, the <SPAN Class="swiss"><A HREF="AA-11-2.html#S0248">exception_handler</A></SPAN> 
for a given master should not be allowed to handle exceptions raised 
during finalization of that master.&nbsp;</DIV>
<DIV Class="paranum">20</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>For a Finalize invoked by a transfer 
of control due to an abort or selection of a terminate alternative, the 
exception is ignored; any other finalizations due to be performed are 
performed.&nbsp;</LI></UL>
<DIV Class="paranum">20.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>This case includes an asynchronous 
transfer of control.&nbsp;</DIV>
<DIV Class="paranum">20.b</DIV>
<DIV Class="Annotations"><B>To be honest:&nbsp;</B>{<I>Program_Error (raised 
by failure of run-time check)</I>} <A NAME="I3683"></A>This violates 
the general principle that it is always possible for a bounded error 
to raise Program_Error (see <A HREF="AA-1-1-5.html">1.1.5</A>, &ldquo;<A HREF="AA-1-1-5.html">Classification 
of Errors</A>&rdquo;).&nbsp;</DIV>
<DIV Class="NotesHeader">NOTES</DIV>
<DIV Class="paranum">21</DIV>
<DIV Class="Notes">19&nbsp;&nbsp;The rules of Section 10 imply that immediately 
prior to partition termination, Finalize operations are applied to library-level 
controlled objects (including those created by <SPAN Class="swiss"><A HREF="AA-4-8.html#S0129">allocator</A></SPAN>s 
of library-level access types, except those already finalized). This 
occurs after waiting for library-level tasks to terminate.&nbsp;</DIV>
<DIV Class="paranum">21.a</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>We considered defining a 
pragma that would apply to a controlled type that would suppress Finalize 
operations for library-level objects of the type upon partition termination. 
This would be useful for types whose finalization actions consist of 
simply reclaiming global heap storage, when this is already provided 
automatically by the environment upon program termination.&nbsp;</DIV>
<DIV Class="paranum">22</DIV>
<DIV Class="Notes">20&nbsp;&nbsp;A constant is only constant between 
its initialization and finalization. Both initialization and finalization 
are allowed to change the value of a constant.</DIV>
<DIV Class="paranum">23</DIV>
<DIV Class="Notes">21&nbsp;&nbsp;Abort is deferred during certain operations 
related to controlled types, as explained in <A HREF="AA-9-8.html">9.8</A>. 
Those rules prevent an abort from causing a controlled object to be left 
in an ill-defined state.</DIV>
<DIV Class="paranum">24</DIV>
<DIV Class="Notes">22&nbsp;&nbsp;The Finalize procedure is called upon 
finalization of a controlled object, even if Finalize was called earlier, 
either explicitly or as part of an assignment; hence, if a controlled 
type is visibly controlled (implying that its Finalize primitive is directly 
callable), or is nonlimited (implying that assignment is allowed), its 
Finalize procedure should be designed to have no ill effect if it is 
applied a second time to the same object.&nbsp;</DIV>
<DIV Class="paranum">24.a</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>Or equivalently, a Finalize 
procedure should be &ldquo;idempotent&rdquo;; applying it twice to the 
same object should be equivalent to applying it once.&nbsp;</DIV>
<DIV Class="paranum">24.b</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>A user-written Finalize procedure 
should be idempotent since it can be called explicitly by a client (at 
least if the type is &quot;visibly&quot; controlled). Also, Finalize 
is used implicitly as part of the <SPAN Class="swiss"><A HREF="AA-5-2.html#S0137">assignment_statement</A></SPAN> 
if the type is nonlimited, and an abort is permitted to disrupt an <SPAN Class="swiss"><A HREF="AA-5-2.html#S0137">assignment_statement</A></SPAN> 
between finalizing the left-hand side and assigning the new value to 
it (an abort is not permitted to disrupt an assignment operation between 
copying in the new value and adjusting it).&nbsp;</DIV>
<DIV Class="paranum">24.c/2</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00287.TXT">AI95-00287-01</A></I>} 
Either Initialize or Adjust, but not both, is applied to (almost) every 
controlled object when it is created: Initialize is done when no initial 
value is assigned to the object, whereas Adjust is done as part of assigning 
the initial value. The one exception is the <SPAN class="delete2">anonymous 
</SPAN>object <SPAN class="insert2">initialized</SPAN><SPAN class="delete2">&nbsp;created</SPAN> 
by an <SPAN Class="swiss"><A HREF="AA-4-3.html#S0104">aggregate</A></SPAN><SPAN class="insert2">&nbsp;(both the anonymous object created for an aggregate, or an object initialized 
by an <SPAN Class="swiss"><A HREF="AA-4-3.html#S0104">aggregate</A></SPAN> 
that is built-in-place)</SPAN>; Initialize is not applied to the <SPAN Class="swiss"><A HREF="AA-4-3.html#S0104">aggregate</A></SPAN> 
as a whole, nor is the value of the <SPAN Class="swiss"><A HREF="AA-4-3.html#S0104">aggregate</A></SPAN> 
<SPAN class="insert2">or object&nbsp;</SPAN>adjusted.</DIV>
<DIV Class="paranum">24.d</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em">{<I>assignment 
operation (list of uses)</I>} <A NAME="I3684"></A>All of the following 
use the assignment operation, and thus perform value adjustment:&nbsp;</DIV>
<DIV Class="paranum">24.e</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>the <SPAN Class="swiss"><A HREF="AA-5-2.html#S0137">assignment_statement</A></SPAN> 
(see <A HREF="AA-5-2.html">5.2</A>);</LI></UL>
<DIV Class="paranum">24.f</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>explicit initialization of a 
stand-alone object (see <A HREF="AA-3-3-1.html">3.3.1</A>) or of a pool 
element (see <A HREF="AA-4-8.html">4.8</A>);</LI></UL>
<DIV Class="paranum">24.g</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>default initialization of a component 
of a stand-alone object or pool element (in this case, the value of each 
component is assigned, and therefore adjusted, but the value of the object 
as a whole is not adjusted);</LI></UL>
<DIV Class="paranum">24.h/2</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10318.TXT">AI95-00318-02</A></I>} 
function return, when the result <SPAN class="insert2">is not built-in-place</SPAN><SPAN class="delete2">&nbsp;type 
is not a return-by-reference type (see <A HREF="AA-6-5.html">6.5</A>);</SPAN> 
(adjustment of the result happens before finalization of the function<SPAN class="delete2">; 
values of return-by-reference types are not adjusted</SPAN>);</LI></UL>
<DIV Class="paranum">24.i</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>predefined operators (although 
the only one that matters is concatenation; see <A HREF="AA-4-5-3.html">4.5.3</A>);</LI></UL>
<DIV Class="paranum">24.j</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>generic formal objects of mode 
<B>in</B> (see <A HREF="AA-12-4.html">12.4</A>); these are defined in 
terms of constant declarations; and</LI></UL>
<DIV Class="paranum">24.k/2</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00287.TXT">AI95-00287-01</A></I>} 
<SPAN Class="swiss"><A HREF="AA-4-3.html#S0104">aggregate</A></SPAN>s 
(see <A HREF="AA-4-3.html">4.3</A>)<SPAN class="insert2">, when the result 
is not built-in-place</SPAN> (in this case, the value of each component, 
and the parent part, for an <SPAN Class="swiss"><A HREF="AA-4-3-2.html#S0109">extension_aggregate</A></SPAN>, 
is assigned, and therefore adjusted, but the value of the <SPAN Class="swiss"><A HREF="AA-4-3.html#S0104">aggregate</A></SPAN> 
as a whole is not adjusted; neither is Initialize called);&nbsp;</LI></UL>
<DIV Class="paranum">24.l</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em">The following 
also use the assignment operation, but adjustment never does anything 
interesting in these cases:&nbsp;</DIV>
<DIV Class="paranum">24.m</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>By-copy parameter passing uses 
the assignment operation (see <A HREF="AA-6-4-1.html">6.4.1</A>), but 
controlled objects are always passed by reference, so the assignment 
operation never does anything interesting in this case. If we were to 
allow by-copy parameter passing for controlled objects, we would need 
to make sure that the actual is finalized before doing the copy back 
for [<B>in</B>] <B>out</B> parameters. The finalization of the parameter 
itself needs to happen after the copy back (if any), similar to the finalization 
of an anonymous function return object or <SPAN Class="swiss"><A HREF="AA-4-3.html#S0104">aggregate</A></SPAN> 
object.</LI></UL>
<DIV Class="paranum">24.n</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC><B>For</B> loops use the assignment 
operation (see <A HREF="AA-5-5.html">5.5</A>), but since the type of 
the loop parameter is never controlled, nothing interesting happens there, 
either.</LI></UL>
<DIV Class="paranum">24.n.1/2</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10318.TXT">AI95-00318-02</A></I>} 
<SPAN class="insert2">Objects initialized by function results and <SPAN Class="swiss"><A HREF="AA-4-3.html#S0104">aggregate</A></SPAN>s 
that are built-in-place. In this case, the assignment operation is never 
executed, and no adjustment takes place. While built-in-place is always 
allowed, it is required for some types &mdash; see <A HREF="AA-7-5.html">7.5</A> 
and <A HREF="AA-7-6.html">7.6</A> &mdash; and that's important since 
limited types have no Adjust to call.</SPAN>&nbsp;</LI></UL>
<DIV Class="paranum">24.o/2</DIV>
<DIV Class="Annotations"><SPAN STYLE="font-size: 80%"><I>This paragraph 
was deleted.</I></SPAN><SPAN class="delete2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00287.TXT">AI95-00287-01</A></I>} 
<SPAN class="delete2">Because Controlled and Limited_Controlled are library-level 
tagged types, all controlled types will be library-level types, because 
of the accessibility rules (see <A HREF="AA-3-10-2.html">3.10.2</A> and 
<A HREF="AA-3-9-1.html">3.9.1</A>). This ensures that the Finalize operations 
may be applied without providing any &ldquo;display&rdquo; or &ldquo;static-link.&rdquo; 
This simplifies finalization as a result of garbage collection, abort, 
and asynchronous transfer of control.</SPAN></DIV>
<DIV Class="paranum">24.p</DIV>
<DIV Class="Annotations">Finalization of the parts of a protected object 
are not done as protected actions. It is possible (in pathological cases) 
to create tasks during finalization that access these parts in parallel 
with the finalization itself. This is an erroneous use of shared variables. 
</DIV>
<DIV Class="paranum">24.q</DIV>
<DIV Class="Annotations"><B>Implementation Note:&nbsp;</B>One implementation 
technique for finalization is to chain the controlled objects together 
on a per-task list. When leaving a master, the list can be walked up 
to a marked place. The links needed to implement the list can be declared 
(privately) in types Controlled and Limited_Controlled, so they will 
be inherited by all controlled types.</DIV>
<DIV Class="paranum">24.r</DIV>
<DIV Class="Annotations">Another implementation technique, which we refer 
to as the &ldquo;PC-map&rdquo; approach essentially implies inserting 
exception handlers at various places, and finalizing objects based on 
where the exception was raised.</DIV>
<DIV Class="paranum">24.s</DIV>
<DIV Class="Annotations">{<I>PC-map approach to finalization</I>} <A NAME="I3685"></A>{<I>program-counter-map 
approach to finalization</I>} <A NAME="I3686"></A>The PC-map approach 
is for the compiler/linker to create a map of code addresses; when an 
exception is raised, or abort occurs, the map can be consulted to see 
where the task was executing, and what finalization needs to be performed. 
This approach was given in the Ada 83 Rationale as a possible implementation 
strategy for exception handling &mdash; the map is consulted to determine 
which exception handler applies.</DIV>
<DIV Class="paranum">24.t</DIV>
<DIV Class="Annotations">If the PC-map approach is used, the implementation 
must take care in the case of arrays. The generated code will generally 
contain a loop to initialize an array. If an exception is raised part 
way through the array, the components that have been initialized must 
be finalized, and the others must not be finalized.</DIV>
<DIV Class="paranum">24.u</DIV>
<DIV Class="Annotations">It is our intention that both of these implementation 
methods should be possible.&nbsp;</DIV>

<H4 Class="centered">Wording Changes from Ada 83</H4>
<DIV Class="paranum">24.v</DIV>
<DIV Class="Annotations">Finalization depends on the concepts of completion 
and leaving, and on the concept of a master. Therefore, we have moved 
the definitions of these concepts here, from where they used to be in 
Section 9. These concepts also needed to be generalized somewhat. Task 
waiting is closely related to user-defined finalization; the rules here 
refer to the task-waiting rules of Section 9.&nbsp;</DIV>

<H4 Class="centered">Wording Changes from Ada 95</H4>
<DIV Class="paranum">24.w/2</DIV>
<DIV Class="Annotations">{<I><A HREF="defect1.html#8652/0021">8652/0021</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00182.TXT">AI95-00182-01</A></I>} 
<SPAN class="insert2"><B>Corrigendum:</B> Fixed the wording to say that 
anonymous objects aren't finalized until the object can't be used anymore.</SPAN></DIV>
<DIV Class="paranum">24.x/2</DIV>
<DIV Class="Annotations">{<I><A HREF="defect1.html#8652/0023">8652/0023</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00169.TXT">AI95-00169-01</A></I>} 
<SPAN class="insert2"><B>Corrigendum:</B> Added wording to clarify what 
happens when Adjust or Finalize raises an exception; some cases had been 
omitted.</SPAN></DIV>
<DIV Class="paranum">24.y/2</DIV>
<DIV Class="Annotations">{<I><A HREF="defect1.html#8652/0024">8652/0024</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00193.TXT">AI95-00193-01</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00256.TXT">AI95-00256-01</A></I>} 
<SPAN class="insert2"><B>Corrigendum:</B> Stated that if Adjust raises 
an exception during initialization, nothing further is required. This 
is corrected in Ada 2005 to include all kinds of assignment other than 
<SPAN Class="swiss"><A HREF="AA-5-2.html#S0137">assignment_statement</A></SPAN>s.</SPAN></DIV>
<DIV Class="paranum">24.z/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00162.TXT">AI95-00162-01</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00416.TXT">AI95-00416-01</A></I>} 
<SPAN class="insert2">Revised the definition of master to include <SPAN Class="swiss"><A HREF="AA-4-4.html#S0115">expression</A></SPAN>s 
and <SPAN Class="swiss"><A HREF="AA-5-1.html#S0131">statement</A></SPAN>s, 
in order to cleanly define what happens for tasks and controlled objects 
created as part of a subprogram call. Having done that, all of the special 
wording to cover those cases is eliminated (at least until the Ada comments 
start rolling in).</SPAN></DIV>
<DIV Class="paranum">24.aa/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00280.TXT">AI95-00280-01</A></I>} 
<SPAN class="insert2">We define <I>finalization of the collection</I> 
here, so as to be able to conveniently refer to it in other rules (especially 
in <A HREF="AA-4-8.html">4.8</A>, &ldquo;<A HREF="AA-4-8.html">Allocators</A>&rdquo;).</SPAN></DIV>
<DIV Class="paranum">24.bb/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00416.TXT">AI95-00416-01</A></I>} 
<SPAN class="insert2">Clarified that a coextension is finalized at the 
same time as the outer object. (This was intended for Ada 95, but since 
the concept did not have a name, it was overlooked.)</SPAN></DIV>

<HR>
<DIV Style="margin-top: 0.0em; margin-bottom: 0.6em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-7-6.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-8.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<DIV Style="margin-top:0.0em"><IMG SRC="AE_logo.gif" height=100 width=113 align=right ALT="Ada-Europe">
<SPAN Style="font-size: 125%">Sponsored by <SPAN Style="font-size: 125%"><A HREF="http://www.ada-europe.org/"><B>Ada-Europe</B></A></SPAN></SPAN></DIV>
</BODY>
</HTML>
