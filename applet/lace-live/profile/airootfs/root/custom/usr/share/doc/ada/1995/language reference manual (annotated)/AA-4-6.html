<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Type Conversions</TITLE>
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    DIV.paranum {position: absolute; font-family: Arial, Helvetica, sans-serif; left: 0.5em; top: auto}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    DIV.Normal {font-family: "Times New Roman", Times, serif; margin-bottom: 0.6em}
    DIV.Wide {font-family: "Times New Roman", Times, serif; margin-top: 0.6em; margin-bottom: 0.6em}
    DIV.Annotations {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-bottom: 0.6em}
    DIV.WideAnnotations {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-top: 0.6em; margin-bottom: 0.6em}
    DIV.Index {font-family: "Times New Roman", Times, serif}
    DIV.SyntaxSummary {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-bottom: 0.4em}
    DIV.Notes {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-bottom: 0.6em}
    DIV.NotesHeader {font-family: "Times New Roman", Times, serif; margin-left: 2.0em}
    DIV.SyntaxIndented {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-bottom: 0.4em}
    DIV.Indented {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-bottom: 0.6em}
    DIV.CodeIndented {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-bottom: 0.6em}
    DIV.SmallIndented {font-family: "Times New Roman", Times, serif; margin-left:  10.0em; margin-bottom: 0.6em}
    DIV.SmallCodeIndented {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-bottom: 0.6em}
    DIV.Examples {font-family: "Courier New", monospace; margin-left: 2.0em; margin-bottom: 0.6em}
    DIV.SmallExamples {font-family: "Courier New", monospace; font-size: 80%; margin-left: 7.5em; margin-bottom: 0.6em}
    DIV.IndentedExamples {font-family: "Courier New", monospace; margin-left: 8.0em; margin-bottom: 0.6em}
    DIV.SmallIndentedExamples {font-family: "Courier New", monospace; font-size: 80%; margin-left:  15.0em; margin-bottom: 0.6em}
    UL.Bulleted {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.SmallBulleted {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.NestedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-right: 4.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.SmallNestedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-right: 8.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.IndentedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-right: 8.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.CodeIndentedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.CodeIndentedNestedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-right: 8.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.SyntaxIndentedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-right: 4.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.NotesBulleted {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-right: 4.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.NotesNestedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    DL.Hanging {font-family: "Times New Roman", Times, serif; margin-top: 0em; margin-bottom: 0.6em}
    DD.Hanging {margin-left: 6.0em}
    DL.IndentedHanging {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-top: 0em; margin-bottom: 0.6em}
    DD.IndentedHanging {margin-left: 2.0em}
    DL.HangingInBulleted {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    DD.HangingInBulleted {margin-left: 4.0em}
    DL.SmallHanging {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-top: 0em; margin-bottom: 0.6em}
    DD.SmallHanging {margin-left: 7.5em}
    DL.SmallIndentedHanging {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-top: 0em; margin-bottom: 0.6em}
    DD.SmallIndentedHanging {margin-left: 2.0em}
    DL.SmallHangingInBulleted {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    DD.SmallHangingInBulleted {margin-left: 5.0em}
    DL.Enumerated {font-family: "Times New Roman", Times, serif; margin-right: 0.0em; margin-top: 0em; margin-bottom: 0.5em}
    DD.Enumerated {margin-left: 2.0em}
    DL.SmallEnumerated {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-right: 4.0em; margin-top: 0em; margin-bottom: 0.5em}
    DD.SmallEnumerated {margin-left: 2.5em}
    DL.NestedEnumerated {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    DL.SmallNestedEnumerated {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">
<P><A HREF="AA-TOC.html">Contents</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-0-29.html">Index</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-SRCH.html">Search</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-4-5-6.html">Previous</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-4-7.html">Next</A></P>
<HR>
<H1> 4.6 Type Conversions</H1>
<DIV Class="Paranum"><FONT SIZE=-2>1</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;[Explicit type conversions, both value conversions
and view conversions, are allowed between closely related types as defined
below. This clause also defines rules for value and view conversions
to a particular subtype of a type, both explicit ones and those implicit
in other constructs. <FONT SIZE="-1">{<I>subtype conversion: See type
conversion</I>}</FONT> <A NAME="I2719"></A><FONT SIZE="-1">{<I>type conversion</I>}</FONT>
<A NAME="I2720"></A><FONT SIZE="-1">{<I>conversion</I>}</FONT> <A NAME="I2721"></A><FONT SIZE="-1">{<I>cast:
See type conversion</I>}</FONT> <A NAME="I2722"></A>]<FONT SIZE="-1">{<I>subtype
conversion: See also implicit subtype conversion</I>}</FONT> <A NAME="I2723"></A><FONT SIZE="-1">{<I>type
conversion, implicit: See implicit subtype conversion</I>}</FONT> <A NAME="I2724"></A></DIV>

<H4 ALIGN=CENTER>Syntax</H4>
<DIV Class="Paranum"><FONT SIZE=-2>2</FONT></DIV>
<DIV Class="SyntaxIndented"><FONT FACE="Arial, Helvetica">type_conversion</FONT><FONT FACE="Arial, Helvetica"><A NAME="I2725"></A>
::= </FONT><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="I2726"></A><FONT FACE="Arial, Helvetica">subtype_mark</FONT>(<A NAME="I2727"></A><FONT FACE="Arial, Helvetica">expression</FONT>)<BR>
&nbsp;&nbsp;|&nbsp;<A NAME="I2728"></A><FONT FACE="Arial, Helvetica">subtype_mark</FONT>(<A NAME="I2729"></A><FONT FACE="Arial, Helvetica">name</FONT>)</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>3</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>target subtype (of a type_conversion)</I>}</FONT>
<A NAME="I2730"></A>The <I>target subtype</I> of a <FONT FACE="Arial, Helvetica">type_conversion</FONT>
is the subtype denoted by the <FONT FACE="Arial, Helvetica">subtype_mark</FONT>.
<FONT SIZE="-1">{<I>operand (of a type_conversion)</I>}</FONT> <A NAME="I2731"></A>The
<I>operand</I> of a <FONT FACE="Arial, Helvetica">type_conversion</FONT>
is the <FONT FACE="Arial, Helvetica">expression</FONT> or <FONT FACE="Arial, Helvetica">name</FONT>
within the parentheses; <FONT SIZE="-1">{<I>operand type (of a type_conversion)</I>}</FONT>
<A NAME="I2732"></A>its type is the <I>operand type</I>.</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>4</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>convertible</I>}</FONT> <A NAME="I2733"></A>One
type is <I>convertible</I> to a second type if a <FONT FACE="Arial, Helvetica">type_conversion</FONT>
with the first type as operand type and the second type as target type
is legal according to the rules of this clause. Two types are convertible
if each is convertible to the other. </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>4.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>Note that
``convertible'' is defined in terms of legality of the conversion. Whether
the conversion would raise an exception at run time is irrelevant to
this definition. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>5/1</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I><A HREF="defect1.html#8652/0017">8652/0017</A></I>}
<FONT SIZE="-1">{<I>view conversion</I>}</FONT> <A NAME="I2734"></A><FONT SIZE="-1">{<I>conversion
(view)</I>}</FONT> <A NAME="I2735"></A>A <FONT FACE="Arial, Helvetica">type_conversion</FONT>
whose operand is the <FONT FACE="Arial, Helvetica">name</FONT> of an
object is called a <I>view conversion</I> if <U>both </U> its target
type <U>and operand type are</U> <S>is</S> tagged, or if it appears as
an actual parameter of mode <B>out</B> or <B>in out</B>; <FONT SIZE="-1">{<I>value
conversion</I>}</FONT> <A NAME="I2736"></A><FONT SIZE="-1">{<I>conversion
(value)</I>}</FONT> <A NAME="I2737"></A>other <FONT FACE="Arial, Helvetica">type_conversion</FONT>s
are called <I>value conversions</I>. <FONT SIZE="-1">{<I>super: See view
conversion</I>}</FONT> <A NAME="I2738"></A></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>5.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>A view
conversion to a tagged type can appear in any context that requires an
object <FONT FACE="Arial, Helvetica">name</FONT>, including in an object
renaming, the <FONT FACE="Arial, Helvetica">prefix</FONT> of a <FONT FACE="Arial, Helvetica">selected_component</FONT>,
and if the operand is a variable, on the left side of an <FONT FACE="Arial, Helvetica">assignment_statement</FONT>.
View conversions to other types only occur as actual parameters. Allowing
view conversions of untagged types in all contexts seemed to incur an
undue implementation burden. </FONT></DIV>

<H4 ALIGN=CENTER>Name Resolution Rules</H4>
<DIV Class="Paranum"><FONT SIZE=-2>6</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>expected type (type_conversion
operand)</I> [partial]}</FONT> <A NAME="I2739"></A>The operand of a <FONT FACE="Arial, Helvetica">type_conversion</FONT>
is expected to be of any type. </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>6.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Discussion: </B>This replaces
the &quot;must be determinable&quot; wording of Ada 83. This is equivalent
to (but hopefully more intuitive than) saying that the operand of a <FONT FACE="Arial, Helvetica">type_conversion</FONT>
is a ``complete context.'' </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>7</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;The operand of a view conversion is interpreted
only as a <FONT FACE="Arial, Helvetica">name</FONT>; the operand of a
value conversion is interpreted as an <FONT FACE="Arial, Helvetica">expression</FONT>.
</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>7.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Reason: </B>This formally
resolves the syntactic ambiguity between the two forms of <FONT FACE="Arial, Helvetica">type_conversion</FONT>,
not that it really matters. </FONT></DIV>

<H4 ALIGN=CENTER>Legality Rules</H4>
<DIV Class="Paranum"><FONT SIZE=-2>8</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>type conversion (numeric)</I>}</FONT>
<A NAME="I2740"></A><FONT SIZE="-1">{<I>conversion (numeric)</I>}</FONT>
<A NAME="I2741"></A>If the target type is a numeric type, then the operand
type shall be a numeric type.</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>9</FONT></DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>type
conversion (array)</I>}</FONT> <A NAME="I2742"></A><FONT SIZE="-1">{<I>conversion
(array)</I>}</FONT> <A NAME="I2743"></A>If the target type is an array
type, then the operand type shall be an array type. Further: </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>10</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC>The types shall have the same dimensionality;</LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>11/1</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="defect1.html#8652/0008">8652/0008</A></I>}
Corresponding index types shall be convertible;<S> and</S> <FONT SIZE="-1">{<I>convertible
(required)</I> [partial]}</FONT> <A NAME="I2744"></A></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>12/1</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="defect1.html#8652/0008">8652/0008</A></I>}
The component subtypes shall statically match<U>; and</U> <S>.</S> <FONT SIZE="-1">{<I>statically
matching (required)</I> [partial]}</FONT> <A NAME="I2745"></A></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>12.1/1</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="defect1.html#8652/0008">8652/0008</A></I>}
<U>In a view conversion, the target type and the operand type shall both
or neither have aliased components.</U>  </LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>12.a.1/1</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Reason: </B><U>Without this
rule, it is possible to violate the constrained status of aliased array
components. Consider:</U>  </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>12.a.2/1</FONT></DIV>
<DIV Class="SmallExamples"><TT><U><B>package</B>&nbsp;P&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T&nbsp;<B>is&nbsp;private</B>;<BR>
&nbsp;&nbsp;&nbsp;A&nbsp;:&nbsp;<B>constant</B>&nbsp;T;<BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;A1&nbsp;<B>is&nbsp;array</B>&nbsp;(1&nbsp;..&nbsp;10)&nbsp;<B>of&nbsp;aliased</B>&nbsp;T;<BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;A2&nbsp;<B>is&nbsp;array</B>&nbsp;(1&nbsp;..&nbsp;10)&nbsp;<B>of</B>&nbsp;T;<BR>
<B>private</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T&nbsp;(D&nbsp;:&nbsp;Integer&nbsp;:=&nbsp;0)&nbsp;<B>is&nbsp;null&nbsp;record</B>;<BR>
&nbsp;&nbsp;&nbsp;A&nbsp;:&nbsp;<B>constant</B>&nbsp;T&nbsp;:=&nbsp;(D&nbsp;=&gt;&nbsp;1);<BR>
<B>end</B>&nbsp;P;</U> </TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>12.a.3/1</FONT></DIV>
<DIV Class="SmallExamples"><TT><U><B>with</B>&nbsp;P;<BR>
<B>procedure</B>&nbsp;Exam&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;X&nbsp;:&nbsp;P.A1;<BR>
&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;S&nbsp;(Y&nbsp;:&nbsp;<B>in&nbsp;out</B>&nbsp;P.A2)&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y&nbsp;(1)&nbsp;:=&nbsp;P.A;<BR>
&nbsp;&nbsp;&nbsp;<B>end</B>;<BR>
<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;S&nbsp;(P.A2&nbsp;(X));&nbsp;--&nbsp;This&nbsp;call&nbsp;will&nbsp;change&nbsp;the&nbsp;discriminant&nbsp;of&nbsp;X&nbsp;(1),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;so&nbsp;we&nbsp;cannot&nbsp;allow&nbsp;the&nbsp;conversion.<BR>
<B>end</B>;</U> </TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>13</FONT></DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>type
conversion (access)</I>}</FONT> <A NAME="I2746"></A><FONT SIZE="-1">{<I>conversion
(access)</I>}</FONT> <A NAME="I2747"></A>If the target type is a general
access type, then the operand type shall be an access-to-object type.
Further: </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>13.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Discussion: </B>The Legality
Rules and Dynamic Semantics are worded so that a <FONT FACE="Arial, Helvetica">type_conversion</FONT>
T(X) (where T is an access type) is (almost) equivalent to the <FONT FACE="Arial, Helvetica">attribute_reference</FONT>
X.<B>all</B>'Access, where the result is of type T. The <FONT FACE="Arial, Helvetica">type_conversion</FONT>
accepts a null value, whereas the <FONT FACE="Arial, Helvetica">attribute_reference</FONT>
would raise Constraint_Error. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>14</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC>If the target type is an access-to-variable
type, then the operand type shall be an access-to-variable type; </LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>14.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>If the
target type is an access-to-constant type, then the operand type can
be access-to-constant or access-to-variable. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>15</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC>If the target designated type is tagged,
then the operand designated type shall be convertible to the target designated
type; <FONT SIZE="-1">{<I>convertible (required)</I> [partial]}</FONT>
<A NAME="I2748"></A></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>16</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC>If the target designated type is not
tagged, then the designated types shall be the same, and either the designated
subtypes shall statically match or the target designated subtype shall
be discriminated and unconstrained; and <FONT SIZE="-1">{<I>statically
matching (required)</I> [partial]}</FONT> <A NAME="I2749"></A></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>16.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Reason: </B>These rules are
designed to ensure that aliased array objects only <I>need</I> &quot;dope&quot;
if their nominal subtype is unconstrained, but they can always <I>have</I>
dope if required by the run-time model (since no sliding is permitted
as part of access type conversion). By contrast, aliased discriminated
objects will always <I>need</I> their discriminants stored with them,
even if nominally constrained. (Here, we are assuming an implementation
that represents an access value as a single pointer.) </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>17</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC><FONT SIZE="-1">{<I>accessibility
rule (type conversion)</I> [partial]}</FONT> <A NAME="I2750"></A>The
accessibility level of the operand type shall not be statically deeper
than that of the target type. <FONT SIZE="-1">{<I>generic contract issue</I>
[partial]}</FONT> <A NAME="I2751"></A>In addition to the places where
Legality Rules normally apply (see <A HREF="AA-12-3.html">12.3</A>),
this rule applies also in the private part of an instance of a generic
unit. </LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>17.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>The access
parameter case is handled by a run-time check. Run-time checks are also
done in instance bodies. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>18</FONT></DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>type
conversion (access)</I>}</FONT> <A NAME="I2752"></A><FONT SIZE="-1">{<I>conversion
(access)</I>}</FONT> <A NAME="I2753"></A>If the target type is an access-to-subprogram
type, then the operand type shall be an access-to-subprogram type. Further:
</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>19</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC>The designated profiles shall be subtype-conformant.
<FONT SIZE="-1">{<I>subtype conformance (required)</I>}</FONT> <A NAME="I2754"></A></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>20</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC><FONT SIZE="-1">{<I>accessibility
rule (type conversion)</I> [partial]}</FONT> <A NAME="I2755"></A>The
accessibility level of the operand type shall not be statically deeper
than that of the target type. <FONT SIZE="-1">{<I>generic contract issue</I>
[partial]}</FONT> <A NAME="I2756"></A>In addition to the places where
Legality Rules normally apply (see <A HREF="AA-12-3.html">12.3</A>),
this rule applies also in the private part of an instance of a generic
unit. If the operand type is declared within a generic body, the target
type shall be declared within the generic body.</LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>20.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Reason: </B>The reason it
is illegal to convert from an access-to-subprogram type declared in a
generic body to one declared outside that body is that in an implementation
that shares generic bodies, procedures declared inside the generic need
to have a different calling convention -- they need an extra parameter
pointing to the data declared in the current instance. For procedures
declared in the spec, that's OK, because the compiler can know about
them at compile time of the instantiation. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>21</FONT></DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>type
conversion (enumeration)</I>}</FONT> <A NAME="I2757"></A><FONT SIZE="-1">{<I>conversion
(enumeration)</I>}</FONT> <A NAME="I2758"></A><FONT SIZE="-1">{<I>type
conversion (composite (non-array))</I>}</FONT> <A NAME="I2759"></A><FONT SIZE="-1">{<I>conversion
(composite (non-array))</I>}</FONT> <A NAME="I2760"></A>If the target
type is not included in any of the above four cases, there shall be a
type that is an ancestor of both the target type and the operand type.
Further, if the target type is tagged, then either: </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>22</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC>The operand type shall be covered
by or descended from the target type; or </LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>22.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>This is
a conversion toward the root, which is always safe. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>23</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC>The operand type shall be a class-wide
type that covers the target type. </LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>23.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>This is
a conversion of a class-wide type toward the leaves, which requires a
tag check. See Dynamic Semantics.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>23.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">These two rules imply that a
conversion from a parent type to a type extension is not permitted, as
this would require specifying the values for additional components, in
general, and changing the tag. An <FONT FACE="Arial, Helvetica">extension_aggregate</FONT>
has to be used instead, constructing a new value, rather than converting
an existing value. However, a conversion from the class-wide type rooted
at the parent type is permitted; such a conversion just verifies that
the operand's tag is a descendant of the target. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>24</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;In a view conversion for an untagged type, the
target type shall be convertible (back) to the operand type. </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>24.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Reason: </B>Untagged view
conversions appear only as [in] out parameters. Hence, the reverse conversion
must be legal as well. The forward conversion must be legal even if an
out parameter, because actual parameters of an access type are always
copied in anyway. </FONT></DIV>

<H4 ALIGN=CENTER>Static Semantics</H4>
<DIV Class="Paranum"><FONT SIZE=-2>25</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;A <FONT FACE="Arial, Helvetica">type_conversion</FONT>
that is a value conversion denotes the value that is the result of converting
the value of the operand to the target subtype.</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>26</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;A <FONT FACE="Arial, Helvetica">type_conversion</FONT>
that is a view conversion denotes a view of the object denoted by the
operand. This view is a variable of the target type if the operand denotes
a variable; otherwise it is a constant of the target type.</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>27</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>nominal subtype (associated
with a type_conversion)</I> [partial]}</FONT> <A NAME="I2761"></A>The
nominal subtype of a <FONT FACE="Arial, Helvetica">type_conversion</FONT>
is its target subtype. </DIV>

<H4 ALIGN=CENTER>Dynamic Semantics</H4>
<DIV Class="Paranum"><FONT SIZE=-2>28</FONT></DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>evaluation
(value conversion)</I> [partial]}</FONT> <A NAME="I2762"></A><FONT SIZE="-1">{<I>corresponding
value (of the target type of a conversion)</I>}</FONT> <A NAME="I2763"></A><FONT SIZE="-1">{<I>conversion</I>}</FONT>
<A NAME="I2764"></A>For the evaluation of a <FONT FACE="Arial, Helvetica">type_conversion</FONT>
that is a value conversion, the operand is evaluated, and then the value
of the operand is <I>converted</I> to a <I>corresponding</I> value of
the target type, if any. <FONT SIZE="-1">{<I>Range_Check</I> [partial]}</FONT>
<A NAME="I2765"></A><FONT SIZE="-1">{<I>check, language-defined (Range_Check)</I>}</FONT>
<A NAME="I2766"></A><FONT SIZE="-1">{<I>Constraint_Error (raised by failure
of run-time check)</I>}</FONT> <A NAME="I2767"></A>If there is no value
of the target type that corresponds to the operand value, Constraint_Error
is raised[; this can only happen on conversion to a modular type, and
only when the operand value is outside the base range of the modular
type.] Additional rules follow: </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>29</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC><FONT SIZE="-1">{<I>type conversion
(numeric)</I>}</FONT> <A NAME="I2768"></A><FONT SIZE="-1">{<I>conversion
(numeric)</I>}</FONT> <A NAME="I2769"></A>Numeric Type Conversion </LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>30</FONT></DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>If the target and the operand
types are both integer types, then the result is the value of the target
type that corresponds to the same mathematical integer as the operand.</LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>31</FONT></DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>If the target type is a decimal
fixed point type, then the result is truncated (toward 0) if the value
of the operand is not a multiple of the <I>small</I> of the target type.</LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>32</FONT></DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC><FONT SIZE="-1">{<I>accuracy</I>}</FONT>
<A NAME="I2770"></A>If the target type is some other real type, then
the result is within the accuracy of the target type (see <A HREF="AA-G-2.html">G.2</A>,
``<A HREF="AA-G-2.html">Numeric Performance Requirements</A>'', for implementations
that support the Numerics Annex). </LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>32.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Discussion: </B>An integer
type might have more bits of precision than a real type, so on conversion
(of a large integer), some precision might be lost. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>33</FONT></DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>If the target type is an integer
type and the operand type is real, the result is rounded to the nearest
integer (away from zero if exactly halfway between two integers). </LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>33.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Discussion: </B>This was
implementation defined in Ada 83. There seems no reason to preserve the
nonportability in Ada 95. Round-away-from-zero is the conventional definition
of rounding, and standard Fortran and COBOL both specify rounding away
from zero, so for interoperability, it seems important to pick this.
This is also the most easily ``undone'' by hand. Round-to-nearest-even
is an alternative, but that is quite complicated if not supported by
the hardware. In any case, this operation is not expected to be part
of an inner loop, so predictability and portability are judged most important.
We anticipate that a floating point attribute function Unbiased_Rounding
will be provided for those applications that require round-to-nearest-even.
``Deterministic'' rounding is required for static conversions to integer
as well. See <A HREF="AA-4-9.html">4.9</A>. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>34</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC><FONT SIZE="-1">{<I>type conversion
(enumeration)</I>}</FONT> <A NAME="I2771"></A><FONT SIZE="-1">{<I>conversion
(enumeration)</I>}</FONT> <A NAME="I2772"></A>Enumeration Type Conversion
</LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>35</FONT></DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>The result is the value of the
target type with the same position number as that of the operand value.
</LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>36</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC><FONT SIZE="-1">{<I>type conversion
(array)</I>}</FONT> <A NAME="I2773"></A><FONT SIZE="-1">{<I>conversion
(array)</I>}</FONT> <A NAME="I2774"></A>Array Type Conversion </LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>37</FONT></DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC><FONT SIZE="-1">{<I>Length_Check</I>
[partial]}</FONT> <A NAME="I2775"></A><FONT SIZE="-1">{<I>check, language-defined
(Length_Check)</I>}</FONT> <A NAME="I2776"></A>If the target subtype
is a constrained array subtype, then a check is made that the length
of each dimension of the value of the operand equals the length of the
corresponding dimension of the target subtype. The bounds of the result
are those of the target subtype.</LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>38</FONT></DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC><FONT SIZE="-1">{<I>Range_Check</I>
[partial]}</FONT> <A NAME="I2777"></A><FONT SIZE="-1">{<I>check, language-defined
(Range_Check)</I>}</FONT> <A NAME="I2778"></A>If the target subtype is
an unconstrained array subtype, then the bounds of the result are obtained
by converting each bound of the value of the operand to the corresponding
index type of the target type. <FONT SIZE="-1">{<I>implicit subtype conversion
(array bounds)</I> [partial]}</FONT> <A NAME="I2779"></A>For each nonnull
index range, a check is made that the bounds of the range belong to the
corresponding index subtype. </LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>38.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Discussion: </B>Only nonnull
index ranges are checked, per AI83-00313. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>39</FONT></DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>In either array case, the value
of each component of the result is that of the matching component of
the operand value (see <A HREF="AA-4-5-2.html">4.5.2</A>). </LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>39.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>This applies
whether or not the component is initialized. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>40</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC><FONT SIZE="-1">{<I>type conversion
(composite (non-array))</I>}</FONT> <A NAME="I2780"></A><FONT SIZE="-1">{<I>conversion
(composite (non-array))</I>}</FONT> <A NAME="I2781"></A>Composite (Non-Array)
Type Conversion </LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>41</FONT></DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>The value of each nondiscriminant
component of the result is that of the matching component of the operand
value. </LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>41.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>This applies
whether or not the component is initialized. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>42</FONT></DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>[The tag of the result is that
of the operand.] <FONT SIZE="-1">{<I>Tag_Check</I> [partial]}</FONT>
<A NAME="I2782"></A><FONT SIZE="-1">{<I>check, language-defined (Tag_Check)</I>}</FONT>
<A NAME="I2783"></A>If the operand type is class-wide, a check is made
that the tag of the operand identifies a (specific) type that is covered
by or descended from the target type. </LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>42.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>This check
is certain to succeed if the operand type is itself covered by or descended
from the target type. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>42.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Proof: </B>The fact that
a <FONT FACE="Arial, Helvetica">type_conversion</FONT> preserves the
tag is stated officially in <A HREF="AA-3-9.html">3.9</A>, ``<A HREF="AA-3-9.html">Tagged
Types and Type Extensions</A>'' </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>43</FONT></DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>For each discriminant of the
target type that corresponds to a discriminant of the operand type, its
value is that of the corresponding discriminant of the operand value;
<FONT SIZE="-1">{<I>Discriminant_Check</I> [partial]}</FONT> <A NAME="I2784"></A><FONT SIZE="-1">{<I>check,
language-defined (Discriminant_Check)</I>}</FONT> <A NAME="I2785"></A>if
it corresponds to more than one discriminant of the operand type, a check
is made that all these discriminants are equal in the operand value.</LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>44</FONT></DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>For each discriminant of the
target type that corresponds to a discriminant that is specified by the
<FONT FACE="Arial, Helvetica">derived_type_definition</FONT> for some
ancestor of the operand type (or if class-wide, some ancestor of the
specific type identified by the tag of the operand), its value in the
result is that specified by the <FONT FACE="Arial, Helvetica">derived_type_definition</FONT>.
</LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>44.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>It is a
ramification of the rules for the discriminants of derived types that
each discriminant of the result is covered either by this paragraph or
the previous one. See <A HREF="AA-3-7.html">3.7</A>. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>45</FONT></DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC><FONT SIZE="-1">{<I>Discriminant_Check</I>
[partial]}</FONT> <A NAME="I2786"></A><FONT SIZE="-1">{<I>check, language-defined
(Discriminant_Check)</I>}</FONT> <A NAME="I2787"></A>For each discriminant
of the operand type that corresponds to a discriminant that is specified
by the <FONT FACE="Arial, Helvetica">derived_type_definition</FONT> for
some ancestor of the target type, a check is made that in the operand
value it equals the value specified for it.</LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>46</FONT></DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC><FONT SIZE="-1">{<I>Range_Check</I>
[partial]}</FONT> <A NAME="I2788"></A><FONT SIZE="-1">{<I>check, language-defined
(Range_Check)</I>}</FONT> <A NAME="I2789"></A>For each discriminant of
the result, a check is made that its value belongs to its subtype. </LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>47</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC><FONT SIZE="-1">{<I>type conversion
(access)</I>}</FONT> <A NAME="I2790"></A><FONT SIZE="-1">{<I>conversion
(access)</I>}</FONT> <A NAME="I2791"></A>Access Type Conversion </LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>48</FONT></DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>For an access-to-object type,
a check is made that the accessibility level of the operand type is not
deeper than that of the target type. <FONT SIZE="-1">{<I>Accessibility_Check</I>
[partial]}</FONT> <A NAME="I2792"></A><FONT SIZE="-1">{<I>check, language-defined
(Accessibility_Check)</I>}</FONT> <A NAME="I2793"></A></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>48.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>This check
is needed for operands that are access parameters and in instance bodies.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>48.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">Note that this check can never
fail for the implicit conversion to the anonymous type of an access parameter
that is done when calling a subprogram with an access parameter. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>49</FONT></DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>If the target type is an anonymous
access type, a check is made that the value of the operand is not null;
if the target is not an anonymous access type, then the result is null
if the operand value is null. <FONT SIZE="-1">{<I>Access_Check</I> [partial]}</FONT>
<A NAME="I2794"></A><FONT SIZE="-1">{<I>check, language-defined (Access_Check)</I>}</FONT>
<A NAME="I2795"></A></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>49.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>A conversion
to an anonymous access type happens implicitly as part of initializing
an access discriminant or access parameter. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>49.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Reason: </B>As explained
in <A HREF="AA-3-10.html">3.10</A>, ``<A HREF="AA-3-10.html">Access Types</A>'',
it is important that a value of an anonymous access type can never be
null. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>50</FONT></DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>If the operand value is not
null, then the result designates the same object (or subprogram) as is
designated by the operand value, but viewed as being of the target designated
subtype (or profile); any checks associated with evaluating a conversion
to the target designated subtype are performed. </LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>50.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>The checks
are certain to succeed if the target and operand designated subtypes
statically match. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>51</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>Range_Check</I> [partial]}</FONT>
<A NAME="I2796"></A><FONT SIZE="-1">{<I>check, language-defined (Range_Check)</I>}</FONT>
<A NAME="I2797"></A><FONT SIZE="-1">{<I>Discriminant_Check</I> [partial]}</FONT>
<A NAME="I2798"></A><FONT SIZE="-1">{<I>check, language-defined (Discriminant_Check)</I>}</FONT>
<A NAME="I2799"></A><FONT SIZE="-1">{<I>Index_Check</I> [partial]}</FONT>
<A NAME="I2800"></A><FONT SIZE="-1">{<I>check, language-defined (Index_Check)</I>}</FONT>
<A NAME="I2801"></A>After conversion of the value to the target type,
if the target subtype is constrained, a check is performed that the value
satisfies this constraint. </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>51.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>The above
check is a Range_Check for scalar subtypes, a Discriminant_Check or Index_Check
for access subtypes, and a Discriminant_Check for discriminated subtypes.
The Length_Check for an array conversion is performed as part of the
conversion to the target type. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>52</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>evaluation (view conversion)</I>
[partial]}</FONT> <A NAME="I2802"></A>For the evaluation of a view conversion,
the operand <FONT FACE="Arial, Helvetica">name</FONT> is evaluated, and
a new view of the object denoted by the operand is created, whose type
is the target type; <FONT SIZE="-1">{<I>Length_Check</I> [partial]}</FONT>
<A NAME="I2803"></A><FONT SIZE="-1">{<I>check, language-defined (Length_Check)</I>}</FONT>
<A NAME="I2804"></A><FONT SIZE="-1">{<I>Tag_Check</I> [partial]}</FONT>
<A NAME="I2805"></A><FONT SIZE="-1">{<I>check, language-defined (Tag_Check)</I>}</FONT>
<A NAME="I2806"></A><FONT SIZE="-1">{<I>Discriminant_Check</I> [partial]}</FONT>
<A NAME="I2807"></A><FONT SIZE="-1">{<I>check, language-defined (Discriminant_Check)</I>}</FONT>
<A NAME="I2808"></A>if the target type is composite, checks are performed
as above for a value conversion.</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>53</FONT></DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;&nbsp;&nbsp;&nbsp;The properties
of this new view are as follows: </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>54/1</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="defect1.html#8652/0017">8652/0017</A></I>}
If the target type is composite, the bounds or discriminants (if any)
of the view are as defined above for a value conversion; each nondiscriminant
component of the view denotes the matching component of the operand object;
the subtype of the view is constrained if either the target subtype or
the operand object is constrained, <U>or if the target subtype is indefinite,</U> 
or if the operand type is a descendant of the target type, and has discriminants
that were not inherited from the target type;</LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>55</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC>If the target type is tagged, then
an assignment to the view assigns to the corresponding part of the object
denoted by the operand; otherwise, an assignment to the view assigns
to the object, after converting the assigned value to the subtype of
the object (which might raise Constraint_Error); <FONT SIZE="-1">{<I>implicit
subtype conversion (assignment to view conversion)</I> [partial]}</FONT>
<A NAME="I2809"></A></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>56</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC>Reading the value of the view yields
the result of converting the value of the operand object to the target
subtype (which might raise Constraint_Error), except if the object is
of an access type and the view conversion is passed as an <B>out</B>
parameter; in this latter case, the value of the operand object is used
to initialize the formal parameter without checking against any constraint
of the target subtype (see <A HREF="AA-6-4-1.html">6.4.1</A>). <FONT SIZE="-1">{<I>implicit
subtype conversion (reading a view conversion)</I> [partial]}</FONT>
<A NAME="I2810"></A></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>56.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Reason: </B>This ensures
that even an <B>out</B> parameter of an access type is initialized reasonably.
</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>57</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>Program_Error (raised by
failure of run-time check)</I>}</FONT> <A NAME="I2811"></A><FONT SIZE="-1">{<I>Constraint_Error
(raised by failure of run-time check)</I>}</FONT> <A NAME="I2812"></A>If
an Accessibility_Check fails, Program_Error is raised. Any other check
associated with a conversion raises Constraint_Error if it fails.</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>58</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;Conversion to a type is the same as conversion
to an unconstrained subtype of the type. </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>58.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Reason: </B>This definition
is needed because the semantics of various constructs involves converting
to a type, whereas an explicit <FONT FACE="Arial, Helvetica">type_conversion</FONT>
actually converts to a subtype. For example, the evaluation of a <FONT FACE="Arial, Helvetica">range</FONT>
is defined to convert the values of the expressions to the type of the
range. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>58.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>A conversion
to a scalar type, or, equivalently, to an unconstrained scalar subtype,
can raise Constraint_Error if the value is outside the base range of
the type. </FONT></DIV>
<DIV Class="NotesHeader"><FONT SIZE="-1">NOTES</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>59</FONT></DIV>
<DIV Class="Notes"><FONT SIZE="-1">20&nbsp;&nbsp;<FONT SIZE="-1">{<I>implicit
subtype conversion</I> [distributed]}</FONT> <A NAME="I2813"></A>In addition
to explicit <FONT FACE="Arial, Helvetica">type_conversion</FONT>s, type
conversions are performed implicitly in situations where the expected
type and the actual type of a construct differ, as is permitted by the
type resolution rules (see <A HREF="AA-8-6.html">8.6</A>). For example,
an integer literal is of the type <I>universal_integer</I>, and is implicitly
converted when assigned to a target of some specific integer type. Similarly,
an actual parameter of a specific tagged type is implicitly converted
when the corresponding formal parameter is of a class-wide type.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>60</FONT></DIV>
<DIV Class="Notes"><FONT SIZE="-1">21&nbsp;&nbsp;<FONT SIZE="-1">{<I>implicit
subtype conversion</I> [distributed]}</FONT> <A NAME="I2814"></A><FONT SIZE="-1">{<I>Constraint_Error
(raised by failure of run-time check)</I>}</FONT> <A NAME="I2815"></A>Even
when the expected and actual types are the same, implicit subtype conversions
are performed to adjust the array bounds (if any) of an operand to match
the desired target subtype, or to raise Constraint_Error if the (possibly
adjusted) value does not satisfy the constraints of the target subtype.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>61</FONT></DIV>
<DIV Class="Notes"><FONT SIZE="-1">A ramification of the overload resolution
rules is that the operand of an (explicit) <FONT FACE="Arial, Helvetica">type_conversion</FONT>
cannot be the literal <B>null</B>, an <FONT FACE="Arial, Helvetica">allocator</FONT>,
an <FONT FACE="Arial, Helvetica">aggregate</FONT>, a <FONT FACE="Arial, Helvetica">string_literal</FONT>,
a <FONT FACE="Arial, Helvetica">character_literal</FONT>, or an <FONT FACE="Arial, Helvetica">attribute_reference</FONT>
for an Access or Unchecked_Access attribute. Similarly, such an <FONT FACE="Arial, Helvetica">expression</FONT>
enclosed by parentheses is not allowed. A <FONT FACE="Arial, Helvetica">qualified_expression</FONT>
(see <A HREF="AA-4-7.html">4.7</A>) can be used instead of such a <FONT FACE="Arial, Helvetica">type_conversion</FONT>.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>62</FONT></DIV>
<DIV Class="Notes"><FONT SIZE="-1">22&nbsp;&nbsp;The constraint of the
target subtype has no effect for a <FONT FACE="Arial, Helvetica">type_conversion</FONT>
of an elementary type passed as an <B>out</B> parameter. Hence, it is
recommended that the first subtype be specified as the target to minimize
confusion (a similar recommendation applies to renaming and generic formal
<B>in out</B> objects). </FONT></DIV>

<H4 ALIGN=CENTER>Examples</H4>
<DIV Class="Paranum"><FONT SIZE=-2>63</FONT></DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;&nbsp;&nbsp;&nbsp;<I>Examples of
numeric type conversion:</I> </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>64</FONT></DIV>
<DIV Class="Examples"><TT>Real(2*J)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>--&nbsp;&nbsp;value&nbsp;is&nbsp;converted&nbsp;to&nbsp;floating&nbsp;point</I><BR>
Integer(1.6)&nbsp;&nbsp;&nbsp;<I>--&nbsp;&nbsp;value&nbsp;is&nbsp;2</I><BR>
Integer(-0.4)&nbsp;&nbsp;<I>--&nbsp;&nbsp;value&nbsp;is&nbsp;0</I></TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>65</FONT></DIV>
<DIV Class="Wide" Style="margin-bottom: 0.4em">&nbsp;&nbsp;&nbsp;&nbsp;<I>Example of conversion
between derived types:</I> </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>66</FONT></DIV>
<DIV Class="Examples"><TT><B>type</B>&nbsp;A_Form&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;B_Form;</TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>67</FONT></DIV>
<DIV Class="Examples"><TT>X&nbsp;:&nbsp;A_Form;<BR>
Y&nbsp;:&nbsp;B_Form;</TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>68</FONT></DIV>
<DIV Class="Examples"><TT>X&nbsp;:=&nbsp;A_Form(Y);<BR>
Y&nbsp;:=&nbsp;B_Form(X);&nbsp;&nbsp;<I>--&nbsp;&nbsp;the&nbsp;reverse&nbsp;conversion&nbsp;</I></TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>69</FONT></DIV>
<DIV Class="Wide" Style="margin-bottom: 0.4em">&nbsp;&nbsp;&nbsp;&nbsp;<I>Examples of conversions
between array types:</I> </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>70</FONT></DIV>
<DIV Class="Examples"><TT><B>type</B>&nbsp;Sequence&nbsp;<B>is</B>&nbsp;<B>array</B>&nbsp;(Integer&nbsp;<B>range</B>&nbsp;&lt;&gt;)&nbsp;<B>of</B>&nbsp;Integer;<BR>
<B>subtype</B>&nbsp;Dozen&nbsp;<B>is</B>&nbsp;Sequence(1&nbsp;..&nbsp;12);<BR>
Ledger&nbsp;:&nbsp;<B>array</B>(1&nbsp;..&nbsp;100)&nbsp;<B>of</B>&nbsp;Integer;</TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>71</FONT></DIV>
<DIV Class="Examples"><TT>Sequence(Ledger)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>--&nbsp;&nbsp;bounds&nbsp;are&nbsp;those&nbsp;of&nbsp;Ledger</I><BR>
Sequence(Ledger(31&nbsp;..&nbsp;42))&nbsp;&nbsp;<I>--&nbsp;&nbsp;bounds&nbsp;are&nbsp;31&nbsp;and&nbsp;42</I><BR>
Dozen(Ledger(31&nbsp;..&nbsp;42))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>--&nbsp;&nbsp;bounds&nbsp;are&nbsp;those&nbsp;of&nbsp;Dozen&nbsp;</I></TT></DIV>

<H4 ALIGN=CENTER>Incompatibilities With Ada 83</H4>
<DIV Class="Paranum"><FONT SIZE=-2>71.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">{<I>incompatibilities with Ada
83</I>} <A NAME="I2816"></A>A <FONT FACE="Arial, Helvetica">character_literal</FONT>
is not allowed as the operand of a <FONT FACE="Arial, Helvetica">type_conversion</FONT>,
since there are now two character types in package Standard.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>71.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">The component subtypes have
to statically match in an array conversion, rather than being checked
for matching constraints at run time.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>71.c</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">Because sliding of array bounds
is now provided for operations where it was not in Ada 83, programs that
used to raise Constraint_Error might now continue executing and produce
a reasonable result. This is likely to fix more bugs than it creates.
</FONT></DIV>

<H4 ALIGN=CENTER>Extensions to Ada 83</H4>
<DIV Class="Paranum"><FONT SIZE=-2>71.d</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">{<I>extensions to Ada 83</I>}
<A NAME="I2817"></A>A <FONT FACE="Arial, Helvetica">type_conversion</FONT>
is considered the name of an object in certain circumstances (such a
<FONT FACE="Arial, Helvetica">type_conversion</FONT> is called a view
conversion). In particular, as in Ada 83, a <FONT FACE="Arial, Helvetica">type_conversion</FONT>
can appear as an <B>in out</B> or <B>out</B> actual parameter. In addition,
if the target type is tagged and the operand is the <FONT FACE="Arial, Helvetica">name</FONT>
of an object, then so is the <FONT FACE="Arial, Helvetica">type_conversion</FONT>,
and it can be used as the <FONT FACE="Arial, Helvetica">prefix</FONT>
to a <FONT FACE="Arial, Helvetica">selected_component</FONT>, in an <FONT FACE="Arial, Helvetica">object_renaming_declaration</FONT>,
etc.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>71.e</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">We no longer require type-mark
conformance between a parameter of the form of a type conversion, and
the corresponding formal parameter. This had caused some problems for
inherited subprograms (since there isn't really a type-mark for converted
formals), as well as for renamings, formal subprograms, etc. See AI83-00245,
AI83-00318, AI83-00547.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>71.f</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">We now specify ``deterministic''
rounding from real to integer types when the value of the operand is
exactly between two integers (rounding is away from zero in this case).</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>71.g</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">``Sliding'' of array bounds
(which is part of conversion to an array subtype) is performed in more
cases in Ada 95 than in Ada 83. Sliding is not performed on the operand
of a membership test, nor on the operand of a <FONT FACE="Arial, Helvetica">qualified_expression</FONT>.
It wouldn't make sense on a membership test, and we wish to retain a
connection between subtype membership and subtype qualification. In general,
a subtype membership test returns True if and only if a corresponding
subtype qualification succeeds without raising an exception. Other operations
that take arrays perform sliding. </FONT></DIV>

<H4 ALIGN=CENTER>Wording Changes from Ada 83</H4>
<DIV Class="Paranum"><FONT SIZE=-2>71.h</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">We no longer explicitly list
the kinds of things that are not allowed as the operand of a <FONT FACE="Arial, Helvetica">type_conversion</FONT>,
except in a NOTE.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>71.i</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">The rules in this clause subsume
the rules for &quot;parameters of the form of a type conversion,&quot;
and have been generalized to cover the use of a type conversion as a
<FONT FACE="Arial, Helvetica">name</FONT>. </FONT></DIV>

<HR>
<P><A HREF="AA-TOC.html">Contents</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-0-29.html">Index</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-SRCH.html">Search</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-4-5-6.html">Previous</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-4-7.html">Next</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-TTL.html">Legal</A></P>
</BODY>
</HTML>
