<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML><HEAD>
<TITLE>Ada 83 LRM, Sec 10.1: Compilation Units - Library Units</TITLE>
</HEAD><BODY>
<hr><a href="ada_lrm.html"><IMG SRC="adass.gif" align=LEFT hspace=6 vspace=6 alt="Lady Ada"></a><H1>Ada '83 Language Reference Manual</H1>
<h6><a href="ada_legal.html">Copyright</a> 1980, 1982, 1983 owned by the United States Government. Direct reproduction and usage requests to the <a href="mailto://adainfo@sw-eng.falls-church.va.us">Ada Information Clearinghouse</a>.</h6>
<br clear=LEFT>
<hr>

<H2><A NAME="10.1">10.1</A>.  Compilation Units - Library Units  </H2>
<A HREF="lrm-10.html#10"><img src="lrm-up.gif" alt="[UP]"></A><A HREF="lrm-10-02.html#10.2"><img src="lrm-next.gif" alt="[NEXT]"></A>
<P>
The text of a program can be submitted to  the  compiler  in  one  or  more
compilations.  Each compilation is a succession of compilation units. 
<pre>
    compilation ::= {compilation_unit} 

    compilation_unit ::=
         context_clause library_unit | context_clause secondary_unit 

    library_unit ::=
         subprogram_declaration | package_declaration
       | generic_declaration    | generic_instantiation
       | subprogram_body 

    secondary_unit ::= library_unit_body | subunit 

    library_unit_body ::= subprogram_body | package_body 
</pre>
<P>
The compilation units of a program are said to belong to a program library.
A  compilation  unit  defines either a library unit or a secondary unit.  A
secondary unit is either the separately compiled proper body of  a  library  
unit,  or  a  subunit  of  another  compilation  unit.  The designator of a
separately compiled subprogram (whether a library unit or a  subunit)  must
be an identifier.  Within a program library the simple names of all library
units must be distinct identifiers.    
<P>
The effect of compiling a library unit is to define (or redefine) this unit
as one that belongs to the program library.  For the visibility rules, each
library  unit  acts  as  a  declaration  that occurs immediately within the
package STANDARD. 
<P>
The effect of compiling a secondary unit is to define the body of a library
unit, or in the case of a subunit, to define the proper body of  a  program
unit that is declared within another compilation unit.                                                 
<P>
A subprogram body given in a compilation unit is interpreted as a secondary
unit  if  the  program  library  already  contains a library unit that is a
subprogram with the same name;  it  is  otherwise  interpreted  both  as  a
library  unit  and  as  the  corresponding library unit body (that is, as a
secondary unit). 
<P>
The compilation units of a compilation are compiled in the given order.   A
pragma  that  applies  to the whole of a compilation must appear before the
first compilation unit of that compilation. 
<P>
A subprogram that is a library unit can be used as a main  program  in  the
usual sense.  Each main program acts as if called by some environment task;
the  means  by  which this execution is initiated are not prescribed by the
language definition.  An implementation may impose certain requirements  on 
the  parameters  and  on  the  result,  if  any,  of  a main program (these
requirements  must  be  stated  in  Appendix  F).   In  any   case,   every
implementation  is  required  to  allow,  at  least, main programs that are
parameterless procedures, and every main program must be a subprogram  that
is a library unit. 
<P>
Notes: 
<P>
A  simple  program may consist of a single compilation unit.  A compilation
need not have any compilation units;  for example, its text can consist  of
pragmas. 
<P>
The  designator  of  a library function cannot be an operator symbol, but a
renaming declaration  is  allowed  to  rename  a  library  function  as  an
operator.   Two  library  subprograms  must  have distinct simple names and
hence cannot overload  each  other.   However,  renaming  declarations  are
allowed  to  define  overloaded  names  for such subprograms, and a locally
declared subprogram is allowed  to  overload  a  library  subprogram.   The
expanded  name STANDARD.L can be used for a library unit L (unless the name
STANDARD is hidden) since library units  act  as  declarations  that  occur
immediately within the package STANDARD. 
<P>
<b>References:</b>   <A HREF="lrm-01-06.html#1.6">allow</A>,
<A HREF="#10.1.1">context clause</A>,
<A HREF="lrm-03-01.html#3.1">declaration</A>,
<A HREF="lrm-06-01.html#6.1">designator</A>,
<A HREF="lrm-10-04.html#10.4">environment</A>,
<A HREF="lrm-12-01.html#12.1">generic  declaration</A>,
<A HREF="lrm-12-03.html#12.3">generic  instantiation</A>,
<A HREF="lrm-08-03.html#8.3">hiding</A>,
<A HREF="lrm-02-03.html#2.3">identifier</A>,
<A HREF="lrm-10-05.html#10.5">library unit</A>,
<A HREF="lrm-08-01.html#8.1">local declaration</A>,
<A HREF="lrm-01-06.html#1.6">must</A>,
<A HREF="lrm-04-01.html#4.1">name</A>,
<A HREF="lrm-08-01.html#8.1">occur immediately within</A>,
<A HREF="lrm-04-05.html#4.5">operator</A>,
<A HREF="lrm-06-01.html#6.1">operator symbol</A>,
<A HREF="lrm-06-06.html#6.6">overloading</A>,
 and <A HREF="lrm-08-07.html#8.7">8.7</A>,
<A HREF="lrm-07-01.html#7.1">package body</A>,
<A HREF="lrm-07-01.html#7.1">package declaration</A>,
<A HREF="lrm-06-02.html#6.2">parameter of a subprogram</A>,
<A HREF="lrm-02-08.html#2.8">pragma</A>,
<A HREF="lrm-06-01.html#6.1">procedure</A>,
<A HREF="lrm-06.html#6">program  unit</A>,
<A HREF="lrm-03-09.html#3.9">proper  body</A>,
<A HREF="lrm-08-05.html#8.5">renaming  declaration</A>,
<A HREF="lrm-04-01.html#4.1">simple  name</A>,
<A HREF="lrm-08-06.html#8.6">standard package</A>,
<A HREF="lrm-06.html#6">subprogram</A>,
<A HREF="lrm-06-03.html#6.3">subprogram body</A>,
<A HREF="lrm-06-01.html#6.1">subprogram declaration</A>,
<A HREF="lrm-10-02.html#10.2">subunit</A>,
<A HREF="lrm-09.html#9">task</A>,
<A HREF="lrm-08-03.html#8.3">visibility</A>.
<P>
<b>Style Guide references:</b> 
	<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-03-03.html#3.3.2">3.3.2&nbsp;File Headers</a>, 
	<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-04-01.html#4.1.1">4.1.1&nbsp;Separate Compilation Capabilities</a>, 
	<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-07-01.html#7.1.4">7.1.4&nbsp;Main Subprogram</a>
<p>
<b>Sub-topics:</b>
<ul>
<li><A HREF="#10.1.1">10.1.1</A> Context Clauses - With Clauses  
<li><A HREF="#10.1.2">10.1.2</A> Examples of Compilation Units  
</ul>


<H3><A NAME="10.1.1">10.1.1</A>.  Context Clauses - With Clauses  </H3>
<A HREF="#10.1"><img src="lrm-up.gif" alt="[UP]"></A><A HREF="#10.1.2"><img src="lrm-next.gif" alt="[NEXT]"></A>
<P>
A context clause is used to specify  the  library  units  whose  names  are 
needed within a compilation unit.   
<pre>
    context_clause ::= {with_clause {use_clause}} 

    with_clause ::= with unit_simple_name {, unit_simple_name}; 
</pre>
<P>
The  names  that  appear  in  a  context clause must be the simple names of
library units.  The simple name of any library unit  is  allowed  within  a
with  clause.   The  only names allowed in a use clause of a context clause
are the simple names of library packages mentioned by previous with clauses
of the context clause.  A simple name declared by a renaming declaration is
not allowed in a context clause. 
<P>
The with clauses and use clauses of the context clause of  a  library  unit
apply  to this library unit and also to the secondary unit that defines the
corresponding body (whether such a clause  is  repeated  or  not  for  this
unit).   Similarly,  the with clauses and use clauses of the context clause
of a compilation unit apply to this unit and also to its subunits, if  any.                                         
<P>
If  a  library unit is named by a with clause that applies to a compilation
unit, then this library unit is directly  visible  within  the  compilation
unit,  except  where  hidden;   the  library unit is visible as if declared
immediately within the package STANDARD (see <a href="lrm-08-06.html#8.6">8.6</a>). 
<P>
Dependences among compilation units are defined by with clauses;  that  is,
a  compilation  unit  that mentions other library units in its with clauses
depends on those library units.  These dependences between units are  taken
into account for the determination of the allowed order of compilation (and
recompilation)  of compilation units, as explained in section <a href="lrm-10-03.html#10.3">10.3</a>, and for   
the determination of the allowed order of elaboration of compilation units,
as explained in section <a href="lrm-10-05.html#10.5">10.5</a>. 
<P>
Notes: 
<P>
A library unit named by a with clause of  a  compilation  unit  is  visible
(except  where hidden) within the compilation unit and hence can be used as
a corresponding program unit.  Thus within the compilation unit,  the  name
of  a  library  package can be given in use clauses and can be used to form
expanded names;  a library subprogram can be called;  and  instances  of  a
library generic unit can be declared. 
<P>
The  rules given for with clauses are such that the same effect is obtained
whether the name of a library unit is mentioned once or more than  once  by
the applicable with clauses, or even within a given with clause. 
<P>
Example 1 : A main program: 
<P>
The  following  is  an  example  of  a  main program consisting of a single
compilation unit:  a procedure for printing the real roots of  a  quadratic
equation.   The  predefined  package  TEXT_IO  and  a  user-defined package
REAL_OPERATIONS (containing the definition of the  type  REAL  and  of  the
packages  REAL_IO  and REAL_FUNCTIONS) are assumed to be already present in
the program library.  Such packages may be used by other main programs. 
<pre>
    with TEXT_IO, REAL_OPERATIONS; use REAL_OPERATIONS;
    procedure QUADRATIC_EQUATION is
       A, B, C, D : REAL;
       use REAL_IO,         --  achieves direct visibility of GET and PUT
                                for REAL
           TEXT_IO,         --  achieves direct visibility of PUT for strings
                                and of NEW_LINE
           REAL_FUNCTIONS;  --  achieves direct visibility of SQRT
    begin
       GET(A); GET(B); GET(C);
       D := B**2 - 4.0*A*C;
       if D &lt; 0.0 then
          PUT("Imaginary Roots.");
       else
          PUT("Real Roots : X1 = ");
          PUT((-B - SQRT(D))/(2.0*A)); PUT(" X2 = ");
          PUT((-B + SQRT(D))/(2.0*A));
       end if;
       NEW_LINE; 
    end QUADRATIC_EQUATION;    
</pre>
<P>
Notes on the example: 
<P>
The with clauses of a compilation unit need only mention the names of those
library subprograms and packages whose  visibility  is  actually  necessary
within  the  unit.   They  need  not (and should not) mention other library
units that are used in turn by some of the units named in the with clauses,
unless these other library units are also  used  directly  by  the  current
compilation unit.  For example, the body of the package REAL_OPERATIONS may
need elementary operations provided by other packages.  The latter packages
should  not  be  named by the with clause of QUADRATIC_EQUATION since these
elementary operations are not directly called within its body.                                              
<P>
<b>References:</b>  <A HREF="lrm-01-06.html#1.6">allow</A>,
<A HREF="#10.1">compilation  unit</A>,
<A HREF="lrm-08-03.html#8.3">direct  visibility</A>,
<A HREF="lrm-03-09.html#3.9">elaboration</A>,
<A HREF="lrm-12-02.html#12.2">generic body</A>,
<A HREF="lrm-12-01.html#12.1">generic unit</A>,
<A HREF="lrm-08-03.html#8.3">hiding</A>,
<A HREF="lrm-12-03.html#12.3">instance</A>,
<A HREF="#10.1">library unit</A>,
<A HREF="#10.1">main program</A>,
<A HREF="lrm-01-06.html#1.6">must</A>,
<A HREF="lrm-04-01.html#4.1">name</A>,
<A HREF="lrm-07.html#7">package</A>,
<A HREF="lrm-07-01.html#7.1">package body</A>,
<A HREF="lrm-07-01.html#7.1">package declaration</A>,
<A HREF="lrm-06-01.html#6.1">procedure</A>,
<A HREF="lrm-06.html#6">program  unit</A>,
<A HREF="#10.1">secondary  unit</A>,
<A HREF="lrm-04-01.html#4.1">simple  name</A>,
<A HREF="lrm-08-06.html#8.6">standard predefined package</A>,
<A HREF="lrm-06-03.html#6.3">subprogram body</A>,
<A HREF="lrm-06-01.html#6.1">subprogram declaration</A>,
<A HREF="lrm-10-02.html#10.2">subunit</A>,
<A HREF="lrm-03-03.html#3.3">type</A>,
<A HREF="lrm-08-04.html#8.4">use clause</A>,
<A HREF="lrm-08-03.html#8.3">visibility</A>.
<P>
<b>Style Guide references:</b> 
	<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-02-01.html#2.1.2">2.1.2&nbsp;Indentation</a>, 
	<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-04-02.html#4.2.1">4.2.1&nbsp;Minimization of Interfaces</a>, 
	<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-04-02.html#4.2.3">4.2.3&nbsp;Restricting Visibility</a>, 
	<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-08-02.html#8.2.6">8.2.6&nbsp;Hidden Tasks</a>, 
	<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-08-04.html#8.4.1">8.4.1&nbsp;Using Generic Parameters to Reduce Coupling</a>, 
	<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-08-04.html#8.4.2">8.4.2&nbsp;Coupling Due to Pragmas</a>

  
<H3><A NAME="10.1.2">10.1.2</A>.  Examples of Compilation Units  </H3>
<A HREF="#10.1.1"><img src="lrm-prev.gif" alt="[PREVIOUS]"></A><A HREF="#10.1"><img src="lrm-up.gif" alt="[UP]"></A>
<P>
A  compilation  unit  can be split into a number of compilation units.  For
example, consider the following program. 
<pre>
    procedure PROCESSOR is 

       SMALL : constant := 20;
       TOTAL : INTEGER  := 0; 

       package STOCK is
          LIMIT : constant := 1 
          TABLE : array (1 .. LIMIT) of INTEGER;   
          procedure RESTART;
       end STOCK; 

       package body STOCK is
          procedure RESTART is
          begin
             for N in 1 .. LIMIT loop
                TABLE(N) := N;
             end loop;
          end;
       begin
          RESTART;
       end STOCK; 

       procedure UPDATE(X : INTEGER) is
          use STOCK;
       begin
          ...
          TABLE(X) := TABLE(X) + SMALL;
          ...
       end UPDATE; 

    begin
       ...
       STOCK.RESTART;  -- reinitializes TABLE
       ...
    end PROCESSOR; 
</pre>
<P>
The following three compilation units  define  a  program  with  an  effect
equivalent to the above example (the broken lines between compilation units
serve  to remind the reader that these units need not be contiguous texts).          
<P>
Example 2 : Several compilation units:  
<pre>
    package STOCK is
       LIMIT : constant := 1 
       TABLE : array (1 .. LIMIT) of INTEGER;
       procedure RESTART;
    end STOCK; 

    ------------------------------------------------- 

    package body STOCK is
       procedure RESTART is
       begin
          for N in 1 .. LIMIT loop
             TABLE(N) := N;
          end loop;
       end;
    begin
       RESTART;
    end STOCK; 

    ------------------------------------------------- 

    with STOCK;
    procedure PROCESSOR is 
       SMALL : constant := 20;
       TOTAL : INTEGER  := 0; 

       procedure UPDATE(X : INTEGER) is
          use STOCK;
       begin
          ...
          TABLE(X) := TABLE(X) + SMALL;
          ...
       end UPDATE;
    begin
       ...
       STOCK.RESTART;  --  reinitializes TABLE
       ...
    end PROCESSOR; 
</pre>
<P>
Note that in the latter version, the package STOCK  has  no  visibility  of  
outer  identifiers  other  than  the predefined identifiers (of the package
STANDARD).  In particular, STOCK does not use any  identifier  declared  in
PROCESSOR  such  as  SMALL  or  TOTAL;  otherwise STOCK could not have been
extracted from PROCESSOR in the above manner.  The procedure PROCESSOR,  on
the  other  hand,  depends  on  STOCK  and  mentions this package in a with
clause.  This permits the inner occurrences of STOCK in the  expanded  name
STOCK.RESTART and in the use clause. 
<P>
These three compilation units can be submitted in one or more compilations.
For  example,  it  is  possible to submit the package specification and the
package body together and in this order in a single compilation.  
<P>
<b>References:</b>   <A HREF="#10.1">compilation  unit</A>,
<A HREF="lrm-03-01.html#3.1">declaration</A>,
<A HREF="lrm-02-03.html#2.3">identifier</A>,
<A HREF="lrm-07.html#7">package</A>,
<A HREF="lrm-07-01.html#7.1">package  body</A>,
<A HREF="lrm-07-01.html#7.1">package  specification</A>,
<A HREF="lrm-10.html#10">program</A>,
<A HREF="lrm-08-06.html#8.6">standard package</A>,
<A HREF="lrm-08-04.html#8.4">use clause</A>,
<A HREF="lrm-08-03.html#8.3">visibility</A>,
<A HREF="#10.1.1">with clause</A>.
<P>


<A HREF="lrm-IDX.html"><img src="lrm-idx.gif" alt="[INDEX]"></A><A HREF="lrm-TOC.html"><img src="lrm-toc.gif" alt="[CONTENTS]"></A>

<hr>
<address><a href="http://sw-eng.falls-church.va.us/AdaIC/"><IMG SRC="small_adaic_logo.gif" ALT="[Ada Information Clearinghouse]"></a><p>
Address any questions or comments to
<A HREF="mailto://adainfo@sw-eng.falls-church.va.us">adainfo@sw-eng.falls-church.va.us</A>.</address>
</BODY></HTML>
