<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Visibility</TITLE>
    <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    H4.centered {text-align: center}
    SPAN.swiss {font-family: Arial, Helvetica, sans-serif; font-size: 92%}
    SPAN.roman {font-family: "Times New Roman", Times, serif}
    DIV.paranum {float: left; font-family: Arial, Helvetica, sans-serif; font-size: 64%; width: 2.8em; margin-left: -0.4em; margin-right: -3.0em; margin-top: 0.2em}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    SPAN.insert1 {text-decoration: underline; color: rgb(0,51,51) }
    SPAN.delete1 {text-decoration: line-through; color: rgb(0,51,51) }
    SPAN.insert2 {text-decoration: underline; color: rgb(0,102,0) }
    SPAN.delete2 {text-decoration: line-through; color: rgb(0,102,0) }
    DIV.Normal {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.2em; margin-bottom: 0.6em}
    DIV.Annotations {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 6.2em; margin-bottom: 0.6em}
    DIV.Notes {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em; margin-bottom: 0.6em}
    DIV.NotesHeader {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em}
    DIV.SmallExamples {font-family: "Courier New", monospace; font-size: 72%; line-height: 122%; margin-left: 9.6em; margin-bottom: 0.6em}
    UL.Bulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.SmallBulleted {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 8.7em; margin-right: 2.5em; margin-top: 0em; margin-bottom: 0.5em}
    UL.NestedBulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 5.2em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    DIV.SmallEnumerated-Body {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 8.7em; margin-right: 2.5em; margin-top: 0em; margin-bottom: 0.5em}
    DIV.SmallEnumerated-Term {float: left; font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 6.2em; margin-top: 0em; margin-bottom: 0em}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#000080" VLINK="#330033" ALINK="#0000FF">
<DIV><B><SPAN Style="font-size:200%; color: rgb(0,51,153)">Annotated</SPAN><SPAN Style="font-size:200%; color: rgb(0,0,102)">&nbsp;Ada Reference Manual</SPAN></B> &mdash; <A HREF="AA-TTL.html"><B>Legal Information</B></A></DIV>
<DIV Style="margin-top: 0.6em; margin-bottom: 0.0em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-8-2.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-8-3-1.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<HR>
<H1>8.3 Visibility</H1>
<DIV Class="paranum">1</DIV>
<DIV Class="Normal">[<SPAN STYLE="font-size: 80%">{<I>visibility rules</I>}</SPAN> 
<A NAME="I3707"></A>The <I>visibility rules</I>, given below, determine 
which declarations are visible and directly visible at each place within 
a program. The visibility rules apply to both explicit and implicit declarations.] 
</DIV>

<H4 Class="centered">Static Semantics</H4>
<DIV Class="paranum">2</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>visibility (direct)</I>}</SPAN> 
<A NAME="I3708"></A><SPAN STYLE="font-size: 80%">{<I>directly visible</I>}</SPAN> 
<A NAME="I3709"></A><SPAN STYLE="font-size: 80%">{<I>directly visible</I>}</SPAN> 
<A NAME="I3710"></A>A declaration is defined to be <I>directly visible</I> 
at places where a <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
consisting of only an <SPAN Class="swiss"><A HREF="AA-2-3.html#S0002">identifier</A></SPAN> 
or <SPAN Class="swiss"><A HREF="AA-6-1.html#S0155">operator_symbol</A></SPAN> 
is sufficient to denote the declaration; that is, no <SPAN Class="swiss"><A HREF="AA-4-1-3.html#S0098">selected_component</A></SPAN> 
notation or special context (such as preceding =&gt; in a named association) 
is necessary to denote the declaration. <SPAN STYLE="font-size: 80%">{<I>visible</I>}</SPAN> 
<A NAME="I3711"></A>A declaration is defined to be <I>visible</I> wherever 
it is directly visible, as well as at other places where some <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
(such as a <SPAN Class="swiss"><A HREF="AA-4-1-3.html#S0098">selected_component</A></SPAN>) 
can denote the declaration.</DIV>
<DIV Class="paranum">3</DIV>
<DIV Class="Normal">The syntactic category <SPAN Class="swiss"><A HREF="AA-4-1.html#S0092">direct_name</A></SPAN> 
is used to indicate contexts where direct visibility is required. The 
syntactic category <SPAN Class="swiss"><A HREF="AA-4-1-3.html#S0099">selector_name</A></SPAN> 
is used to indicate contexts where visibility, but not direct visibility, 
is required.</DIV>
<DIV Class="paranum">4</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>visibility (immediate)</I>}</SPAN> 
<A NAME="I3712"></A><SPAN STYLE="font-size: 80%">{<I>visibility (use 
clause)</I>}</SPAN> <A NAME="I3713"></A>There are two kinds of direct 
visibility: <I>immediate visibility</I> and <I>use-visibility</I>. <SPAN STYLE="font-size: 80%">{<I>immediately 
visible</I>}</SPAN> <A NAME="I3714"></A>A declaration is immediately 
visible at a place if it is directly visible because the place is within 
its immediate scope. <SPAN STYLE="font-size: 80%">{<I>use-visible</I>}</SPAN> 
<A NAME="I3715"></A>A declaration is use-visible if it is directly visible 
because of a <SPAN Class="swiss"><A HREF="AA-8-4.html#S0179">use_clause</A></SPAN> 
(see <A HREF="AA-8-4.html">8.4</A>). Both conditions can apply.</DIV>
<DIV Class="paranum">5</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>hiding</I>}</SPAN> 
<A NAME="I3716"></A>A declaration can be <I>hidden</I>, either from direct 
visibility, or from all visibility, within certain parts of its scope. 
<SPAN STYLE="font-size: 80%">{<I>hidden from all visibility</I>}</SPAN> 
<A NAME="I3717"></A>Where <I>hidden from all visibility</I>, it is not 
visible at all (neither using a <SPAN Class="swiss"><A HREF="AA-4-1.html#S0092">direct_name</A></SPAN> 
nor a <SPAN Class="swiss"><A HREF="AA-4-1-3.html#S0099">selector_name</A></SPAN>). 
<SPAN STYLE="font-size: 80%">{<I>hidden from direct visibility</I>}</SPAN> 
<A NAME="I3718"></A>Where <I>hidden from direct visibility</I>, only 
direct visibility is lost; visibility using a <SPAN Class="swiss"><A HREF="AA-4-1-3.html#S0099">selector_name</A></SPAN> 
is still possible.</DIV>
<DIV Class="paranum">6</DIV>
<DIV Class="Normal">[<SPAN STYLE="font-size: 80%">{<I>overloaded</I>}</SPAN> 
<A NAME="I3719"></A>Two or more declarations are <I>overloaded</I> if 
they all have the same defining name and there is a place where they 
are all directly visible.]&nbsp;</DIV>
<DIV Class="paranum">6.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>Note that a <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
can have more than one possible interpretation even if it denotes a non-overloadable 
entity. For example, if there are two functions F that return records, 
both containing a component called C, then the name F.C has two possible 
interpretations, even though component declarations are not overloadable. 
</DIV>
<DIV Class="paranum">7</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>overloadable</I>}</SPAN> 
<A NAME="I3720"></A>The declarations of callable entities [(including 
enumeration literals)] are <I>overloadable</I>[, meaning that overloading 
is allowed for them].&nbsp;</DIV>
<DIV Class="paranum">7.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>A <SPAN Class="swiss"><A HREF="AA-12-1.html#S0252">generic_declaration</A></SPAN> 
is not overloadable within its own <SPAN Class="swiss"><A HREF="AA-12-1.html#S0255">generic_formal_part</A></SPAN>. 
This follows from the rules about when a <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
denotes a current instance. See AI83-00286. This implies that within 
a <SPAN Class="swiss"><A HREF="AA-12-1.html#S0255">generic_formal_part</A></SPAN>, 
outer declarations with the same defining name are hidden from direct 
visibility. It also implies that if a generic formal parameter has the 
same defining name as the generic itself, the formal parameter hides 
the generic from direct visibility.&nbsp;</DIV>
<DIV Class="paranum">8</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>homograph</I>}</SPAN> 
<A NAME="I3721"></A>Two declarations are <I>homographs</I> if they have 
the same defining name, and, if both are overloadable, their profiles 
are type conformant. <SPAN STYLE="font-size: 80%">{<I>type conformance</I> 
[partial]}</SPAN> <A NAME="I3722"></A>[An inner declaration hides any 
outer homograph from direct visibility.]</DIV>
<DIV Class="paranum">8.a/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Glossary entry:&nbsp;</B>{<I>Overriding 
operation</I>} An overriding operation is one that replaces an inherited 
primitive operation. Operations may be marked explicitly as overriding 
or not overriding.</SPAN></DIV>
<DIV Class="paranum">9/1</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">{<I><A HREF="defect1.html#8652/0025">8652/0025</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00044.TXT">AI95-00044-01</A></I>} 
[Two homographs are not generally allowed immediately within the same 
declarative region unless one <I>overrides</I> the other (see Legality 
Rules below).] <SPAN STYLE="font-size: 80%">{<I>override</I>}</SPAN> 
<A NAME="I3723"></A><SPAN class="insert1">The only declarations that 
are <SPAN STYLE="font-size: 80%">{<I>overridable</I>}</SPAN> <A NAME="I3724"></A><I>overridable</I> 
are the implicit declarations for predefined operators and inherited 
primitive subprograms.</SPAN> A declaration overrides another homograph 
that occurs immediately within the same declarative region in the following 
cases:&nbsp;</DIV>
<DIV Class="paranum">10/1</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="defect1.html#8652/0025">8652/0025</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00044.TXT">AI95-00044-01</A></I>} 
<SPAN class="insert1">A declaration that is not overridable overrides 
one that is overridable</SPAN><SPAN class="delete1">&nbsp;An explicit declaration 
overrides an implicit declaration of a primitive subprogram</SPAN>, [regardless 
of which declaration occurs first];&nbsp;</LI></UL>
<DIV Class="paranum">10.a/1</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>{<I><A HREF="defect1.html#8652/0025">8652/0025</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00044.TXT">AI95-00044-01</A></I>} 
And regardless of whether the <SPAN class="insert1">non-overridable</SPAN><SPAN class="delete1">&nbsp;explicit</SPAN> 
declaration is overloadable or not. <SPAN class="insert1">For example, 
<SPAN Class="swiss"><A HREF="AA-5-1.html#S0136">statement_identifier</A></SPAN>s 
are covered by this rule.</SPAN></DIV>
<DIV Class="paranum">10.b</DIV>
<DIV Class="Annotations">The &ldquo;regardless of which declaration occurs 
first&rdquo; is there because the explicit declaration could be a primitive 
subprogram of a partial view, and then the full view might inherit a 
homograph. We are saying that the explicit one wins (within its scope), 
even though the implicit one comes later.</DIV>
<DIV Class="paranum">10.c</DIV>
<DIV Class="Annotations">If the overriding declaration is also a subprogram, 
then it is a primitive subprogram.</DIV>
<DIV Class="paranum">10.d</DIV>
<DIV Class="Annotations">As explained in <A HREF="AA-7-3-1.html">7.3.1</A>, 
&ldquo;<A HREF="AA-7-3-1.html">Private Operations</A>&rdquo;, some inherited 
primitive subprograms are never declared. Such subprograms cannot be 
overridden, although they can be reached by dispatching calls in the 
case of a tagged type.&nbsp;</DIV>
<DIV Class="paranum">11</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>The implicit declaration of an inherited 
operator overrides that of a predefined operator;&nbsp;</LI></UL>
<DIV Class="paranum">11.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>In a previous version of 
Ada 9X, we tried to avoid the notion of predefined operators, and say 
that they were inherited from some magical root type. However, this seemed 
like too much mechanism. Therefore, a type can have a predefined &quot;+&quot; 
as well as an inherited &quot;+&quot;. The above rule says the inherited 
one wins.</DIV>
<DIV Class="paranum">11.b/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00114.TXT">AI95-00114-01</A></I>} 
The &ldquo;regardless of which declaration occurs first&rdquo; applies 
here as well, in the case where <SPAN class="insert2"><SPAN Class="swiss"><A HREF="AA-3-4.html#S0035">derived_type_definition</A></SPAN></SPAN><SPAN class="delete2"><SPAN Class="swiss">&nbsp;derived_type_declaration</SPAN></SPAN> 
in the visible part of a public library unit derives from a private type 
declared in the parent unit, and the full view of the parent type has 
additional predefined operators, as explained in <A HREF="AA-7-3-1.html">7.3.1</A>, 
&ldquo;<A HREF="AA-7-3-1.html">Private Operations</A>&rdquo;. Those predefined 
operators can be overridden by inherited subprograms implicitly declared 
earlier.&nbsp;</DIV>
<DIV Class="paranum">12</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>An implicit declaration of an inherited 
subprogram overrides a previous implicit declaration of an inherited 
subprogram.</LI></UL>
<DIV Class="paranum">12.1/2</DIV>
<UL Class="Bulleted" Style="margin-bottom: 0.3em"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
<SPAN class="insert2">If two or more homographs are implicitly declared 
at the same place:</SPAN></LI></UL>
<DIV Class="paranum">12.2/2</DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
<SPAN class="insert2">If at least one is a subprogram that is neither 
a null procedure nor an abstract subprogram, and does not require overriding 
(see <A HREF="AA-3-9-3.html">3.9.3</A>), then they override those that 
are null procedures, abstract subprograms, or require overriding. If 
more than one such homograph remains that is not thus overridden, then 
they are all hidden from all visibility.</SPAN></LI></UL>
<DIV Class="paranum">12.3/2</DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
<SPAN class="insert2">Otherwise (all are null procedures, abstract subprograms, 
or require overriding), then any null procedure overrides all abstract 
subprograms and all subprograms that require overriding; if more than 
one such homograph remains that is not thus overridden, then if they 
are all fully conformant with one another, one is chosen arbitrarily; 
if not, they are all hidden from all visibility. <SPAN STYLE="font-size: 80%">{<I>full 
conformance (required)</I>}</SPAN> <A NAME="I3725"></A></SPAN></LI></UL>
<DIV Class="paranum">12.a/2</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><SPAN class="insert2"><B>Discussion: 
</B>In the case where the implementation arbitrarily chooses one overrider 
from among a group of inherited subprograms, users should not be able 
to determine which member was chosen, as the set of inherited subprograms 
which are chosen from must be fully conformant. This rule is needed in 
order to allow</SPAN></DIV>
<DIV Class="paranum">12.b/2</DIV>
<DIV Class="SmallExamples"><SPAN class="insert2"><B>package</B>&nbsp;Outer&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>package</B>&nbsp;P1&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Ifc1&nbsp;<B>is&nbsp;interface</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Null_Procedure&nbsp;(X&nbsp;:&nbsp;Ifc1)&nbsp;<B>is&nbsp;null</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Abstract_Subp&nbsp;&nbsp;(X&nbsp;:&nbsp;Ifc1)&nbsp;<B>is&nbsp;abstract</B>;<BR>
&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;P1;</SPAN></DIV>
<DIV Class="paranum">12.c/2</DIV>
<DIV Class="SmallExamples"><SPAN class="insert2">&nbsp;&nbsp;&nbsp;<B>package</B>&nbsp;P2&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Ifc2&nbsp;<B>is&nbsp;interface</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Null_Procedure&nbsp;(X&nbsp;:&nbsp;Ifc2)&nbsp;<B>is&nbsp;null</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Abstract_Subp&nbsp;&nbsp;(X&nbsp;:&nbsp;Ifc2)&nbsp;<B>is&nbsp;abstract</B>;<BR>
&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;P2;</SPAN></DIV>
<DIV Class="paranum">12.d/2</DIV>
<DIV Class="SmallExamples"><SPAN class="insert2">&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T&nbsp;<B>is&nbsp;abstract&nbsp;new</B>&nbsp;P1.Ifc1&nbsp;<B>and</B>&nbsp;P2.Ifc2&nbsp;<B>with&nbsp;null&nbsp;record</B>;<BR>
<B>end</B>&nbsp;Outer;</SPAN></DIV>
<DIV Class="paranum">12.e/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2">without requiring that 
T explicitly override any of its inherited operations.</SPAN></DIV>
<DIV Class="paranum">12.f/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2">Full conformance is required 
here, as we cannot allow the parameter names to differ. If they did differ, 
the routine which was selected for overriding could be determined by 
using named parameter notation in a call.</SPAN></DIV>
<DIV Class="paranum">12.g/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2">When the subprograms do 
not conform, we chose not to adopt the &ldquo;use clause&rdquo; rule 
which would make them all visible resulting in likely ambiguity. If we 
had used such a rule, any successful calls would be confusing; and the 
fact that there are no Beaujolais-like effect to worry about means we 
can consider other rules. The hidden-from-all-visibility homographs are 
still inherited by further derivations, which avoids order-of-declaration 
dependencies and other anomalies.</SPAN></DIV>
<DIV Class="paranum">12.h/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2">We have to be careful 
to not include arbitrary selection if the routines have real bodies. 
(This can happen in generics, see the example in the incompatibilities 
section below.) We don't want the ability to successfully call routines 
where the body executed depends on the compiler or a phase of the moon.</SPAN></DIV>
<DIV Class="paranum">12.i/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2">Note that if the type 
is concrete, abstract subprograms are inherited as subprograms that require 
overriding. We include functions that require overriding as well; these 
don't have real bodies, so they can use the more liberal rules.</SPAN> 
</DIV>
<DIV Class="paranum">13</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>[For an implicit declaration of a 
primitive subprogram in a generic unit, there is a copy of this declaration 
in an instance.] However, a whole new set of primitive subprograms is 
implicitly declared for each type declared within the visible part of 
the instance. These new declarations occur immediately after the type 
declaration, and override the copied ones. [The copied ones can be called 
only from within the instance; the new ones can be called only from outside 
the instance, although for tagged types, the body of a new one can be 
executed by a call to an old one.]&nbsp;</LI></UL>
<DIV Class="paranum">13.a</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>In addition, this is also 
stated redundantly (again), and is repeated, in <A HREF="AA-12-3.html">12.3</A>, 
&ldquo;<A HREF="AA-12-3.html">Generic Instantiation</A>&rdquo;. The rationale 
for the rule is explained there.&nbsp;</DIV>
<DIV Class="paranum">14</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em"><SPAN STYLE="font-size: 80%">{<I>visible</I>}</SPAN> 
<A NAME="I3726"></A><SPAN STYLE="font-size: 80%">{<I>hidden from all 
visibility</I> [distributed]}</SPAN> <A NAME="I3727"></A>A declaration 
is visible within its scope, except where hidden from all visibility, 
as follows:&nbsp;</DIV>
<DIV Class="paranum">15</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN STYLE="font-size: 80%">{<I>hidden 
from all visibility (for overridden declaration)</I> [partial]}</SPAN> 
<A NAME="I3728"></A>An overridden declaration is hidden from all visibility 
within the scope of the overriding declaration.&nbsp;</LI></UL>
<DIV Class="paranum">15.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>We have to talk about the 
scope of the overriding declaration, not its visibility, because it hides 
even when it is itself hidden.</DIV>
<DIV Class="paranum">15.b</DIV>
<DIV Class="Annotations">Note that the scope of an explicit <SPAN Class="swiss"><A HREF="AA-6-1.html#S0148">subprogram_declaration</A></SPAN> 
does not start until after its profile.&nbsp;</DIV>
<DIV Class="paranum">16</DIV>
<UL Class="Bulleted" Style="margin-bottom: 0.3em"><LI TYPE=DISC><SPAN STYLE="font-size: 80%">{<I>hidden 
from all visibility (within the declaration itself)</I> [partial]}</SPAN> 
<A NAME="I3729"></A>A declaration is hidden from all visibility until 
the end of the declaration, except:&nbsp;</LI></UL>
<DIV Class="paranum">17</DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>For a record type or record 
extension, the declaration is hidden from all visibility only until the 
reserved word <B>record</B>;</LI></UL>
<DIV Class="paranum">18/2</DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00345.TXT">AI95-00345-01</A></I>} 
For a <SPAN Class="swiss"><A HREF="AA-7-1.html#S0173">package_declaration</A></SPAN>, 
<SPAN class="delete2">task declaration, protected declaration,&nbsp;</SPAN><SPAN Class="swiss"><A HREF="AA-12-1.html#S0254">generic_package_declaration</A></SPAN>, 
or <SPAN Class="swiss"><A HREF="AA-6-3.html#S0162">subprogram_body</A></SPAN>, 
the declaration is hidden from all visibility only until the reserved 
word <B>is</B> of the declaration<SPAN class="insert2">;</SPAN><SPAN class="delete2">.</SPAN> 
</LI></UL>
<DIV Class="paranum">18.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>We're talking about the 
<B>is</B> of the construct itself, here, not some random <B>is</B> that 
might appear in a <SPAN Class="swiss"><A HREF="AA-12-1.html#S0255">generic_formal_part</A></SPAN>. 
</DIV>
<DIV Class="paranum">18.1/2</DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00345.TXT">AI95-00345-01</A></I>} 
<SPAN class="insert2">For a task declaration or protected declaration, 
the declaration is hidden from all visibility only until the reserved 
word <B>with</B> of the declaration if there is one, or the reserved 
word <B>is</B> of the declaration if there is no <B>with</B>.</SPAN></LI></UL>
<DIV Class="paranum">18.b/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>To be honest:&nbsp;</B>If 
there is neither a <B>with</B> nor <B>is</B>, then the exception does 
not apply and the name is hidden from all visibility until the end of 
the declaration. This oddity was inherited from Ada 95.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">18.c/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Reason:&nbsp;</B>We need 
the &ldquo;<B>with</B> or <B>is</B>&rdquo; rule so that the visibility 
within an <SPAN Class="swiss"><A HREF="AA-3-9-4.html#S0078">interface_list</A></SPAN> 
does not vary by construct. That would make it harder to complete private 
extensions and would complicate implementations.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">19</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN STYLE="font-size: 80%">{<I>hidden 
from all visibility (for a declaration completed   by a subsequent declaration)</I> 
[partial]}</SPAN> <A NAME="I3730"></A>If the completion of a declaration 
is a declaration, then within the scope of the completion, the first 
declaration is hidden from all visibility. Similarly, a <SPAN Class="swiss"><A HREF="AA-3-7.html#S0062">discriminant_specification</A></SPAN> 
or <SPAN Class="swiss"><A HREF="AA-6-1.html#S0160">parameter_specification</A></SPAN> 
is hidden within the scope of a corresponding <SPAN Class="swiss"><A HREF="AA-3-7.html#S0062">discriminant_specification</A></SPAN> 
or <SPAN Class="swiss"><A HREF="AA-6-1.html#S0160">parameter_specification</A></SPAN> 
of a corresponding completion, or of a corresponding <SPAN Class="swiss"><A HREF="AA-9-5-2.html#S0201">accept_statement</A></SPAN>. 
</LI></UL>
<DIV Class="paranum">19.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>This rule means, for example, 
that within the scope of a <SPAN Class="swiss"><A HREF="AA-3-2-1.html#S0024">full_type_declaration</A></SPAN> 
that completes a <SPAN Class="swiss"><A HREF="AA-7-3.html#S0176">private_type_declaration</A></SPAN>, 
the name of the type will denote the <SPAN Class="swiss"><A HREF="AA-3-2-1.html#S0024">full_type_declaration</A></SPAN>, 
and therefore the full view of the type. On the other hand, if the completion 
is not a declaration, then it doesn't hide anything, and you can't denote 
it.&nbsp;</DIV>
<DIV Class="paranum">20/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-50217.TXT">AI95-00217-06</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00412.TXT">AI95-00412-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>hidden from all visibility (by lack 
of a with_clause)</I> [partial]}</SPAN> <A NAME="I3731"></A>The declaration 
of a library unit (including a <SPAN Class="swiss"><A HREF="AA-10-1-1.html#S0232">library_unit_renaming_declaration</A></SPAN>) 
is hidden from all visibility <SPAN class="delete2">except&nbsp;</SPAN>at 
places <SPAN class="insert2">outside</SPAN><SPAN class="delete2">&nbsp;that 
are within</SPAN> its declarative region <SPAN class="insert2">that are 
not</SPAN><SPAN class="delete2">&nbsp;or</SPAN> within the scope of a <SPAN class="insert2"><SPAN Class="swiss"><A HREF="AA-10-1-2.html#S0239">nonlimited_with_clause</A></SPAN></SPAN><SPAN class="delete2"><SPAN Class="swiss"><A HREF="AA-10-1-2.html#S0237">&nbsp;with_clause</A></SPAN></SPAN> 
that mentions it.<SPAN class="insert2">&nbsp;The limited view of a library 
package is hidden from all visibility at places that are not within the 
scope of a <SPAN Class="swiss"><A HREF="AA-10-1-2.html#S0238">limited_with_clause</A></SPAN> 
that mentions it; in addition, the limited view is hidden from all visibility 
within the declarative region of the package, as well as within the scope 
of any <SPAN Class="swiss"><A HREF="AA-10-1-2.html#S0239">nonlimited_with_clause</A></SPAN> 
that mentions the package. Where the declaration of the limited view 
of a package is visible, any name that denotes the package denotes the 
limited view, including those provided by a package renaming.</SPAN><SPAN class="delete2">&nbsp;[For 
each declaration or renaming of a generic unit as a child of some parent 
generic package, there is a corresponding declaration nested immediately 
within each instance of the parent.] Such a nested declaration is hidden 
from all visibility except at places that are within the scope of a <SPAN Class="swiss"><A HREF="AA-10-1-2.html#S0237">with_clause</A></SPAN> 
that mentions the child.</SPAN></LI></UL>
<DIV Class="paranum">20.a/2</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-50217.TXT">AI95-00217-06</A></I>} 
This is the rule that prevents <SPAN Class="swiss"><A HREF="AA-10-1-2.html#S0237">with_clause</A></SPAN>s 
from being transitive; the [immediate] scope includes indirect semantic 
dependents. <SPAN class="insert2">This rule also prevents the limited 
view of a package from being visible in the same place as the full view 
of the package, which prevents various ripple effects.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">20.1/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-50217.TXT">AI95-00217-06</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00412.TXT">AI95-00412-01</A></I>} 
<SPAN class="insert2">[For each declaration or renaming of a generic 
unit as a child of some parent generic package, there is a corresponding 
declaration nested immediately within each instance of the parent.] Such 
a nested declaration is hidden from all visibility except at places that 
are within the scope of a <SPAN Class="swiss"><A HREF="AA-10-1-2.html#S0237">with_clause</A></SPAN> 
that mentions the child.</SPAN></LI></UL>
<DIV Class="paranum">21</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em"><SPAN STYLE="font-size: 80%">{<I>directly 
visible</I>}</SPAN> <A NAME="I3732"></A><SPAN STYLE="font-size: 80%">{<I>immediately 
visible</I>}</SPAN> <A NAME="I3733"></A><SPAN STYLE="font-size: 80%">{<I>visibility 
(direct)</I>}</SPAN> <A NAME="I3734"></A><SPAN STYLE="font-size: 80%">{<I>visibility 
(immediate)</I>}</SPAN> <A NAME="I3735"></A>A declaration with a <SPAN Class="swiss"><A HREF="AA-3-1.html#S0022">defining_identifier</A></SPAN> 
or <SPAN Class="swiss"><A HREF="AA-6-1.html#S0156">defining_operator_symbol</A></SPAN> 
is immediately visible [(and hence directly visible)] within its immediate 
scope <SPAN STYLE="font-size: 80%">{<I>hidden from direct visibility</I> 
[distributed]}</SPAN> <A NAME="I3736"></A> except where hidden from direct 
visibility, as follows:&nbsp;</DIV>
<DIV Class="paranum">22</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN STYLE="font-size: 80%">{<I>hidden 
from direct visibility (by an inner homograph)</I> [partial]}</SPAN> 
<A NAME="I3737"></A>A declaration is hidden from direct visibility within 
the immediate scope of a homograph of the declaration, if the homograph 
occurs within an inner declarative region;</LI></UL>
<DIV Class="paranum">23</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN STYLE="font-size: 80%">{<I>hidden 
from direct visibility (where hidden from all visibility)</I> [partial]}</SPAN> 
<A NAME="I3738"></A>A declaration is also hidden from direct visibility 
where hidden from all visibility.&nbsp;</LI></UL>
<DIV Class="paranum">23.1/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00195.TXT">AI95-00195-01</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00408.TXT">AI95-00408-01</A></I>} 
<SPAN class="insert2"><SPAN STYLE="font-size: 80%">{<I>visible (attribute_</I> 
[partial]}</SPAN> <A NAME="I3739"></A>An <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN> 
is <I>visible</I> everywhere within its scope.</SPAN></DIV>

<H4 Class="centered">Name Resolution Rules</H4>
<DIV Class="paranum">24</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>possible interpretation 
(for direct_names)</I> [partial]}</SPAN> <A NAME="I3740"></A>A <SPAN Class="swiss"><A HREF="AA-4-1.html#S0092">direct_name</A></SPAN> 
shall resolve to denote a directly visible declaration whose defining 
name is the same as the <SPAN Class="swiss"><A HREF="AA-4-1.html#S0092">direct_name</A></SPAN>. 
<SPAN STYLE="font-size: 80%">{<I>possible interpretation (for selector_names)</I> 
[partial]}</SPAN> <A NAME="I3741"></A>A <SPAN Class="swiss"><A HREF="AA-4-1-3.html#S0099">selector_name</A></SPAN> 
shall resolve to denote a visible declaration whose defining name is 
the same as the <SPAN Class="swiss"><A HREF="AA-4-1-3.html#S0099">selector_name</A></SPAN>. 
</DIV>
<DIV Class="paranum">24.a</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>&quot;The same as&quot; has 
the obvious meaning here, so for +, the possible interpretations are 
declarations whose defining name is &quot;+&quot; (an <SPAN Class="swiss"><A HREF="AA-6-1.html#S0155">operator_symbol</A></SPAN>). 
</DIV>
<DIV Class="paranum">25</DIV>
<DIV Class="Normal">These rules on visibility and direct visibility do 
not apply in a <SPAN Class="swiss"><A HREF="AA-10-1-2.html#S0235">context_clause</A></SPAN>, 
a <SPAN Class="swiss"><A HREF="AA-10-1-1.html#S0234">parent_unit_name</A></SPAN>, 
or a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
that appears at the place of a <SPAN Class="swiss"><A HREF="AA-10-1-1.html#S0229">compilation_unit</A></SPAN>. 
For those contexts, see the rules in <A HREF="AA-10-1-6.html">10.1.6</A>, 
&ldquo;<A HREF="AA-10-1-6.html">Environment-Level Visibility Rules</A>&rdquo;. 
</DIV>
<DIV Class="paranum">25.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>Direct visibility is irrelevant 
for <SPAN Class="swiss"><A HREF="AA-2-5.html#S0015">character_literal</A></SPAN>s. 
In terms of overload resolution <SPAN Class="swiss"><A HREF="AA-2-5.html#S0015">character_literal</A></SPAN>s 
are similar to other literals, like <B>null</B> &mdash; see <A HREF="AA-4-2.html">4.2</A>. 
For <SPAN Class="swiss"><A HREF="AA-2-5.html#S0015">character_literal</A></SPAN>s, 
there is no need to worry about hiding, since there is no way to declare 
homographs.&nbsp;</DIV>

<H4 Class="centered">Legality Rules</H4>
<DIV Class="paranum">26/2</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="defect1.html#8652/0025">8652/0025</A></I>} 
{<I><A HREF="defect1.html#8652/0026">8652/0026</A></I>} {<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00044.TXT">AI95-00044-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00150.TXT">AI95-00150-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00377.TXT">AI95-00377-01</A></I>} 
<SPAN class="insert1">A non-overridable</SPAN><SPAN class="delete1">&nbsp;An 
explicit</SPAN> declaration is illegal if there is a homograph occurring 
immediately within the same declarative region that is visible at the 
place of the declaration, and is not hidden from all visibility by the 
<SPAN class="insert1">non-overridable</SPAN><SPAN class="delete1">&nbsp;explicit</SPAN> 
declaration. <SPAN class="insert1">In addition, a type extension is illegal 
if somewhere within its immediate scope it has two visible components 
with the same name.</SPAN> Similarly, the <SPAN Class="swiss"><A HREF="AA-10-1-2.html#S0235">context_clause</A></SPAN> 
for a <SPAN class="insert2">compilation unit</SPAN><SPAN class="delete2"><SPAN Class="swiss"><A HREF="AA-10-1-3.html#S0245">&nbsp;subunit</A></SPAN></SPAN> 
is illegal if it mentions (in a <SPAN Class="swiss"><A HREF="AA-10-1-2.html#S0237">with_clause</A></SPAN>) 
some library unit, and there is a homograph of the library unit that 
is visible at the place of the <SPAN class="insert2">compilation unit</SPAN><SPAN class="delete2">&nbsp;corresponding 
stub</SPAN>, and the homograph and the mentioned library unit are both 
declared immediately within the same declarative region.<SPAN STYLE="font-size: 80%">{<I>generic 
contract issue</I> [partial]}</SPAN> <A NAME="I3742"></A>These rules 
also apply to dispatching operations declared in the visible part of 
an instance of a generic unit. However, they do not apply to other overloadable 
declarations in an instance[; such declarations may have type conformant 
profiles in the instance, so long as the corresponding declarations in 
the generic were not type conformant]. <SPAN STYLE="font-size: 80%">{<I>type 
conformance</I> [partial]}</SPAN> <A NAME="I3743"></A></DIV>
<DIV Class="paranum">26.a</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><B>Discussion: 
</B>Normally, these rules just mean you can't explicitly declare two 
homographs immediately within the same declarative region. The wording 
is designed to handle the following special cases:&nbsp;</DIV>
<DIV Class="paranum">26.b</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>If the second declaration completes 
the first one, the second declaration is legal.</LI></UL>
<DIV Class="paranum">26.c</DIV>
<UL Class="SmallBulleted" Style="margin-bottom: 0.3em"><LI TYPE=DISC>If 
the body of a library unit contains an explicit homograph of a child 
of that same library unit, this is illegal only if the body mentions 
the child in its <SPAN Class="swiss"><A HREF="AA-10-1-2.html#S0235">context_clause</A></SPAN>, 
or if some subunit mentions the child. Here's an example:&nbsp;</LI></UL>
<DIV Class="paranum">26.d</DIV>
<DIV Class="SmallExamples"><B>package</B>&nbsp;P&nbsp;<B>is</B><BR>
<B>end</B>&nbsp;P;</DIV>
<DIV Class="paranum">26.e</DIV>
<DIV Class="SmallExamples"><B>package</B>&nbsp;P.Q&nbsp;<B>is</B><BR>
<B>end</B>&nbsp;P.Q;</DIV>
<DIV Class="paranum">26.f</DIV>
<DIV Class="SmallExamples"><B>package</B>&nbsp;<B>body</B>&nbsp;P&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;Q&nbsp;:&nbsp;Integer;&nbsp;--<SPAN Class="roman"><I>&nbsp;OK;&nbsp;we&nbsp;cannot&nbsp;see&nbsp;package&nbsp;P.Q&nbsp;here.</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Sub&nbsp;<B>is</B>&nbsp;<B>separate</B>;<BR>
<B>end</B>&nbsp;P;</DIV>
<DIV Class="paranum">26.g</DIV>
<DIV Class="SmallExamples"><B>with</B>&nbsp;P.Q;<BR>
<B>separate</B>(P)<BR>
<B>procedure</B>&nbsp;Sub&nbsp;<B>is</B>&nbsp;--<SPAN Class="roman"><I>&nbsp;Illegal.</I></SPAN><BR>
<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>null</B>;<BR>
<B>end</B>&nbsp;Sub;</DIV>
<DIV Class="paranum">26.h</DIV>
<UL Class="SmallBulleted">If package body P said &quot;<B>with</B> P.Q;&quot;, 
then it would be illegal to declare the homograph Q: Integer. But it 
does not, so the body of P is OK. However, the subunit would be able 
to see both P.Q's, and is therefore illegal.</UL>
<DIV Class="paranum">26.i</DIV>
<UL Class="SmallBulleted">A previous version of Ada 9X allowed the subunit, 
and said that references to P.Q would tend to be ambiguous. However, 
that was a bad idea, because it requires overload resolution to resolve 
references to directly visible non-overloadable homographs, which is 
something compilers have never before been required to do.</UL>
<DIV Class="paranum">26.i.1/1</DIV>
<UL Class="SmallBulleted" Style="margin-bottom: 0.3em"><LI TYPE=DISC>{<I><A HREF="defect1.html#8652/0026">8652/0026</A></I>} 
<SPAN class="insert1"></SPAN>{<I><A HREF="defect2.html#8652/0102">8652/0102</A></I>} 
<SPAN class="insert1"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00150.TXT">AI95-00150-01</A></I>} 
<SPAN class="insert1"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00157.TXT">AI95-00157-01</A></I>} 
<SPAN class="insert1">If a type extension contains a component with the 
same name as a component in an ancestor type, there must be no place 
where both components are visible. For instance:</SPAN>&nbsp;</LI></UL>
<DIV Class="paranum">26.i.2/1</DIV>
<DIV Class="SmallExamples"><SPAN class="insert1"><B>package</B>&nbsp;A&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T&nbsp;<B>is&nbsp;tagged&nbsp;private</B>;<BR>
&nbsp;&nbsp;&nbsp;<B>package</B>&nbsp;B&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;NT&nbsp;<B>is&nbsp;new</B>&nbsp;T&nbsp;<B>with&nbsp;record</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I:&nbsp;Integer;&nbsp;--&nbsp;<SPAN Class="roman"><I>Illegal&nbsp;because&nbsp;T.I&nbsp;is&nbsp;visible&nbsp;in&nbsp;the&nbsp;body.</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>end&nbsp;record</B>;&nbsp;--&nbsp;<SPAN Class="roman"><I>T.I&nbsp;is&nbsp;not&nbsp;visible&nbsp;here.</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;B;<BR>
<B>private</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T&nbsp;<B>is&nbsp;tagged&nbsp;record</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I:&nbsp;Integer;&nbsp;--&nbsp;<SPAN Class="roman"><I>Illegal&nbsp;because&nbsp;T.I&nbsp;is&nbsp;visible&nbsp;in&nbsp;the&nbsp;body.</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;<B>end&nbsp;record</B>;<BR>
<B>end</B>&nbsp;A;</SPAN></DIV>
<DIV Class="paranum">26.i.3/2</DIV>
<DIV Class="SmallExamples">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00114.TXT">AI95-00114-01</A></I>} 
<SPAN class="insert1"></SPAN><SPAN class="insert1"><SPAN class="delete2"><B>package</B>&nbsp;A&nbsp;<B>is</B><BR>
</SPAN></SPAN><SPAN class="insert1"><B>package</B>&nbsp;<B>body</B>&nbsp;A&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>package</B>&nbsp;<B>body</B>&nbsp;B&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>T.I&nbsp;becomes&nbsp;visible&nbsp;here.</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;B;<BR>
<B>end</B>&nbsp;A;</SPAN></DIV>
<DIV Class="paranum">26.i.4/1</DIV>
<DIV Class="SmallExamples"><SPAN class="insert1"><B>package</B>&nbsp;A.C&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;NT2&nbsp;<B>is&nbsp;new</B>&nbsp;A.T&nbsp;<B>with&nbsp;record</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I:&nbsp;Integer;&nbsp;--&nbsp;<SPAN Class="roman"><I>Illegal&nbsp;because&nbsp;T.I&nbsp;is&nbsp;visible&nbsp;in&nbsp;the&nbsp;private&nbsp;part.</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;<B>end&nbsp;record</B>;&nbsp;--&nbsp;<SPAN Class="roman"><I>T.I&nbsp;is&nbsp;not&nbsp;visible&nbsp;here.</I></SPAN><BR>
<B>private</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>T.I&nbsp;is&nbsp;visible&nbsp;here.</I></SPAN><BR>
<B>end</B>&nbsp;A.C;</SPAN></DIV>
<DIV Class="paranum">26.i.5/1</DIV>
<DIV Class="SmallExamples"><SPAN class="insert1"><B>with</B>&nbsp;A;<BR>
<B>package</B>&nbsp;D&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;NT3&nbsp;<B>is&nbsp;new</B>&nbsp;A.T&nbsp;<B>with&nbsp;record</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I:&nbsp;Integer;&nbsp;--&nbsp;<SPAN Class="roman"><I>Legal&nbsp;because&nbsp;T.I&nbsp;is&nbsp;never&nbsp;visible&nbsp;in&nbsp;this&nbsp;package.</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;<B>end&nbsp;record</B>;<BR>
<B>end</B>&nbsp;D;</SPAN></DIV>
<DIV Class="paranum">26.i.6/1</DIV>
<DIV Class="SmallExamples"><SPAN class="insert1"><B>with</B>&nbsp;D;<BR>
<B>package</B>&nbsp;A.E&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;NT4&nbsp;<B>is&nbsp;new</B>&nbsp;D.NT3&nbsp;<B>with&nbsp;null&nbsp;record</B>;<BR>
&nbsp;&nbsp;&nbsp;X&nbsp;:&nbsp;NT4;<BR>
&nbsp;&nbsp;&nbsp;I1&nbsp;:&nbsp;Integer&nbsp;:=&nbsp;X.I;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>D.NT3.I</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;I2&nbsp;:&nbsp;Integer&nbsp;:=&nbsp;D.NT3(X).I;&nbsp;--&nbsp;<SPAN Class="roman"><I>D.NT3.I</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;I3&nbsp;:&nbsp;Integer&nbsp;:=&nbsp;A.T(X).I;&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>A.T.I</I></SPAN><BR>
<B>end</B>&nbsp;A.E;</SPAN></DIV>
<DIV Class="paranum">26.i.7/1</DIV>
<UL Class="SmallBulleted">{<I><A HREF="defect2.html#8652/0102">8652/0102</A></I>} 
<SPAN class="insert1"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00157.TXT">AI95-00157-01</A></I>} 
<SPAN class="insert1">D.NT3 can have a component I because the component 
I of the parent type is never visible. The parent component exists, of 
course, but is never declared for the type D.NT3. In the child package 
A.E, the component I of A.T is visible, but that does not change the 
fact that the A.T.I component was never declared for type D.NT3. Thus, 
A.E.NT4 does not (visibly) inherit the component I from A.T, while it 
does inherit the component I from D.NT3. Of course, both components exist, 
and can be accessed by a type conversion as shown above. This behavior 
stems from the fact that every characteristic of a type (including components) 
must be declared somewhere in the innermost declarative region containing 
the type &mdash; if the characteristic is never visible in that declarative 
region, it is never declared. Therefore, such characteristics do not 
suddenly become available even if they are in fact visible in some other 
scope. See <A HREF="AA-7-3-1.html">7.3.1</A> for more on the rules.</SPAN></UL>
<DIV Class="paranum">26.i.8/2</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00377.TXT">AI95-00377-01</A></I>} 
<SPAN class="insert2">It is illegal to mention both an explicit child 
of an instance, and a child of the generic from which the instance was 
instantiated. This is easier to understand with an example:</SPAN>&nbsp;</LI></UL>
<DIV Class="paranum">26.i.9/2</DIV>
<DIV Class="SmallExamples"><SPAN class="insert2"><B>generic</B><BR>
<B>package</B>&nbsp;G1&nbsp;<B>is</B><BR>
<B>end</B>&nbsp;G1;</SPAN></DIV>
<DIV Class="paranum">26.i.10/2</DIV>
<DIV Class="SmallExamples"><SPAN class="insert2"><B>generic</B><BR>
<B>package</B>&nbsp;G1.G2&nbsp;<B>is</B><BR>
<B>end</B>&nbsp;G1.G2;</SPAN></DIV>
<DIV Class="paranum">26.i.11/2</DIV>
<DIV Class="SmallExamples"><SPAN class="insert2"><B>with</B>&nbsp;G1;<BR>
<B>package</B>&nbsp;I1&nbsp;<B>is&nbsp;new</B>&nbsp;G1;</SPAN></DIV>
<DIV Class="paranum">26.i.12/2</DIV>
<DIV Class="SmallExamples"><SPAN class="insert2"><B>package</B>&nbsp;I1.G2&nbsp;<B>renames</B>&nbsp;...</SPAN></DIV>
<DIV Class="paranum">26.i.13/2</DIV>
<DIV Class="SmallExamples"><SPAN class="insert2"><B>with</B>&nbsp;G1.G2;<BR>
<B>with</B>&nbsp;I1.G2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>Illegal</I></SPAN><BR>
<B>package</B>&nbsp;Bad&nbsp;<B>is</B>&nbsp;...</SPAN></DIV>
<DIV Class="paranum">26.i.14/2</DIV>
<UL Class="SmallBulleted"><SPAN class="insert2">The context clause for 
Bad is illegal as I1 has an implicit declaration of I1.G2 based on the 
generic child G1.G2, as well as the mention of the explicit child I1.G2. 
As in the previous cases, this is illegal only if the context clause 
makes both children visible; the explicit child can be mentioned as long 
as the generic child is not (and vice-versa).</SPAN>&nbsp;</UL>
<DIV Class="paranum">26.j</DIV>
<DIV Class="Annotations">Note that we need to be careful which things 
we make &quot;hidden from all visibility&quot; versus which things we 
make simply illegal for names to denote. The distinction is subtle. The 
rules that disallow names denoting components within a type declaration 
(see <A HREF="AA-3-7.html">3.7</A>) do not make the components invisible 
at those places, so that the above rule makes components with the same 
name illegal. The same is true for the rule that disallows names denoting 
formal parameters within a <SPAN Class="swiss"><A HREF="AA-6-1.html#S0159">formal_part</A></SPAN> 
(see <A HREF="AA-6-1.html">6.1</A>).&nbsp;</DIV>
<DIV Class="paranum">26.k</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>The part about instances 
is from AI83-00012. The reason it says &ldquo;overloadable declarations&rdquo; 
is because we don't want it to apply to type extensions that appear in 
an instance; components are not overloadable.&nbsp;</DIV>
<DIV Class="NotesHeader">NOTES</DIV>
<DIV Class="paranum">27</DIV>
<DIV Class="Notes">5&nbsp;&nbsp;Visibility for compilation units follows 
from the definition of the environment in <A HREF="AA-10-1-4.html">10.1.4</A>, 
except that it is necessary to apply a <SPAN Class="swiss"><A HREF="AA-10-1-2.html#S0237">with_clause</A></SPAN> 
to obtain visibility to a <SPAN Class="swiss"><A HREF="AA-10-1-1.html#S0231">library_unit_declaration</A></SPAN> 
or <SPAN Class="swiss"><A HREF="AA-10-1-1.html#S0232">library_unit_renaming_declaration</A></SPAN>.</DIV>
<DIV Class="paranum">28</DIV>
<DIV Class="Notes">6&nbsp;&nbsp;In addition to the visibility rules given 
above, the meaning of the occurrence of a <SPAN Class="swiss"><A HREF="AA-4-1.html#S0092">direct_name</A></SPAN> 
or <SPAN Class="swiss"><A HREF="AA-4-1-3.html#S0099">selector_name</A></SPAN> 
at a given place in the text can depend on the overloading rules (see 
<A HREF="AA-8-6.html">8.6</A>).</DIV>
<DIV Class="paranum">29</DIV>
<DIV Class="Notes">7&nbsp;&nbsp;Not all contexts where an <SPAN Class="swiss"><A HREF="AA-2-3.html#S0002">identifier</A></SPAN>, 
<SPAN Class="swiss"><A HREF="AA-2-5.html#S0015">character_literal</A></SPAN>, 
or <SPAN Class="swiss"><A HREF="AA-6-1.html#S0155">operator_symbol</A></SPAN> 
are allowed require visibility of a corresponding declaration. Contexts 
where visibility is not required are identified by using one of these 
three syntactic categories directly in a syntax rule, rather than using 
<SPAN Class="swiss"><A HREF="AA-4-1.html#S0092">direct_name</A></SPAN> 
or <SPAN Class="swiss"><A HREF="AA-4-1-3.html#S0099">selector_name</A></SPAN>. 
</DIV>
<DIV Class="paranum">29.a</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><B>Ramification: 
</B>An <SPAN Class="swiss"><A HREF="AA-2-3.html#S0002">identifier</A></SPAN>, 
<SPAN Class="swiss"><A HREF="AA-2-5.html#S0015">character_literal</A></SPAN> 
or <SPAN Class="swiss"><A HREF="AA-6-1.html#S0155">operator_symbol</A></SPAN> 
that occurs in one of the following contexts is not required to denote 
a visible or directly visible declaration:&nbsp;</DIV>
<DIV Class="paranum">29.b</DIV>
<DIV Class="SmallEnumerated-Term">1.</DIV><DIV Class="SmallEnumerated-Body">
A defining name.</DIV>
<DIV Class="paranum">29.c</DIV>
<DIV Class="SmallEnumerated-Term">2.</DIV><DIV Class="SmallEnumerated-Body">
The <SPAN Class="swiss"><A HREF="AA-2-3.html#S0002">identifier</A></SPAN>s 
or <SPAN Class="swiss"><A HREF="AA-6-1.html#S0155">operator_symbol</A></SPAN> 
that appear after the reserved word <B>end</B> in a <SPAN Class="swiss"><A HREF="AA-3-11.html#S0090">proper_body</A></SPAN>. 
Similarly for &ldquo;<B>end loop</B>&rdquo;, etc.</DIV>
<DIV Class="paranum">29.d</DIV>
<DIV Class="SmallEnumerated-Term">3.</DIV><DIV Class="SmallEnumerated-Body">
An <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0101">attribute_designator</A></SPAN>.</DIV>
<DIV Class="paranum">29.e</DIV>
<DIV Class="SmallEnumerated-Term">4.</DIV><DIV Class="SmallEnumerated-Body">
A <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> <SPAN Class="swiss"><A HREF="AA-2-3.html#S0002">identifier</A></SPAN>.</DIV>
<DIV Class="paranum">29.f</DIV>
<DIV Class="SmallEnumerated-Term">5.</DIV><DIV Class="SmallEnumerated-Body">
A <I>pragma_argument_</I><SPAN Class="swiss"><A HREF="AA-2-3.html#S0002">identifier</A></SPAN>.</DIV>
<DIV Class="paranum">29.g</DIV>
<DIV Class="SmallEnumerated-Term">6.</DIV><DIV Class="SmallEnumerated-Body">
An <SPAN Class="swiss"><A HREF="AA-2-3.html#S0002">identifier</A></SPAN> 
specific to a pragma used in a pragma argument.&nbsp;</DIV>
<DIV Class="paranum">29.h</DIV>
<DIV Class="Annotations">The visibility rules have nothing to do with 
the above cases; the meanings of such things are defined elsewhere. Reserved 
words are not <SPAN Class="swiss"><A HREF="AA-2-3.html#S0002">identifier</A></SPAN>s; 
the visibility rules don't apply to them either.</DIV>
<DIV Class="paranum">29.i</DIV>
<DIV Class="Annotations">Because of the way we have defined &quot;declaration&quot;, 
it is possible for a usage name to denote a <SPAN Class="swiss"><A HREF="AA-6-3.html#S0162">subprogram_body</A></SPAN>, 
either within that body, or (for a non-library unit) after it (since 
the body hides the corresponding declaration, if any). Other bodies do 
not work that way. Completions of <SPAN Class="swiss"><A HREF="AA-3-2-1.html#S0023">type_declaration</A></SPAN>s 
and deferred constant declarations do work that way. <SPAN Class="swiss"><A HREF="AA-9-5-2.html#S0201">Accept_statement</A></SPAN>s 
are never denoted, although the <SPAN Class="swiss"><A HREF="AA-6-1.html#S0160">parameter_specification</A></SPAN>s 
in their profiles can be.</DIV>
<DIV Class="paranum">29.j</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em">The scope of a 
subprogram does not start until after its profile. Thus, the following 
is legal:&nbsp;</DIV>
<DIV Class="paranum">29.k</DIV>
<DIV Class="SmallExamples">X&nbsp;:&nbsp;<B>constant</B>&nbsp;Integer&nbsp;:=&nbsp;17;<BR>
...<BR>
<B>package</B>&nbsp;P&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;X(Y&nbsp;:&nbsp;<B>in</B>&nbsp;Integer&nbsp;:=&nbsp;X);<BR>
<B>end</B>&nbsp;P;</DIV>
<DIV Class="paranum">29.l</DIV>
<DIV Class="Annotations">The body of the subprogram will probably be 
illegal, however, since the constant X will be hidden by then.</DIV>
<DIV Class="paranum">29.m</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em">The rule is different 
for generic subprograms, since they are not overloadable; the following 
is illegal:&nbsp;</DIV>
<DIV Class="paranum">29.n</DIV>
<DIV Class="SmallExamples">X&nbsp;:&nbsp;<B>constant</B>&nbsp;Integer&nbsp;:=&nbsp;17;<BR>
<B>package</B>&nbsp;P&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>generic</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Z&nbsp;:&nbsp;Integer&nbsp;:=&nbsp;X;&nbsp;--<SPAN Class="roman"><I>&nbsp;Illegal!</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;X(Y&nbsp;:&nbsp;<B>in</B>&nbsp;Integer&nbsp;:=&nbsp;X);&nbsp;--<SPAN Class="roman"><I>&nbsp;Illegal!</I></SPAN><BR>
<B>end</B>&nbsp;P;</DIV>
<DIV Class="paranum">29.o</DIV>
<DIV Class="Annotations">The constant X is hidden from direct visibility 
by the generic declaration.&nbsp;</DIV>

<H4 Class="centered">Extensions to Ada 83</H4>
<DIV Class="paranum">29.p</DIV>
<DIV Class="Annotations">{<I>extensions to Ada 83</I>} <A NAME="I3744"></A>Declarations 
with the same defining name as that of a subprogram or entry being defined 
are nevertheless visible within the subprogram specification or entry 
declaration.&nbsp;</DIV>

<H4 Class="centered">Wording Changes from Ada 83</H4>
<DIV Class="paranum">29.q</DIV>
<DIV Class="Annotations">The term &ldquo;visible by selection&rdquo; 
is no longer defined. We use the terms &ldquo;directly visible&rdquo; 
and &ldquo;visible&rdquo; (among other things). There are only two regions 
of text that are of interest, here: the region in which a declaration 
is visible, and the region in which it is directly visible.</DIV>
<DIV Class="paranum">29.r</DIV>
<DIV Class="Annotations">Visibility is defined only for declarations. 
</DIV>

<H4 Class="centered">Incompatibilities With Ada 95</H4>
<DIV Class="paranum">29.s/2</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
<SPAN class="insert2">{<I>incompatibilities with Ada 95</I>} <A NAME="I3745"></A>Added 
rules to handle the inheritance and overriding of multiple homographs 
for a single type declaration, in order to support multiple inheritance 
from interfaces. The new rules are intended to be compatible with the 
existing rules so that programs that do not use interfaces do not change 
their legality. However, there is a very rare case where this is not 
true:</SPAN>&nbsp;</DIV>
<DIV Class="paranum">29.t/2</DIV>
<DIV Class="SmallExamples"><SPAN class="insert2"><B>generic</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T1&nbsp;<B>is&nbsp;private</B>;<BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T2&nbsp;<B>is&nbsp;private</B>;<BR>
<B>package</B>&nbsp;G&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T&nbsp;<B>is&nbsp;null&nbsp;record</B>;<BR>
&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;P&nbsp;(X&nbsp;:&nbsp;T;&nbsp;Y&nbsp;:&nbsp;T1);<BR>
&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;P&nbsp;(X&nbsp;:&nbsp;T;&nbsp;Z&nbsp;:&nbsp;T2);<BR>
<B>end</B>&nbsp;G;</SPAN> ]</DIV>
<DIV Class="paranum">29.u/2</DIV>
<DIV Class="SmallExamples"><SPAN class="insert2"><B>package</B>&nbsp;I&nbsp;<B>is&nbsp;new</B>&nbsp;G&nbsp;(Integer,&nbsp;Integer);&nbsp;--&nbsp;<SPAN Class="roman"><I>Exports&nbsp;homographs&nbsp;of&nbsp;P.</I></SPAN></SPAN></DIV>
<DIV Class="paranum">29.v/2</DIV>
<DIV Class="SmallExamples"><SPAN class="insert2"><B>type</B>&nbsp;D&nbsp;<B>is&nbsp;new</B>&nbsp;I.T;&nbsp;--&nbsp;<SPAN Class="roman"><I>Both&nbsp;Ps&nbsp;are&nbsp;inherited.</I></SPAN></SPAN></DIV>
<DIV Class="paranum">29.w/2</DIV>
<DIV Class="SmallExamples"><SPAN class="insert2">Obj&nbsp;:&nbsp;D;</SPAN></DIV>
<DIV Class="paranum">29.x/2</DIV>
<DIV Class="SmallExamples"><SPAN class="insert2">P&nbsp;(Obj,&nbsp;Z&nbsp;=&gt;&nbsp;10);&nbsp;--&nbsp;<SPAN Class="roman"><I>Legal&nbsp;in&nbsp;Ada&nbsp;95,&nbsp;illegal&nbsp;in&nbsp;Ada&nbsp;2005.</I></SPAN></SPAN></DIV>
<DIV Class="paranum">29.y/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2">The call to P would resolve 
in Ada 95 by using the parameter name, while the procedures P would be 
hidden from all visibility in Ada 2005 and thus would not resolve. This 
case doesn't seem worth making the rules any more complex than they already 
are.</SPAN></DIV>
<DIV Class="paranum">29.z/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00377.TXT">AI95-00377-01</A></I>} 
<SPAN class="insert2"><B>Amendment Correction:</B> A <SPAN Class="swiss"><A HREF="AA-10-1-2.html#S0237">with_clause</A></SPAN> 
is illegal if it would create a homograph of an implicitly declared generic 
child (see <A HREF="AA-10-1-1.html">10.1.1</A>). An Ada 95 compiler could 
have allowed this, but which unit of the two units involved would be 
denoted wasn't specified, so any successful use isn't portable. Removing 
one of the two <SPAN Class="swiss"><A HREF="AA-10-1-2.html#S0237">with_clause</A></SPAN>s 
involved will fix the problem.</SPAN>&nbsp;</DIV>

<H4 Class="centered">Wording Changes from Ada 95</H4>
<DIV Class="paranum">29.aa/2</DIV>
<DIV Class="Annotations">{<I><A HREF="defect1.html#8652/0025">8652/0025</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00044.TXT">AI95-00044-01</A></I>} 
<SPAN class="insert2"><B>Corrigendum:</B> Clarified the overriding rules 
so that &quot;/=&quot; and <SPAN Class="swiss"><A HREF="AA-5-1.html#S0136">statement_identifier</A></SPAN>s 
are covered.</SPAN></DIV>
<DIV Class="paranum">29.bb/2</DIV>
<DIV Class="Annotations">{<I><A HREF="defect1.html#8652/0026">8652/0026</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00150.TXT">AI95-00150-01</A></I>} 
<SPAN class="insert2"><B>Corrigendum:</B> Clarified that is it never 
possible for two components with the same name to be visible; any such 
program is illegal.</SPAN></DIV>
<DIV Class="paranum">29.cc/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00195.TXT">AI95-00195-01</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00408.TXT">AI95-00408-01</A></I>} 
<SPAN class="insert2">The visibility of an <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN> 
is defined so that it can be used by the stream attribute availability 
rules (see <A HREF="AA-13-13-2.html">13.13.2</A>).</SPAN></DIV>
<DIV Class="paranum">29.dd/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-50217.TXT">AI95-00217-06</A></I>} 
<SPAN class="insert2">The visibility of a limited view of a library package 
is defined (see <A HREF="AA-10-1-1.html">10.1.1</A>).</SPAN>&nbsp;</DIV>

<HR>
<DIV Style="margin-top: 0.0em; margin-bottom: 0.6em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-8-2.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-8-3-1.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<DIV Style="margin-top:0.0em"><IMG SRC="AE_logo.gif" height=100 width=113 align=right ALT="Ada-Europe">
<SPAN Style="font-size: 125%">Sponsored by <SPAN Style="font-size: 125%"><A HREF="http://www.ada-europe.org/"><B>Ada-Europe</B></A></SPAN></SPAN></DIV>
</BODY>
</HTML>
