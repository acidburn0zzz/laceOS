<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Pragmas and Restrictions</TITLE>
    <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    H4.centered {text-align: center}
    SPAN.swiss {font-family: Arial, Helvetica, sans-serif; font-size: 92%}
    SPAN.roman {font-family: "Times New Roman", Times, serif}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    DIV.Normal {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-bottom: 0.6em}
    DIV.SwissExamples {font-family: Arial, Helvetica, sans-serif; font-size: 90%; line-height: 122%; margin-left: 2.2em; margin-bottom: 0.6em}
    DIV.Bulleted-NoPrefix {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 2.0em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    DIV.Bulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 2.0em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em; display: list-item; list-style-type: disc}
    </STYLE>
<!-- BEGIN Google Analytics -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-117428-5']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
<!-- END Google Analytics -->
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">
<H1 Style='font-family: "Rockwell", "Times New Roman", Times, serif; font-size: 240%'><B><SPAN Style="color:rgb(0,0,153)">Rationale</SPAN> for <SPAN Style="color:rgb(204,0,0)">Ada 2005</SPAN></B></H1>
<DIV Class="Normal"><FONT SIZE="+1"><I><A HREF="Rat-TTL.html">John Barnes</A></I></FONT></DIV>
<div style="margin-top: 0.6em; margin-bottom: 0.0em"><A HREF="Rat-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="Rat-0-3.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="Rat-0-2.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="Rat-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="Rat-6-3.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="Rat-6-5.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</div>
<HR>
<H1>6.4 Pragmas and Restrictions</H1>
<div class="Normal">Ada 2005 introduces a number of new pragmas and <SPAN Class="swiss">Restrictions</SPAN> 
identifiers. Many of these were described in Section <A HREF="Rat-5-4.html">5.4</A> 
when discussing tasking and the Real-Time and High Integrity annexes. 
For convenience here is a complete list giving the annex if appropriate.</div>
<div class="Normal" style="margin-bottom: 0.4em">The new pragmas are 
</div>
<div class="SwissExamples">Assert<BR>
Assertion_Policy<BR>
Detect_Blocking&nbsp;&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><I>High-Integrity</I></SPAN><BR>
No_Return<BR>
Preelaborable_Initialization<BR>
Profile&nbsp;&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><I>Real-Time</I></SPAN><BR>
Relative_Deadline&nbsp;&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><I>Real-Time</I></SPAN><BR>
Unchecked_Union&nbsp;&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><I>Interface</I></SPAN><BR>
Unsuppress</div>
<div class="Normal" style="margin-bottom: 0.4em">The new <SPAN Class="swiss">Restrictions</SPAN> 
identifiers are&nbsp;</div>
<div class="SwissExamples">Max_Entry_Queue_Length&nbsp;&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><I>Real-Time</I></SPAN><BR>
No_Dependence<BR>
No_Dynamic_Attachment&nbsp;&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><I>Real-Time</I></SPAN><BR>
No_Implementation_Attributes<BR>
No_Implementation_Pragmas<BR>
No_Local_Protected_Objects&nbsp;&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><I>Real-Time</I></SPAN><BR>
No_Obsolescent_Features<BR>
No_Protected_Type_Allocators&nbsp;&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><I>Real-Time</I></SPAN><BR>
No_Relative_Delay&nbsp;&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><I>Real-Time</I></SPAN><BR>
No_Requeue_Statements&nbsp;&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><I>Real-Time</I></SPAN><BR>
No_Select_Statements&nbsp;&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><I>Real-Time</I></SPAN><BR>
No_Synchronous_Control&nbsp;&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><I>Real-Time</I></SPAN><BR>
No_Task_Termination&nbsp;&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><I>Real-Time</I></SPAN><BR>
Simple_Barriers&nbsp;&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><I>Real-Time</I></SPAN></div>
<div class="Normal">We will now discuss in detail the pragmas and <SPAN Class="swiss">Restrictions</SPAN> 
identifiers in the core language and so not discussed in the previous 
chapter.</div>
<div class="Normal" style="margin-bottom: 0.4em"><A NAME="I1240"></A><A NAME="I1241"></A><A NAME="I1242"></A><A NAME="I1243"></A>First 
there is the pragma <SPAN Class="swiss">Assert</SPAN> and the associated 
pragma <SPAN Class="swiss">Assertion_Policy</SPAN>. Their syntax is as 
follows&nbsp;</div>
<div class="SwissExamples"><B>pragma</B>&nbsp;Assert([Check&nbsp;=&gt;]&nbsp;<SPAN Class="roman"><I>boolean</I></SPAN>_expression&nbsp;[,&nbsp;[Message&nbsp;=&gt;]&nbsp;<SPAN Class="roman"><I>string</I></SPAN>_expression]);</div>
<div class="SwissExamples"><B>pragma</B>&nbsp;Assertion_Policy(<SPAN Class="roman"><I>policy</I></SPAN>_identifier);</div>
<div class="Normal">The first parameter of <SPAN Class="swiss">Assert</SPAN> 
is thus a boolean expression and the second (and optional) parameter 
is a string. Remember that when we write Boolean we mean of the predefined 
type whereas boolean includes any type derived from <SPAN Class="swiss">Boolean</SPAN> 
as well.</div>
<div class="Normal">The parameter of <SPAN Class="swiss">Assertion_Policy 
</SPAN>is an identifier which controls the behaviour of the pragma <SPAN Class="swiss">Assert</SPAN>. 
Two policies are defined by the language, namely, <SPAN Class="swiss">Check</SPAN> 
and <SPAN Class="swiss">Ignore</SPAN>. Further policies may be defined 
by the implementation.</div>
<div class="Normal" style="margin-bottom: 0.4em">There is also a package 
<SPAN Class="swiss">Ada.Assertions</SPAN> thus<A NAME="I1244"></A><A NAME="I1245"></A><A NAME="I1246"></A> 
</div>
<div class="SwissExamples"><B>package</B>&nbsp;Ada.Assertions&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>pragma</B>&nbsp;Pure(Assertions);</div>
<div class="SwissExamples">&nbsp;&nbsp;&nbsp;Assertion_Error:&nbsp;<B>exception</B>;</div>
<div class="SwissExamples">&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Assert(Check:&nbsp;<B>in</B>&nbsp;Boolean);<BR>
&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Assert(Check:&nbsp;<B>in</B>&nbsp;Boolean;&nbsp;Message:&nbsp;<B>in</B>&nbsp;String);<BR>
<B>end</B>&nbsp;Ada.Assertions;</div>
<div class="Normal" style="margin-bottom: 0.4em">The pragma <SPAN Class="swiss">Assert</SPAN> 
can be used wherever a declaration or statement is allowed. Thus it might 
occur in a list of declarations such as&nbsp;</div>
<div class="SwissExamples">N:&nbsp;<B>constant</B>&nbsp;Integer&nbsp;:=&nbsp;...&nbsp;;<BR>
<B>pragma</B>&nbsp;Assert(N&nbsp;&gt;&nbsp;1);<BR>
A:&nbsp;Real_Matrix(1&nbsp;..&nbsp;N,&nbsp;1&nbsp;..&nbsp;N);<BR>
EV:&nbsp;Real_Vector(1&nbsp;..&nbsp;N);</div>
<div class="Normal" style="margin-bottom: 0.4em">and in a sequence of 
statements such as&nbsp;</div>
<div class="SwissExamples"><B>pragma</B>&nbsp;Assert(Transpose(A)&nbsp;=&nbsp;A,&nbsp;&quot;A&nbsp;not&nbsp;symmetric&quot;);<BR>
EV&nbsp;:=&nbsp;Eigenvalues(A);</div>
<div class="Normal" style="margin-bottom: 0.4em">If the policy set by 
<SPAN Class="swiss">Assertion_Policy</SPAN> is <SPAN Class="swiss">Check</SPAN> 
then the above pragmas are equivalent to&nbsp;</div>
<div class="SwissExamples"><B>if&nbsp;not</B>&nbsp;N&nbsp;&gt;&nbsp;1&nbsp;<B>then</B><BR>
&nbsp;&nbsp;&nbsp;<B>raise</B>&nbsp;Assertion_Error;<BR>
<B>end&nbsp;if</B>;</div>
<div class="Normal" style="margin-bottom: 0.4em">and&nbsp;</div>
<div class="SwissExamples"><B>if&nbsp;not</B>&nbsp;Transpose(A)&nbsp;=&nbsp;A&nbsp;<B>then</B><BR>
&nbsp;&nbsp;&nbsp;<B>raise</B>&nbsp;Assertion_Error&nbsp;<B>with</B>&nbsp;&quot;A&nbsp;not&nbsp;symmetric&quot;;<BR>
<B>end&nbsp;if</B>;</div>
<div class="Normal">Remember from Section <A HREF="Rat-6-2.html">6.2</A> 
that a raise statement without any explicit message is not the same as 
one with an explicit null message. In the former case a subsequent call 
of <SPAN Class="swiss">Exception_Message</SPAN> returns implementation 
defined information whereas in the latter case it returns a null string. 
This same behaviour thus occurs with the <SPAN Class="swiss">Assert</SPAN> 
pragma as well &ndash; providing no message is not the same as providing 
a null message.</div>
<div class="Normal">If the policy set by <SPAN Class="swiss">Assertion_Policy</SPAN> 
is <SPAN Class="swiss">Ignore</SPAN> then the <SPAN Class="swiss">Assert</SPAN> 
pragma is ignored at execution time &ndash; but of course the syntax 
of the parameters is checked during compilation.</div>
<div class="Normal" style="margin-bottom: 0.4em">The two procedures 
<SPAN Class="swiss">Assert</SPAN> in the package <SPAN Class="swiss">Ada.Assertions</SPAN> 
have an identical effect to the corresponding <SPAN Class="swiss">Assert</SPAN> 
pragmas except that their behaviour does not depend upon the assertion 
policy. Thus the call&nbsp;</div>
<div class="SwissExamples">Assert(Some_Test);</div>
<div class="Normal" style="margin-bottom: 0.4em">is always equivalent 
to&nbsp;</div>
<div class="SwissExamples"><B>if&nbsp;not</B>&nbsp;Some_Test&nbsp;<B>then</B><BR>
&nbsp;&nbsp;&nbsp;<B>raise</B>&nbsp;Assertion_Error;<BR>
<B>end&nbsp;if</B>;</div>
<div class="Normal" style="margin-bottom: 0.4em">In other words we could 
define the behaviour of&nbsp;</div>
<div class="SwissExamples"><B>pragma</B>&nbsp;Assert(Some_Test);</div>
<div class="Normal" style="margin-bottom: 0.4em">as equivalent to&nbsp;</div>
<div class="SwissExamples"><B>if</B>&nbsp;<SPAN Class="roman"><I>policy_identifier</I></SPAN>&nbsp;=&nbsp;Check&nbsp;<B>then</B><BR>
&nbsp;&nbsp;&nbsp;Assert(Some_Test);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>call&nbsp;of&nbsp;procedure&nbsp;Assert</I></SPAN><BR>
<B>end&nbsp;if</B>;</div>
<div class="Normal">Note again that there are two procedures <SPAN Class="swiss">Assert</SPAN>, 
one with and one without the message parameter. These correspond to raise 
statements with and without an explicit message.</div>
<div class="Normal">The pragma <SPAN Class="swiss">Assertion_Policy</SPAN> 
is a configuration pragma and controls the behaviour of <SPAN Class="swiss">Assert</SPAN> 
throughout the units to which it applies. It is thus possible for different 
policies to be in effect in different parts of a partition.</div>
<div class="Normal">An implementation could define other policies such 
as <SPAN Class="swiss">Assume</SPAN> which might mean that the compiler 
is free to do optimizations based on the assumption that the boolean 
expressions are true although there would be no code to check that they 
were true. Careless use of such a policy could lead to erroneous behaviour.</div>
<div class="Normal" style="margin-bottom: 0.4em">There was some concern 
that pragmas such as <SPAN Class="swiss">Assert</SPAN> might be misunderstood 
to imply that static analysis was being carried out. Thus in the SPARK 
language <A HREF="Rat-0-2.html#R9">[9]</A>, the annotation&nbsp;</div>
<div class="SwissExamples">--#&nbsp;<B>assert</B>&nbsp;N&nbsp;/=&nbsp;0</div>
<div class="Normal">is indeed a static assertion and the appropriate 
tools can be used to verify this.</div>
<div class="Normal">However, other languages such as Eiffel have used 
<B>assert</B> in a dynamic manner as now introduced into Ada 2005 and, 
moreover, many implementations of Ada have already provided a pragma 
<SPAN Class="swiss">Assert</SPAN> so it is expected that there will be 
no confusion with its incorporation into the standard.</div>
<div class="Normal" style="margin-bottom: 0.4em"><A NAME="I1247"></A><A NAME="I1248"></A>Another 
pragma with a related flavour is <SPAN Class="swiss">No_Return</SPAN>. 
This can be applied to a procedure (not to a function) and asserts that 
the procedure never returns in the normal sense. Control can leave the 
procedure only by the propagation of an exception or it might loop forever 
(which is common among certain real-time programs). The syntax is&nbsp;</div>
<div class="SwissExamples"><B>pragma</B>&nbsp;No_Return(<SPAN Class="roman"><I>procedure</I></SPAN>_local_name&nbsp;{,&nbsp;<SPAN Class="roman"><I>procedure</I></SPAN>_local_name});</div>
<div class="Normal" style="margin-bottom: 0.4em">Thus we might have 
a procedure <SPAN Class="swiss">Fatal_Error</SPAN> which outputs some 
message and then propagates an exception which can be handled in the 
main subprogram. For example&nbsp;</div>
<div class="SwissExamples"><B>procedure</B>&nbsp;Fatal_Error(Msg:&nbsp;<B>in</B>&nbsp;String)&nbsp;is<BR>
&nbsp;&nbsp;&nbsp;<B>pragma</B>&nbsp;No_Return(Fatal_Error);<BR>
<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;Put_Line(Msg);<BR>
&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>other&nbsp;last&nbsp;wishes</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;<B>raise</B>&nbsp;Death;<BR>
<B>end</B>&nbsp;Fatal_Error;<BR>
...</div>
<div class="SwissExamples"><B>procedure</B>&nbsp;Main&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;...<BR>
&nbsp;&nbsp;&nbsp;...<BR>
&nbsp;&nbsp;&nbsp;Put_Line(&quot;Program&nbsp;terminated&nbsp;successfully&quot;);<BR>
<B>exception</B><BR>
&nbsp;&nbsp;&nbsp;<B>when</B>&nbsp;Death&nbsp;=&gt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Put_Line(&quot;Program&nbsp;terminated:&nbsp;known&nbsp;error&quot;);<BR>
&nbsp;&nbsp;&nbsp;<B>when&nbsp;others</B>&nbsp;=&gt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Put_Line(&quot;Program&nbsp;terminated:&nbsp;unknown&nbsp;error&quot;);<BR>
<B>end</B>&nbsp;Main;</div>
<div class="Normal">There are two consequences of supplying a pragma 
<SPAN Class="swiss">No_Return</SPAN>.</div>
<div class="Bulleted">The implementation checks at compile time that 
the procedure concerned has no explicit return statements. There is also 
a check at run time that it does not attempt to run into the final end 
&ndash; <SPAN Class="swiss">Program_Error</SPAN> is raised if it does 
as in the case of running into the end of a function.</div>
<div class="Bulleted">The implementation is able to assume that calls 
of the procedure do not return and so various optimizations can be made. 
</div>
<div class="Normal" style="margin-bottom: 0.4em">We might then have 
a call of <SPAN Class="swiss">Fatal_Error</SPAN> as in</div>
<div class="SwissExamples"><B>function</B>&nbsp;Pop&nbsp;<B>return</B>&nbsp;Symbol&nbsp;<B>is</B><BR>
<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;<B>if</B>&nbsp;Top&nbsp;=&nbsp;0&nbsp;<B>then</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fatal_Error(&quot;Stack&nbsp;empty&quot;);&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>never&nbsp;returns</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;<B>elsif</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Top&nbsp;:=&nbsp;Top&nbsp;&ndash;&nbsp;1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>return</B>&nbsp;S(Top+1);<BR>
&nbsp;&nbsp;&nbsp;<B>end&nbsp;if</B>;<BR>
<B>end</B>&nbsp;Pop;</div>
<div class="Normal">If <SPAN Class="swiss">No_Return</SPAN> applies to 
<SPAN Class="swiss">Fatal_Error</SPAN> then the compiler should not compile 
a jump after the call of <SPAN Class="swiss">Fatal_Error</SPAN> and should 
not produce a warning that control might run into the final end of <SPAN Class="swiss">Pop</SPAN>.</div>
<div class="Normal" style="margin-bottom: 0.4em">The pragma <SPAN Class="swiss">No_Return</SPAN> 
now applies to the predefined procedure <SPAN Class="swiss">Raise_Exception</SPAN>. 
To enable this to be possible its behaviour with <SPAN Class="swiss">Null_Id</SPAN> 
has had to be changed. In Ada 95 writing&nbsp;</div>
<div class="SwissExamples">Raise_Exception(Null_Id,&nbsp;&quot;Nothing&quot;);</div>
<div class="Normal">does nothing at all (and so does return in that case) 
whereas in Ada 2005 it is defined to raise <SPAN Class="swiss">Constraint_Error</SPAN> 
and so now never returns.</div>
<div class="Normal" style="margin-bottom: 0.4em">We could restructure 
the procedure <SPAN Class="swiss">Fatal_Error</SPAN> to use <SPAN Class="swiss">Raise_Exception</SPAN> 
thus&nbsp;</div>
<div class="SwissExamples"><B>procedure</B>&nbsp;Fatal_Error(Msg:&nbsp;<B>in</B>&nbsp;String)&nbsp;is<BR>
&nbsp;&nbsp;&nbsp;<B>pragma</B>&nbsp;No_Return(Fatal_Error);<BR>
<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>other&nbsp;last&nbsp;wishes</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;Raise_Exception(Death'Identity,&nbsp;Msg);<BR>
<B>end</B>&nbsp;Fatal_Error;</div>
<div class="Normal">Since pragma <SPAN Class="swiss">No_Return</SPAN> 
applies to <SPAN Class="swiss">Fatal_Error</SPAN> it is important that 
we also know that <SPAN Class="swiss">Raise_Exception</SPAN> cannot return.</div>
<div class="Normal">The exception handler for <SPAN Class="swiss">Death</SPAN> 
in the main subprogram can now use <SPAN Class="swiss">Exception_Message</SPAN> 
to print out the message.</div>
<div class="Normal" style="margin-bottom: 0.4em">Remember also from 
Section <A HREF="Rat-6-2.html">6.2</A> that we can now also write&nbsp;</div>
<div class="SwissExamples"><B>raise</B>&nbsp;Death&nbsp;<B>with</B>&nbsp;Msg;</div>
<div class="Normal">rather than call <SPAN Class="swiss">Raise_Exception</SPAN>.</div>
<div class="Normal">The pragma <SPAN Class="swiss">No_Return</SPAN> is 
a representation pragma. If a subprogram has no distinct specification 
then the pragma <SPAN Class="swiss">No_Return</SPAN> is placed inside 
the body (as shown above). If a subprogram has a distinct specification 
then the pragma must follow the specification in the same compilation 
or declarative region. Thus one pragma <SPAN Class="swiss">No_Return</SPAN> 
could apply to several subprograms declared in the same package specification.</div>
<div class="Normal" style="margin-bottom: 0.4em">It is important that 
dispatching works correctly with procedures that do not return. A non-returning 
dispatching procedure can only be overridden by a non-returning procedure 
and so the overriding procedure must also have pragma <SPAN Class="swiss">No_Return</SPAN> 
thus&nbsp;</div>
<div class="SwissExamples"><B>type</B>&nbsp;T&nbsp;<B>is&nbsp;tagged</B>&nbsp;...<BR>
<B>procedure</B>&nbsp;P(X:&nbsp;T;&nbsp;...&nbsp;);<BR>
<B>pragma</B>&nbsp;No_Return(P);<BR>
...<BR>
<B>type</B>&nbsp;TT&nbsp;<B>is&nbsp;new</B>&nbsp;T&nbsp;<B>with</B>&nbsp;...<BR>
<B>overriding</B><BR>
<B>procedure</B>&nbsp;P(X:&nbsp;TT;&nbsp;...&nbsp;);<BR>
<B>pragma</B>&nbsp;No_Return(P);</div>
<div class="Normal">The reverse is not true of course. A procedure that 
does return can be overridden by one that does not.</div>
<div class="Normal">It is possible to give a pragma <SPAN Class="swiss">No_Return</SPAN> 
for an abstract procedure, but obviously not for a null procedure. A 
pragma <SPAN Class="swiss">No_Return</SPAN> can also be given for a generic 
procedure. It then applies to all instances.</div>
<div class="Normal" style="margin-bottom: 0.4em"><A NAME="I1249"></A><A NAME="I1250"></A>The 
next new pragma is <SPAN Class="swiss">Preelaborable_Initialization</SPAN>. 
The syntax is&nbsp;</div>
<div class="SwissExamples"><B>pragma</B>&nbsp;Preelaborable_Initialization(direct_name);</div>
<div class="Normal">This pragma concerns the categorization of library 
units and is related to pragmas such as <SPAN Class="swiss">Pure</SPAN> 
and <SPAN Class="swiss">Preelaborate</SPAN>. It is used with a private 
type and promises that the full type given by the parameter will indeed 
have preelaborable initialization. The details of its use will be explained 
in the next chapter (see <A HREF="Rat-7-7.html">7.7</A>).</div>
<div class="Normal" style="margin-bottom: 0.4em"><A NAME="I1251"></A><A NAME="I1252"></A>Another 
new pragma is <SPAN Class="swiss">Unchecked_Union</SPAN>. The syntax 
is&nbsp;</div>
<div class="SwissExamples"><B>pragma</B>&nbsp;Unchecked_Union(<SPAN Class="roman"><I>first_subtype</I></SPAN>_local_name);</div>
<div class="Normal">The parameter has to denote an unconstrained discriminated 
record subtype with a variant part. The purpose of the pragma is to permit 
interfacing to unions in C. The following example was given in the Introduction<A NAME="I1253"></A> 
</div>
<div class="SwissExamples"><B>type</B>&nbsp;Number(Kind:&nbsp;Precision)&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>record</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>case</B>&nbsp;Kind&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>when</B>&nbsp;Single_Precision&nbsp;=&gt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SP_Value:&nbsp;Long_Float;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>when</B>&nbsp;Multiple_Precision&nbsp;=&gt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MP_Value_Length:&nbsp;Integer;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MP_Value_First:&nbsp;<B>access</B>&nbsp;Long_Float;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>end&nbsp;case</B>;<BR>
&nbsp;&nbsp;&nbsp;<B>end&nbsp;record</B>;</div>
<div class="SwissExamples"><B>pragma</B>&nbsp;Unchecked_Union(Number);</div>
<div class="Normal" style="margin-bottom: 0.4em">Specifying the pragma 
<SPAN Class="swiss">Unchecked_Union</SPAN> ensures the following&nbsp;</div>
<div class="Bulleted">The representation of the type does not allow space 
for any discriminants.</div>
<div class="Bulleted">There is an implicit suppression of <SPAN Class="swiss">Discriminant_Check</SPAN>.</div>
<div class="Bulleted">There is an implicit <B>pragma</B> <SPAN Class="swiss">Convention(C)</SPAN>. 
</div>
<div class="Normal" style="margin-bottom: 0.4em">The above Ada text 
provides a mapping of the following C union&nbsp;</div>
<div class="SwissExamples">union&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;double&nbsp;spvalue;<BR>
&nbsp;&nbsp;&nbsp;struct&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;length;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double*&nbsp;first;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;mpvalue;<BR>
}&nbsp;number;</div>
<div class="Normal">The general idea is that the C programmer has created 
a type which can be used to represent a floating point number in one 
of two ways according to the precision required. One way is just as a 
double length value (a single item) and the other way is as a number 
of items considered juxtaposed to create a multiple precision value. 
This latter is represented as a structure consisting of an integer giving 
the number of items followed by a pointer to the first of them. These 
two different forms are the two alternatives of the union.</div>
<div class="Normal" style="margin-bottom: 0.4em">In the Ada mapping 
the choice of precision is governed by the discriminant <SPAN Class="swiss">Kind</SPAN> 
which is of an enumeration type as follows&nbsp;</div>
<div class="SwissExamples"><B>type</B>&nbsp;Precision&nbsp;<B>is</B>&nbsp;(Single_Precision,&nbsp;Multiple_Precision);</div>
<div class="Normal">In the single precision case the component <SPAN Class="swiss">SP_Value</SPAN> 
of type <SPAN Class="swiss">Long_Float</SPAN> maps onto the C component 
<SPAN Class="swiss">spvalue&nbsp;</SPAN>of type <SPAN Class="swiss">double</SPAN>.</div>
<div class="Normal">The multiple precision case is somewhat troublesome. 
The Ada component <SPAN Class="swiss">MP_Value_Length</SPAN> maps onto 
the C component <SPAN Class="swiss">length</SPAN> and the Ada component 
<SPAN Class="swiss">MP_Value_First</SPAN> of type <B>access</B><SPAN Class="swiss">&nbsp;Long_Float</SPAN> maps onto the C component <SPAN Class="swiss">first</SPAN> 
of type <SPAN Class="swiss">double*</SPAN>.</div>
<div class="Normal" style="margin-bottom: 0.4em">In our Ada program 
we can declare a variable thus&nbsp;</div>
<div class="SwissExamples">X:&nbsp;Number(Multiple_Precision);</div>
<div class="Normal" style="margin-bottom: 0.4em">and we then obtain 
a value in <SPAN Class="swiss">X</SPAN> by calling some C subprogram. 
We can then declare an array and map it onto the C sequence of double 
length values thus&nbsp;</div>
<div class="SwissExamples">A:&nbsp;<B>array</B>&nbsp;(1&nbsp;..&nbsp;X.MP_Value_Length)&nbsp;<B>of</B>&nbsp;Long_Float;<BR>
<B>for</B>&nbsp;A'Address&nbsp;<B>use</B>&nbsp;X.MP_Value_First.<B>all</B>'Address;<BR>
<B>pragma</B>&nbsp;Import(C,&nbsp;A);</div>
<div class="Normal">The elements of <SPAN Class="swiss">A</SPAN> are 
now the required values. Note that we don't use an Ada array in the declaration 
of <SPAN Class="swiss">Number</SPAN> because there might be problems 
with dope information.</div>
<div class="Normal">The Ada type can also have a non-variant part preceding 
the variant part and variant parts can be nested. It may have several 
discriminants.</div>
<div class="Normal" style="margin-bottom: 0.4em">When an object of an 
unchecked union type is created, values must be supplied for all its 
discriminants even though they are not stored. This ensures that appropriate 
default values can be supplied and that an aggregate contains the correct 
components. However, since the discriminants are not stored, they cannot 
be read. So we can write&nbsp;</div>
<div class="SwissExamples">X:&nbsp;Number&nbsp;:=&nbsp;(Single_Precision,&nbsp;45.6);<BR>
Y:&nbsp;Number(Single_Precision);<BR>
...<BR>
Y.SP_Value&nbsp;:=&nbsp;55.7;</div>
<div class="Normal" style="margin-bottom: 0.4em">The variable <SPAN Class="swiss">Y</SPAN> 
is said to have an inferable discriminant whereas <SPAN Class="swiss">X</SPAN> 
does not. Although it is clear that playing with unchecked unions is 
potentially dangerous, nevertheless Ada 2005 imposes certain rules that 
avoid some dangers. One rule is that predefined equality can only be 
used on operands with inferable discriminants; <SPAN Class="swiss">Program_Error</SPAN> 
is raised otherwise. So&nbsp;</div>
<div class="SwissExamples"><B>if</B>&nbsp;Y&nbsp;=&nbsp;55.8&nbsp;<B>then</B>&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>OK</I></SPAN></div>
<div class="SwissExamples"><B>if</B>&nbsp;X&nbsp;=&nbsp;45.5&nbsp;<B>then</B>&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>raises&nbsp;Program_Error</I></SPAN></div>
<div class="SwissExamples"><B>if</B>&nbsp;X&nbsp;=&nbsp;Y&nbsp;<B>then</B>&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>raises&nbsp;Program_Error</I></SPAN></div>
<div class="Normal" style="margin-bottom: 0.4em">It is important to 
be aware that unchecked union types are introduced in Ada 2005 for the 
sole purpose of interfacing to C programs and not for living dangerously. 
Thus consider&nbsp;</div>
<div class="SwissExamples"><B>type</B>&nbsp;T(Flag:&nbsp;Boolean&nbsp;:=&nbsp;False)&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>record</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>case</B>&nbsp;Flag&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>when</B>&nbsp;False&nbsp;=&gt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F1:&nbsp;Float&nbsp;:=&nbsp;0.0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>when</B>&nbsp;True&nbsp;=&gt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F2:&nbsp;Integer&nbsp;:=&nbsp;0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>end&nbsp;case</B>;<BR>
&nbsp;&nbsp;&nbsp;<B>end&nbsp;record</B>;<BR>
<B>pragma</B>&nbsp;Unchecked_Union(T);</div>
<div class="Normal" style="margin-bottom: 0.4em">The type <SPAN Class="swiss">T</SPAN> 
can masquerade as either type <SPAN Class="swiss">Integer</SPAN> or <SPAN Class="swiss">Float</SPAN>. 
But we should not use unchecked union types as an alternative to unchecked 
conversion. Thus consider&nbsp;</div>
<div class="SwissExamples">X:&nbsp;T;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>Float&nbsp;by&nbsp;default</I></SPAN><BR>
Y:&nbsp;Integer&nbsp;:=&nbsp;X.F2;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>erroneous</I></SPAN></div>
<div class="Normal">The object <SPAN Class="swiss">X</SPAN> has discriminant 
<SPAN Class="swiss">False</SPAN> by default and thus has the value zero 
of type <SPAN Class="swiss">Integer</SPAN>. In the absence of the pragma 
<SPAN Class="swiss">Unchecked_Union</SPAN>, the attempt to read <SPAN Class="swiss">X.F2</SPAN> 
would raise <SPAN Class="swiss">Constraint_Error</SPAN> because of the 
discriminant check. The use of <SPAN Class="swiss">Unchecked_Union</SPAN> 
suppresses the discriminant check and so the assignment will occur. But 
note that the ARM clearly says (11.5(26)) that if a check is suppressed 
and the corresponding error situation arises then the program is erroneous.</div>
<div class="Normal">However, assigning a <SPAN Class="swiss">Float</SPAN> 
value to an <SPAN Class="swiss">Integer</SPAN> object using <SPAN Class="swiss">Unchecked_Conversion</SPAN> 
is not erroneous providing certain conditions hold such as that <SPAN Class="swiss">Float'Size 
= Integer'Size</SPAN>.</div>
<div class="Normal" style="margin-bottom: 0.4em"><A NAME="I1254"></A><A NAME="I1255"></A>The 
final pragma to be considered is <SPAN Class="swiss">Unsuppress</SPAN>. 
Its syntax is&nbsp;</div>
<div class="SwissExamples"><B>pragma</B>&nbsp;Unsuppress(identifier);</div>
<div class="Normal">The identifier is that of a check or perhaps <SPAN Class="swiss">All_Checks</SPAN>. 
The pragma <SPAN Class="swiss">Unsuppress</SPAN> is essentially the opposite 
of the existing pragma <SPAN Class="swiss">Suppress</SPAN> and can be 
used in the same places with similar scoping rules.</div>
<div class="Normal">Remember that pragma <SPAN Class="swiss">Suppress</SPAN> 
gives an implementation the permission to omit the checks but it does 
not require that the checks be omitted (they might be done by hardware). 
The pragma <SPAN Class="swiss">Unsuppress</SPAN> simply revokes this 
permission. One pragma can override the other in a nested manner. If 
both are given in the same region then they apply from the point where 
they are given and the later one thus overrides.</div>
<div class="Normal">A likely scenario would be that <SPAN Class="swiss">Suppress</SPAN> 
applies to a large region of the program (perhaps all of it) and <SPAN Class="swiss">Unsuppress</SPAN> 
applies to a smaller region within. The reverse would also be possible 
but perhaps less likely.</div>
<div class="Normal">Note that <SPAN Class="swiss">Unsuppress</SPAN> does 
not override the implicit <SPAN Class="swiss">Suppress</SPAN> of <SPAN Class="swiss">Discriminant_Check</SPAN> 
provided by the pragma <SPAN Class="swiss">Unchecked_Union</SPAN> just 
discussed.</div>
<div class="Normal" style="margin-bottom: 0.4em">A sensible application 
of <SPAN Class="swiss">Unsuppress</SPAN> would be in the fixed point 
operations mentioned in Section <A HREF="Rat-6-3.html">6.3</A> thus&nbsp;</div>
<div class="SwissExamples"><B>function</B>&nbsp;&quot;*&quot;(Left,&nbsp;Right:&nbsp;Frac)&nbsp;<B>return</B>&nbsp;Frac&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>pragma</B>&nbsp;Unsuppress(Overflow_Check);<BR>
<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;<B>return</B>&nbsp;Standard.&quot;*&quot;(Left,&nbsp;Right);<BR>
<B>exception</B><BR>
&nbsp;&nbsp;&nbsp;<B>when</B>&nbsp;Constraint_Error&nbsp;=&gt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>if</B>&nbsp;(Left&gt;0.0&nbsp;<B>and</B>&nbsp;Right&gt;0.0)&nbsp;<B>or</B>&nbsp;(Left&lt;0.0&nbsp;<B>and</B>&nbsp;Right&lt;0.0)&nbsp;<B>then</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>return</B>&nbsp;Frac'Last;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>else</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>return</B>&nbsp;Frac'First;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>end&nbsp;if</B>;<BR>
<B>end</B>&nbsp;&quot;*&quot;;</div>
<div class="Normal">The use of <SPAN Class="swiss">Unsuppress</SPAN> 
ensures that the overflow check is not suppressed even if there is a 
global <SPAN Class="swiss">Suppress</SPAN> for the whole program (or 
the user has switched checks off through the compiler command line). 
So <SPAN Class="swiss">Constraint_Error</SPAN> will be raised as necessary 
and the code will work correctly.</div>
<div class="Normal" style="margin-bottom: 0.4em">In Ada 95 the pragma 
<SPAN Class="swiss">Suppress</SPAN> has the syntax&nbsp;</div>
<div class="SwissExamples"><B>pragma</B>&nbsp;Suppress(identifier&nbsp;[&nbsp;,&nbsp;[On&nbsp;=&gt;]&nbsp;name]);&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>Ada&nbsp;95</I></SPAN></div>
<div class="Normal" style="margin-bottom: 0.4em">The second and optional 
parameter gives the name of the entity to which the permission applies. 
There was never any clear agreement on what this meant and implementations 
varied. Accordingly, in Ada 2005 the second parameter is banished to 
<A HREF="http://www.adaic.org/resources/add_content/standards/05rm/html/RM-J-10.html">Annex 
J</A> so that the syntax in the core language is similar to <SPAN Class="swiss">Unsuppress</SPAN> 
thus&nbsp;</div>
<div class="SwissExamples"><B>pragma</B>&nbsp;Suppress(identifier);&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>Ada&nbsp;2005</I></SPAN></div>
<div class="Normal">For symmetry, Annex J actually allows an obsolete 
<SPAN Class="swiss">On</SPAN> parameter for <SPAN Class="swiss">Unsuppress</SPAN>. 
It might seem curious that a feature should be born obsolescent.</div>
<div class="Normal" style="margin-bottom: 0.4em"><A NAME="I1256"></A>A 
number of new <SPAN Class="swiss">Restrictions</SPAN> identifiers are 
added in Ada 2005. The first is <SPAN Class="swiss">No_Dependence</SPAN> 
whose syntax is&nbsp;</div>
<div class="SwissExamples"><B>pragma</B>&nbsp;Restrictions(No_Dependence&nbsp;=&gt;&nbsp;name);</div>
<div class="Normal">This indicates that there is no dependence on a library 
unit with the given name.</div>
<div class="Normal" style="margin-bottom: 0.4em">The name might be that 
of a predefined unit but it could in fact be any unit. For example, it 
might be helpful to know that there is no dependence on a particular 
implementation-defined unit such as a package <SPAN Class="swiss">Superstring</SPAN> 
thus&nbsp;</div>
<div class="SwissExamples"><B>pragma</B>&nbsp;Restrictions(No_Dependence&nbsp;=&gt;&nbsp;Superstring);</div>
<div class="Normal">Care needs to be taken to spell the name correctly; 
if we write <SPAN Class="swiss">Supperstring</SPAN> by mistake then the 
compiler will not be able to help us.</div>
<div class="Normal" style="margin-bottom: 0.4em">The introduction of 
<SPAN Class="swiss">No_Dependence</SPAN> means that the existing <SPAN Class="swiss">Restrictions</SPAN> 
identifier <SPAN Class="swiss">No_Asynchronous_Control</SPAN> is moved 
to <A HREF="http://www.adaic.org/resources/add_content/standards/05rm/html/RM-J-13.html">Annex 
J</A> since we can now write&nbsp;</div>
<div class="SwissExamples"><B>pragma</B>&nbsp;Restrictions(No_Dependence&nbsp;=&gt;&nbsp;Ada.Asynchronous_Task_Control);</div>
<div class="Normal">Similarly, the identifiers <SPAN Class="swiss">No_Unchecked_Conversion</SPAN> 
and <SPAN Class="swiss">No_Unchecked_Deallocation</SPAN> are also moved 
to <A HREF="http://www.adaic.org/resources/add_content/standards/05rm/html/RM-J-13.html">Annex 
J</A>.</div>
<div class="Normal">Note that the identifier <SPAN Class="swiss">No_Dynamic_Attachment</SPAN> 
which refers to the use of the subprograms in the package <SPAN Class="swiss">Ada.Interrupts</SPAN> 
cannot be treated in this way because of the child package <SPAN Class="swiss">Ada.Interrupts.Names</SPAN>. 
No dependence on <SPAN Class="swiss">Ada.Interrupts</SPAN> would exclude 
the use of the child package <SPAN Class="swiss">Names</SPAN> as well.</div>
<div class="Normal">The restrictions identifier <SPAN Class="swiss">No_Dynamic_Priorities</SPAN> 
cannot be treated this way either for a rather different reason. In Ada 
2005 this identifier is extended so that it also excludes the use of 
the attribute <SPAN Class="swiss">Priority</SPAN> and this would not 
be excluded by just saying no dependence on <SPAN Class="swiss">Ada.Dynamic_Priorities</SPAN>.</div>
<div class="Normal" style="margin-bottom: 0.4em"><A NAME="I1257"></A><A NAME="I1258"></A>Two 
further <SPAN Class="swiss">Restrictions</SPAN> identifiers are introduced 
to encourage portability. We can write&nbsp;</div>
<div class="SwissExamples"><B>pragma</B>&nbsp;Restrictions(No_Implementation_Pragmas,&nbsp;No_Implementation_Attributes);</div>
<div class="Normal">These do not apply to the whole partition but only 
to the compilation or environment concerned. This helps us to ensure 
that implementation dependent areas of a program are identified.</div>
<div class="Normal" style="margin-bottom: 0.4em"><A NAME="I1259"></A>The 
final new restrictions identifier similarly prevents us from inadvertently 
using features in <A HREF="http://www.adaic.org/resources/add_content/standards/05rm/html/RM-J.html">Annex 
J</A> thus&nbsp;</div>
<div class="SwissExamples"><B>pragma</B>&nbsp;Restrictions(No_Obsolescent_Features);</div>
<div class="Normal">Again this does not apply to the whole partition 
but only to the compilation or environment concerned. (It is of course 
not itself defined in Annex J.)</div>
<div class="Normal" style="margin-bottom: 0.4em">The reader will recall 
that in Ada 83 the predefined packages had names such as <SPAN Class="swiss">Text_IO</SPAN> 
whereas in Ada 95 they are <SPAN Class="swiss">Ada.Text_IO</SPAN> and 
so on. In order to ease transition from Ada 83, a number of renamings 
were declared in <A HREF="http://www.adaic.org/resources/add_content/standards/05rm/html/RM-J-1.html">Annex 
J</A> such as&nbsp;</div>
<div class="SwissExamples"><B>with</B>&nbsp;Ada.Text_IO;<BR>
<B>package</B>&nbsp;Text_IO&nbsp;<B>renames</B>&nbsp;Ada.Text_IO;</div>
<div class="Normal">A mild problem is that the user could write these 
renamings anyway and we do not want the <SPAN Class="swiss">No_Obsolescent_Features</SPAN> 
restriction to prevent this. Moreover, implementations might actually 
implement the renamings in Annex J by just compiling them and we don't 
want to force implementations to use some trickery to permit the user 
to do it but not the implementation. Accordingly, whether the <SPAN Class="swiss">No_Obsolescent_Features</SPAN> 
restriction applies to these renamings or not is implementation defined.</div>

<HR>
<div style="margin-top: 0.0em; margin-bottom: 0.6em"><A HREF="Rat-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="Rat-0-3.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="Rat-0-2.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="Rat-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="Rat-6-3.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="Rat-6-5.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</div>
<DIV Class="Normal">&copy; 2005, 2006, 2007 John Barnes Informatics.</DIV>
<DIV Class="Normal">Sponsored in part by:</DIV>
<TABLE Summary="Sponsors" Width="710">
<TR><TD VAlign="Top" Width="490">
<SPAN Style="font-family: Arial, Helvetica, sans-serif; font-size: 92%">The <A HREF="http://www.adaic.org/community/">Ada Resource Association</A> and its member companies:</SPAN>
<img src="http://www.adaic.org/resources/images/sponsors/ARA-members-5.gif" alt="ARA Members" usemap="#member-map" border=1>
<map name="member-map">
  <AREA href="http://www.adacore.com/" alt="AdaCore"
          shape="rect"          coords="0,0,222,66">
  <AREA href="http://www.polyspace.com/" alt="Polyspace Technologies"
          shape="rect"          coords="0,66,155,179">
	<AREA href="http://www.sparkada.com/" alt="Praxis Critical Systems"
	         shape="rect"         coords="156,66,295,179">
	<AREA href="http://www-306.ibm.com/software/awdtools/developer/ada/" alt="IBM Rational"
	         shape="rect"         coords="222,0,480,66">
	<AREA href="http://www.sofcheck.com/" alt="Sofcheck"
	         shape="rect"         coords="296,66,480,130">
</map>
<TD Width="220" Align="Center" VAlign="Top">
<SPAN Style="font-family: Arial, Helvetica, sans-serif; font-size: 92%">and &nbsp; <A HREF="http://www.ada-europe.org">Ada-Europe</A>:<BR>
<A HREF="http://www.ada-europe.org"><IMG SRC="AE_logo.gif" ALT="Ada-Europe" Height="200" Border="0"></A></SPAN>
</TABLE>
</BODY>
</HTML>
