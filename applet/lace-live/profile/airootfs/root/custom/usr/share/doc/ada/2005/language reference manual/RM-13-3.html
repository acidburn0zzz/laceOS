<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Operational and Representation Attributes</TITLE>
    <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    H4.centered {text-align: center}
    SPAN.swiss {font-family: Arial, Helvetica, sans-serif; font-size: 92%}
    SPAN.roman {font-family: "Times New Roman", Times, serif}
    DIV.paranum {float: left; font-family: Arial, Helvetica, sans-serif; font-size: 64%; width: 2.8em; margin-left: -0.4em; margin-right: -3.0em; margin-top: 0.2em}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    DIV.Normal {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.2em; margin-bottom: 0.6em}
    DIV.Notes {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em; margin-bottom: 0.6em}
    DIV.NotesHeader {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em}
    DIV.SyntaxIndented {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-bottom: 0.4em}
    DIV.Examples {font-family: "Courier New", monospace; font-size: 90%; line-height: 122%; margin-left: 3.4em; margin-bottom: 0.6em}
    UL.Bulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.NestedBulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 5.2em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.IndentedBulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 9.2em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    DIV.Hanging-Body {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 7.2em; margin-top: 0em; margin-bottom: 0.6em}
    DIV.Hanging-Term {float: left; font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.2em; margin-top: 0em; margin-bottom: 0em}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#000080" VLINK="#330033" ALINK="#0000FF">
<DIV><SPAN Style="font-size:200%; color: rgb(0,0,153)"><B>Ada Reference Manual</B></SPAN> &mdash; <A HREF="RM-TTL.html"><B>Legal Information</B></A></DIV>
<DIV Style="margin-top: 0.6em; margin-bottom: 0.0em"><A HREF="RM-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RM-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RM-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RM-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RM-13-2.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RM-13-4.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<HR>
<H1>13.3 Operational and Representation Attributes</H1>
<DIV Class="paranum">1/1</DIV>
<DIV Class="Normal"><A NAME="I4459"></A><A NAME="I4460"></A>The values 
of certain implementation-dependent characteristics can be obtained by 
interrogating appropriate operational or representation attributes. <A NAME="I4461"></A>Some 
of these attributes are specifiable via an <SPAN Class="swiss"><A HREF="RM-13-3.html#S0286">attribute_definition_clause</A></SPAN>. 
</DIV>

<H4 Class="centered">Syntax</H4>
<DIV Class="paranum">2</DIV>
<DIV Class="SyntaxIndented"><SPAN Class="swiss">attribute_definition_clause</SPAN><A NAME="I4462"></A><A NAME="S0286"></A><SPAN Class="swiss">&nbsp;::=&nbsp;</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>for</B>&nbsp;<A NAME="I4463"></A><SPAN Class="swiss"><A HREF="RM-13-1.html#S0285">local_name</A></SPAN>'<A NAME="I4464"></A><SPAN Class="swiss"><A HREF="RM-4-1-4.html#S0101">attribute_designator</A></SPAN>&nbsp;<B>use</B>&nbsp;<A NAME="I4465"></A><SPAN Class="swiss"><A HREF="RM-4-4.html#S0115">expression</A></SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<B>for</B>&nbsp;<A NAME="I4466"></A><SPAN Class="swiss"><A HREF="RM-13-1.html#S0285">local_name</A></SPAN>'<A NAME="I4467"></A><SPAN Class="swiss"><A HREF="RM-4-1-4.html#S0101">attribute_designator</A></SPAN>&nbsp;<B>use</B>&nbsp;<A NAME="I4468"></A><SPAN Class="swiss"><A HREF="RM-4-1.html#S0091">name</A></SPAN>;</DIV>

<H4 Class="centered">Name Resolution Rules</H4>
<DIV Class="paranum">3</DIV>
<DIV Class="Normal">For an <SPAN Class="swiss"><A HREF="RM-13-3.html#S0286">attribute_definition_clause</A></SPAN> 
that specifies an attribute that denotes a value, the form with an <SPAN Class="swiss"><A HREF="RM-4-4.html#S0115">expression</A></SPAN> 
shall be used. Otherwise, the form with a <SPAN Class="swiss"><A HREF="RM-4-1.html#S0091">name</A></SPAN> 
shall be used.</DIV>
<DIV Class="paranum">4</DIV>
<DIV Class="Normal"><A NAME="I4469"></A>For an <SPAN Class="swiss"><A HREF="RM-13-3.html#S0286">attribute_definition_clause</A></SPAN> 
that specifies an attribute that denotes a value or an object, the expected 
type for the expression or <SPAN Class="swiss"><A HREF="RM-4-1.html#S0091">name</A></SPAN> 
is that of the attribute. <A NAME="I4470"></A>For an <SPAN Class="swiss"><A HREF="RM-13-3.html#S0286">attribute_definition_clause</A></SPAN> 
that specifies an attribute that denotes a subprogram, the expected profile 
for the <SPAN Class="swiss"><A HREF="RM-4-1.html#S0091">name</A></SPAN> 
is the profile required for the attribute. For an <SPAN Class="swiss"><A HREF="RM-13-3.html#S0286">attribute_definition_clause</A></SPAN> 
that specifies an attribute that denotes some other kind of entity, the 
<SPAN Class="swiss"><A HREF="RM-4-1.html#S0091">name</A></SPAN> shall 
resolve to denote an entity of the appropriate kind.&nbsp;</DIV>

<H4 Class="centered">Legality Rules</H4>
<DIV Class="paranum">5/1</DIV>
<DIV Class="Normal"><A NAME="I4471"></A><A NAME="I4472"></A>An <SPAN Class="swiss"><A HREF="RM-4-1-4.html#S0101">attribute_designator</A></SPAN> 
is allowed in an <SPAN Class="swiss"><A HREF="RM-13-3.html#S0286">attribute_definition_clause</A></SPAN> 
only if this International Standard explicitly allows it, or for an implementation-defined 
attribute if the implementation allows it. <A NAME="I4473"></A>Each specifiable 
attribute constitutes an <A NAME="I4474"></A>operational aspect or aspect 
of representation.&nbsp;</DIV>
<DIV Class="paranum">6</DIV>
<DIV Class="Normal">For an <SPAN Class="swiss"><A HREF="RM-13-3.html#S0286">attribute_definition_clause</A></SPAN> 
that specifies an attribute that denotes a subprogram, the profile shall 
be mode conformant with the one required for the attribute, and the convention 
shall be Ada. Additional requirements are defined for particular attributes. 
<A NAME="I4475"></A></DIV>

<H4 Class="centered">Static Semantics</H4>
<DIV Class="paranum">7/2</DIV>
<DIV Class="Normal"><A NAME="I4476"></A><A NAME="I4477"></A><A NAME="I4478"></A><A NAME="I4479"></A><A NAME="I4480"></A><A NAME="I4481"></A><A NAME="I4482"></A><A NAME="I4483"></A><A NAME="I4484"></A><A NAME="I4485"></A><A NAME="I4486"></A><A NAME="I4487"></A><A NAME="I4488"></A><A NAME="I4489"></A><A NAME="I4490"></A>A 
<I>Size clause</I> is an <SPAN Class="swiss"><A HREF="RM-13-3.html#S0286">attribute_definition_clause</A></SPAN> 
whose <SPAN Class="swiss"><A HREF="RM-4-1-4.html#S0101">attribute_designator</A></SPAN> 
is Size. Similar definitions apply to the other specifiable attributes. 
</DIV>
<DIV Class="paranum">8</DIV>
<DIV Class="Normal"><A NAME="I4491"></A><A NAME="I4492"></A>A <I>storage 
element</I> is an addressable element of storage in the machine. <A NAME="I4493"></A>A 
<I>word</I> is the largest amount of storage that can be conveniently 
and efficiently manipulated by the hardware, given the implementation's 
run-time model. A word consists of an integral number of storage elements. 
</DIV>
<DIV Class="paranum">8.1/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;<A NAME="I4494"></A>A <I>machine scalar</I> is 
an amount of storage that can be conveniently and efficiently loaded, 
stored, or operated upon by the hardware. Machine scalars consist of 
an integral number of storage elements. The set of machine scalars is 
implementation defined, but must include at least the storage element 
and the word. Machine scalars are used to interpret <SPAN Class="swiss"><A HREF="RM-13-5-1.html#S0290">component_clause</A></SPAN>s 
when the nondefault bit ordering applies.&nbsp;</DIV>
<DIV Class="paranum">9/1</DIV>
<DIV Class="Normal">The following representation attributes are defined: 
Address, Alignment, Size, Storage_Size, and Component_Size.</DIV>
<DIV Class="paranum">10/1</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;For a <SPAN Class="swiss"><A HREF="RM-4-1.html#S0093">prefix</A></SPAN> 
X that denotes an object, program unit, or label:&nbsp;</DIV>
<DIV Class="paranum">11</DIV>
<DIV Class="Hanging-Term">X'Address</DIV><DIV Class="Hanging-Body">
<A NAME="I4495"></A><A NAME="I4496"></A>Denotes the address of the first 
of the storage elements allocated to X. For a program unit or label, 
this value refers to the machine code associated with the corresponding 
body or <SPAN Class="swiss"><A HREF="RM-5-1.html#S0131">statement</A></SPAN>. 
The value of this attribute is of type System.Address.&nbsp;</DIV>
<DIV Class="paranum">12</DIV>
<DIV Class="Hanging-Body"><A NAME="I4497"></A><A NAME="I4498"></A>Address 
may be specified for stand-alone objects and for program units via an 
<SPAN Class="swiss"><A HREF="RM-13-3.html#S0286">attribute_definition_clause</A></SPAN>. 
</DIV>

<H4 Class="centered">Erroneous Execution</H4>
<DIV Class="paranum">13</DIV>
<DIV Class="Normal"><A NAME="I4499"></A>If an Address is specified, it 
is the programmer's responsibility to ensure that the address is valid; 
otherwise, program execution is erroneous.&nbsp;</DIV>

<H4 Class="centered">Implementation Advice</H4>
<DIV Class="paranum">14</DIV>
<DIV Class="Normal">For an array X, X'Address should point at the first 
component of the array, and not at the array bounds.&nbsp;</DIV>
<DIV Class="paranum">15</DIV>
<DIV Class="Normal"><A NAME="I4500"></A>The recommended level of support 
for the Address attribute is:&nbsp;</DIV>
<DIV Class="paranum">16</DIV>
<UL Class="Bulleted" Style="margin-bottom: 0.3em"><LI TYPE=DISC>X'Address 
should produce a useful result if X is an object that is aliased or of 
a by-reference type, or is an entity whose Address has been specified. 
</LI></UL>
<DIV Class="paranum">17</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>An implementation should support Address 
clauses for imported subprograms.</LI></UL>
<DIV Class="paranum">18/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN STYLE="font-size: 80%"><I>This 
paragraph was deleted.</I></SPAN></LI></UL>
<DIV Class="paranum">19</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>If the Address of an object is specified, 
or it is imported or exported, then the implementation should not perform 
optimizations based on assumptions of no aliases.&nbsp;</LI></UL>
<DIV Class="NotesHeader">NOTES</DIV>
<DIV Class="paranum">20</DIV>
<DIV Class="Notes">1&nbsp;&nbsp;The specification of a link name in a 
<SPAN Class="swiss"><A HREF="RM-2-8.html#S0019">pragma</A></SPAN> Export 
(see <A HREF="RM-B-1.html">B.1</A>) for a subprogram or object is an 
alternative to explicit specification of its link-time address, allowing 
a link-time directive to place the subprogram or object within memory.</DIV>
<DIV Class="paranum">21</DIV>
<DIV Class="Notes">2&nbsp;&nbsp;The rules for the Size attribute imply, 
for an aliased object X, that if X'Size = Storage_Unit, then X'Address 
points at a storage element containing all of the bits of X, and only 
the bits of X.&nbsp;</DIV>

<H4 Class="centered">Static Semantics</H4>
<DIV Class="paranum">22/2</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;For a <SPAN Class="swiss"><A HREF="RM-4-1.html#S0093">prefix</A></SPAN> 
X that denotes an object:&nbsp;</DIV>
<DIV Class="paranum">23/2</DIV>
<DIV Class="Hanging-Term">&nbsp;X'Alignment</DIV><DIV Class="Hanging-Body">
<A NAME="I4501"></A><A NAME="I4502"></A>The value of this attribute is 
of type <I>universal_integer</I>, and nonnegative; zero means that the 
object is not necessarily aligned on a storage element boundary. If X'Alignment 
is not zero, then X is aligned on a storage unit boundary and X'Address 
is an integral multiple of X'Alignment (that is, the Address modulo the 
Alignment is zero).</DIV>
<DIV Class="paranum">24/2</DIV>
<DIV Class="Hanging-Term">&nbsp;<SPAN STYLE="font-size: 80%"><I>This paragraph 
was deleted.</I></SPAN></DIV>
<DIV Class="paranum">25/2</DIV>
<DIV Class="Hanging-Body"><A NAME="I4503"></A><A NAME="I4504"></A>Alignment 
may be specified for stand-alone objects via an <SPAN Class="swiss"><A HREF="RM-13-3.html#S0286">attribute_definition_clause</A></SPAN>; 
the expression of such a clause shall be static, and its value nonnegative.</DIV>
<DIV Class="paranum">26/2</DIV>
<DIV Class="Hanging-Term">&nbsp;<SPAN STYLE="font-size: 80%"><I>This paragraph 
was deleted.</I></SPAN></DIV>
<DIV Class="paranum">26.1/2</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;&nbsp;&nbsp;For every subtype 
S:&nbsp;</DIV>
<DIV Class="paranum">26.2/2</DIV>
<DIV Class="Hanging-Term">&nbsp;&nbsp;&nbsp;S'Alignment</DIV><DIV Class="Hanging-Body"><BR clear="left">
<A NAME="I4505"></A><A NAME="I4506"></A>The value of this attribute is 
of type <I>universal_integer</I>, and nonnegative.</DIV>
<DIV Class="paranum">26.3/2</DIV>
<DIV Class="Hanging-Body">For an object X of subtype S, if S'Alignment 
is not zero, then X'Alignment is a nonzero integral multiple of S'Alignment 
unless specified otherwise by a representation item.</DIV>
<DIV Class="paranum">26.4/2</DIV>
<DIV Class="Hanging-Body"><A NAME="I4507"></A><A NAME="I4508"></A>Alignment 
may be specified for first subtypes via an <SPAN Class="swiss"><A HREF="RM-13-3.html#S0286">attribute_definition_clause</A></SPAN>; 
the expression of such a clause shall be static, and its value nonnegative.</DIV>

<H4 Class="centered">Erroneous Execution</H4>
<DIV Class="paranum">27</DIV>
<DIV Class="Normal"><A NAME="I4509"></A>Program execution is erroneous 
if an Address clause is given that conflicts with the Alignment.&nbsp;</DIV>
<DIV Class="paranum">28/2</DIV>
<DIV Class="Normal">&nbsp;<A NAME="I4510"></A>For an object that is not allocated 
under control of the implementation, execution is erroneous if the object 
is not aligned according to its Alignment.</DIV>

<H4 Class="centered">Implementation Advice</H4>
<DIV Class="paranum">29</DIV>
<DIV Class="Normal"><A NAME="I4511"></A>The recommended level of support 
for the Alignment attribute for subtypes is:&nbsp;</DIV>
<DIV Class="paranum">30/2</DIV>
<UL Class="Bulleted" Style="margin-bottom: 0.3em"><LI TYPE=DISC>An implementation 
should support an Alignment clause for a discrete type, fixed point type, 
record type, or array type, specifying an Alignment value that is zero 
or a power of two, subject to the following:</LI></UL>
<DIV Class="paranum">31/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>An implementation need not support 
an Alignment clause for a signed integer type specifying an Alignment 
greater than the largest Alignment value that is ever chosen by default 
by the implementation for any signed integer type. A corresponding limitation 
may be imposed for modular integer types, fixed point types, enumeration 
types, record types, and array types.</LI></UL>
<DIV Class="paranum">32/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>An implementation need not support 
a nonconfirming Alignment clause which could enable the creation of an 
object of an elementary type which cannot be easily loaded and stored 
by available machine instructions.</LI></UL>
<DIV Class="paranum">32.1/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>An implementation need not support 
an Alignment specified for a derived tagged type which is not a multiple 
of the Alignment of the parent type. An implementation need not support 
a nonconfirming Alignment specified for a derived untagged by-reference 
type.&nbsp;</LI></UL>
<DIV Class="paranum">33</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em"><A NAME="I4512"></A>The 
recommended level of support for the Alignment attribute for objects 
is:&nbsp;</DIV>
<DIV Class="paranum">34/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN STYLE="font-size: 80%"><I>This 
paragraph was deleted.</I></SPAN></LI></UL>
<DIV Class="paranum">35</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>For stand-alone library-level objects 
of statically constrained subtypes, the implementation should support 
all Alignments supported by the target linker. For example, page alignment 
is likely to be supported for such objects, but not for subtypes.</LI></UL>
<DIV Class="paranum">35.1/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>For other objects, an implementation 
should at least support the alignments supported for their subtype, subject 
to the following:</LI></UL>
<DIV Class="paranum">35.2/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>An implementation need not support 
Alignments specified for objects of a by-reference type or for objects 
of types containing aliased subcomponents if the specified Alignment 
is not a multiple of the Alignment of the subtype of the object.&nbsp;</LI></UL>
<DIV Class="NotesHeader">NOTES</DIV>
<DIV Class="paranum">36</DIV>
<DIV Class="Notes">3&nbsp;&nbsp;Alignment is a subtype-specific attribute.</DIV>
<DIV Class="paranum">37/2</DIV>
<DIV Class="Notes"><SPAN STYLE="font-size: 80%"><I>This paragraph was 
deleted.</I></SPAN></DIV>
<DIV Class="paranum">38</DIV>
<DIV Class="Notes">4&nbsp;&nbsp;A <SPAN Class="swiss"><A HREF="RM-13-5-1.html#S0290">component_clause</A></SPAN>, 
Component_Size clause, or a <SPAN Class="swiss"><A HREF="RM-2-8.html#S0019">pragma</A></SPAN> 
Pack can override a specified Alignment.&nbsp;</DIV>

<H4 Class="centered">Static Semantics</H4>
<DIV Class="paranum">39/1</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;For a <SPAN Class="swiss"><A HREF="RM-4-1.html#S0093">prefix</A></SPAN> 
X that denotes an object:&nbsp;</DIV>
<DIV Class="paranum">40</DIV>
<DIV Class="Hanging-Term">X'Size</DIV><DIV Class="Hanging-Body">
<A NAME="I4513"></A><A NAME="I4514"></A>Denotes the size in bits of the 
representation of the object. The value of this attribute is of the type 
<I>universal_integer</I>.&nbsp;</DIV>
<DIV Class="paranum">41</DIV>
<DIV Class="Hanging-Body"><A NAME="I4515"></A><A NAME="I4516"></A>Size 
may be specified for stand-alone objects via an <SPAN Class="swiss"><A HREF="RM-13-3.html#S0286">attribute_definition_clause</A></SPAN>; 
the expression of such a clause shall be static and its value nonnegative. 
</DIV>

<H4 Class="centered">Implementation Advice</H4>
<DIV Class="paranum">41.1/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;The size of an array object should not include 
its bounds.&nbsp;</DIV>
<DIV Class="paranum">42/2</DIV>
<DIV Class="Normal">&nbsp;<A NAME="I4517"></A>The recommended level of support 
for the Size attribute of objects is the same as for subtypes (see below), 
except that only a confirming Size clause need be supported for an aliased 
elementary object.&nbsp;</DIV>
<DIV Class="paranum">43/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN STYLE="font-size: 80%"><I>This 
paragraph was deleted.</I></SPAN></LI></UL>

<H4 Class="centered">Static Semantics</H4>
<DIV Class="paranum">44</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">For every subtype S: 
</DIV>
<DIV Class="paranum">45</DIV>
<DIV Class="Hanging-Term" Style="margin-bottom: 0.4em">S'Size</DIV><DIV Class="Hanging-Body">
<A NAME="I4518"></A><A NAME="I4519"></A>If S is definite, denotes the 
size (in bits) that the implementation would choose for the following 
objects of subtype S:&nbsp;</DIV>
<DIV Class="paranum">46</DIV>
<UL Class="IndentedBulleted"><LI TYPE=DISC>A record component of subtype 
S when the record type is packed.</LI></UL>
<DIV Class="paranum">47</DIV>
<UL Class="IndentedBulleted"><LI TYPE=DISC>The formal parameter of an 
instance of Unchecked_Conversion that converts from subtype S to some 
other subtype.&nbsp;</LI></UL>
<DIV Class="paranum">48</DIV>
<DIV Class="Hanging-Body">If S is indefinite, the meaning is implementation 
defined. The value of this attribute is of the type <I>universal_integer</I>. 
<A NAME="I4520"></A><A NAME="I4521"></A>The Size of an object is at least 
as large as that of its subtype, unless the object's Size is determined 
by a Size clause, a component_clause, or a Component_Size clause. Size 
may be specified for first subtypes via an <SPAN Class="swiss"><A HREF="RM-13-3.html#S0286">attribute_definition_clause</A></SPAN>; 
the expression of such a clause shall be static and its value nonnegative. 
</DIV>

<H4 Class="centered">Implementation Requirements</H4>
<DIV Class="paranum">49</DIV>
<DIV Class="Normal">In an implementation, Boolean'Size shall be 1.&nbsp;</DIV>

<H4 Class="centered">Implementation Advice</H4>
<DIV Class="paranum">50/2</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;If the Size of a subtype 
allows for efficient independent addressability (see <A HREF="RM-9-10.html">9.10</A>) 
on the target architecture, then the Size of the following objects of 
the subtype should equal the Size of the subtype:&nbsp;</DIV>
<DIV Class="paranum">51</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>Aliased objects (including components).</LI></UL>
<DIV Class="paranum">52</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>Unaliased components, unless the Size 
of the component is determined by a <SPAN Class="swiss"><A HREF="RM-13-5-1.html#S0290">component_clause</A></SPAN> 
or Component_Size clause.&nbsp;</LI></UL>
<DIV Class="paranum">53</DIV>
<DIV Class="Normal">A Size clause on a composite subtype should not affect 
the internal layout of components.&nbsp;</DIV>
<DIV Class="paranum">54</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em"><A NAME="I4522"></A>The 
recommended level of support for the Size attribute of subtypes is:&nbsp;</DIV>
<DIV Class="paranum">55</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>The Size (if not specified) of a static 
discrete or fixed point subtype should be the number of bits needed to 
represent each value belonging to the subtype using an unbiased representation, 
leaving space for a sign bit only if the subtype contains negative values. 
If such a subtype is a first subtype, then an implementation should support 
a specified Size for it that reflects this representation.</LI></UL>
<DIV Class="paranum">56</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>For a subtype implemented with levels 
of indirection, the Size should include the size of the pointers, but 
not the size of what they point at.&nbsp;</LI></UL>
<DIV Class="paranum">56.1/2</DIV>
<UL Class="Bulleted" Style="margin-bottom: 0.3em"><LI TYPE=DISC>An implementation 
should support a Size clause for a discrete type, fixed point type, record 
type, or array type, subject to the following:&nbsp;</LI></UL>
<DIV Class="paranum">56.2/2</DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>An implementation need not support 
a Size clause for a signed integer type specifying a Size greater than 
that of the largest signed integer type supported by the implementation 
in the absence of a size clause (that is, when the size is chosen by 
default). A corresponding limitation may be imposed for modular integer 
types, fixed point types, enumeration types, record types, and array 
types.</LI></UL>
<DIV Class="paranum">56.3/2</DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>A nonconfirming size clause 
for the first subtype of a derived untagged by-reference type need not 
be supported.&nbsp;</LI></UL>
<DIV Class="NotesHeader">NOTES</DIV>
<DIV Class="paranum">57</DIV>
<DIV Class="Notes">5&nbsp;&nbsp;Size is a subtype-specific attribute.</DIV>
<DIV Class="paranum">58</DIV>
<DIV Class="Notes">6&nbsp;&nbsp;A <SPAN Class="swiss"><A HREF="RM-13-5-1.html#S0290">component_clause</A></SPAN> 
or Component_Size clause can override a specified Size. A <SPAN Class="swiss"><A HREF="RM-2-8.html#S0019">pragma</A></SPAN> 
Pack cannot.&nbsp;</DIV>

<H4 Class="centered">Static Semantics</H4>
<DIV Class="paranum">59/1</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;For a <SPAN Class="swiss"><A HREF="RM-4-1.html#S0093">prefix</A></SPAN> 
T that denotes a task object (after any implicit dereference):&nbsp;</DIV>
<DIV Class="paranum">60</DIV>
<DIV Class="Hanging-Term">T'Storage_Size</DIV><DIV Class="Hanging-Body"><BR clear="left">
<A NAME="I4523"></A><A NAME="I4524"></A>Denotes the number of storage 
elements reserved for the task. The value of this attribute is of the 
type <I>universal_integer</I>. The Storage_Size includes the size of 
the task's stack, if any. The language does not specify whether or not 
it includes other storage associated with the task (such as the &ldquo;task 
control block&rdquo; used by some implementations.) If a <SPAN Class="swiss"><A HREF="RM-2-8.html#S0019">pragma</A></SPAN> 
Storage_Size is given, the value of the Storage_Size attribute is at 
least the value specified in the <SPAN Class="swiss"><A HREF="RM-2-8.html#S0019">pragma</A></SPAN>. 
</DIV>
<DIV Class="paranum">61</DIV>
<DIV Class="Normal"><A NAME="I4525"></A>A <SPAN Class="swiss"><A HREF="RM-2-8.html#S0019">pragma</A></SPAN> 
Storage_Size specifies the amount of storage to be reserved for the execution 
of a task.&nbsp;</DIV>

<H4 Class="centered">Syntax</H4>
<DIV Class="paranum">62</DIV>
<DIV Class="SyntaxIndented" Style="margin-bottom: 0.2em">The form of 
a <SPAN Class="swiss"><A HREF="RM-2-8.html#S0019">pragma</A></SPAN> Storage_Size 
is as follows:&nbsp;</DIV>
<DIV Class="paranum">63</DIV>
<DIV Class="SyntaxIndented">&nbsp;&nbsp;<B>pragma</B> <A NAME="I4526"></A><A NAME="I4527"></A>Storage_Size(<A NAME="I4528"></A><SPAN Class="swiss"><A HREF="RM-4-4.html#S0115">expression</A></SPAN>);</DIV>
<DIV Class="paranum">64</DIV>
<DIV Class="SyntaxIndented">A <SPAN Class="swiss"><A HREF="RM-2-8.html#S0019">pragma</A></SPAN> 
Storage_Size is allowed only immediately within a <SPAN Class="swiss"><A HREF="RM-9-1.html#S0190">task_definition</A></SPAN>. 
</DIV>

<H4 Class="centered">Name Resolution Rules</H4>
<DIV Class="paranum">65</DIV>
<DIV Class="Normal"><A NAME="I4529"></A>The <SPAN Class="swiss"><A HREF="RM-4-4.html#S0115">expression</A></SPAN> 
of a <SPAN Class="swiss"><A HREF="RM-2-8.html#S0019">pragma</A></SPAN> 
Storage_Size is expected to be of any integer type.&nbsp;</DIV>

<H4 Class="centered">Dynamic Semantics</H4>
<DIV Class="paranum">66</DIV>
<DIV Class="Normal">A <SPAN Class="swiss"><A HREF="RM-2-8.html#S0019">pragma</A></SPAN> 
Storage_Size is elaborated when an object of the type defined by the 
immediately enclosing <SPAN Class="swiss"><A HREF="RM-9-1.html#S0190">task_definition</A></SPAN> 
is created. <A NAME="I4530"></A>For the elaboration of a <SPAN Class="swiss"><A HREF="RM-2-8.html#S0019">pragma</A></SPAN> 
Storage_Size, the <SPAN Class="swiss"><A HREF="RM-4-4.html#S0115">expression</A></SPAN> 
is evaluated; the Storage_Size attribute of the newly created task object 
is at least the value of the <SPAN Class="swiss"><A HREF="RM-4-4.html#S0115">expression</A></SPAN>. 
</DIV>
<DIV Class="paranum">67</DIV>
<DIV Class="Normal"><A NAME="I4531"></A><A NAME="I4532"></A><A NAME="I4533"></A>At 
the point of task object creation, or upon task activation, Storage_Error 
is raised if there is insufficient free storage to accommodate the requested 
Storage_Size.&nbsp;</DIV>

<H4 Class="centered">Static Semantics</H4>
<DIV Class="paranum">68/1</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;For a <SPAN Class="swiss"><A HREF="RM-4-1.html#S0093">prefix</A></SPAN> 
X that denotes an array subtype or array object (after any implicit dereference): 
</DIV>
<DIV Class="paranum">69</DIV>
<DIV Class="Hanging-Term">X'Component_Size</DIV><DIV Class="Hanging-Body"><BR clear="left">
<A NAME="I4534"></A><A NAME="I4535"></A>Denotes the size in bits of components 
of the type of X. The value of this attribute is of type <I>universal_integer</I>. 
</DIV>
<DIV Class="paranum">70</DIV>
<DIV Class="Hanging-Body"><A NAME="I4536"></A><A NAME="I4537"></A>Component_Size 
may be specified for array types via an <SPAN Class="swiss"><A HREF="RM-13-3.html#S0286">attribute_definition_clause</A></SPAN>; 
the expression of such a clause shall be static, and its value nonnegative. 
</DIV>

<H4 Class="centered">Implementation Advice</H4>
<DIV Class="paranum">71</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em"><A NAME="I4538"></A>The 
recommended level of support for the Component_Size attribute is:&nbsp;</DIV>
<DIV Class="paranum">72</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>An implementation need not support 
specified Component_Sizes that are less than the Size of the component 
subtype.</LI></UL>
<DIV Class="paranum">73</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>An implementation should support specified 
Component_Sizes that are factors and multiples of the word size. For 
such Component_Sizes, the array should contain no gaps between components. 
For other Component_Sizes (if supported), the array should contain no 
gaps between components when packing is also specified; the implementation 
should forbid this combination in cases where it cannot support a no-gaps 
representation.&nbsp;</LI></UL>

<H4 Class="centered">Static Semantics</H4>
<DIV Class="paranum">73.1/1</DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;The following operational attribute is defined: 
External_Tag.</DIV>
<DIV Class="paranum">74/1</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;For every subtype 
S of a tagged type <I>T</I> (specific or class-wide):</DIV>
<DIV Class="paranum">75/1</DIV>
<DIV Class="Hanging-Term">&nbsp;S'External_Tag</DIV><DIV Class="Hanging-Body"><BR clear="left">
<A NAME="I4539"></A><A NAME="I4540"></A><A NAME="I4541"></A><A NAME="I4542"></A>S'External_Tag 
denotes an external string representation for S'Tag; it is of the predefined 
type String. External_Tag may be specified for a specific tagged type 
via an <SPAN Class="swiss"><A HREF="RM-13-3.html#S0286">attribute_definition_clause</A></SPAN>; 
the expression of such a clause shall be static. The default external 
tag representation is implementation defined. See <A HREF="RM-3-9-2.html">3.9.2</A> 
and <A HREF="RM-13-13-2.html">13.13.2</A>. The value of External_Tag 
is never inherited; the default value is always used unless a new value 
is directly specified for a type.&nbsp;</DIV>

<H4 Class="centered">Implementation Requirements</H4>
<DIV Class="paranum">76</DIV>
<DIV Class="Normal">In an implementation, the default external tag for 
each specific tagged type declared in a partition shall be distinct, 
so long as the type is declared outside an instance of a generic body. 
If the compilation unit in which a given tagged type is declared, and 
all compilation units on which it semantically depends, are the same 
in two different partitions, then the external tag for the type shall 
be the same in the two partitions. What it means for a compilation unit 
to be the same in two different partitions is implementation defined. 
At a minimum, if the compilation unit is not recompiled between building 
the two different partitions that include it, the compilation unit is 
considered the same in the two partitions.&nbsp;</DIV>
<DIV Class="NotesHeader">NOTES</DIV>
<DIV Class="paranum">77/2</DIV>
<DIV Class="Notes">7&nbsp;&nbsp;The following language-defined attributes 
are specifiable, at least for some of the kinds of entities to which 
they apply: Address, Alignment, Bit_Order, Component_Size, External_Tag, 
Input, Machine_Radix, Output, Read, Size, Small, Storage_Pool, Storage_Size, 
Stream_Size, and Write.</DIV>
<DIV Class="paranum">78</DIV>
<DIV Class="Notes">8&nbsp;&nbsp;It follows from the general rules in 
<A HREF="RM-13-1.html">13.1</A> that if one writes &ldquo;<B>for</B> 
X'Size <B>use</B> Y;&rdquo; then the X'Size <SPAN Class="swiss"><A HREF="RM-4-1-4.html#S0100">attribute_reference</A></SPAN> 
will return Y (assuming the implementation allows the Size clause). The 
same is true for all of the specifiable attributes except Storage_Size. 
</DIV>

<H4 Class="centered">Examples</H4>
<DIV Class="paranum">79</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em"><I>Examples of attribute 
definition clauses:</I>&nbsp;</DIV>
<DIV Class="paranum">80</DIV>
<DIV Class="Examples">Byte&nbsp;:&nbsp;<B>constant</B>&nbsp;:=&nbsp;8;<BR>
Page&nbsp;:&nbsp;<B>constant</B>&nbsp;:=&nbsp;2**12;</DIV>
<DIV Class="paranum">81</DIV>
<DIV Class="Examples"><B>type</B>&nbsp;Medium&nbsp;<B>is</B>&nbsp;<B>range</B>&nbsp;0&nbsp;..&nbsp;65_000;<BR>
<B>for</B>&nbsp;Medium'Size&nbsp;<B>use</B>&nbsp;2*Byte;<BR>
<B>for</B>&nbsp;Medium'Alignment&nbsp;<B>use</B>&nbsp;2;<BR>
Device_Register&nbsp;:&nbsp;Medium;<BR>
<B>for</B>&nbsp;Device_Register'Size&nbsp;<B>use</B>&nbsp;Medium'Size;<BR>
<B>for</B>&nbsp;Device_Register'Address&nbsp;<B>use</B>&nbsp;System.Storage_Elements.To_Address(16#FFFF_0020#);</DIV>
<DIV Class="paranum">82</DIV>
<DIV Class="Examples"><B>type</B>&nbsp;Short&nbsp;<B>is</B>&nbsp;<B>delta</B>&nbsp;0.01&nbsp;<B>range</B>&nbsp;-100.0&nbsp;..&nbsp;100.0;<BR>
<B>for</B>&nbsp;Short'Size&nbsp;<B>use</B>&nbsp;15;</DIV>
<DIV Class="paranum">83</DIV>
<DIV Class="Examples"><B>for</B>&nbsp;Car_Name'Storage_Size&nbsp;<B>use</B>&nbsp;--<SPAN Class="roman"><I>&nbsp;specify&nbsp;access&nbsp;type's&nbsp;storage&nbsp;pool&nbsp;size</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2000*((Car'Size/System.Storage_Unit)&nbsp;+1);&nbsp;--<SPAN Class="roman"><I>&nbsp;approximately&nbsp;2000&nbsp;cars</I></SPAN></DIV>
<DIV Class="paranum">84/2</DIV>
<DIV Class="Examples"><B>function</B>&nbsp;My_Input(Stream&nbsp;:&nbsp;<B>not&nbsp;null&nbsp;access</B>&nbsp;Ada.Streams.Root_Stream_Type'Class)<BR>
&nbsp;&nbsp;<B>return</B>&nbsp;T;<BR>
<B>for</B>&nbsp;T'Input&nbsp;<B>use</B>&nbsp;My_Input;&nbsp;--<SPAN Class="roman"><I>&nbsp;see&nbsp;<A HREF="RM-13-13-2.html">13.13.2</A></I></SPAN></DIV>
<DIV Class="NotesHeader">NOTES</DIV>
<DIV Class="paranum">85</DIV>
<DIV Class="Notes">9&nbsp;&nbsp;<I>Notes on the examples:</I> In the 
Size clause for Short, fifteen bits is the minimum necessary, since the 
type definition requires Short'Small &lt;= 2**(&ndash;7).&nbsp;</DIV>

<HR>
<DIV Style="margin-top: 0.0em; margin-bottom: 0.6em"><A HREF="RM-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RM-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RM-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RM-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RM-13-2.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RM-13-4.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<DIV Style="margin-top:0.0em"><IMG SRC="AE_logo.gif" height=100 width=113 align=right ALT="Ada-Europe">
<SPAN Style="vertical-align: middle">Sponsored by <SPAN Style="font-size: 125%"><A HREF="http://www.ada-europe.org/"><B>Ada-Europe</B></A></SPAN></SPAN></DIV>
</BODY>
</HTML>
