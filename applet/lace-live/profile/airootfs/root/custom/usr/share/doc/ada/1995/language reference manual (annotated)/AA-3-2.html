<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Types and Subtypes</TITLE>
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    DIV.paranum {position: absolute; font-family: Arial, Helvetica, sans-serif; left: 0.5em; top: auto}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    DIV.Normal {font-family: "Times New Roman", Times, serif; margin-bottom: 0.6em}
    DIV.Wide {font-family: "Times New Roman", Times, serif; margin-top: 0.6em; margin-bottom: 0.6em}
    DIV.Annotations {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-bottom: 0.6em}
    DIV.WideAnnotations {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-top: 0.6em; margin-bottom: 0.6em}
    DIV.Index {font-family: "Times New Roman", Times, serif}
    DIV.SyntaxSummary {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-bottom: 0.4em}
    DIV.Notes {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-bottom: 0.6em}
    DIV.NotesHeader {font-family: "Times New Roman", Times, serif; margin-left: 2.0em}
    DIV.SyntaxIndented {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-bottom: 0.4em}
    DIV.Indented {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-bottom: 0.6em}
    DIV.CodeIndented {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-bottom: 0.6em}
    DIV.SmallIndented {font-family: "Times New Roman", Times, serif; margin-left:  10.0em; margin-bottom: 0.6em}
    DIV.SmallCodeIndented {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-bottom: 0.6em}
    DIV.Examples {font-family: "Courier New", monospace; margin-left: 2.0em; margin-bottom: 0.6em}
    DIV.SmallExamples {font-family: "Courier New", monospace; font-size: 80%; margin-left: 7.5em; margin-bottom: 0.6em}
    DIV.IndentedExamples {font-family: "Courier New", monospace; margin-left: 8.0em; margin-bottom: 0.6em}
    DIV.SmallIndentedExamples {font-family: "Courier New", monospace; font-size: 80%; margin-left:  15.0em; margin-bottom: 0.6em}
    UL.Bulleted {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.SmallBulleted {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.NestedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-right: 4.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.SmallNestedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-right: 8.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.IndentedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-right: 8.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.CodeIndentedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.CodeIndentedNestedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-right: 8.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.SyntaxIndentedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-right: 4.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.NotesBulleted {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-right: 4.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.NotesNestedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    DL.Hanging {font-family: "Times New Roman", Times, serif; margin-top: 0em; margin-bottom: 0.6em}
    DD.Hanging {margin-left: 6.0em}
    DL.IndentedHanging {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-top: 0em; margin-bottom: 0.6em}
    DD.IndentedHanging {margin-left: 2.0em}
    DL.HangingInBulleted {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    DD.HangingInBulleted {margin-left: 4.0em}
    DL.SmallHanging {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-top: 0em; margin-bottom: 0.6em}
    DD.SmallHanging {margin-left: 7.5em}
    DL.SmallIndentedHanging {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-top: 0em; margin-bottom: 0.6em}
    DD.SmallIndentedHanging {margin-left: 2.0em}
    DL.SmallHangingInBulleted {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    DD.SmallHangingInBulleted {margin-left: 5.0em}
    DL.Enumerated {font-family: "Times New Roman", Times, serif; margin-right: 0.0em; margin-top: 0em; margin-bottom: 0.5em}
    DD.Enumerated {margin-left: 2.0em}
    DL.SmallEnumerated {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-right: 4.0em; margin-top: 0em; margin-bottom: 0.5em}
    DD.SmallEnumerated {margin-left: 2.5em}
    DL.NestedEnumerated {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    DL.SmallNestedEnumerated {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">
<P><A HREF="AA-TOC.html">Contents</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-0-29.html">Index</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-SRCH.html">Search</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-3-1.html">Previous</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-3-2-1.html">Next</A></P>
<HR>
<H1> 3.2 Types and Subtypes</H1>

<H4 ALIGN=CENTER>Static Semantics</H4>
<DIV Class="Paranum"><FONT SIZE=-2>1</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>type</I>}</FONT> <A NAME="I1336"></A><FONT SIZE="-1">{<I>primitive
operation</I> [partial]}</FONT> <A NAME="I1337"></A>A <I>type</I> is
characterized by a set of values, and a set of <I>primitive operations</I>
which implement the fundamental aspects of its semantics. <FONT SIZE="-1">{<I>object</I>
[partial]}</FONT> <A NAME="I1338"></A>An <I>object</I> of a given type
is a run-time entity that contains (has) a value of the type. </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>1.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Glossary entry: </B>{<I>Type</I>}
Each object has a type. A <I>type</I> has an associated set of values,
and a set of <I>primitive operations</I> which implement the fundamental
aspects of its semantics. Types are grouped into <I>classes</I>. The
types of a given class share a set of primitive operations. {<I>closed
under derivation</I>} <A NAME="I1339"></A>Classes are closed under derivation;
that is, if a type is in a class, then all of its derivatives are in
that class.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>1.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Glossary entry: </B>{<I>Subtype</I>}
A subtype is a type together with a constraint, which constrains the
values of the subtype to satisfy a certain condition. The values of a
subtype are a subset of the values of its type.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>2</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>class (of types)</I>}</FONT>
<A NAME="I1340"></A>Types are grouped into <I>classes</I> of types, reflecting
the similarity of their values and primitive operations. <FONT SIZE="-1">{<I>language-defined
class (of types)</I>}</FONT> <A NAME="I1341"></A>There exist several
<I>language-defined classes</I> of types (see NOTES below). <FONT SIZE="-1">{<I>elementary
type</I>}</FONT> <A NAME="I1342"></A><I>Elementary</I> types are those
whose values are logically indivisible; <FONT SIZE="-1">{<I>composite
type</I>}</FONT> <A NAME="I1343"></A><FONT SIZE="-1">{<I>component</I>}</FONT>
<A NAME="I1344"></A><I>composite</I> types are those whose values are
composed of <I>component</I> values. <FONT SIZE="-1">{<I>aggregate: See
also composite type</I>}</FONT> <A NAME="I1345"></A></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>2.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Glossary entry: </B>{<I>Class</I>}
{<I>closed under derivation</I>} <A NAME="I1346"></A>A class is a set
of types that is closed under derivation, which means that if a given
type is in the class, then all types derived from that type are also
in the class. The set of types of a class share common properties, such
as their primitive operations.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>2.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Glossary entry: </B>{<I>Elementary
type</I>} An elementary type does not have components.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>2.c</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Glossary entry: </B>{<I>Composite
type</I>} A composite type has components.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>2.d</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Glossary entry: </B>{<I>Scalar
type</I>} A scalar type is either a discrete type or a real type.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>2.e</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Glossary entry: </B>{<I>Access
type</I>} An access type has values that designate aliased objects. Access
types correspond to ``pointer types'' or ``reference types'' in some
other languages.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>2.f</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Glossary entry: </B>{<I>Discrete
type</I>} A discrete type is either an integer type or an enumeration
type. Discrete types may be used, for example, in <FONT FACE="Arial, Helvetica">case_statement</FONT>s
and as array indices.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>2.g</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Glossary entry: </B>{<I>Real
type</I>} A real type has values that are approximations of the real
numbers. Floating point and fixed point types are real types.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>2.h</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Glossary entry: </B>{<I>Integer
type</I>} Integer types comprise the signed integer types and the modular
types. A signed integer type has a base range that includes both positive
and negative numbers, and has operations that may raise an exception
when the result is outside the base range. A modular type has a base
range whose lower bound is zero, and has operations with ``wraparound''
semantics. Modular types subsume what are called ``unsigned types'' in
some other languages.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>2.i</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Glossary entry: </B>{<I>Enumeration
type</I>} An enumeration type is defined by an enumeration of its values,
which may be named by identifiers or character literals.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>2.j</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Glossary entry: </B>{<I>Character
type</I>} A character type is an enumeration type whose values include
characters.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>2.k</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Glossary entry: </B>{<I>Record
type</I>} A record type is a composite type consisting of zero or more
named components, possibly of different types.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>2.l</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Glossary entry: </B>{<I>Record
extension</I>} A record extension is a type that extends another type
by adding additional components.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>2.m</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Glossary entry: </B>{<I>Array
type</I>} An array type is a composite type whose components are all
of the same type. Components are selected by indexing.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>2.n</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Glossary entry: </B>{<I>Task
type</I>} A task type is a composite type whose values are tasks, which
are active entities that may execute concurrently with other tasks. The
top-level task of a partition is called the environment task.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>2.o</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Glossary entry: </B>{<I>Protected
type</I>} A protected type is a composite type whose components are protected
from concurrent access by multiple tasks.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>2.p</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Glossary entry: </B>{<I>Private
type</I>} A private type is a partial view of a type whose full view
is hidden from its clients.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>2.q</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Glossary entry: </B>{<I>Private
extension</I>} A private extension is like a record extension, except
that the components of the extension part are hidden from its clients.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>3</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>scalar type</I>}</FONT> <A NAME="I1347"></A>The
elementary types are the <I>scalar</I> types (<I>discrete</I> and <I>real</I>)
and the <I>access</I> types (whose values provide access to objects or
subprograms). <FONT SIZE="-1">{<I>discrete type</I>}</FONT> <A NAME="I1348"></A><FONT SIZE="-1">{<I>enumeration
type</I>}</FONT> <A NAME="I1349"></A>Discrete types are either <I>integer</I>
types or are defined by enumeration of their values (<I>enumeration</I>
types). <FONT SIZE="-1">{<I>real type</I>}</FONT> <A NAME="I1350"></A>Real
types are either <I>floating point</I> types or <I>fixed point</I> types.</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>4</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;The composite types are the <I>record</I> types,
<I>record extensions</I>, <I>array</I> types, <I>task</I> types, and
<I>protected</I> types. <FONT SIZE="-1">{<I>private type</I>}</FONT>
<A NAME="I1351"></A><FONT SIZE="-1">{<I>private extension</I>}</FONT>
<A NAME="I1352"></A>A <I>private</I> type or <I>private extension</I>
represents a partial view (see <A HREF="AA-7-3.html">7.3</A>) of a type,
providing support for data abstraction. A partial view is a composite
type. </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>4.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>To be honest: </B>The set
of all record types do not form a class (because tagged record types
can have private extensions), though the set of untagged record types
do. In any case, what record types had in common in Ada 83 (component
selection) is now a property of the composite class, since all composite
types (other than array types) can have discriminants. Similarly, the
set of all private types do not form a class (because tagged private
types can have record extensions), though the set of untagged private
types do. Nevertheless, the set of untagged private types is not particularly
``interesting'' -- more interesting is the set of all nonlimited types,
since that is what a generic formal (nonlimited) private type matches.
</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>5</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>discriminant</I>}</FONT> <A NAME="I1353"></A>Certain
composite types (and partial views thereof) have special components called
<I>discriminants</I> whose values affect the presence, constraints, or
initialization of other components. Discriminants can be thought of as
parameters of the type.</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>6</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>subcomponent</I>}</FONT> <A NAME="I1354"></A>The
term <I>subcomponent</I> is used in this International Standard in place
of the term component to indicate either a component, or a component
of another subcomponent. Where other subcomponents are excluded, the
term component is used instead. <FONT SIZE="-1">{<I>part (of an object
or value)</I>}</FONT> <A NAME="I1355"></A>Similarly, a <I>part</I> of
an object or value is used to mean the whole object or value, or any
set of its subcomponents. </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>6.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Discussion: </B>The definition
of ``part'' here is designed to simplify rules elsewhere. By design,
the intuitive meaning of ``part'' will convey the correct result to the
casual reader, while this formalistic definition will answer the concern
of the compiler-writer.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>6.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">We use the term ``part'' when
talking about the parent part, ancestor part, or extension part of a
type extension. In contexts such as these, the part might represent an
empty set of subcomponents (e.g. in a null record extension, or a nonnull
extension of a null record). We also use ``part'' when specifying rules
such as those that apply to an object with a ``controlled part'' meaning
that it applies if the object as a whole is controlled, or any subcomponent
is. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>7</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>constraint</I> [partial]}</FONT>
<A NAME="I1356"></A>The set of possible values for an object of a given
type can be subjected to a condition that is called a <I>constraint</I>
<FONT SIZE="-1">{<I>null constraint</I>}</FONT> <A NAME="I1357"></A>(the
case of a <I>null constraint</I> that specifies no restriction is also
included)[; the rules for which values satisfy a given kind of constraint
are given in <A HREF="AA-3-5.html">3.5</A> for <FONT FACE="Arial, Helvetica">range_constraint</FONT>s,
<A HREF="AA-3-6-1.html">3.6.1</A> for <FONT FACE="Arial, Helvetica">index_constraint</FONT>s,
and <A HREF="AA-3-7-1.html">3.7.1</A> for <FONT FACE="Arial, Helvetica">discriminant_constraint</FONT>s].</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>8</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>subtype</I>}</FONT> <A NAME="I1358"></A>A
<I>subtype</I> of a given type is a combination of the type, a constraint
on values of the type, and certain attributes specific to the subtype.
The given type is called the type <I>of</I> the subtype. Similarly, the
associated constraint is called the constraint <I>of</I> the subtype.
The set of values of a subtype consists of the values of its type that
satisfy its constraint. <FONT SIZE="-1">{<I>belong (to a subtype)</I>}</FONT>
<A NAME="I1359"></A>Such values <I>belong</I> to the subtype. </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>8.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Discussion: </B>We make a
strong distinction between a type and its subtypes. In particular, a
type is <I>not</I> a subtype of itself. There is no constraint associated
with a type (not even a null one), and type-related attributes are distinct
from subtype-specific attributes. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>8.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Discussion: </B>We no longer
use the term &quot;base type.&quot; All types were &quot;base types&quot;
anyway in Ada 83, so the term was redundant, and occasionally confusing.
In the RM95 we say simply &quot;the type <I>of</I> the subtype&quot;
instead of &quot;the base type of the subtype.&quot; </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>8.c</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>The value
subset for a subtype might be empty, and need not be a proper subset.
</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>8.d</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>To be honest: </B>Any name
of a class of types (such as ``discrete'' or ``real''), or other category
of types (such as ``limited'' or ``incomplete'') is also used to qualify
its subtypes, as well as its objects, values, declarations, and definitions,
such as an ``integer type declaration'' or an ``integer value.'' In addition,
if a term such as ``parent subtype'' or ``index subtype'' is defined,
then the corresponding term for the type of the subtype is ``parent type''
or ``index type.'' </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>8.e</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Discussion: </B>We use these
corresponding terms without explicitly defining them, when the meaning
is obvious. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>9</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>constrained</I>}</FONT> <A NAME="I1360"></A><FONT SIZE="-1">{<I>unconstrained</I>}</FONT>
<A NAME="I1361"></A><FONT SIZE="-1">{<I>constrained (subtype)</I>}</FONT>
<A NAME="I1362"></A><FONT SIZE="-1">{<I>unconstrained (subtype)</I>}</FONT>
<A NAME="I1363"></A>A subtype is called an <I>unconstrained</I> subtype
if its type has unknown discriminants, or if its type allows range, index,
or discriminant constraints, but the subtype does not impose such a constraint;
otherwise, the subtype is called a <I>constrained</I> subtype (since
it has no unconstrained characteristics). </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>9.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Discussion: </B>In an earlier
version of Ada 9X, &quot;constrained&quot; meant &quot;has a non-null
constraint.&quot; However, we changed to this definition since we kept
having to special case composite non-array/non-discriminated types. It
also corresponds better to the (now obsolescent) attribute 'Constrained.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>9.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">For scalar types, ``constrained''
means ``has a non-null constraint''. For composite types, in implementation
terms, ``constrained'' means that the size of all objects of the subtype
is the same, assuming a typical implementation model.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>9.c</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">Class-wide subtypes are always
unconstrained. </FONT></DIV>
<DIV Class="NotesHeader"><FONT SIZE="-1">NOTES</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>10</FONT></DIV>
<DIV Class="Notes"><FONT SIZE="-1">2&nbsp;&nbsp;Any set of types that
is closed under derivation (see <A HREF="AA-3-4.html">3.4</A>) can be
called a ``class'' of types. However, only certain classes are used in
the description of the rules of the language -- generally those that
have their own particular set of primitive operations (see <A HREF="AA-3-2-3.html">3.2.3</A>),
or that correspond to a set of types that are matched by a given kind
of generic formal type (see <A HREF="AA-12-5.html">12.5</A>). <FONT SIZE="-1">{<I>language-defined
class</I> [partial]}</FONT> <A NAME="I1364"></A>The following are examples
of ``interesting'' <I>language-defined classes</I>: elementary, scalar,
discrete, enumeration, character, boolean, integer, signed integer, modular,
real, floating point, fixed point, ordinary fixed point, decimal fixed
point, numeric, access, access-to-object, access-to-subprogram, composite,
array, string, (untagged) record, tagged, task, protected, nonlimited.
Special syntax is provided to define types in each of these classes.
</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>10.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Discussion: </B>{<I>value</I>}
<A NAME="I1365"></A>A <I>value</I> is a run-time entity with a given
type which can be assigned to an object of an appropriate subtype of
the type. {<I>operation</I>} <A NAME="I1366"></A>An <I>operation</I>
is a program entity that operates on zero or more operands to produce
an effect, or yield a result, or both. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>10.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>Note that
a type's class depends on the place of the reference -- a private type
is composite outside and possibly elementary inside. It's really the
<I>view</I> that is elementary or composite. Note that although private
types are composite, there are some properties that depend on the corresponding
full view -- for example, parameter passing modes, and the constraint
checks that apply in various places.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>10.c</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">Not every property of types
represents a class. For example, the set of all abstract types does not
form a class, because this set is not closed under derivation.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>10.d</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">The set of limited types forms
a class in the sense that it is closed under derivation, but the more
interesting class, from the point of generic formal type matching, is
the set of all types, limited and nonlimited, since that is what matches
a generic formal ``limited'' private type. Note also that a limited type
can ``become nonlimited'' under certain circumstances, which makes ``limited''
somewhat problematic as a class of types. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>11</FONT></DIV>
<DIV Class="Notes"><FONT SIZE="-1">These language-defined classes are
organized like this: </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>12</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">all&nbsp;types<BR>
&nbsp;&nbsp;&nbsp;elementary<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scalar<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;discrete<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enumeration<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;character<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;other&nbsp;enumeration<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;integer<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signed&nbsp;integer<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;modular&nbsp;integer<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;floating&nbsp;point<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fixed&nbsp;point<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ordinary&nbsp;fixed&nbsp;point<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decimal&nbsp;fixed&nbsp;point<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;access<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;access-to-object<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;access-to-subprogram<BR>
&nbsp;&nbsp;&nbsp;composite<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;other&nbsp;array<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;untagged&nbsp;record<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tagged<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;task<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;protected</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>13</FONT></DIV>
<DIV Class="Notes"><FONT SIZE="-1">The classes ``numeric'' and ``nonlimited''
represent other classification dimensions and do not fit into the above
strictly hierarchical picture. </FONT></DIV>

<H4 ALIGN=CENTER>Wording Changes from Ada 83</H4>
<DIV Class="Paranum"><FONT SIZE=-2>13.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">This clause and its subclauses
now precede the clause and subclauses on objects and named numbers, to
cut down on the number of forward references.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>13.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">We have dropped the term &quot;base
type&quot; in favor of simply &quot;type&quot; (all types in Ada 83 were
&quot;base types&quot; so it wasn't clear when it was appropriate/necessary
to say &quot;base type&quot;). Given a subtype S of a type T, we call
T the &quot;type of the subtype S.&quot; </FONT></DIV>

<HR>
<P><A HREF="AA-TOC.html">Contents</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-0-29.html">Index</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-SRCH.html">Search</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-3-1.html">Previous</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-3-2-1.html">Next</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-TTL.html">Legal</A></P>
</BODY>
</HTML>
