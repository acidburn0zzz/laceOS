<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Derivation Classes</TITLE>
    <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    H4.centered {text-align: center}
    SPAN.swiss {font-family: Arial, Helvetica, sans-serif; font-size: 92%}
    SPAN.roman {font-family: "Times New Roman", Times, serif}
    DIV.paranum {float: left; font-family: Arial, Helvetica, sans-serif; font-size: 64%; width: 2.8em; margin-left: -0.4em; margin-right: -3.0em; margin-top: 0.2em}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    SPAN.insert2 {text-decoration: underline; color: rgb(0,102,0) }
    SPAN.delete2 {text-decoration: line-through; color: rgb(0,102,0) }
    DIV.Normal {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.2em; margin-bottom: 0.6em}
    DIV.Annotations {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 6.2em; margin-bottom: 0.6em}
    DIV.Notes {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em; margin-bottom: 0.6em}
    DIV.NotesHeader {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em}
    UL.SmallBulleted {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 8.7em; margin-right: 2.5em; margin-top: 0em; margin-bottom: 0.5em}
    DIV.Hanging-Body {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 7.2em; margin-top: 0em; margin-bottom: 0.6em}
    DIV.Hanging-Term {float: left; font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.2em; margin-top: 0em; margin-bottom: 0em}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#000080" VLINK="#330033" ALINK="#0000FF">
<DIV><B><SPAN Style="font-size:200%; color: rgb(0,51,153)">Annotated</SPAN><SPAN Style="font-size:200%; color: rgb(0,0,102)">&nbsp;Ada Reference Manual</SPAN></B> &mdash; <A HREF="AA-TTL.html"><B>Legal Information</B></A></DIV>
<DIV Style="margin-top: 0.6em; margin-bottom: 0.0em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-3-4.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-3-5.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<HR>
<H1>3.4.1 Derivation Classes</H1>
<DIV Class="paranum">1</DIV>
<DIV Class="Normal">In addition to the various language-defined classes 
of types, types can be grouped into <I>derivation classes</I>.&nbsp;</DIV>

<H4 Class="centered">Static Semantics</H4>
<DIV Class="paranum">2/2</DIV>
<DIV Class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00401.TXT">AI95-00401-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>derived from (directly or indirectly)</I>}</SPAN> 
<A NAME="I1626"></A>A derived type is <I>derived from</I> its parent 
type <I>directly</I>; it is derived <I>indirectly</I> from any type from 
which its parent type is derived.<SPAN class="insert2">&nbsp;A derived type, 
interface type, type extension, task type, protected type, or formal 
derived type is also derived from every ancestor of each of its progenitor 
types, if any.</SPAN> <SPAN STYLE="font-size: 80%">{<I>derivation class 
(for a type)</I>}</SPAN> <A NAME="I1627"></A><SPAN STYLE="font-size: 80%">{<I>root 
type (of a class)</I>}</SPAN> <A NAME="I1628"></A><SPAN STYLE="font-size: 80%">{<I>rooted 
at a type</I>}</SPAN> <A NAME="I1629"></A>The derivation class of types 
for a type <I>T</I> (also called the class <I>rooted</I> at <I>T</I>) 
is the set consisting of <I>T</I> (the <I>root type</I> of the class) 
and all types derived from <I>T</I> (directly or indirectly) plus any 
associated universal or class-wide types (defined below).&nbsp;</DIV>
<DIV Class="paranum">2.a</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>Note that the definition 
of &ldquo;derived from&rdquo; is a recursive definition. We don't define 
a root type for all interesting language-defined classes, though presumably 
we could.&nbsp;</DIV>
<DIV Class="paranum">2.b</DIV>
<DIV Class="Annotations"><B>To be honest:&nbsp;</B>By the class-wide type 
&ldquo;associated&rdquo; with a type <I>T</I>, we mean the type <I>T</I>'Class. 
Similarly, the universal type associated with <I>root_integer</I>, <I>root_real</I>, 
and <I>root_fixed</I> are <I>universal_integer</I>, <I>universal_real</I>, 
and <I>universal_fixed</I>, respectively.&nbsp;</DIV>
<DIV Class="paranum">3/2</DIV>
<DIV Class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00230.TXT">AI95-00230-01</A></I>} 
Every type is either a <I>specific</I> type, a <I>class-wide</I> type, 
or a <I>universal</I> type. <SPAN STYLE="font-size: 80%">{<I>specific 
type</I>}</SPAN> <A NAME="I1630"></A>A specific type is one defined by 
a <SPAN Class="swiss"><A HREF="AA-3-2-1.html#S0023">type_declaration</A></SPAN>, 
a <SPAN Class="swiss"><A HREF="AA-12-5.html#S0262">formal_type_declaration</A></SPAN>, 
or a full type definition embedded in <SPAN class="insert2">another construct</SPAN><SPAN class="delete2">&nbsp;a 
declaration for an object</SPAN>. Class-wide and universal types are 
implicitly defined, to act as representatives for an entire class of 
types, as follows:&nbsp;</DIV>
<DIV Class="paranum">3.a</DIV>
<DIV Class="Annotations"><B>To be honest:&nbsp;</B>The root types <I>root_integer</I>, 
<I>root_real</I>, and <I>root_fixed</I> are also specific types. They 
are declared in the specification of package Standard.&nbsp;</DIV>
<DIV Class="paranum">4</DIV>
<DIV Class="Hanging-Term"><SPAN STYLE="font-size: 80%">{<I>class-wide 
type</I>}</SPAN> <A NAME="I1631"></A>Class-wide types&nbsp;</DIV><DIV Class="Hanging-Body"><BR clear="left">
Class-wide types are defined for [(and belong to)] each derivation class 
rooted at a tagged type (see <A HREF="AA-3-9.html">3.9</A>). Given a 
subtype S of a tagged type <I>T</I>, S'Class is the <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0028">subtype_mark</A></SPAN> 
for a corresponding subtype of the tagged class-wide type <I>T</I>'Class. 
Such types are called &ldquo;class-wide&rdquo; because when a formal 
parameter is defined to be of a class-wide type <I>T</I>'Class, an actual 
parameter of any type in the derivation class rooted at <I>T</I> is acceptable 
(see <A HREF="AA-8-6.html">8.6</A>).</DIV>
<DIV Class="paranum">5</DIV>
<DIV Class="Hanging-Body"><SPAN STYLE="font-size: 80%">{<I>first subtype</I>}</SPAN> 
<A NAME="I1632"></A>The set of values for a class-wide type <I>T</I>'Class 
is the discriminated union of the set of values of each specific type 
in the derivation class rooted at <I>T</I> (the tag acts as the implicit 
discriminant &mdash; see <A HREF="AA-3-9.html">3.9</A>). Class-wide types 
have no primitive subprograms of their own. However, as explained in 
<A HREF="AA-3-9-2.html">3.9.2</A>, operands of a class-wide type <I>T</I>'Class 
can be used as part of a dispatching call on a primitive subprogram of 
the type <I>T</I>. The only components [(including discriminants)] of 
<I>T</I>'Class that are visible are those of <I>T</I>. If S is a first 
subtype, then S'Class is a first subtype.&nbsp;</DIV>
<DIV Class="paranum">5.a</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>We want S'Class to be a first 
subtype when S is, so that an <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN> 
like &ldquo;<B>for</B> S'Class'Output <B>use</B> ...;&rdquo; will be 
legal.&nbsp;</DIV>
<DIV Class="paranum">6/2</DIV>
<DIV Class="Hanging-Term">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00230.TXT">AI95-00230-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>universal type</I>}</SPAN> <A NAME="I1633"></A>Universal 
types&nbsp;</DIV><DIV Class="Hanging-Body"><BR clear="left">
Universal types are defined for [(and belong to)] the integer, real, 
<SPAN class="delete2">and&nbsp;</SPAN>fixed point<SPAN class="insert2">, and 
access</SPAN> classes, and are referred to in this standard as respectively, 
<I>universal_integer</I>, <I>universal_real</I>, <SPAN class="delete2">and 
</SPAN><I>universal_fixed</I><SPAN class="insert2">, and <I>universal_access</I></SPAN>. 
These are analogous to class-wide types for these language-defined <SPAN class="insert2">elementary</SPAN><SPAN class="delete2">&nbsp;numeric</SPAN> 
classes. As with class-wide types, if a formal parameter is of a universal 
type, then an actual parameter of any type in the corresponding class 
is acceptable. In addition, a value of a universal type (including an 
integer or real <SPAN Class="swiss"><A HREF="AA-2-4.html#S0006">numeric_literal</A></SPAN><SPAN class="insert2">, 
or the literal <B>null</B></SPAN>) is &ldquo;universal&rdquo; in that 
it is acceptable where some particular type in the class is expected 
(see <A HREF="AA-8-6.html">8.6</A>).</DIV>
<DIV Class="paranum">7</DIV>
<DIV Class="Hanging-Body">The set of values of a universal type is the 
undiscriminated union of the set of values possible for any definable 
type in the associated class. Like class-wide types, universal types 
have no primitive subprograms of their own. However, their &ldquo;universality&rdquo; 
allows them to be used as operands with the primitive subprograms of 
any type in the corresponding class.&nbsp;</DIV>
<DIV Class="paranum">7.a</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>A class-wide type is only 
class-wide in one direction, from specific to class-wide, whereas a universal 
type is class-wide (universal) in both directions, from specific to universal 
and back.</DIV>
<DIV Class="paranum">7.b/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00230.TXT">AI95-00230-01</A></I>} 
We considered defining class-wide or perhaps universal types for all 
derivation classes, not just tagged classes and these <SPAN class="insert2">four 
elementary</SPAN><SPAN class="delete2">&nbsp;three numeric</SPAN> classes. 
However, this was felt to overly weaken the strong-typing model in some 
situations. Tagged types preserve strong type distinctions thanks to 
the run-time tag. Class-wide or universal types for untagged types would 
weaken the compile-time type distinctions without providing a compensating 
run-time-checkable distinction.</DIV>
<DIV Class="paranum">7.c</DIV>
<DIV Class="Annotations">We considered defining standard names for the 
universal numeric types so they could be used in formal parameter specifications. 
However, this was felt to impose an undue implementation burden for some 
implementations.&nbsp;</DIV>
<DIV Class="paranum">7.d</DIV>
<DIV Class="Annotations"><B>To be honest:&nbsp;</B>Formally, the set of values 
of a universal type is actually a <I>copy</I> of the undiscriminated 
union of the values of the types in its class. This is because we want 
each value to have exactly one type, with explicit or implicit conversion 
needed to go between types. An alternative, consistent model would be 
to associate a class, rather than a particular type, with a value, even 
though any given expression would have a particular type. In that case, 
implicit type conversions would not generally need to change the value, 
although an associated subtype conversion might need to.&nbsp;</DIV>
<DIV Class="paranum">8</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>root_integer</I> 
[partial]}</SPAN> <A NAME="I1634"></A><SPAN STYLE="font-size: 80%">{<I>root_real</I> 
[partial]}</SPAN> <A NAME="I1635"></A>The integer and real numeric classes 
each have a specific root type in addition to their universal type, named 
respectively <I>root_integer</I> and <I>root_real</I>.</DIV>
<DIV Class="paranum">9</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>cover (a type)</I>}</SPAN> 
<A NAME="I1636"></A>A class-wide or universal type is said to <I>cover</I> 
all of the types in its class. A specific type covers only itself.</DIV>
<DIV Class="paranum">10/2</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00230.TXT">AI95-00230-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>descendant (of a type)</I>}</SPAN> <A NAME="I1637"></A>A 
specific type <I>T2</I> is defined to be a <I>descendant</I> of a type 
<I>T1</I> if <I>T2</I> is the same as <I>T1</I>, or if <I>T2</I> is derived 
(directly or indirectly) from <I>T1</I>. A class-wide type <I>T2</I>'Class 
is defined to be a descendant of type <I>T1</I> if <I>T2</I> is a descendant 
of <I>T1</I>. Similarly, the <SPAN class="insert2">numeric&nbsp;</SPAN>universal 
types are defined to be descendants of the root types of their classes. 
<SPAN STYLE="font-size: 80%">{<I>ancestor (of a type)</I>}</SPAN> <A NAME="I1638"></A>If 
a type <I>T2</I> is a descendant of a type <I>T1</I>, then <I>T1</I> 
is called an <I>ancestor</I> of <I>T2</I>. <SPAN STYLE="font-size: 80%">{<I>ultimate 
ancestor (of a type)</I>}</SPAN> <A NAME="I1639"></A><SPAN STYLE="font-size: 80%">{<I>ancestor 
(ultimate)</I>}</SPAN> <A NAME="I1640"></A><SPAN class="insert2">An</SPAN><SPAN class="delete2">&nbsp;The</SPAN> 
<I>ultimate ancestor</I> of a type is <SPAN class="insert2">an</SPAN><SPAN class="delete2">&nbsp;the</SPAN> 
ancestor of <SPAN class="insert2">that</SPAN><SPAN class="delete2">&nbsp;the</SPAN> 
type that is not <SPAN class="insert2">itself&nbsp;</SPAN>a descendant of 
any other type.<SPAN class="insert2">&nbsp;Every untagged type has a unique 
ultimate ancestor.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">10.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>A specific type is a descendant 
of itself. Class-wide types are considered descendants of the corresponding 
specific type, and do not have any descendants of their own.</DIV>
<DIV Class="paranum">10.b</DIV>
<DIV Class="Annotations">A specific type is an ancestor of itself. The 
root of a derivation class is an ancestor of all types in the class, 
including any class-wide types in the class.&nbsp;</DIV>
<DIV Class="paranum">10.c</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><B>Discussion: 
</B>The terms root, parent, ancestor, and ultimate ancestor are all related. 
For example:&nbsp;</DIV>
<DIV Class="paranum">10.d/2</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
Each type has at most one parent, and one or more ancestor types; each 
<SPAN class="insert2">untagged&nbsp;</SPAN>type has exactly one ultimate ancestor. 
In Ada 83, the term &ldquo;parent type&rdquo; was sometimes used more 
generally to include any ancestor type (e.g. RM83-9.4(14)). In Ada 95, 
we restrict parent to mean the immediate ancestor.</LI></UL>
<DIV Class="paranum">10.e</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>A class of types has at most 
one root type; a derivation class has exactly one root type.</LI></UL>
<DIV Class="paranum">10.f</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>The root of a class is an ancestor 
of all of the types in the class (including itself).</LI></UL>
<DIV Class="paranum">10.g</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>The type <I>root_integer</I> 
is the root of the integer class, and is the ultimate ancestor of all 
integer types. A similar statement applies to <I>root_real</I>.&nbsp;</LI></UL>
<DIV Class="paranum">10.h/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Glossary entry:&nbsp;</B>{<I>Ancestor</I>} 
An ancestor of a type is the type itself or, in the case of a type derived 
from other types, its parent type or one of its progenitor types or one 
of their ancestors. Note that ancestor and descendant are inverse relationships.</SPAN></DIV>
<DIV Class="paranum">10.i/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Glossary entry:&nbsp;</B>{<I>Descendant</I>} 
A type is a descendant of itself, its parent and progenitor types, and 
their ancestors. Note that descendant and ancestor are inverse relationships.</SPAN></DIV>
<DIV Class="paranum">11</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>inherited (from 
an ancestor type)</I>}</SPAN> <A NAME="I1641"></A>An inherited component 
[(including an inherited discriminant)] of a derived type is inherited 
<I>from</I> a given ancestor of the type if the corresponding component 
was inherited by each derived type in the chain of derivations going 
back to the given ancestor.</DIV>
<DIV Class="NotesHeader">NOTES</DIV>
<DIV Class="paranum">12</DIV>
<DIV Class="Notes">20&nbsp;&nbsp;Because operands of a universal type 
are acceptable to the predefined operators of any type in their class, 
ambiguity can result. For <I>universal_integer</I> and <I>universal_real</I>, 
this potential ambiguity is resolved by giving a preference (see <A HREF="AA-8-6.html">8.6</A>) 
to the predefined operators of the corresponding root types (<I>root_integer</I> 
and <I>root_real</I>, respectively). Hence, in an apparently ambiguous 
expression like&nbsp;</DIV>
<DIV Class="paranum">13</DIV>
<DIV Class="Annotations">1&nbsp;+&nbsp;4&nbsp;&lt;&nbsp;7</DIV>
<DIV Class="paranum">14</DIV>
<DIV Class="Notes">where each of the literals is of type <I>universal_integer</I>, 
the predefined operators of <I>root_integer</I> will be preferred over 
those of other specific integer types, thereby resolving the ambiguity. 
</DIV>
<DIV Class="paranum">14.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>Except for this preference, 
a root numeric type is essentially like any other specific type in the 
associated numeric class. In particular, the result of a predefined operator 
of a root numeric type is not &ldquo;universal&rdquo; (implicitly convertible) 
even if both operands were.&nbsp;</DIV>

<H4 Class="centered">Wording Changes from Ada 95</H4>
<DIV Class="paranum">14.b/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00230.TXT">AI95-00230-01</A></I>} 
<SPAN class="insert2">Updated the wording to define the <I>universal_access</I> 
type. This was defined to make <B>null</B> for anonymous access types 
sensible.</SPAN></DIV>
<DIV Class="paranum">14.c/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00401.TXT">AI95-00401-01</A></I>} 
<SPAN class="insert2">The definitions of ancestors and descendants were 
updated to allow multiple ancestors (necessary to support interfaces).</SPAN> 
</DIV>

<HR>
<DIV Style="margin-top: 0.0em; margin-bottom: 0.6em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-3-4.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-3-5.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<DIV Style="margin-top:0.0em"><IMG SRC="AE_logo.gif" height=100 width=113 align=right ALT="Ada-Europe">
<SPAN Style="font-size: 125%">Sponsored by <SPAN Style="font-size: 125%"><A HREF="http://www.ada-europe.org/"><B>Ada-Europe</B></A></SPAN></SPAN></DIV>
</BODY>
</HTML>
