<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Elaboration Control</TITLE>
    <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    H4.centered {text-align: center}
    SPAN.swiss {font-family: Arial, Helvetica, sans-serif; font-size: 92%}
    SPAN.roman {font-family: "Times New Roman", Times, serif}
    DIV.paranum {float: left; font-family: Arial, Helvetica, sans-serif; font-size: 64%; width: 2.8em; margin-left: -0.4em; margin-right: -3.0em; margin-top: 0.2em}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    SPAN.insert4 {text-decoration: underline; color: rgb(153,0,0) }
    SPAN.delete4 {text-decoration: line-through; color: rgb(153,0,0) }
    A.Bar:link {font-family: Arial, Helvetica, sans-serif; font-style: normal; text-decoration: none; color: rgb(204,204,51)}
    A.Bar:visited {font-family: Arial, Helvetica, sans-serif; font-style: normal; text-decoration: none; color: rgb(204,204,51)}
    DIV.Normal {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.2em; margin-bottom: 0.6em}
    DIV.Indented1 {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-bottom: 0.6em}
    DIV.Notes {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em; margin-bottom: 0.6em}
    DIV.Annotations {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 6.2em; margin-bottom: 0.6em}
    DIV.NotesHeader {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em}
    DIV.SmallExamples {font-family: "Courier New", monospace; font-size: 72%; line-height: 122%; margin-left: 9.6em; margin-bottom: 0.6em}
    DIV.Bulleted-NoPrefix {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    DIV.Bulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em; display: list-item; list-style-type: disc}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#000080" VLINK="#330033" ALINK="#0000FF">
<DIV><B><SPAN Style="font-size:200%; color: rgb(0,51,153)">Annotated</SPAN><SPAN Style="font-size:200%; color: rgb(0,0,102)">&nbsp;Ada Reference Manual</SPAN></B> &mdash; <A HREF="AA-TTL.html"><B>Legal Information</B></A></DIV>
<div style="margin-top: 0.6em; margin-bottom: 0.0em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-10-2.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-11.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</div>
<HR>
<H1>10.2.1 Elaboration Control</H1>
<div class="paranum"><a name="p1">1</a></div>
<div class="Normal">[<A NAME="I4881"></A> This subclause defines pragmas 
that help control the elaboration order of <SPAN Class="swiss"><A HREF="AA-10-1-1.html#S0248">library_item</A></SPAN>s.] 
</div>

<H4 Class="centered">Language Design Principles</H4>
<div class="paranum"><a name="p1.a">1.a</a></div>
<div class="Annotations">The rules governing preelaboration are designed 
to allow it to be done largely by bulk initialization of statically allocated 
storage from information in a &ldquo;load module&rdquo; created by a 
linker. Some implementations may require run-time code to be executed 
in some cases, but we consider these cases rare enough that we need not 
further complicate the rules.</div>
<div class="paranum"><a name="p1.b">1.b</a></div>
<div class="Annotations">It is important that programs be able to declare 
data structures that are link-time initialized with <SPAN Class="swiss"><A HREF="AA-4-3.html#S0106">aggregate</A></SPAN>s, 
<SPAN Class="swiss"><A HREF="AA-2-6.html#S0016">string_literal</A></SPAN>s, 
and concatenations thereof. It is important to be able to write link-time 
evaluated expressions involving the First, Last, and Length attributes 
of such data structures (including variables), because they might be 
initialized with positional <SPAN Class="swiss"><A HREF="AA-4-3.html#S0106">aggregate</A></SPAN>s 
or <SPAN Class="swiss"><A HREF="AA-2-6.html#S0016">string_literal</A></SPAN>s, 
and we don't want the user to have to count the elements. There is no 
corresponding need for accessing discriminants, since they can be initialized 
with a static constant, and then the constant can be referred to elsewhere. 
It is important to allow link-time initialized data structures involving 
discriminant-dependent components. It is important to be able to write 
link-time evaluated expressions involving pointers (both access values 
and addresses) to the above-mentioned data structures.</div>
<div class="paranum"><a name="p1.c">1.c</a></div>
<div class="Annotations">The rules also ensure that no Elaboration_Check 
need be performed for calls on library-level subprograms declared within 
a preelaborated package. This is true also of the Elaboration_Check on 
task activation for library level task types declared in a preelaborated 
package. However, it is not true of the Elaboration_Check on instantiations.</div>
<div class="paranum"><a name="p1.d">1.d</a></div>
<div class="Annotations">A static expression should never prevent a library 
unit from being preelaborable.</div>

<H4 Class="centered">Syntax</H4>
<div class="paranum"><a name="p2">2</a></div>
<div class="Indented1" style="margin-bottom: 0.4em">The form of a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Preelaborate is as follows:&nbsp;</div>
<div class="paranum"><a name="p3">3</a></div>
<div class="Indented1">&nbsp;&nbsp;<B>pragma</B> <A NAME="I4882"></A><A NAME="I4883"></A>Preelaborate[(<I>library_unit_</I><A NAME="I4884"></A><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>)];</div>
<div class="paranum"><a name="p4">4</a></div>
<div class="Indented1"><A NAME="I4885"></A><A NAME="I4886"></A>A <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Preelaborate is a library unit pragma.&nbsp;</div>
<div class="paranum"><a name="p4.1">4.1/2</a></div>
<div class="Indented1" style="margin-bottom: 0.4em">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00161.TXT">AI95-00161-01</A></I>} 
The form of a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Preelaborable_Initialization is as follows:&nbsp;</div>
<div class="paranum"><a name="p4.2">4.2/2</a></div>
<div class="Indented1">&nbsp;&nbsp;<B>pragma</B> <A NAME="I4887"></A><A NAME="I4888"></A>Preelaborable_Initialization(<A NAME="I4889"></A><SPAN Class="swiss"><A HREF="AA-4-1.html#S0092">direct_name</A></SPAN>); 
</div>

<H4 Class="centered">Legality Rules</H4>
<div class="paranum"><a name="p5">5</a></div>
<div class="Normal" style="margin-bottom: 0.4em"><A NAME="I4890"></A>An 
elaborable construct is preelaborable unless its elaboration performs 
any of the following actions:&nbsp;</div>
<div class="paranum"><a name="p5.a">5.a</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>A <I>preelaborable</I> 
construct can be elaborated without using any information that is available 
only at run time. Note that we don't try to prevent exceptions in preelaborable 
constructs; if the implementation wishes to generate code to raise an 
exception, that's OK.</div>
<div class="paranum"><a name="p5.b">5.b</a></div>
<div class="Annotations">Because there is no flow of control and there 
are no calls (other than to predefined subprograms), these run-time properties 
can actually be detected at compile time. This is necessary in order 
to require compile-time enforcement of the rules.&nbsp;</div>
<div class="paranum"><a name="p6">6</a></div>
<div class="Bulleted">The execution of a <SPAN Class="swiss"><A HREF="AA-5-1.html#S0146">statement</A></SPAN> 
other than a <SPAN Class="swiss"><A HREF="AA-5-1.html#S0149">null_statement</A></SPAN>. 
</div>
<div class="paranum"><a name="p6.a">6.a</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>A preelaborable construct 
can contain <SPAN Class="swiss"><A HREF="AA-5-1.html#S0150">label</A></SPAN>s 
and <SPAN Class="swiss"><A HREF="AA-5-1.html#S0149">null_statement</A></SPAN>s. 
</div>
<div class="paranum"><a name="p7">7</a></div>
<div class="Bulleted">A call to a subprogram other than a static function.</div>
<div class="paranum"><a name="p8">8</a></div>
<div class="Bulleted">The evaluation of a <SPAN Class="swiss"><A HREF="AA-4-4.html#S0126">primary</A></SPAN> 
that is a <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
of an object, unless the <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
is a static expression, or statically denotes a discriminant of an enclosing 
type.&nbsp;</div>
<div class="paranum"><a name="p8.a">8.a</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>One can evaluate such a 
<SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>, but 
not as a <SPAN Class="swiss"><A HREF="AA-4-4.html#S0126">primary</A></SPAN>. 
For example, one can evaluate an attribute of the object. One can evaluate 
an <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0100">attribute_reference</A></SPAN>, 
so long as it does not denote an object, and its <SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN> 
does not disobey any of these rules. For example, Obj'Access, Obj'Unchecked_Access, 
and Obj'Address are generally legal in preelaborated library units.&nbsp;</div>
<div class="paranum"><a name="p9">9/3</a></div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00161.TXT">AI95-00161-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0028-1.TXT">AI05-0028-1</A></I>} 
The creation of an object [(including a component)] that is initialized 
by default, if its type does not have preelaborable initialization. Similarly, 
the evaluation of an <SPAN Class="swiss"><A HREF="AA-4-3-2.html#S0111">extension_aggregate</A></SPAN> 
with an ancestor <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0028">subtype_mark</A></SPAN> 
denoting a subtype of such a type.</div>
<div class="paranum"><a name="p9.a">9.a</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>One can declare these kinds 
of types, but one cannot create objects of those types.</div>
<div class="paranum"><a name="p9.b">9.b</a></div>
<div class="Annotations">It is also nonpreelaborable to create an object 
if that will cause the evaluation of a default expression that will call 
a user-defined function. This follows from the rule above forbidding 
nonnull statements.&nbsp;</div>
<div class="paranum"><a name="p9.c">9.c/2</a></div>
<div class="Annotations"><SPAN STYLE="font-size: 80%"><I>This paragraph 
was deleted.</I></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00161.TXT">AI95-00161-01</A></I>} 
</div>
<div class="paranum"><a name="p10">10/2</a></div>
<div class="Normal" style="margin-bottom: 0.4em">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00403.TXT">AI95-00403-01</A></I>} 
A generic body is preelaborable only if elaboration of a corresponding 
instance body would not perform any such actions, presuming that: <A NAME="I4891"></A></div>
<div class="paranum"><a name="p10.1">10.1/3</a></div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00403.TXT">AI95-00403-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00028.TXT">AI95-0028-1</A></I>} 
the actual for each discriminated formal derived type, formal private 
type, or formal private extension declared within the formal part of 
the generic unit is a type that does not have preelaborable initialization, 
unless <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Preelaborable_Initialization has been applied to the formal type;</div>
<div class="paranum"><a name="p10.2">10.2/2</a></div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00403.TXT">AI95-00403-01</A></I>} 
the actual for each formal type is nonstatic;</div>
<div class="paranum"><a name="p10.3">10.3/2</a></div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00403.TXT">AI95-00403-01</A></I>} 
the actual for each formal object is nonstatic; and</div>
<div class="paranum"><a name="p10.4">10.4/2</a></div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00403.TXT">AI95-00403-01</A></I>} 
the actual for each formal subprogram is a user-defined subprogram.&nbsp;</div>
<div class="paranum"><a name="p10.a.1">10.a.1/2</a></div>
<div class="Annotations"><B>Discussion:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00403.TXT">AI95-00403-01</A></I>} 
This is an &ldquo;assume-the-worst&rdquo; rule. The elaboration of a 
generic unit doesn't perform any of the actions listed above, because 
its sole effect is to establish that the generic can from now on be instantiated. 
So the elaboration of the generic itself is not the interesting part 
when it comes to preelaboration rules. The interesting part is what happens 
when you elaborate &ldquo;any instantiation&rdquo; of the generic. For 
instance, declaring an object of a limited formal private type might 
well start tasks, call functions, and do all sorts of nonpreelaborable 
things. We prevent these situations by assuming that the actual parameters 
are as badly behaved as possible.&nbsp;</div>
<div class="paranum"><a name="p10.a">10.a</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>Without this rule about generics, 
we would have to forbid instantiations in preelaborated library units, 
which would significantly reduce their usefulness.&nbsp;</div>
<div class="paranum"><a name="p11">11/3</a></div>
<div class="Normal">&nbsp;{<I><A HREF="defect1.html#8652/0035">8652/0035</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00002.TXT">AI95-00002-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0034-1.TXT">AI05-0034-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0243-1.TXT">AI05-0243-1</A></I>} 
<A NAME="I4892"></A>A <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Preelaborate (or <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Pure &mdash; see below) is used to specify that a library unit is <I>preelaborated</I>, 
namely that the Preelaborate aspect<A NAME="I4893"></A><A NAME="I4894"></A> 
of the library unit is True; all compilation units of the library unit 
are preelaborated. The declaration and body of a preelaborated library 
unit, and all subunits that are elaborated as part of elaborating the 
library unit, shall be preelaborable. All compilation units of a preelaborated 
library unit shall depend semantically only on declared pure or preelaborated 
<SPAN Class="swiss"><A HREF="AA-10-1-1.html#S0248">library_item</A></SPAN>s. 
<A NAME="I4895"></A>In addition to the places where Legality Rules normally 
apply (see <A HREF="AA-12-3.html">12.3</A>), these rules also apply in 
the private part of an instance of a generic unit. [ <A NAME="I4896"></A>If 
a library unit is preelaborated, then its declaration, if any, and body, 
if any, are elaborated prior to all nonpreelaborated <SPAN Class="swiss"><A HREF="AA-10-1-1.html#S0248">library_item</A></SPAN>s 
of the partition.]&nbsp;</div>
<div class="paranum"><a name="p11.a">11.a</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>In a generic body, we assume 
the worst about formal private types and extensions.</div>
<div class="paranum"><a name="p11.a.1">11.a.1/1</a></div>
<div class="Annotations">{<I><A HREF="defect1.html#8652/0035">8652/0035</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00002.TXT">AI95-00002-01</A></I>} 
Subunits of a preelaborated subprogram unit do not need to be preelaborable. 
This is needed in order to be consistent with units nested in a subprogram 
body, which do not need to be preelaborable even if the subprogram is 
preelaborated. However, such subunits cannot depend semantically on nonpreelaborated 
units, which is also consistent with nested units.&nbsp;</div>
<div class="paranum"><a name="p11.b">11.b/3</a></div>
<div class="Annotations"><B>Aspect Description for&nbsp;</B><B>Preelaborate: 
</B>Code execution during elaboration is avoided for a given package.</div>
<div class="paranum"><a name="p11.1">11.1/2</a></div>
<div class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00161.TXT">AI95-00161-01</A></I>} 
<A NAME="I4897"></A>The following rules specify which entities have <I>preelaborable 
initialization</I>:</div>
<div class="paranum"><a name="p11.2">11.2/3</a></div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0028-1.TXT">AI05-0028-1</A></I>} 
The partial view of a private type or private extension, a protected 
type without <SPAN Class="swiss"><A HREF="AA-9-5-2.html#S0218">entry_declaration</A></SPAN>s, 
a generic formal private type, or a generic formal derived type, has 
preelaborable initialization if and only if the <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Preelaborable_Initialization has been applied to them. [A protected type 
with <SPAN Class="swiss"><A HREF="AA-9-5-2.html#S0218">entry_declaration</A></SPAN>s 
or a task type never has preelaborable initialization.]</div>
<div class="paranum"><a name="p11.3">11.3/2</a></div>
<div class="Bulleted">A component (including a discriminant) of a record 
or protected type has preelaborable initialization if its declaration 
includes a <SPAN Class="swiss"><A HREF="AA-3-7.html#S0063">default_expression</A></SPAN> 
whose execution does not perform any actions prohibited in preelaborable 
constructs as described above, or if its declaration does not include 
a default expression and its type has preelaborable initialization.</div>
<div class="paranum"><a name="p11.4">11.4/3</a></div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0028-1.TXT">AI05-0028-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0221-1.TXT">AI05-0221-1</A></I>} 
A derived type has preelaborable initialization if its parent type has 
preelaborable initialization and if the noninherited components all have 
preelaborable initialization. However, a controlled type with an Initialize 
procedure that is not a null procedure does not have preelaborable initialization.</div>
<div class="paranum"><a name="p11.5">11.5/2</a></div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00161.TXT">AI95-00161-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00345.TXT">AI95-00345-01</A></I>} 
A view of a type has preelaborable initialization if it is an elementary 
type, an array type whose component type has preelaborable initialization, 
a record type whose components all have preelaborable initialization, 
or an interface type.&nbsp;</div>
<div class="paranum"><a name="p11.6">11.6/2</a></div>
<div class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00161.TXT">AI95-00161-01</A></I>} 
A <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> Preelaborable_Initialization 
specifies that a type has preelaborable initialization. This pragma shall 
appear in the visible part of a package or generic package.</div>
<div class="paranum"><a name="p11.7">11.7/3</a></div>
<div class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00161.TXT">AI95-00161-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00345.TXT">AI95-00345-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0028-1.TXT">AI05-0028-1</A></I>} 
If the pragma appears in the first list of <SPAN Class="swiss"><A HREF="AA-3-11.html#S0088">basic_declarative_item</A></SPAN>s 
of a <SPAN Class="swiss"><A HREF="AA-7-1.html#S0191">package_specification</A></SPAN>, 
then the <SPAN Class="swiss"><A HREF="AA-4-1.html#S0092">direct_name</A></SPAN> 
shall denote the first subtype of a composite type, and the type shall 
be declared immediately within the same package as the <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN>. 
If the <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
is applied to a private type or a private extension, the full view of 
the type shall have preelaborable initialization. If the <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
is applied to a protected type, the protected type shall not have entries, 
and each component of the protected type shall have preelaborable initialization. 
For any other composite type, the type shall have preelaborable initialization. 
<A NAME="I4898"></A>In addition to the places where Legality Rules normally 
apply (see <A HREF="AA-12-3.html">12.3</A>), these rules apply also in 
the private part of an instance of a generic unit.</div>
<div class="paranum"><a name="p11.c">11.c/3</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0028-1.TXT">AI05-0028-1</A></I>} 
The reason why we need the pragma for private types, private extensions, 
and protected types is fairly clear: the properties of the full view 
determine whether the type has preelaborable initialization or not; in 
order to preserve privacy we need a way to express on the partial view 
that the full view is well-behaved. The reason why we need the pragma 
for other composite types is more subtle: a nonnull override for Initialize 
might occur in the private part, even for a nonprivate type; in order 
to preserve privacy, we need a way to express on a type declared in a 
visible part that the private part does not contain any nasty override 
of Initialize.&nbsp;</div>
<div class="paranum"><a name="p11.8">11.8/2</a></div>
<div class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00161.TXT">AI95-00161-01</A></I>} 
If the <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
appears in a <SPAN Class="swiss"><A HREF="AA-12-1.html#S0274">generic_formal_part</A></SPAN>, 
then the <SPAN Class="swiss"><A HREF="AA-4-1.html#S0092">direct_name</A></SPAN> 
shall denote a generic formal private type or a generic formal derived 
type declared in the same <SPAN Class="swiss"><A HREF="AA-12-1.html#S0274">generic_formal_part</A></SPAN> 
as the <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN>. 
In a <SPAN Class="swiss"><A HREF="AA-12-3.html#S0276">generic_instantiation</A></SPAN> 
the corresponding actual type shall have preelaborable initialization.</div>
<div class="paranum"><a name="p11.d">11.d/2</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>Not only do protected types 
with <SPAN Class="swiss"><A HREF="AA-9-5-2.html#S0218">entry_declaration</A></SPAN>s 
and task types not have preelaborable initialization, but they cannot 
have pragma Preelaborable_Initialization applied to them.&nbsp;</div>

<H4 Class="centered">Implementation Advice</H4>
<div class="paranum"><a name="p12">12</a></div>
<div class="Normal">In an implementation, a type declared in a preelaborated 
package should have the same representation in every elaboration of a 
given version of the package, whether the elaborations occur in distinct 
executions of the same program, or in executions of distinct programs 
or partitions that include the given version.&nbsp;</div>
<div class="paranum"><a name="p12.a">12.a/2</a></div>
<div class="Annotations"><B>Implementation Advice:&nbsp;</B>A type declared 
in a preelaborated package should have the same representation in every 
elaboration of a given version of the package.</div>

<H4 Class="centered">Syntax</H4>
<div class="paranum"><a name="p13">13</a></div>
<div class="Indented1" style="margin-bottom: 0.4em">The form of a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Pure is as follows:&nbsp;</div>
<div class="paranum"><a name="p14">14</a></div>
<div class="Indented1">&nbsp;&nbsp;<B>pragma</B> <A NAME="I4899"></A><A NAME="I4900"></A>Pure[(<I>library_unit_</I><A NAME="I4901"></A><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>)];</div>
<div class="paranum"><a name="p15">15</a></div>
<div class="Indented1"><A NAME="I4902"></A><A NAME="I4903"></A>A <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Pure is a library unit pragma.&nbsp;</div>

<H4 Class="centered">Static Semantics</H4>
<div class="paranum"><a name="p15.1">15.1/3</a></div>
<div class="Normal" style="margin-bottom: 0.4em">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00366.TXT">AI95-00366-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0035-1.TXT">AI05-0035-1</A></I>} 
<A NAME="I4904"></A>A <I>pure</I> compilation unit is a preelaborable 
compilation unit whose elaboration does not perform any of the following 
actions:</div>
<div class="paranum"><a name="p15.2">15.2/2</a></div>
<div class="Bulleted">the elaboration of a variable declaration;</div>
<div class="paranum"><a name="p15.3">15.3/2</a></div>
<div class="Bulleted">the evaluation of an <SPAN Class="swiss"><A HREF="AA-4-8.html#S0143">allocator</A></SPAN> 
of an access-to-variable type; for the purposes of this rule, the partial 
view of a type is presumed to have nonvisible components whose default 
initialization evaluates such an <SPAN Class="swiss"><A HREF="AA-4-8.html#S0143">allocator</A></SPAN>;</div>
<div class="paranum"><a name="p15.a.1">15.a.1/3</a></div>
<div class="Annotations" style="margin-bottom: 0.4em"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0004-1.TXT">AI05-0004-1</A></I>} 
Such an <SPAN Class="swiss"><A HREF="AA-4-8.html#S0143">allocator</A></SPAN> 
would provide a backdoor way to get a global variable into a pure unit, 
so it is prohibited. Most such <SPAN Class="swiss"><A HREF="AA-4-8.html#S0143">allocator</A></SPAN>s 
are illegal anyway, as their type is required to have Storage_Size = 
0 (see the next two rules). But access parameters and access discriminants 
don't necessarily disallow <SPAN Class="swiss"><A HREF="AA-4-8.html#S0143">allocator</A></SPAN>s. 
However, a call is also illegal here (by the preelaboration rules), so 
access parameters cannot cause trouble. So this rule is really about 
prohibiting allocators in discriminant constraints:</div>
<div class="paranum"><a name="p15.a.2">15.a.2/3</a></div>
<div class="SmallExamples"><B>type</B>&nbsp;Rec&nbsp;(Acc&nbsp;:&nbsp;<B>access</B>&nbsp;Integer)&nbsp;<B>is&nbsp;record</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;C&nbsp;:&nbsp;Character;<BR>
<B>end&nbsp;record</B>;</div>
<div class="paranum"><a name="p15.a.3">15.a.3/3</a></div>
<div class="SmallExamples">Not_Const&nbsp;:&nbsp;<B>constant</B>&nbsp;Rec&nbsp;(Acc&nbsp;=&gt;&nbsp;<B>new</B>&nbsp;Integer'(2));&nbsp;--&nbsp;<SPAN Class="roman"><I>Illegal&nbsp;in&nbsp;a&nbsp;pure&nbsp;unit</I></SPAN>.</div>
<div class="paranum"><a name="p15.a">15.a/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0004-1.TXT">AI05-0004-1</A></I>} 
The second half of the rule is needed because aggregates can specify 
the default initialization of a private type or extension using &lt;&gt; 
or the ancestor subtype of an extension aggregate. The subtype of a component 
could use an <SPAN Class="swiss"><A HREF="AA-4-8.html#S0143">allocator</A></SPAN> 
to initialize an access discriminant; the type still could have a pragma 
Preelaborable_Initialization given. Ada 95 did not allow such private 
types to have preelaborable initialization, so such a default initialization 
could not have occurred. Thus this rule is not incompatible with Ada 
95.&nbsp;</div>
<div class="paranum"><a name="p15.4">15.4/3</a></div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0035-1.TXT">AI05-0035-1</A></I>} 
the elaboration of the declaration of a nonderived named access-to-variable 
type unless the Storage_Size of the type has been specified by a static 
expression with value zero or is defined by the language to be zero;</div>
<div class="paranum"><a name="p15.b">15.b/2</a></div>
<div class="Annotations"><B>Discussion:&nbsp;</B>A remote access-to-class-wide 
type (see <A HREF="AA-E-2-2.html">E.2.2</A>) has its Storage_Size defined 
to be zero.&nbsp;</div>
<div class="paranum"><a name="p15.c">15.c/2</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00366.TXT">AI95-00366-01</A></I>} 
We disallow most named access-to-object types because an <SPAN Class="swiss"><A HREF="AA-4-8.html#S0143">allocator</A></SPAN> 
has a side effect; the pool constitutes variable data. We allow access-to-subprogram 
types because they don't have <SPAN Class="swiss"><A HREF="AA-4-8.html#S0143">allocator</A></SPAN>s. 
We even allow named access-to-object types if they have an empty predefined 
pool (they can't have a user-defined pool as System.Storage_Pools is 
not pure). In this case, most attempts to use an <SPAN Class="swiss"><A HREF="AA-4-8.html#S0143">allocator</A></SPAN> 
are illegal, and any others (in a generic body) will raise Storage_Error. 
</div>
<div class="paranum"><a name="p15.5">15.5/3</a></div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0035-1.TXT">AI05-0035-1</A></I>} 
the elaboration of the declaration of a nonderived named access-to-constant 
type for which the Storage_Size has been specified by an expression other 
than a static expression with value zero.</div>
<div class="paranum"><a name="p15.d">15.d/2</a></div>
<div class="Annotations"><B>Discussion:&nbsp;</B>We allow access-to-constant 
types so long as there is no user-specified nonzero Storage_Size; if 
there were a user-specified nonzero Storage_Size restricting the size 
of the storage pool, allocators would be problematic since the package 
is supposedly &lsquo;stateless&rsquo;, and the allocated size count for 
the storage pool would represent state.&nbsp;</div>
<div class="paranum"><a name="p15.6">15.6/3</a></div>
<div class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0035-1.TXT">AI05-0035-1</A></I>} 
A generic body is pure only if elaboration of a corresponding instance 
body would not perform any such actions presuming any composite formal 
types have nonvisible components whose default initialization evaluates 
an <SPAN Class="swiss"><A HREF="AA-4-8.html#S0143">allocator</A></SPAN> 
of an access-to-variable type.</div>
<div class="paranum"><a name="p15.7">15.7/2</a></div>
<div class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00366.TXT">AI95-00366-01</A></I>} 
The Storage_Size for an anonymous access-to-variable type declared at 
library level in a library unit that is declared pure is defined to be 
zero.</div>
<div class="paranum"><a name="p15.e">15.e/2</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>This makes <SPAN Class="swiss"><A HREF="AA-4-8.html#S0143">allocator</A></SPAN>s 
illegal for such types (see <A HREF="AA-4-8.html">4.8</A>), making a 
storage pool unnecessary for these types. A storage pool would represent 
state.</div>
<div class="paranum"><a name="p15.f">15.f/2</a></div>
<div class="Annotations">Note that access discriminants and access parameters 
are never library-level, even when they are declared in a type or subprogram 
declared at library-level. That's because they have their own special 
accessibility rules (see <A HREF="AA-3-10-2.html">3.10.2</A>).&nbsp;</div>

<H4 Class="centered">Legality Rules</H4>
<div class="paranum"><a name="p16">16/2</a></div>
<div class="Normal">&nbsp;<SPAN STYLE="font-size: 80%"><I>This paragraph was 
deleted.</I></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00366.TXT">AI95-00366-01</A></I>} 
</div>
<div class="paranum"><a name="p17">17/3</a></div>
<div class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00366.TXT">AI95-00366-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0034-1.TXT">AI05-0034-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0035-1.TXT">AI05-0035-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0243-1.TXT">AI05-0243-1</A></I>} 
<A NAME="I4905"></A>A <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Pure is used to specify that a library unit is <I>declared pure</I>, 
namely that the Pure aspect<A NAME="I4906"></A><A NAME="I4907"></A> of 
the library unit is True; all compilation units of the library unit are 
declared pure. In addition, the limited view of any library package is 
declared pure. The declaration and body of a declared pure library unit, 
and all subunits that are elaborated as part of elaborating the library 
unit, shall be pure. All compilation units of a declared pure library 
unit shall depend semantically only on declared pure <SPAN Class="swiss"><A HREF="AA-10-1-1.html#S0248">library_item</A></SPAN>s. 
<A NAME="I4908"></A>In addition to the places where Legality Rules normally 
apply (see <A HREF="AA-12-3.html">12.3</A>), these rules also apply in 
the private part of an instance of a generic unit. Furthermore, the full 
view of any partial view declared in the visible part of a declared pure 
library unit that has any available stream attributes shall support external 
streaming (see <A HREF="AA-13-13-2.html">13.13.2</A>).&nbsp;</div>
<div class="paranum"><a name="p17.a">17.a/3</a></div>
<div class="Annotations"><SPAN STYLE="font-size: 80%"><I>This paragraph 
was deleted.</I></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0243-1.TXT">AI05-0243-1</A></I>} 
</div>
<div class="paranum"><a name="p17.b">17.b</a></div>
<div class="Annotations"><B>Discussion:&nbsp;</B>A declared-pure package is 
useful for defining types to be shared between partitions with no common 
address space.&nbsp;</div>
<div class="paranum"><a name="p17.c">17.c</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>Note that generic packages are 
not mentioned in the list of things that can contain variable declarations. 
Note that the Ada 95 rules for deferred constants make them allowable 
in library units that are declared pure; that isn't true of Ada 83's 
deferred constants.&nbsp;</div>
<div class="paranum"><a name="p17.d">17.d/2</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00366.TXT">AI95-00366-01</A></I>} 
Anonymous access types are allowed.</div>
<div class="paranum"><a name="p17.d.1">17.d.1/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0243-1.TXT">AI05-0243-1</A></I>} 
A limited view is not a library unit, so any rule that starts &ldquo;declared 
pure library unit&rdquo; does not apply to a limited view. In particular, 
the 3rd and last sentences never apply to limited views. However, a limited 
view is a <SPAN Class="swiss"><A HREF="AA-10-1-1.html#S0248">library_item</A></SPAN>, 
so rules that discuss &ldquo;declared pure <SPAN Class="swiss"><A HREF="AA-10-1-1.html#S0248">library_item</A></SPAN>s&rdquo; 
do include limited views.&nbsp;</div>
<div class="paranum"><a name="p17.e">17.e/2</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00366.TXT">AI95-00366-01</A></I>} 
Ada 95 didn't allow any access types as these (including access-to-subprogram 
types) cause trouble for <A HREF="AA-E.html">Annex E</A>, &ldquo;<A HREF="AA-E.html">Distributed 
Systems</A>&rdquo;, because such types  allow access values in a shared 
passive partition to designate objects in an active partition, thus allowing 
inter-address space references. We decided to disallow such uses in the 
relatively rare cases where they cause problems, rather than making life 
harder for the majority of users. Types declared in a pure package can 
be used in remote operations only if they are externally streamable. 
That simply means that there is a means to transport values of the type; 
that's automatically true for nonlimited types that don't have an access 
part. The only tricky part about this is to avoid privacy leakage; that 
was handled by ensuring that any private types (and private extensions) 
declared in a pure package that have available stream attributes (which 
include all nonlimited types by definition) have to be externally streamable. 
</div>
<div class="paranum"><a name="p17.f">17.f/3</a></div>
<div class="Annotations"><B>Aspect Description for&nbsp;</B><B>Pure:&nbsp;</B>Side 
effects are avoided in the subprograms of a given package.</div>

<H4 Class="centered">Erroneous Execution</H4>
<div class="paranum"><a name="p17.1">17.1/4</a></div>
<div class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0076-1.TXT">AI12-0076-1</A></I>} 
<span class="insert4">Execution is erroneous if some operation (other 
than the initialization or finalization of the object) modifies the value 
of a constant object declared at library-level in a pure package.</span></div>
<div class="paranum"><a name="p17.g">17.g/4</a></div>
<div class="Annotations"><span class="insert4"><B>Discussion:&nbsp;</B>This 
could be accomplished via a self-referencing pointer or via squirrelling 
a writable pointer to a controlled object.</span>&nbsp;</div>

<H4 Class="centered">Implementation Permissions</H4>
<div class="paranum"><a name="p18">18/3</a></div>
<div class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00366.TXT">AI95-00366-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0219-1.TXT">AI05-0219-1</A></I>} 
If a library unit is declared pure, then the implementation is permitted 
to omit a call on a library-level subprogram of the library unit if the 
results are not needed after the call. In addition, the implementation 
may omit a call on such a subprogram and simply reuse the results produced 
by an earlier call on the same subprogram, provided that none of the 
parameters nor any object accessible via access values from the parameters 
have any part that is of a type whose full type is an immutably limited 
type, and the addresses and values of all by-reference actual parameters, 
the values of all by-copy-in actual parameters, and the values of all 
objects accessible via access values from the parameters, are the same 
as they were at the earlier call. [This permission applies even if the 
subprogram produces other side effects when called.]&nbsp;</div>
<div class="paranum"><a name="p18.a">18.a/3</a></div>
<div class="Annotations"><B>Discussion:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00366.TXT">AI95-00366-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0005-1.TXT">AI05-0005-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0299-1.TXT">AI05-0299-1</A></I>} 
A declared-pure <SPAN Class="swiss"><A HREF="AA-10-1-1.html#S0248">library_item</A></SPAN> 
has no variable state. Hence, a call on one of its (nonnested) subprograms 
cannot normally have side effects. Side effects are still possible via 
dispatching calls and via indirect calls through access-to-subprogram 
values. Other mechanisms that might be used to modify variable state 
include machine code insertions, imported subprograms,  and unchecked 
conversion to an access type declared within the subprogram; this list 
is not exhaustive. Thus, the permissions described in this subclause 
may apply to a subprogram whose execution has side effects. The compiler 
may omit a call to such a subprogram even if  side effects exist, so 
the writer of such a subprogram has to keep this in mind.&nbsp;</div>

<H4 Class="centered">Syntax</H4>
<div class="paranum"><a name="p19">19</a></div>
<div class="Indented1" style="margin-bottom: 0.4em">The form of a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Elaborate, Elaborate_All, or Elaborate_Body is as follows:&nbsp;</div>
<div class="paranum"><a name="p20">20</a></div>
<div class="Indented1">&nbsp;&nbsp;<B>pragma</B> <A NAME="I4909"></A><A NAME="I4910"></A>Elaborate(<I>library_unit_</I><A NAME="I4911"></A><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>{, 
<I>library_unit_</I><A NAME="I4912"></A><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>});</div>
<div class="paranum"><a name="p21">21</a></div>
<div class="Indented1">&nbsp;&nbsp;<B>pragma</B> <A NAME="I4913"></A><A NAME="I4914"></A>Elaborate_All(<I>library_unit_</I><A NAME="I4915"></A><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>{, 
<I>library_unit_</I><A NAME="I4916"></A><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>});</div>
<div class="paranum"><a name="p22">22</a></div>
<div class="Indented1">&nbsp;&nbsp;<B>pragma</B> <A NAME="I4917"></A><A NAME="I4918"></A>Elaborate_Body[(<I>library_unit_</I><A NAME="I4919"></A><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>)];</div>
<div class="paranum"><a name="p23">23</a></div>
<div class="Indented1">A <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Elaborate or Elaborate_All is only allowed within a <SPAN Class="swiss"><A HREF="AA-10-1-2.html#S0253">context_clause</A></SPAN>. 
</div>
<div class="paranum"><a name="p23.a">23.a</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>&ldquo;Within a <SPAN Class="swiss"><A HREF="AA-10-1-2.html#S0253">context_clause</A></SPAN>&rdquo; 
allows it to be the last item in the <SPAN Class="swiss"><A HREF="AA-10-1-2.html#S0253">context_clause</A></SPAN>. 
It can't be first, because the <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
has to denote something mentioned earlier.&nbsp;</div>
<div class="paranum"><a name="p24">24</a></div>
<div class="Indented1"><A NAME="I4920"></A><A NAME="I4921"></A>A <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Elaborate_Body is a library unit pragma.&nbsp;</div>
<div class="paranum"><a name="p24.a">24.a</a></div>
<div class="Annotations"><B>Discussion:&nbsp;</B>Hence, a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Elaborate or Elaborate_All is not elaborated, not that it makes any practical 
difference.</div>
<div class="paranum"><a name="p24.b">24.b</a></div>
<div class="Annotations">Note that a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Elaborate or Elaborate_All is neither a program unit pragma, nor a library 
unit pragma.</div>

<H4 Class="centered">Legality Rules</H4>
<div class="paranum"><a name="p25">25/3</a></div>
<div class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0229-1.TXT">AI05-0229-1</A></I>} 
<A NAME="I4922"></A>If the aspect Elaborate_Body is True for a declaration 
[(including when <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Elaborate_Body applies)], then the declaration requires a completion 
[(a body)].<A NAME="I4923"></A></div>
<div class="paranum"><a name="p25.a">25.a/3</a></div>
<div class="Annotations"><B>Proof:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0229-1.TXT">AI05-0229-1</A></I>} 
<SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">Pragma</A></SPAN> Elaborate_Body 
sets the aspect (see below).&nbsp;</div>
<div class="paranum"><a name="p25.1">25.1/2</a></div>
<div class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-50217.TXT">AI95-00217-06</A></I>} 
The <I>library_unit_</I><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
of a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Elaborate or Elaborate_All shall denote a nonlimited view of a library 
unit.&nbsp;</div>
<div class="paranum"><a name="p25.b">25.b/2</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>These <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN>s 
are intended to prevent elaboration check failures. But a limited view 
does not make anything visible that has an elaboration check, so the 
<SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN>s cannot 
do anything useful. Moreover, the <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN>s 
would probably reintroduce the circularity that the <SPAN Class="swiss"><A HREF="AA-10-1-2.html#S0256">limited_with_clause</A></SPAN> 
was intended to break. So we make such uses illegal.&nbsp;</div>

<H4 Class="centered">Static Semantics</H4>
<div class="paranum"><a name="p26">26/3</a></div>
<div class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0229-1.TXT">AI05-0229-1</A></I>} 
[A <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Elaborate specifies that the body of the named library unit is elaborated 
before the current <SPAN Class="swiss"><A HREF="AA-10-1-1.html#S0248">library_item</A></SPAN>. 
A <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> Elaborate_All 
specifies that each <SPAN Class="swiss"><A HREF="AA-10-1-1.html#S0248">library_item</A></SPAN> 
that is needed by the named library unit declaration is elaborated before 
the current <SPAN Class="swiss"><A HREF="AA-10-1-1.html#S0248">library_item</A></SPAN>.]</div>
<div class="paranum"><a name="p26.a">26.a</a></div>
<div class="Annotations"><B>Proof:&nbsp;</B>The official statement of the 
semantics of these <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN>s 
is given in <A HREF="AA-10-2.html">10.2</A>.&nbsp;</div>
<div class="paranum"><a name="p26.1">26.1/3</a></div>
<div class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0229-1.TXT">AI05-0229-1</A></I>} 
A <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> Elaborate_Body 
sets the Elaborate_Body representation aspect of the library unit to 
which it applies to the value True. [If the Elaborate_Body aspect of 
a library unit is True, the body of the library unit is elaborated immediately 
after its declaration.<A NAME="I4924"></A><A NAME="I4925"></A>]</div>
<div class="paranum"><a name="p26.a.1">26.a.1/3</a></div>
<div class="Annotations"><B>Proof:&nbsp;</B>The official statement of the 
semantics of this aspect is given in <A HREF="AA-10-2.html">10.2</A>. 
</div>
<div class="paranum"><a name="p26.b">26.b</a></div>
<div class="Annotations"><B>Implementation Note:&nbsp;</B>The presence of 
a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> Elaborate_Body 
simplifies the removal of unnecessary Elaboration_Checks. For a subprogram 
declared immediately within a library unit to which a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Elaborate_Body applies, the only calls that can fail the Elaboration_Check 
are those that occur in the library unit itself, between the declaration 
and body of the called subprogram; if there are no such calls (which 
can easily be detected at compile time if there are no <SPAN Class="swiss">stub</SPAN>s), 
then no Elaboration_Checks are needed for that subprogram. The same is 
true for Elaboration_Checks on task activations and instantiations, and 
for library subprograms and generic units.&nbsp;</div>
<div class="paranum"><a name="p26.c">26.c</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>The fact that the unit 
of elaboration is the <SPAN Class="swiss"><A HREF="AA-10-1-1.html#S0248">library_item</A></SPAN> 
means that if a <SPAN Class="swiss"><A HREF="AA-6-3.html#S0177">subprogram_body</A></SPAN> 
is not a completion, it is impossible for any <SPAN Class="swiss"><A HREF="AA-10-1-1.html#S0248">library_item</A></SPAN> 
to be elaborated between the declaration and the body of such a subprogram. 
Therefore, it is impossible for a call to such a subprogram to fail its 
Elaboration_Check.&nbsp;</div>
<div class="paranum"><a name="p26.d">26.d</a></div>
<div class="Annotations"><B>Discussion:&nbsp;</B>The visibility rules imply 
that each <I>library_unit_</I><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
of a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Elaborate or Elaborate_All has to denote a library unit mentioned by 
a previous <SPAN Class="swiss"><A HREF="AA-10-1-2.html#S0255">with_clause</A></SPAN> 
of the same <SPAN Class="swiss"><A HREF="AA-10-1-2.html#S0253">context_clause</A></SPAN>. 
</div>
<div class="paranum"><a name="p26.e">26.e/3</a></div>
<div class="Annotations"><B>Aspect Description for&nbsp;</B><B>Elaborate_Body: 
</B>A given package must have a body, and that body is elaborated immediately 
after the declaration.</div>
<div class="NotesHeader">NOTES</div>
<div class="paranum"><a name="p27">27</a></div>
<div class="Notes">12&nbsp;&nbsp;A preelaborated library unit is allowed 
to have nonpreelaborable children.&nbsp;</div>
<div class="paranum"><a name="p27.a">27.a/1</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>{<I><A HREF="defect1.html#8652/0035">8652/0035</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00002.TXT">AI95-00002-01</A></I>} 
But generally not nonpreelaborated subunits. (Nonpreelaborated subunits 
of subprograms are allowed as discussed above.)&nbsp;</div>
<div class="paranum"><a name="p28">28</a></div>
<div class="Notes">13&nbsp;&nbsp;A library unit that is declared pure 
is allowed to have impure children.&nbsp;</div>
<div class="paranum"><a name="p28.a">28.a/1</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>{<I><A HREF="defect1.html#8652/0035">8652/0035</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00002.TXT">AI95-00002-01</A></I>} 
But generally not impure subunits. (Impure subunits of subprograms are 
allowed as discussed above.)&nbsp;</div>
<div class="paranum"><a name="p28.b">28.b</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>Pragma Elaborate is mainly 
for closely related library units, such as when two package bodies 'with' 
each other's declarations. In such cases, Elaborate_All sometimes won't 
work.&nbsp;</div>

<H4 Class="centered">Extensions to Ada 83</H4>
<div class="paranum"><a name="p28.c">28.c</a></div>
<div class="Annotations"><A NAME="I4926"></A>The concepts of preelaborability 
and purity are new to Ada 95. The Elaborate_All, Elaborate_Body, Preelaborate, 
and Pure <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN>s 
are new to Ada 95.</div>
<div class="paranum"><a name="p28.d">28.d</a></div>
<div class="Annotations">Pragmas Elaborate are allowed to be mixed in 
with the other things in the <SPAN Class="swiss"><A HREF="AA-10-1-2.html#S0253">context_clause</A></SPAN> 
&mdash; in Ada 83, they were required to appear last.&nbsp;</div>

<H4 Class="centered">Incompatibilities With Ada 95</H4>
<div class="paranum"><a name="p28.e">28.e/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00366.TXT">AI95-00366-01</A></I>} 
<A NAME="I4927"></A>The requirement that a partial view with available 
stream attributes be externally streamable can cause an incompatibility 
in rare cases. If there is a limited tagged type declared in a pure package 
with available attributes, and that type is used to declare a private 
extension in another pure package, and the full type for the private 
extension has a component of an explicitly limited record type, a protected 
type, or a type with access discriminants, then the stream attributes 
will have to be user-specified in the visible part of the package. That 
is not a requirement for Ada 95, but this combination seems very unlikely 
in pure packages. Note that this cannot be an incompatibility for a nonlimited 
type, as all of the types that are allowed in Ada 95 that would require 
explicitly defined stream attributes are limited (and thus cannot be 
used as components in a nonlimited type).</div>
<div class="paranum"><a name="p28.f">28.f/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00403.TXT">AI95-00403-01</A></I>} 
<B>Amendment Correction:</B> Added wording to cover missing cases for 
preelaborated generic units. This is incompatible as a preelaborated 
unit could have used a formal object to initialize a library-level object; 
that isn't allowed in Ada 2005. But such a unit wouldn't really be preelaborable, 
and Ada 95 compilers can reject such units (as this is a Binding Interpretation), 
so such units should be very rare.&nbsp;</div>

<H4 Class="centered">Extensions to Ada 95</H4>
<div class="paranum"><a name="p28.g">28.g/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00161.TXT">AI95-00161-01</A></I>} 
<A NAME="I4928"></A><B>Amendment Correction:</B> The concept of preelaborable 
initialization and <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Preelaborable_Initialization are new. These allow more types of objects 
to be created in preelaborable units, and fix holes in the old rules.</div>
<div class="paranum"><a name="p28.h">28.h/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00366.TXT">AI95-00366-01</A></I>} 
Access-to-subprogram types and access-to-object types with a Storage_Size 
of 0 are allowed in pure units. The permission to omit calls was adjusted 
accordingly (which also fixes a hole in Ada 95, as access parameters 
are allowed, and changes in the values accessed by them must be taken 
into account).&nbsp;</div>

<H4 Class="centered">Wording Changes from Ada 95</H4>
<div class="paranum"><a name="p28.i">28.i/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00002.TXT">AI95-00002-01</A></I>} 
<B>Corrigendum:</B> The wording was changed so that subunits of a preelaborated 
subprogram are also preelaborated.</div>
<div class="paranum"><a name="p28.j">28.j/2</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-50217.TXT">AI95-00217-06</A></I>} 
Disallowed pragma Elaborate and Elaborate_All for packages that are mentioned 
in a <SPAN Class="swiss"><A HREF="AA-10-1-2.html#S0256">limited_with_clause</A></SPAN>. 
</div>

<H4 Class="centered">Incompatibilities With Ada 2005</H4>
<div class="paranum"><a name="p28.k">28.k/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0028-1.TXT">AI05-0028-1</A></I>} 
<A NAME="I4929"></A><B>Correction:</B> Corrected a serious unintended 
incompatibility with Ada 95 in the new preelaboration wording &mdash; 
explicit initialization of objects of types that don't have preelaborable 
initialization was not allowed. Ada 2012 switches back to the Ada 95 
rule in these cases. This is unlikely to occur in practice, as it is 
unlikely that a compiler would have implemented the more restrictive 
rule (it would fail many ACATS tests if it did).</div>
<div class="paranum"><a name="p28.l">28.l/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0035-1.TXT">AI05-0035-1</A></I>} 
<B>Correction:</B> Added an assume-the-worst rule for generic bodies 
(else they would never be checked for purity) and added the boilerplate 
so that the entire generic specification is rechecked. Also fixed wording 
to have consistent handling for subunits for Pure and Preelaborate. An 
Ada 95 program could have depended on marking a generic pure that was 
not really pure, although this would defeat the purpose of the categorization 
and likely cause problems with distributed programs.&nbsp;</div>

<H4 Class="centered">Extensions to Ada 2005</H4>
<div class="paranum"><a name="p28.m">28.m/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0035-1.TXT">AI05-0035-1</A></I>} 
<A NAME="I4930"></A><B>Correction:</B> Adjusted wording so that a subunit 
can be pure (it is not a <SPAN Class="swiss"><A HREF="AA-10-1-1.html#S0248">library_item</A></SPAN>, 
but it is a compilation unit).</div>
<div class="paranum"><a name="p28.n">28.n/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0035-1.TXT">AI05-0035-1</A></I>} 
<B>Correction:</B> Adjusted wording so that the rules for access types 
only apply to nonderived types (derived types share their storage pool 
with their parent, so if the parent access type is legal, so is any derived 
type.)</div>
<div class="paranum"><a name="p28.o">28.o/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0229-1.TXT">AI05-0229-1</A></I>} 
Elaborate_Body is now an aspect, so it can be specified by an <SPAN Class="swiss"><A HREF="AA-13-1-1.html#S0307">aspect_specification</A></SPAN> 
&mdash; although the pragma is still preferred by the Standard.</div>
<div class="paranum"><a name="p28.p">28.p/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0243-1.TXT">AI05-0243-1</A></I>} 
Pure and Preelaborate are now aspects, so they can be specified by an 
<SPAN Class="swiss"><A HREF="AA-13-1-1.html#S0307">aspect_specification</A></SPAN> 
&mdash; although the pragmas are still preferred by the Standard.&nbsp;</div>

<H4 Class="centered">Wording Changes from Ada 2005</H4>
<div class="paranum"><a name="p28.q">28.q/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0034-1.TXT">AI05-0034-1</A></I>} 
<B>Correction:</B> Added wording so that a limited view is always treated 
as pure, no matter what categorization is used for the originating unit. 
This was undefined in Ada 2005.</div>
<div class="paranum"><a name="p28.r">28.r/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0028-1.TXT">AI05-0028-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0221-1.TXT">AI05-0221-1</A></I>} 
<B>Correction:</B> Fixed minor issues with preelaborable initialization 
(PI): null Initialize procedures do not make a type non-PI; formal types 
with pragma PI can be assumed to have PI; formal extensions are assumed 
to not have PI; all composite types can have pragma PI (so that the possibility 
of hidden Initialize routines can be handled); added discriminants of 
a derived type are not considered in calculating PI.</div>
<div class="paranum"><a name="p28.s">28.s/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0219-1.TXT">AI05-0219-1</A></I>} 
<B>Correction:</B> Clarified that the implementation permission to omit 
pure subprogram calls does not apply if any part of the parameters or 
any designated object has a part that is immutably limited. The old wording 
just said &quot;limited type&quot;, which can change via visibility and 
thus isn't appropriate for dynamic semantics permissions.&nbsp;</div>

<H4 Class="centered">Wording Changes from Ada 2012</H4>
<div class="paranum"><a name="p28.t">28.t/4</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0076-1.TXT">AI12-0076-1</A></I>} 
<span class="insert4"><B>Corrigendum:</B> Explicitly stated that modifying 
a library-level constant in a pure package is erroneous. We don't document 
this as inconsistent as implementations certainly can still do whatever 
they were previously doing (no change is required); moreover, this case 
(and many more) were erroneous in Ada 2005 and before, so we're just 
restoring the previous semantics.</span>&nbsp;</div>

<HR>
<div style="margin-top: 0.0em; margin-bottom: 0.6em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-10-2.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-11.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</div>
<DIV Style="margin-top:0.0em"><IMG SRC="AE_logo.gif" height=100 width=113 align=right ALT="Ada-Europe">
<SPAN Style="vertical-align: middle; font-size:120%">Ada 2005 and 2012 Editions sponsored in part by <SPAN Style="font-size: 125%"><A HREF="http://www.ada-europe.org/"><B>Ada-Europe</B></A></SPAN></SPAN></DIV>
</BODY>
</HTML>
