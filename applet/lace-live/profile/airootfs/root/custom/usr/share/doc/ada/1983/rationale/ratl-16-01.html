<HTML><HEAD>
<a href="http://sw-eng.falls-church.va.us/AdaIC/"><IMG SRC="small_adaic_logo.gif" ALT="[Ada Information Clearinghouse]"></a>
<hr>
<TITLE>Ada '83 Rationale, Sec 16.1: Introduction (to Ch 16: Input-Output)</TITLE>
</HEAD>

<BODY>
<center><h2>"Rationale for the Design of the<BR>
Ada&#174; Programming Language"</H2>
<H3>[Ada '83 Rationale, HTML Version]</h3>
<h6><i><a href="ratl-00.html#copyright">Copyright</a> &#169;1986
owned by the United States Government. All rights reserved.<BR>
Direct inquiries to the <a href="http://sw-eng.falls-church.va.us/AdaIC/">Ada Information Clearinghouse</a>
at <A HREF="mailto://adainfo@sw-eng.falls-church.va.us">adainfo@sw-eng.falls-church.va.us</A>.</i></h6></center>
<hr>

<H2>CHAPTER 16: Input-Output</H2>

<H3><a name="16.1">16.1 Introduction</a></H3>

Input-output is  one of  the most  difficult areas  to define  in  any
programming language.  The requirements  of individual problem domains
vary widely,  and it  is probably  impossible to  satisfy  one  domain
completely without  seriously compromising  the needs  of another. For
example, the  requirements for  input-output for  a  commercial  stock
control problem  are quite different from those of an embedded machine
controlling a  steel works,  or a  bare board  controlling a  missile.
There is  major conflict  between flexibility,  variety of facilities,
and raw efficiency and compactness, which have different priorities in
the different domains.
<p>
Another problem  is that, whereas the general facilities required of a
procedural language  are reasonably  well  understood  and  likely  to
remain stable,  the requirements for input-output are likely to change
dramatically during the lifetime of Ada, as the means of communication
between man and machine evolve during the next few decades.
<p>
It is clear therefore that any attempt to define a permanent and fully
comprehensive set  of facilities,  intrinsically bound into Ada, would
have been  very likely to fail: either the language would rapidly have
become obsolete,  or it  would  have  been  threatened  with  frequent
change, in  attempting to  cope with changing demands. Indeed, Fortran
is an  obvious example of an old language that has suffered from these
problems -  its built-in  input-output has restricted its utility in a
number of domains of growing importance.
<p>
A further  difficulty  with  built-in  input-output  is  that  special
syntactic forms  are almost  inevitably used:  examples are the format
lists in Fortran and the variable numbers of parameters of the special
write procedures  in Pascal. These special forms make it impossible to
change  the   intrinsic  input-output   whilst  retaining  the  normal
interface to  the user;  it is,  for example, very difficult to insert
local  filtering  into  the  input-output  calls  for  monitoring  and
debugging purposes (that is, to replace these calls by calls to normal
procedures which in turn call write).
<p>
Having rejected the possibility of successfully defining an intrinsic,
complete, comprehensive,  and stable  set of facilities for all input-
output for  all time,  one could contemplate the opposite extreme view
of ignoring  the whole  problem in  the hope  that appropriate sets of
facilities would emerge, defined on top of the base language.
<p>
This was  the view  taken by  <a href="ratl-BIB.html#languages">Algol 60</a>,  and undoubtedly  was a  prime
reason for  the  premature  obsolescence  of  that  language  and  its
dominance  by   <a href="ratl-BIB.html#languages">Fortran</a>.  Individual  developers  of  early  Algol  60
compilers provided  their  customers  with  quite  different  sets  of
procedures for  input-output, thereby  destroying the  portability  of
Algol 60  programs, and this resulted in the fragmentation of the user
base. The  later provision  of a recommended standard came too late to
be widely used, and the language died.
<p>
Another risk with the approach of leaving all input-output to be built
on top  of the  base language  is  that  the  absence  of  appropriate
syntactic support  can lead  to an  unfriendly, clumsy,  and  possibly
inefficient set  of facilities. This was certainly also a problem with
Algol 60, which required a plethora of differently named procedures to
cope with the demand for flexibilty in areas such as formatting.
<p>
The approach  taken in  Ada lies  between the  two extremes  of all or
nothing. Input-output  is not  built into  the syntax of the language;
instead, a number of standard input-output packages are defined, using
the normal  extension mechanisms  that the  language provides.  As  we
shall see,  Ada is  sufficiently rich  in these mechanisms to overcome
the clumsiness  that  plagued  Algol  60.  This  solves  the  problems
outlined above  and, in  particular, ensures  the portability  of  the
mainstream of  programs without  compromising  the  needs  of  special
applications. Furthermore,  it allows  easier  evolution  if  this  is
needed in the future.
<p>
The main purpose of this chapter is thus to show how the Ada extension
facilities described  in the  previous chapters  have been used in the
definition of the standard input-output packages. This also serves the
purpose of showing, in principle, how Ada can be used to develop other
sets  of   packages,  tailored   for  major   classes  of  specialized
applications; this  is important,  since we  take the  view  that  the
standard packages  are  indeed  just  one  possibility,  and  are  not
designed to deal with every foreseeable circumstance in the future.
<p>
<center>
<hr width=60%>
&#128; <a href="ratl-16-02.html#16.2"><b>NEXT</b></a>
&#128; <a href="ratl-16.html#16"><b>PREVIOUS</b></a>
&#128; <a href="ratl-16.html#16"><b>UP</b></a>
&#128; <a href="ratl-TOC.html"><b>TOC</b></a>
&#128; <a href="ratl-IDX.html"><b>INDEX</b></a>
&#128;
<hr width=60%>
<address>Address any questions or comments to
<A HREF="mailto://adainfo@sw-eng.falls-church.va.us">adainfo@sw-eng.falls-church.va.us</A>.</address></center>
<p>
</BODY></HTML>
