<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Generic Instantiation</TITLE>
    <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    H4.centered {text-align: center}
    SPAN.swiss {font-family: Arial, Helvetica, sans-serif; font-size: 92%}
    SPAN.roman {font-family: "Times New Roman", Times, serif}
    DIV.paranum {float: left; font-family: Arial, Helvetica, sans-serif; font-size: 64%; width: 2.8em; margin-left: -0.4em; margin-right: -3.0em; margin-top: 0.2em}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    SPAN.insert1 {text-decoration: underline; color: rgb(0,51,51) }
    SPAN.delete1 {text-decoration: line-through; color: rgb(0,51,51) }
    SPAN.insert2 {text-decoration: underline; color: rgb(0,102,0) }
    SPAN.delete2 {text-decoration: line-through; color: rgb(0,102,0) }
    DIV.Normal {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.2em; margin-bottom: 0.6em}
    DIV.Wide {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.2em; margin-top: 0.6em; margin-bottom: 0.6em}
    DIV.Annotations {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 6.2em; margin-bottom: 0.6em}
    DIV.Notes {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em; margin-bottom: 0.6em}
    DIV.NotesHeader {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em}
    DIV.SyntaxIndented {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-bottom: 0.4em}
    DIV.Examples {font-family: "Courier New", monospace; font-size: 90%; line-height: 122%; margin-left: 3.4em; margin-bottom: 0.6em}
    DIV.SmallExamples {font-family: "Courier New", monospace; font-size: 72%; line-height: 122%; margin-left: 9.6em; margin-bottom: 0.6em}
    UL.SmallBulleted {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 8.7em; margin-right: 2.5em; margin-top: 0em; margin-bottom: 0.5em}
    UL.SmallNestedBulleted {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left:  11.2em; margin-right: 2.5em; margin-top: 0em; margin-bottom: 0.5em}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#000080" VLINK="#330033" ALINK="#0000FF">
<DIV><B><SPAN Style="font-size:200%; color: rgb(0,51,153)">Annotated</SPAN><SPAN Style="font-size:200%; color: rgb(0,0,102)">&nbsp;Ada Reference Manual</SPAN></B> &mdash; <A HREF="AA-TTL.html"><B>Legal Information</B></A></DIV>
<DIV Style="margin-top: 0.6em; margin-bottom: 0.0em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-12-2.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-12-4.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<HR>
<H1>12.3 Generic Instantiation</H1>
<DIV Class="paranum">1</DIV>
<DIV Class="Normal">[<SPAN STYLE="font-size: 80%">{<I>instance (of a 
generic unit)</I>}</SPAN> <A NAME="I4697"></A>An instance of a generic 
unit is declared by a <SPAN Class="swiss"><A HREF="AA-12-3.html#S0257">generic_instantiation</A></SPAN>.] 
</DIV>

<H4 Class="centered">Language Design Principles</H4>
<DIV Class="paranum">1.a</DIV>
<DIV Class="Annotations">{<I>generic contract model</I>} <A NAME="I4698"></A>{<I>contract 
model of generics</I>} <A NAME="I4699"></A>The legality of an instance 
should be determinable without looking at the generic body. Likewise, 
the legality of a generic body should be determinable without looking 
at any instances. Thus, the <SPAN Class="swiss"><A HREF="AA-12-1.html#S0252">generic_declaration</A></SPAN> 
forms a contract between the body and the instances; if each obeys the 
rules with respect to the <SPAN Class="swiss"><A HREF="AA-12-1.html#S0252">generic_declaration</A></SPAN>, 
then no legality problems will arise. This is really a special case of 
the &ldquo;legality determinable via semantic dependences&rdquo; Language 
Design Principle (see Section 10), given that a <SPAN Class="swiss"><A HREF="AA-12-3.html#S0257">generic_instantiation</A></SPAN> 
does not depend semantically upon the generic body, nor vice-versa.</DIV>
<DIV Class="paranum">1.b</DIV>
<DIV Class="Annotations">Run-time issues are another story. For example, 
whether parameter passing is by copy or by reference is determined in 
part by the properties of the generic actuals, and thus cannot be determined 
at compile time of the generic body. Similarly, the contract model does 
not apply to Post-Compilation Rules.&nbsp;</DIV>

<H4 Class="centered">Syntax</H4>
<DIV Class="paranum">2/2</DIV>
<DIV Class="SyntaxIndented">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-20218.TXT">AI95-00218-03</A></I>} 
<SPAN Class="swiss">generic_instantiation</SPAN><A NAME="I4700"></A><A NAME="S0257"></A><SPAN Class="swiss">&nbsp;::=&nbsp;</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>package</B>&nbsp;<A NAME="I4701"></A><SPAN Class="swiss"><A HREF="AA-6-1.html#S0154">defining_program_unit_name</A></SPAN>&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>new</B>&nbsp;<I>generic_package_</I><A NAME="I4702"></A><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>&nbsp;[<A NAME="I4703"></A><SPAN Class="swiss"><A HREF="AA-12-3.html#S0258">generic_actual_part</A></SPAN>];<BR>
&nbsp;&nbsp;&nbsp;|&nbsp;<SPAN class="insert2">[<A NAME="I4704"></A><SPAN Class="swiss"><A HREF="AA-8-3-1.html#S0178">overriding_indicator</A></SPAN>]<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><B>procedure</B>&nbsp;<A NAME="I4705"></A><SPAN Class="swiss"><A HREF="AA-6-1.html#S0154">defining_program_unit_name</A></SPAN>&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>new</B>&nbsp;<I>generic_procedure_</I><A NAME="I4706"></A><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>&nbsp;[<A NAME="I4707"></A><SPAN Class="swiss"><A HREF="AA-12-3.html#S0258">generic_actual_part</A></SPAN>];<BR>
&nbsp;&nbsp;&nbsp;|&nbsp;<SPAN class="insert2">[<A NAME="I4708"></A><SPAN Class="swiss"><A HREF="AA-8-3-1.html#S0178">overriding_indicator</A></SPAN>]<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><B>function</B>&nbsp;<A NAME="I4709"></A><SPAN Class="swiss"><A HREF="AA-6-1.html#S0153">defining_designator</A></SPAN>&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>new</B>&nbsp;<I>generic_function_</I><A NAME="I4710"></A><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>&nbsp;[<A NAME="I4711"></A><SPAN Class="swiss"><A HREF="AA-12-3.html#S0258">generic_actual_part</A></SPAN>];</DIV>
<DIV Class="paranum">3</DIV>
<DIV Class="SyntaxIndented"><SPAN Class="swiss">generic_actual_part</SPAN><A NAME="I4712"></A><A NAME="S0258"></A><SPAN Class="swiss">&nbsp;::=&nbsp;</SPAN><BR>
&nbsp;&nbsp;&nbsp;(<A NAME="I4713"></A><SPAN Class="swiss"><A HREF="AA-12-3.html#S0259">generic_association</A></SPAN>&nbsp;{,&nbsp;<A NAME="I4714"></A><SPAN Class="swiss"><A HREF="AA-12-3.html#S0259">generic_association</A></SPAN>})</DIV>
<DIV Class="paranum">4</DIV>
<DIV Class="SyntaxIndented"><SPAN Class="swiss">generic_association</SPAN><A NAME="I4715"></A><A NAME="S0259"></A><SPAN Class="swiss">&nbsp;::=&nbsp;</SPAN><BR>
&nbsp;&nbsp;&nbsp;[<I>generic_formal_parameter_</I><A NAME="I4716"></A><SPAN Class="swiss"><A HREF="AA-4-1-3.html#S0099">selector_name</A></SPAN>&nbsp;=&gt;]&nbsp;<A NAME="I4717"></A><SPAN Class="swiss"><A HREF="AA-12-3.html#S0260">explicit_generic_actual_parameter</A></SPAN></DIV>
<DIV Class="paranum">5</DIV>
<DIV Class="SyntaxIndented"><SPAN Class="swiss">explicit_generic_actual_parameter</SPAN><A NAME="I4718"></A><A NAME="S0260"></A><SPAN Class="swiss">&nbsp;::=&nbsp;</SPAN><A NAME="I4719"></A><SPAN Class="swiss"><A HREF="AA-4-4.html#S0115">expression</A></SPAN>&nbsp;|&nbsp;<I>variable_</I><A NAME="I4720"></A><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN><BR>
&nbsp;&nbsp;&nbsp;|&nbsp;<I>subprogram_</I><A NAME="I4721"></A><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>&nbsp;|&nbsp;<I>entry_</I><A NAME="I4722"></A><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>&nbsp;|&nbsp;<A NAME="I4723"></A><SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0028">subtype_mark</A></SPAN><BR>
&nbsp;&nbsp;&nbsp;|&nbsp;<I>package_instance_</I><A NAME="I4724"></A><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN></DIV>
<DIV Class="paranum">6</DIV>
<DIV Class="SyntaxIndented"><SPAN STYLE="font-size: 80%">{<I>named association</I>}</SPAN> 
<A NAME="I4725"></A><SPAN STYLE="font-size: 80%">{<I>positional association</I>}</SPAN> 
<A NAME="I4726"></A>A <SPAN Class="swiss"><A HREF="AA-12-3.html#S0259">generic_association</A></SPAN> 
is <I>named</I> or <I>positional</I> according to whether or not the 
<I>generic_formal_parameter_</I><SPAN Class="swiss"><A HREF="AA-4-1-3.html#S0099">selector_name</A></SPAN> 
is specified. Any positional associations shall precede any named associations. 
</DIV>
<DIV Class="paranum">7/2</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>generic actual parameter</I>}</SPAN> 
<A NAME="I4727"></A><SPAN STYLE="font-size: 80%">{<I>generic actual</I>}</SPAN> 
<A NAME="I4728"></A><SPAN STYLE="font-size: 80%">{<I>actual</I>}</SPAN> 
<A NAME="I4729"></A>The <I>generic actual parameter</I> is either the 
<SPAN Class="swiss"><A HREF="AA-12-3.html#S0260">explicit_generic_actual_parameter</A></SPAN> 
given in a <SPAN class="insert2"><SPAN Class="swiss"><A HREF="AA-12-3.html#S0259">generic_association</A></SPAN></SPAN><SPAN class="delete2"><SPAN Class="swiss">&nbsp;generic_parameter_association</SPAN></SPAN> 
for each formal, or the corresponding <SPAN Class="swiss"><A HREF="AA-3-7.html#S0063">default_expression</A></SPAN> 
or <SPAN Class="swiss"><A HREF="AA-12-6.html#S0279">default_name</A></SPAN> 
if no <SPAN class="insert2"><SPAN Class="swiss"><A HREF="AA-12-3.html#S0259">generic_association</A></SPAN></SPAN><SPAN class="delete2"><SPAN Class="swiss">&nbsp;generic_parameter_association</SPAN></SPAN> 
is given for the formal. When the meaning is clear from context, the 
term &ldquo;generic actual,&rdquo; or simply &ldquo;actual,&rdquo; is 
used as a synonym for &ldquo;generic actual parameter&rdquo; and also 
for the view denoted by one, or the value of one.&nbsp;</DIV>

<H4 Class="centered">Legality Rules</H4>
<DIV Class="paranum">8</DIV>
<DIV Class="Normal">In a <SPAN Class="swiss"><A HREF="AA-12-3.html#S0257">generic_instantiation</A></SPAN> 
for a particular kind of program unit [(package, procedure, or function)], 
the <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> shall 
denote a generic unit of the corresponding kind [(generic package, generic 
procedure, or generic function, respectively)].</DIV>
<DIV Class="paranum">9</DIV>
<DIV Class="Normal">The <I>generic_formal_parameter_</I><SPAN Class="swiss"><A HREF="AA-4-1-3.html#S0099">selector_name</A></SPAN> 
of a <SPAN Class="swiss"><A HREF="AA-12-3.html#S0259">generic_association</A></SPAN> 
shall denote a <SPAN Class="swiss"><A HREF="AA-12-1.html#S0256">generic_formal_parameter_declaration</A></SPAN> 
of the generic unit being instantiated. If two or more formal subprograms 
have the same defining name, then named associations are not allowed 
for the corresponding actuals.</DIV>
<DIV Class="paranum">10</DIV>
<DIV Class="Normal">A <SPAN Class="swiss"><A HREF="AA-12-3.html#S0257">generic_instantiation</A></SPAN> 
shall contain at most one <SPAN Class="swiss"><A HREF="AA-12-3.html#S0259">generic_association</A></SPAN> 
for each formal. Each formal without an association shall have a <SPAN Class="swiss"><A HREF="AA-3-7.html#S0063">default_expression</A></SPAN> 
or <SPAN Class="swiss"><A HREF="AA-12-6.html#S0278">subprogram_default</A></SPAN>.</DIV>
<DIV Class="paranum">11</DIV>
<DIV Class="Normal">In a generic unit Legality Rules are enforced at 
compile time of the <SPAN Class="swiss"><A HREF="AA-12-1.html#S0252">generic_declaration</A></SPAN> 
and generic body, given the properties of the formals. In the visible 
part and formal part of an instance, Legality Rules are enforced at compile 
time of the <SPAN Class="swiss"><A HREF="AA-12-3.html#S0257">generic_instantiation</A></SPAN>, 
given the properties of the actuals. In other parts of an instance, Legality 
Rules are not enforced; this rule does not apply when a given rule explicitly 
specifies otherwise.&nbsp;</DIV>
<DIV Class="paranum">11.a/2</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00114.TXT">AI95-00114-01</A></I>} 
Since rules are checked using the properties of the formals, and since 
these properties do not always carry over to the actuals, we need to 
check the rules again in the visible part of the instance. For example, 
only if a tagged type is limited may an extension of it have limited 
components in the <SPAN class="insert2"><SPAN Class="swiss"><A HREF="AA-3-9-1.html#S0075">record_extension_part</A></SPAN></SPAN><SPAN class="delete2"><SPAN Class="swiss">&nbsp;extension_part</SPAN></SPAN>. 
A formal tagged limited type is limited, but the actual might be nonlimited. 
Hence any rule that requires a tagged type to be limited runs into this 
problem. Such rules are rare; in most cases, the rules for matching of 
formals and actuals guarantee that if the rule is obeyed in the generic 
unit, then it has to be obeyed in the instance.&nbsp;</DIV>
<DIV Class="paranum">11.b</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><B>Ramification: 
</B>The &ldquo;properties&rdquo; of the formals are determined without 
knowing anything about the actuals:&nbsp;</DIV>
<DIV Class="paranum">11.c/1</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>{<I><A HREF="defect2.html#8652/0095">8652/0095</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00034.TXT">AI95-00034-01</A></I>} 
A formal derived subtype is constrained if and only if the ancestor subtype 
is constrained. A formal array type is constrained if and only if the 
declarations <SPAN class="insert1">say</SPAN><SPAN class="delete1">&nbsp;says</SPAN> 
so.<SPAN class="insert1">&nbsp;A formal private type is constrained if it 
does not have a discriminant part.</SPAN> Other formal subtypes are unconstrained, 
even though they might be constrained in an instance.</LI></UL>
<DIV Class="paranum">11.d</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>A formal subtype can be indefinite, 
even though the copy might be definite in an instance.</LI></UL>
<DIV Class="paranum">11.e</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>A formal object of mode <B>in</B> 
is not a static constant; in an instance, the copy is static if the actual 
is.</LI></UL>
<DIV Class="paranum">11.f</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>A formal subtype is not static, 
even though the actual might be.</LI></UL>
<DIV Class="paranum">11.g</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>Formal types are specific, even 
though the actual can be class-wide.</LI></UL>
<DIV Class="paranum">11.h</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>The subtype of a formal object 
of mode <B>in out</B> is not static. (This covers the case of AI83-00878.)</LI></UL>
<DIV Class="paranum">11.i</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>The subtype of a formal parameter 
of a formal subprogram does not provide an applicable index constraint.</LI></UL>
<DIV Class="paranum">11.j</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>The profile of a formal subprogram 
is not subtype-conformant with any other profile. {<I>subtype conformance</I>} 
<A NAME="I4730"></A></LI></UL>
<DIV Class="paranum">11.k</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>A generic formal function is 
not static.&nbsp;</LI></UL>
<DIV Class="paranum">11.l</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><B>Ramification: 
</B>The exceptions to the above rule about when legality rules are enforced 
fall into these categories:&nbsp;</DIV>
<DIV Class="paranum">11.m</DIV>
<UL Class="SmallBulleted" Style="margin-bottom: 0.3em"><LI TYPE=DISC>Some 
rules are checked in the generic declaration, and then again in both 
the visible and private parts of the instance:&nbsp;</LI></UL>
<DIV Class="paranum">11.n</DIV>
<UL Class="SmallNestedBulleted"><LI TYPE=DISC>The parent type of a record 
extension has to be specific (see <A HREF="AA-3-9-1.html">3.9.1</A>). 
This rule is not checked in the instance body.</LI></UL>
<DIV Class="paranum">11.o</DIV>
<UL Class="SmallNestedBulleted"><LI TYPE=DISC>The parent type of a private 
extension has to be specific (see <A HREF="AA-7-3.html">7.3</A>). This 
rule is not checked in the instance body.</LI></UL>
<DIV Class="paranum">11.p/2</DIV>
<UL Class="SmallNestedBulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00402.TXT">AI95-00402-01</A></I>} 
A type with <SPAN class="insert2">a <SPAN Class="swiss"><A HREF="AA-3-7.html#S0063">default_expression</A></SPAN> 
of&nbsp;</SPAN>an access discriminant has to be a descendant of <SPAN class="insert2">an 
explicitly limited record type</SPAN><SPAN class="delete2">&nbsp;a type declared 
with <B>limited</B></SPAN>, or be a task or protected type. This rule 
is irrelevant in the instance body.]}</LI></UL>
<DIV Class="paranum">11.q</DIV>
<UL Class="SmallNestedBulleted"><LI TYPE=DISC>In the declaration of a 
record extension, if the parent type is nonlimited, then each of the 
components of the <SPAN Class="swiss"><A HREF="AA-3-9-1.html#S0075">record_extension_part</A></SPAN> 
have to be nonlimited (see <A HREF="AA-3-9-1.html">3.9.1</A>). In the 
generic body, this rule is checked in an assume-the-worst manner.</LI></UL>
<DIV Class="paranum">11.r</DIV>
<UL Class="SmallNestedBulleted"><LI TYPE=DISC>A preelaborated library 
unit has to be preelaborable (see <A HREF="AA-10-2-1.html">10.2.1</A>). 
In the generic body, this rule is checked in an assume-the-worst manner. 
</LI></UL>
<DIV Class="paranum">11.r.1/2</DIV>
<UL Class="SmallBulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00402.TXT">AI95-00402-01</A></I>} 
<SPAN class="insert2">The corrections made by the Corrigendum added a 
number of such rules, and the Amendment added many more. There doesn't 
seem to be much value in repeating all of these rules here (as of this 
writing, there are roughly 17 such rules). As noted below, all such rules 
are indexed in the AARM.</SPAN></UL>
<DIV Class="paranum">11.s</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>{<I>accessibility rule (checking 
in generic units)</I> [partial]} <A NAME="I4731"></A>For the accessibility 
rules, the formals have nothing to say about the property in question. 
Like the above rules, these rules are checked in the generic declaration, 
and then again in both the visible and private parts of the instance. 
In the generic body, we have explicit rules that essentially assume the 
worst (in the cases of type extensions and access-to-subprogram types), 
and we have run-time checks (in the case of access-to-object types). 
See <A HREF="AA-3-9-1.html">3.9.1</A>, <A HREF="AA-3-10-2.html">3.10.2</A>, 
and <A HREF="AA-4-6.html">4.6</A>.</LI></UL>
<DIV Class="paranum">11.t</DIV>
<UL Class="SmallBulleted">We considered run-time checks for access-to-subprogram 
types as well. However, this would present difficulties for implementations 
that share generic bodies.</UL>
<DIV Class="paranum">11.u</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>The rules requiring &ldquo;reasonable&rdquo; 
values for static expressions are ignored when the expected type for 
the expression is a descendant of a generic formal type other than a 
generic formal derived type, and do not apply in an instance.</LI></UL>
<DIV Class="paranum">11.v</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>The rule forbidding two explicit 
homographs in the same declarative region does not apply in an instance 
of a generic unit, except that it <I>does</I> apply in the declaration 
of a record extension that appears in the visible part of an instance.</LI></UL>
<DIV Class="paranum">11.w</DIV>
<UL Class="SmallBulleted" Style="margin-bottom: 0.3em"><LI TYPE=DISC>Some 
rules do not apply at all in an instance, not even in the visible part: 
</LI></UL>
<DIV Class="paranum">11.x</DIV>
<UL Class="SmallNestedBulleted"><LI TYPE=DISC><SPAN Class="swiss"><A HREF="AA-10-1-3.html#S0240">Body_stub</A></SPAN>s 
are not normally allowed to be multiply nested, but they can be in instances. 
</LI></UL>
<DIV Class="paranum">11.y</DIV>
<DIV Class="Annotations">{<I>generic contract issue</I> [distributed]} 
<A NAME="I4732"></A>Each rule that is an exception is marked with &ldquo;generic 
contract issue;&rdquo; look that up in the index to find them all.&nbsp;</DIV>
<DIV Class="paranum">11.z</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>The Legality Rules are 
the ones labeled Legality Rules. We are talking about all Legality Rules 
in the entire language here. Note that, with some exceptions, the legality 
of a generic unit is checked even if there are no instantiations of the 
generic unit.&nbsp;</DIV>
<DIV Class="paranum">11.aa</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>The Legality Rules are 
described here, and the overloading rules were described earlier in this 
clause. Presumably, every Static Semantic Item is sucked in by one of 
those. Thus, we have covered all the compile-time rules of the language. 
There is no need to say anything special about the Post-Compilation Rules 
or the Dynamic Semantic Items.&nbsp;</DIV>
<DIV Class="paranum">11.bb</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>Here is an example illustrating 
how this rule is checked: &ldquo;In the declaration of a record extension, 
if the parent type is nonlimited, then each of the components of the 
<SPAN Class="swiss"><A HREF="AA-3-9-1.html#S0075">record_extension_part</A></SPAN> 
shall be nonlimited.&rdquo;&nbsp;</DIV>
<DIV Class="paranum">11.cc</DIV>
<DIV Class="SmallExamples"><B>generic</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Parent&nbsp;<B>is</B>&nbsp;<B>tagged</B>&nbsp;<B>private</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Comp&nbsp;<B>is</B>&nbsp;<B>limited</B>&nbsp;<B>private</B>;<BR>
<B>package</B>&nbsp;G1&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Extension&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Parent&nbsp;<B>with</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>record</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C&nbsp;:&nbsp;Comp;&nbsp;--<SPAN Class="roman"><I>&nbsp;Illegal!</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;<B>record</B>;<BR>
<B>end</B>&nbsp;G1;</DIV>
<DIV Class="paranum">11.dd/1</DIV>
<DIV Class="Annotations">The parent type is nonlimited, and the component 
type is limited, which is illegal. It doesn't matter that <SPAN class="delete1">an 
</SPAN>one could imagine writing an instantiation with the actual for 
Comp being nonlimited &mdash; we never get to the instance, because the 
generic itself is illegal.</DIV>
<DIV Class="paranum">11.ee</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em">On the other hand: 
</DIV>
<DIV Class="paranum">11.ff</DIV>
<DIV Class="SmallExamples"><B>generic</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Parent&nbsp;<B>is</B>&nbsp;<B>tagged</B>&nbsp;<B>limited</B>&nbsp;<B>private</B>;&nbsp;--<SPAN Class="roman"><I>&nbsp;Parent&nbsp;is&nbsp;limited.</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Comp&nbsp;<B>is</B>&nbsp;<B>limited</B>&nbsp;<B>private</B>;<BR>
<B>package</B>&nbsp;G2&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Extension&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Parent&nbsp;<B>with</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>record</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C&nbsp;:&nbsp;Comp;&nbsp;--<SPAN Class="roman"><I>&nbsp;OK.</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;<B>record</B>;<BR>
<B>end</B>&nbsp;G2;</DIV>
<DIV Class="paranum">11.gg</DIV>
<DIV Class="SmallExamples"><B>type</B>&nbsp;Limited_Tagged&nbsp;<B>is</B>&nbsp;<B>tagged</B>&nbsp;<B>limited</B>&nbsp;<B>null</B>&nbsp;<B>record</B>;<BR>
<B>type</B>&nbsp;Non_Limited_Tagged&nbsp;<B>is</B>&nbsp;<B>tagged</B>&nbsp;<B>null</B>&nbsp;<B>record</B>;</DIV>
<DIV Class="paranum">11.hh</DIV>
<DIV Class="SmallExamples"><B>type</B>&nbsp;Limited_Untagged&nbsp;<B>is</B>&nbsp;<B>limited</B>&nbsp;<B>null</B>&nbsp;<B>record</B>;<BR>
<B>type</B>&nbsp;Non_Limited_Untagged&nbsp;<B>is</B>&nbsp;<B>null</B>&nbsp;<B>record</B>;</DIV>
<DIV Class="paranum">11.ii</DIV>
<DIV Class="SmallExamples"><B>package</B>&nbsp;Good_1&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;G2(Parent&nbsp;=&gt;&nbsp;Limited_Tagged,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Comp&nbsp;=&gt;&nbsp;Limited_Untagged);<BR>
<B>package</B>&nbsp;Good_2&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;G2(Parent&nbsp;=&gt;&nbsp;Non_Limited_Tagged,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Comp&nbsp;=&gt;&nbsp;Non_Limited_Untagged);<BR>
<B>package</B>&nbsp;Bad&nbsp;&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;G2(Parent&nbsp;=&gt;&nbsp;Non_Limited_Tagged,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Comp&nbsp;=&gt;&nbsp;Limited_Untagged);&nbsp;--<SPAN Class="roman"><I>&nbsp;Illegal!</I></SPAN></DIV>
<DIV Class="paranum">11.jj</DIV>
<DIV Class="Annotations">The first instantiation is legal, because in 
the instance the parent is limited, so the rule is not violated. Likewise, 
in the second instantiation, the rule is not violated in the instance. 
However, in the Bad instance, the parent type is nonlimited, and the 
component type is limited, so this instantiation is illegal.&nbsp;</DIV>

<H4 Class="centered">Static Semantics</H4>
<DIV Class="paranum">12</DIV>
<DIV Class="Normal">A <SPAN Class="swiss"><A HREF="AA-12-3.html#S0257">generic_instantiation</A></SPAN> 
declares an instance; it is equivalent to the instance declaration (a 
<SPAN Class="swiss"><A HREF="AA-7-1.html#S0173">package_declaration</A></SPAN> 
or <SPAN Class="swiss"><A HREF="AA-6-1.html#S0148">subprogram_declaration</A></SPAN>) 
immediately followed by the instance body, both at the place of the instantiation. 
</DIV>
<DIV Class="paranum">12.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>The declaration and the 
body of the instance are not &ldquo;implicit&rdquo; in the technical 
sense, even though you can't see them in the program text. Nor are declarations 
within an instance &ldquo;implicit&rdquo; (unless they are implicit by 
other rules). This is necessary because implicit declarations have special 
semantics that should not be attached to instances. For a generic subprogram, 
the profile of a <SPAN Class="swiss"><A HREF="AA-12-3.html#S0257">generic_instantiation</A></SPAN> 
is that of the instance declaration, by the stated equivalence.&nbsp;</DIV>
<DIV Class="paranum">12.b</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>{<I>visible part (of an 
instance)</I> [partial]} <A NAME="I4733"></A>{<I>private part (of a package)</I> 
[partial]} <A NAME="I4734"></A>The visible and private parts of a package 
instance are defined in <A HREF="AA-7-1.html">7.1</A>, &ldquo;<A HREF="AA-7-1.html">Package 
Specifications and Declarations</A>&rdquo; and <A HREF="AA-12-7.html">12.7</A>, 
&ldquo;<A HREF="AA-12-7.html">Formal Packages</A>&rdquo;. The visible 
and private parts of a subprogram instance are defined in <A HREF="AA-8-2.html">8.2</A>, 
&ldquo;<A HREF="AA-8-2.html">Scope of Declarations</A>&rdquo;.&nbsp;</DIV>
<DIV Class="paranum">13</DIV>
<DIV Class="Normal">The instance is a copy of the text of the template. 
[Each use of a formal parameter becomes (in the copy) a use of the actual, 
as explained below.] <SPAN STYLE="font-size: 80%">{<I>package instance</I>}</SPAN> 
<A NAME="I4735"></A><SPAN STYLE="font-size: 80%">{<I>subprogram instance</I>}</SPAN> 
<A NAME="I4736"></A><SPAN STYLE="font-size: 80%">{<I>procedure instance</I>}</SPAN> 
<A NAME="I4737"></A><SPAN STYLE="font-size: 80%">{<I>function instance</I>}</SPAN> 
<A NAME="I4738"></A><SPAN STYLE="font-size: 80%">{<I>instance (of a generic 
package)</I>}</SPAN> <A NAME="I4739"></A><SPAN STYLE="font-size: 80%">{<I>instance 
(of a generic subprogram)</I>}</SPAN> <A NAME="I4740"></A><SPAN STYLE="font-size: 80%">{<I>instance 
(of a generic procedure)</I>}</SPAN> <A NAME="I4741"></A><SPAN STYLE="font-size: 80%">{<I>instance 
(of a generic function)</I>}</SPAN> <A NAME="I4742"></A>An instance of 
a generic package is a package, that of a generic procedure is a procedure, 
and that of a generic function is a function.&nbsp;</DIV>
<DIV Class="paranum">13.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>An instance is a package 
or subprogram (because we say so), even though it contains a copy of 
the <SPAN Class="swiss"><A HREF="AA-12-1.html#S0255">generic_formal_part</A></SPAN>, 
and therefore doesn't look like one. This is strange, but it's OK, since 
the syntax rules are overloading rules, and therefore do not apply in 
an instance.&nbsp;</DIV>
<DIV Class="paranum">13.b</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>We use a macro-expansion 
model, with some explicitly-stated exceptions (see below). The main exception 
is that the interpretation of each construct in a generic unit (especially 
including the denotation of each name) is determined when the declaration 
and body of the generic unit (as opposed to the instance) are compiled, 
and in each instance this interpretation is (a copy of) the template 
interpretation. In other words, if a construct is interpreted as a <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
denoting a declaration D, then in an instance, the copy of the construct 
will still be a name, and will still denote D (or a copy of D). From 
an implementation point of view, overload resolution is performed on 
the template, and not on each copy.</DIV>
<DIV Class="paranum">13.c</DIV>
<DIV Class="Annotations">We describe the substitution of generic actual 
parameters by saying (in most cases) that the copy of each generic formal 
parameter declares a view of the actual. Suppose a name in a generic 
unit denotes a <SPAN Class="swiss"><A HREF="AA-12-1.html#S0256">generic_formal_parameter_declaration</A></SPAN>. 
The copy of that name in an instance will denote the copy of that <SPAN Class="swiss"><A HREF="AA-12-1.html#S0256">generic_formal_parameter_declaration</A></SPAN> 
in the instance. Since the <SPAN Class="swiss"><A HREF="AA-12-1.html#S0256">generic_formal_parameter_declaration</A></SPAN> 
in the instance declares a view of the actual, the name will denote a 
view of the actual.</DIV>
<DIV Class="paranum">13.d/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00442.TXT">AI95-00442-01</A></I>} 
Other properties of the copy (for example, staticness, <SPAN class="insert2">categories</SPAN><SPAN class="delete2">&nbsp;classes</SPAN> 
to which types belong) are recalculated for each instance; this is implied 
by the fact that it's a copy.</DIV>
<DIV Class="paranum">13.e/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00317.TXT">AI95-00317-01</A></I>} 
Although the <SPAN Class="swiss"><A HREF="AA-12-1.html#S0255">generic_formal_part</A></SPAN> 
is included in an instance, the declarations in the <SPAN Class="swiss"><A HREF="AA-12-1.html#S0255">generic_formal_part</A></SPAN> 
are only visible outside the instance in the case of a generic formal 
package whose <SPAN Class="swiss"><A HREF="AA-12-7.html#S0281">formal_package_actual_part</A></SPAN> 
<SPAN class="insert2">includes one or more &lt;&gt; indicators</SPAN><SPAN class="delete2">&nbsp;is 
(&lt;&gt;)</SPAN> &mdash; see <A HREF="AA-12-7.html">12.7</A>.&nbsp;</DIV>
<DIV Class="paranum">14</DIV>
<DIV Class="Normal">The interpretation of each construct within a generic 
declaration or body is determined using the overloading rules when that 
generic declaration or body is compiled. In an instance, the interpretation 
of each (copied) construct is the same, except in the case of a name 
that denotes the <SPAN Class="swiss"><A HREF="AA-12-1.html#S0252">generic_declaration</A></SPAN> 
or some declaration within the generic unit; the corresponding name in 
the instance then denotes the corresponding copy of the denoted declaration. 
The overloading rules do not apply in the instance.&nbsp;</DIV>
<DIV Class="paranum">14.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>See <A HREF="AA-8-6.html">8.6</A>, 
&ldquo;<A HREF="AA-8-6.html">The Context of Overload Resolution</A>&rdquo; 
for definitions of &ldquo;interpretation&rdquo; and &ldquo;overloading 
rule.&rdquo;</DIV>
<DIV Class="paranum">14.b</DIV>
<DIV Class="Annotations">Even the <SPAN Class="swiss"><A HREF="AA-12-1.html#S0256">generic_formal_parameter_declaration</A></SPAN>s 
have corresponding declarations in the instance, which declare views 
of the actuals.</DIV>
<DIV Class="paranum">14.c</DIV>
<DIV Class="Annotations">Although the declarations in the instance are 
copies of those in the generic unit, they often have quite different 
properties, as explained below. For example a constant declaration in 
the generic unit might declare a nonstatic constant, whereas the copy 
of that declaration might declare a static constant. This can happen 
when the staticness depends on some generic formal.</DIV>
<DIV Class="paranum">14.d</DIV>
<DIV Class="Annotations">This rule is partly a ramification of the &ldquo;current 
instance&rdquo; rule in <A HREF="AA-8-6.html">8.6</A>, &ldquo;<A HREF="AA-8-6.html">The 
Context of Overload Resolution</A>&rdquo;. Note that that rule doesn't 
cover the <SPAN Class="swiss"><A HREF="AA-12-1.html#S0255">generic_formal_part</A></SPAN>.</DIV>
<DIV Class="paranum">14.e</DIV>
<DIV Class="Annotations">Although the overloading rules are not observed 
in the instance, they are, of course, observed in the <SPAN Class="swiss">_instantiation</SPAN> 
in order to determine the interpretation of the constituents of the <SPAN Class="swiss">_instantiation</SPAN>.</DIV>
<DIV Class="paranum">14.f</DIV>
<DIV Class="Annotations">Since children are considered to occur within 
their parent's declarative region, the above rule applies to a name that 
denotes a child of a generic unit, or a declaration inside such a child.</DIV>
<DIV Class="paranum">14.g</DIV>
<DIV Class="Annotations">Since the Syntax Rules are overloading rules, 
it is possible (legal) to violate them in an instance. For example, it 
is possible for an instance body to occur in a <SPAN Class="swiss"><A HREF="AA-7-1.html#S0174">package_specification</A></SPAN>, 
even though the Syntax Rules forbid bodies in <SPAN Class="swiss"><A HREF="AA-7-1.html#S0174">package_specification</A></SPAN>s. 
</DIV>
<DIV Class="paranum">15</DIV>
<DIV Class="Normal">In an instance, a <SPAN Class="swiss"><A HREF="AA-12-1.html#S0256">generic_formal_parameter_declaration</A></SPAN> 
declares a view whose properties are identical to those of the actual, 
except as specified in <A HREF="AA-12-4.html">12.4</A>, &ldquo;<A HREF="AA-12-4.html">Formal 
Objects</A>&rdquo; and <A HREF="AA-12-6.html">12.6</A>, &ldquo;<A HREF="AA-12-6.html">Formal 
Subprograms</A>&rdquo;. Similarly, for a declaration within a <SPAN Class="swiss"><A HREF="AA-12-1.html#S0256">generic_formal_parameter_declaration</A></SPAN>, 
the corresponding declaration in an instance declares a view whose properties 
are identical to the corresponding declaration within the declaration 
of the actual.&nbsp;</DIV>
<DIV Class="paranum">15.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>In an instance, there are 
no &ldquo;properties&rdquo; of types and subtypes that come from the 
formal. The primitive operations of the type come from the formal, but 
these are declarations in their own right, and are therefore handled 
separately.</DIV>
<DIV Class="paranum">15.b</DIV>
<DIV Class="Annotations">Note that certain properties that come from 
the actuals are irrelevant in the instance. For example, if an actual 
type is of a class deeper in the derived-type hierarchy than the formal, 
it is impossible to call the additional operations of the deeper class 
in the instance, because any such call would have to be a copy of some 
corresponding call in the generic unit, which would have been illegal. 
However, it is sometimes possible to reach into the specification of 
the instance from outside, and notice such properties. For example, one 
could pass an object declared in the instance specification to one of 
the additional operations of the deeper type.</DIV>
<DIV Class="paranum">15.c/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00114.TXT">AI95-00114-01</A></I>} 
A <SPAN Class="swiss"><A HREF="AA-12-5.html#S0262">formal_type_declaration</A></SPAN> 
can contain <SPAN Class="swiss"><A HREF="AA-3-7.html#S0062">discriminant_specification</A></SPAN>s, 
a <SPAN Class="swiss"><A HREF="AA-12-6.html#S0275">formal_subprogram_declaration</A></SPAN> 
can contain <SPAN class="insert2"><SPAN Class="swiss"><A HREF="AA-6-1.html#S0160">parameter_specification</A></SPAN>s</SPAN><SPAN class="delete2"><SPAN Class="swiss">&nbsp;formal_parameter_specification</SPAN>s</SPAN>, 
and a <SPAN Class="swiss"><A HREF="AA-12-7.html#S0280">formal_package_declaration</A></SPAN> 
can contain many kinds of declarations. These are all inside the generic 
unit, and have corresponding declarations in the instance.</DIV>
<DIV Class="paranum">15.d</DIV>
<DIV Class="Annotations">This rule implies, for example, that if a subtype 
in a generic unit is a subtype of a generic formal subtype, then the 
corresponding subtype in the instance is a subtype of the corresponding 
actual subtype.</DIV>
<DIV Class="paranum">15.e</DIV>
<DIV Class="Annotations">For a <SPAN Class="swiss"><A HREF="AA-12-3.html#S0257">generic_instantiation</A></SPAN>, 
if a generic actual is a static [(scalar or string)] subtype, then each 
use of the corresponding formal parameter within the specification of 
the instance is considered to be static. (See AI83-00409.)</DIV>
<DIV Class="paranum">15.f</DIV>
<DIV Class="Annotations">Similarly, if a generic actual is a static expression 
and the corresponding formal parameter has a static [(scalar or string)] 
subtype, then each use of the formal parameter in the specification of 
the instance is considered to be static. (See AI83-00505.)</DIV>
<DIV Class="paranum">15.g</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em">If a primitive 
subprogram of a type derived from a generic formal derived tagged type 
is not overriding (that is, it is a new subprogram), it is possible for 
the copy of that subprogram in an instance to override a subprogram inherited 
from the actual. For example:&nbsp;</DIV>
<DIV Class="paranum">15.h</DIV>
<DIV Class="SmallExamples"><B>type</B>&nbsp;T1&nbsp;<B>is</B>&nbsp;<B>tagged</B>&nbsp;<B>record</B>&nbsp;...&nbsp;<B>end</B>&nbsp;<B>record</B>;</DIV>
<DIV Class="paranum">15.i</DIV>
<DIV Class="SmallExamples"><B>generic</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Formal&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;T1;<BR>
<B>package</B>&nbsp;G&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Derived_From_Formal&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Formal&nbsp;<B>with</B>&nbsp;<B>record</B>&nbsp;...&nbsp;<B>end</B>&nbsp;<B>record</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Foo(X&nbsp;:&nbsp;<B>in</B>&nbsp;Derived_From_Formal);&nbsp;--<SPAN Class="roman"><I>&nbsp;Does&nbsp;not&nbsp;override&nbsp;anything.</I></SPAN><BR>
<B>end</B>&nbsp;G;</DIV>
<DIV Class="paranum">15.j</DIV>
<DIV Class="SmallExamples"><B>type</B>&nbsp;T2&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;T1&nbsp;<B>with</B>&nbsp;<B>record</B>&nbsp;...&nbsp;<B>end</B>&nbsp;<B>record</B>;<BR>
<B>procedure</B>&nbsp;Foo(X&nbsp;:&nbsp;<B>in</B>&nbsp;T2);</DIV>
<DIV Class="paranum">15.k</DIV>
<DIV Class="SmallExamples"><B>package</B>&nbsp;Inst&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;G(Formal&nbsp;=&gt;&nbsp;T2);</DIV>
<DIV Class="paranum">15.l</DIV>
<DIV Class="Annotations">In the instance Inst, the declaration of Foo 
for Derived_From_Formal overrides the Foo inherited from T2.&nbsp;</DIV>
<DIV Class="paranum">15.m/1</DIV>
<DIV Class="Annotations"><B>Implementation Note:&nbsp;</B>{<I><A HREF="defect1.html#8652/0009">8652/0009</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00137.TXT">AI95-00137-01</A></I>} 
For formal types, an implementation that shares the code among multiple 
instances of the same generic unit needs to beware that things like parameter 
passing mechanisms (by-copy vs. by-reference) and <SPAN class="insert1"><SPAN Class="swiss"><A HREF="AA-13-1.html#S0283">aspect_clause</A></SPAN>s</SPAN><SPAN class="delete1"><SPAN Class="swiss"><A HREF="AA-13-1.html#S0284">&nbsp;representation_clause</A></SPAN>s</SPAN> 
are determined by the actual.&nbsp;</DIV>
<DIV Class="paranum">16</DIV>
<DIV Class="Normal">[Implicit declarations are also copied, and a name 
that denotes an implicit declaration in the generic denotes the corresponding 
copy in the instance. However, for a type declared within the visible 
part of the generic, a whole new set of primitive subprograms is implicitly 
declared for use outside the instance, and may differ from the copied 
set if the properties of the type in some way depend on the properties 
of some actual type specified in the instantiation. For example, if the 
type in the generic is derived from a formal private type, then in the 
instance the type will inherit subprograms from the corresponding actual 
type.</DIV>
<DIV Class="paranum">17</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>override</I>}</SPAN> 
<A NAME="I4743"></A>These new implicit declarations occur immediately 
after the type declaration in the instance, and override the copied ones. 
The copied ones can be called only from within the instance; the new 
ones can be called only from outside the instance, although for tagged 
types, the body of a new one can be executed by a call to an old one.] 
</DIV>
<DIV Class="paranum">17.a</DIV>
<DIV Class="Annotations"><B>Proof:&nbsp;</B>This rule is stated officially 
in <A HREF="AA-8-3.html">8.3</A>, &ldquo;<A HREF="AA-8-3.html">Visibility</A>&rdquo;. 
</DIV>
<DIV Class="paranum">17.b</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>The new ones follow from 
the class(es) of the formal types. For example, for a type T derived 
from a generic formal private type, if the actual is Integer, then the 
copy of T in the instance has a &quot;+&quot; primitive operator, which 
can be called from outside the instance (assuming T is declared in the 
visible part of the instance).</DIV>
<DIV Class="paranum">17.c</DIV>
<DIV Class="Annotations">AI83-00398.</DIV>
<DIV Class="paranum">17.d/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00442.TXT">AI95-00442-01</A></I>} 
Since an actual type is always in the <SPAN class="insert2">category</SPAN><SPAN class="delete2">&nbsp;class</SPAN> 
determined for the formal, the new subprograms hide all of the copied 
ones, except for a declaration of &quot;/=&quot; that corresponds to 
an explicit declaration of &quot;=&quot;. Such &quot;/=&quot; operators 
are special, because unlike other implicit declarations of primitive 
subprograms, they do not appear by virtue of the class, but because of 
an explicit declaration of &quot;=&quot;. If the declaration of &quot;=&quot; 
is implicit (and therefore overridden in the instance), then a corresponding 
implicitly declared &quot;/=&quot; is also overridden. But if the declaration 
of &quot;=&quot; is explicit (and therefore not overridden in the instance), 
then a corresponding implicitly declared &quot;/=&quot; is not overridden 
either, even though it's implicit.</DIV>
<DIV Class="paranum">17.e</DIV>
<DIV Class="Annotations">Note that the copied ones can be called from 
inside the instance, even though they are hidden from all visibility, 
because the names are resolved in the generic unit &mdash; visibility 
is irrelevant for calls in the instance.&nbsp;</DIV>
<DIV Class="paranum">18</DIV>
<DIV Class="Normal">[In the visible part of an instance, an explicit 
declaration overrides an implicit declaration if they are homographs, 
as described in <A HREF="AA-8-3.html">8.3</A>.] On the other hand, an 
explicit declaration in the private part of an instance overrides an 
implicit declaration in the instance, only if the corresponding explicit 
declaration in the generic overrides a corresponding implicit declaration 
in the generic. Corresponding rules apply to the other kinds of overriding 
described in <A HREF="AA-8-3.html">8.3</A>.&nbsp;</DIV>
<DIV Class="paranum">18.a</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><B>Ramification: 
</B>For example:&nbsp;</DIV>
<DIV Class="paranum">18.b</DIV>
<DIV Class="SmallExamples"><B>type</B>&nbsp;Ancestor&nbsp;<B>is</B>&nbsp;<B>tagged</B>&nbsp;<B>null</B>&nbsp;<B>record</B>;</DIV>
<DIV Class="paranum">18.c</DIV>
<DIV Class="SmallExamples"><B>generic</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Formal&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Ancestor&nbsp;<B>with</B>&nbsp;<B>private</B>;<BR>
<B>package</B>&nbsp;G&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Formal&nbsp;<B>with</B>&nbsp;<B>null</B>&nbsp;<B>record</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;P(X&nbsp;:&nbsp;<B>in</B>&nbsp;T);&nbsp;--<SPAN Class="roman"><I>&nbsp;(1)</I></SPAN><BR>
<B>private</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Q(X&nbsp;:&nbsp;<B>in</B>&nbsp;T);&nbsp;--<SPAN Class="roman"><I>&nbsp;(2)</I></SPAN><BR>
<B>end</B>&nbsp;G;</DIV>
<DIV Class="paranum">18.d</DIV>
<DIV Class="SmallExamples"><B>type</B>&nbsp;Actual&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Ancestor&nbsp;<B>with</B>&nbsp;<B>null</B>&nbsp;<B>record</B>;<BR>
<B>procedure</B>&nbsp;P(X&nbsp;:&nbsp;<B>in</B>&nbsp;Actual);<BR>
<B>procedure</B>&nbsp;Q(X&nbsp;:&nbsp;<B>in</B>&nbsp;Actual);</DIV>
<DIV Class="paranum">18.e</DIV>
<DIV Class="SmallExamples"><B>package</B>&nbsp;Instance&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;G(Formal&nbsp;=&gt;&nbsp;Actual);</DIV>
<DIV Class="paranum">18.f</DIV>
<DIV Class="Annotations">In the instance, the copy of P at (1) overrides 
Actual's P, whereas the copy of Q at (2) does not override anything; 
in implementation terms, it occupies a separate slot in the type descriptor. 
</DIV>
<DIV Class="paranum">18.g</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>The reason for this rule is so 
a programmer writing an <SPAN Class="swiss">_instantiation</SPAN> need 
not look at the private part of the generic in order to determine which 
subprograms will be overridden.&nbsp;</DIV>

<H4 Class="centered">Post-Compilation Rules</H4>
<DIV Class="paranum">19</DIV>
<DIV Class="Normal">Recursive generic instantiation is not allowed in 
the following sense: if a given generic unit includes an instantiation 
of a second generic unit, then the instance generated by this instantiation 
shall not include an instance of the first generic unit [(whether this 
instance is generated directly, or indirectly by intermediate instantiations)]. 
</DIV>
<DIV Class="paranum">19.a</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>Note that this rule is not 
a violation of the generic contract model, because it is not a Legality 
Rule. Some implementations may be able to check this rule at compile 
time, but that requires access to all the bodies, so we allow implementations 
to check the rule at link time.&nbsp;</DIV>

<H4 Class="centered">Dynamic Semantics</H4>
<DIV Class="paranum">20</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>elaboration (generic_instantiation)</I> 
[partial]}</SPAN> <A NAME="I4744"></A>For the elaboration of a <SPAN Class="swiss"><A HREF="AA-12-3.html#S0257">generic_instantiation</A></SPAN>, 
each <SPAN Class="swiss"><A HREF="AA-12-3.html#S0259">generic_association</A></SPAN> 
is first evaluated. If a default is used, an implicit <SPAN Class="swiss"><A HREF="AA-12-3.html#S0259">generic_association</A></SPAN> 
is assumed for this rule. These evaluations are done in an arbitrary 
order, except that the evaluation for a default actual takes place after 
the evaluation for another actual if the default includes a <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
that denotes the other one. Finally, the instance declaration and body 
are elaborated.&nbsp;</DIV>
<DIV Class="paranum">20.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>Note that if the evaluation 
of a default depends on some side-effect of some other evaluation, the 
order is still arbitrary.&nbsp;</DIV>
<DIV Class="paranum">21</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>evaluation (generic_association)</I> 
[partial]}</SPAN> <A NAME="I4745"></A>For the evaluation of a <SPAN Class="swiss"><A HREF="AA-12-3.html#S0259">generic_association</A></SPAN> 
the generic actual parameter is evaluated. Additional actions are performed 
in the case of a formal object of mode <B>in</B> (see <A HREF="AA-12-4.html">12.4</A>). 
</DIV>
<DIV Class="paranum">21.a</DIV>
<DIV Class="Annotations"><B>To be honest:&nbsp;</B>Actually, the actual is 
evaluated only if evaluation is defined for that kind of construct &mdash; 
we don't actually &ldquo;evaluate&rdquo; <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0028">subtype_mark</A></SPAN>s. 
</DIV>
<DIV Class="NotesHeader">NOTES</DIV>
<DIV Class="paranum">22</DIV>
<DIV Class="Notes">5&nbsp;&nbsp;If a formal type is not tagged, then 
the type is treated as an untagged type within the generic body. Deriving 
from such a type in a generic body is permitted; the new type does not 
get a new tag value, even if the actual is tagged. Overriding operations 
for such a derived type cannot be dispatched to from outside the instance. 
</DIV>
<DIV Class="paranum">22.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>If two overloaded subprograms 
declared in a generic package specification differ only by the (formal) 
type of their parameters and results, then there exist legal instantiations 
for which all calls of these subprograms from outside the instance are 
ambiguous. For example:&nbsp;</DIV>
<DIV Class="paranum">22.b</DIV>
<DIV Class="SmallExamples"><B>generic</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;A&nbsp;<B>is</B>&nbsp;(&lt;&gt;);<BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;B&nbsp;<B>is</B>&nbsp;<B>private</B>;<BR>
<B>package</B>&nbsp;G&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;Next(X&nbsp;:&nbsp;A)&nbsp;<B>return</B>&nbsp;A;<BR>
&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;Next(X&nbsp;:&nbsp;B)&nbsp;<B>return</B>&nbsp;B;<BR>
<B>end</B>&nbsp;G;</DIV>
<DIV Class="paranum">22.c</DIV>
<DIV Class="SmallExamples"><B>package</B>&nbsp;P&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;G(A&nbsp;=&gt;&nbsp;Boolean,&nbsp;B&nbsp;=&gt;&nbsp;Boolean);<BR>
--<SPAN Class="roman"><I>&nbsp;All&nbsp;calls&nbsp;of&nbsp;P.Next&nbsp;are&nbsp;ambiguous.</I></SPAN></DIV>
<DIV Class="paranum">22.d</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><B>Ramification: 
</B>The following example illustrates some of the subtleties of the substitution 
of formals and actuals:&nbsp;</DIV>
<DIV Class="paranum">22.e</DIV>
<DIV Class="SmallExamples"><B>generic</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T1&nbsp;<B>is</B>&nbsp;<B>private</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;A&nbsp;predefined&nbsp;&quot;=&quot;&nbsp;operator&nbsp;is&nbsp;implicitly&nbsp;declared&nbsp;here:</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;function&nbsp;&quot;=&quot;(Left,&nbsp;Right&nbsp;:&nbsp;T1)&nbsp;return&nbsp;Boolean;</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;Call&nbsp;this&nbsp;&quot;=&quot;</I><SUB><SPAN STYLE="font-size: 140%"><SPAN STYLE="font-size: 64%"><I>1</I></SPAN></SPAN></SUB><I>.</I></SPAN><BR>
<B>package</B>&nbsp;G&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>subtype</B>&nbsp;S1&nbsp;<B>is</B>&nbsp;T1;&nbsp;--<SPAN Class="roman"><I>&nbsp;So&nbsp;we&nbsp;can&nbsp;get&nbsp;our&nbsp;hands&nbsp;on&nbsp;the&nbsp;type&nbsp;from</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;outside&nbsp;an&nbsp;instance.</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T2&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;T1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;An&nbsp;inherited&nbsp;&quot;=&quot;&nbsp;operator&nbsp;is&nbsp;implicitly&nbsp;declared&nbsp;here:</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;function&nbsp;&quot;=&quot;(Left,&nbsp;Right&nbsp;:&nbsp;T2)&nbsp;return&nbsp;Boolean;</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;Call&nbsp;this&nbsp;&quot;=&quot;</I><SUB><SPAN STYLE="font-size: 140%"><SPAN STYLE="font-size: 64%"><I>2</I></SPAN></SPAN></SUB><I>.</I></SPAN></DIV>
<DIV Class="paranum">22.f</DIV>
<DIV Class="SmallExamples">&nbsp;&nbsp;&nbsp;&nbsp;T1_Obj&nbsp;:&nbsp;T1&nbsp;:=&nbsp;...;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Bool_1&nbsp;:&nbsp;Boolean&nbsp;:=&nbsp;T1_Obj&nbsp;=&nbsp;T1_Obj;</DIV>
<DIV Class="paranum">22.g</DIV>
<DIV Class="SmallExamples">&nbsp;&nbsp;&nbsp;&nbsp;T2_Obj&nbsp;:&nbsp;T2&nbsp;:=&nbsp;...;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Bool_2&nbsp;:&nbsp;Boolean&nbsp;:=&nbsp;T2_Obj&nbsp;=&nbsp;T2_Obj;<BR>
<B>end</B>&nbsp;G;<BR>
...</DIV>
<DIV Class="paranum">22.h</DIV>
<DIV Class="SmallExamples"><B>package</B>&nbsp;P&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;My_Int&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Integer;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;A&nbsp;predefined&nbsp;&quot;=&quot;&nbsp;operator&nbsp;is&nbsp;implicitly&nbsp;declared&nbsp;here:</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;function&nbsp;&quot;=&quot;(Left,&nbsp;Right&nbsp;:&nbsp;My_Int)&nbsp;return&nbsp;Boolean;</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;Call&nbsp;this&nbsp;&quot;=&quot;</I><SUB><SPAN STYLE="font-size: 140%"><SPAN STYLE="font-size: 64%"><I>3</I></SPAN></SPAN></SUB><I>.</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;&quot;=&quot;(X,&nbsp;Y&nbsp;:&nbsp;My_Int)&nbsp;<B>return</B>&nbsp;Boolean;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;Call&nbsp;this&nbsp;&quot;=&quot;</I><SUB><SPAN STYLE="font-size: 140%"><SPAN STYLE="font-size: 64%"><I>4</I></SPAN></SPAN></SUB><I>.</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;&quot;=&quot;</I><SUB><SPAN STYLE="font-size: 140%"><SPAN STYLE="font-size: 64%"><I>3</I></SPAN></SPAN></SUB><I>&nbsp;is&nbsp;hidden&nbsp;from&nbsp;all&nbsp;visibility&nbsp;by&nbsp;&quot;=&quot;</I><SUB><SPAN STYLE="font-size: 140%"><SPAN STYLE="font-size: 64%"><I>4</I></SPAN></SPAN></SUB><I>.</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;Nonetheless,&nbsp;&quot;=&quot;</I><SUB><SPAN STYLE="font-size: 140%"><SPAN STYLE="font-size: 64%"><I>3</I></SPAN></SPAN></SUB><I>&nbsp;can&nbsp;&ldquo;reemerge&rdquo;&nbsp;in&nbsp;certain&nbsp;circumstances.</I></SPAN><BR>
<B>end</B>&nbsp;P;<BR>
<B>use</B>&nbsp;P;<BR>
...<BR>
<B>package</B>&nbsp;I&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;G(T1&nbsp;=&gt;&nbsp;My_Int);&nbsp;--<SPAN Class="roman"><I>&nbsp;&quot;=&quot;</I><SUB><SPAN STYLE="font-size: 140%"><SPAN STYLE="font-size: 64%"><I>5</I></SPAN></SPAN></SUB><I>&nbsp;is&nbsp;declared&nbsp;in&nbsp;I&nbsp;(see&nbsp;below).</I></SPAN><BR>
<B>use</B>&nbsp;I;</DIV>
<DIV Class="paranum">22.i</DIV>
<DIV Class="SmallExamples">Another_T1_Obj&nbsp;:&nbsp;S1&nbsp;:=&nbsp;13;&nbsp;--<SPAN Class="roman"><I>&nbsp;Can't&nbsp;denote&nbsp;T1,&nbsp;but&nbsp;S1&nbsp;will&nbsp;do.</I></SPAN><BR>
Bool_3&nbsp;:&nbsp;Boolean&nbsp;:=&nbsp;Another_T1_Obj&nbsp;=&nbsp;Another_T1_Obj;</DIV>
<DIV Class="paranum">22.j</DIV>
<DIV Class="SmallExamples">Another_T2_Obj&nbsp;:&nbsp;T2&nbsp;:=&nbsp;45;<BR>
Bool_4&nbsp;:&nbsp;Boolean&nbsp;:=&nbsp;Another_T2_Obj&nbsp;=&nbsp;Another_T2_Obj;</DIV>
<DIV Class="paranum">22.k</DIV>
<DIV Class="SmallExamples">Double&nbsp;:&nbsp;T2&nbsp;:=&nbsp;T2_Obj&nbsp;+&nbsp;Another_T2_Obj;</DIV>
<DIV Class="paranum">22.l</DIV>
<DIV Class="Annotations">In the instance I, there is a copy of &quot;=&quot;<SUB><SPAN STYLE="font-size: 140%"><SPAN STYLE="font-size: 64%">1</SPAN></SPAN></SUB> 
(call it &quot;=&quot;<SUB><SPAN STYLE="font-size: 140%"><SPAN STYLE="font-size: 64%">1i</SPAN></SPAN></SUB>) 
and &quot;=&quot;<SUB><SPAN STYLE="font-size: 140%"><SPAN STYLE="font-size: 64%">2</SPAN></SPAN></SUB> 
(call it &quot;=&quot;<SUB><SPAN STYLE="font-size: 140%"><SPAN STYLE="font-size: 64%">2i</SPAN></SPAN></SUB>). 
The &quot;=&quot;<SUB><SPAN STYLE="font-size: 140%"><SPAN STYLE="font-size: 64%">1i</SPAN></SPAN></SUB> 
and &quot;=&quot;<SUB><SPAN STYLE="font-size: 140%"><SPAN STYLE="font-size: 64%">2i</SPAN></SPAN></SUB> 
declare views of the predefined &quot;=&quot; of My_Int (that is, &quot;=&quot;<SUB><SPAN STYLE="font-size: 140%"><SPAN STYLE="font-size: 64%">3</SPAN></SPAN></SUB>). 
In the initialization of Bool_1 and Bool_2 in the generic unit G, the 
names &quot;=&quot; denote &quot;=&quot;<SUB><SPAN STYLE="font-size: 140%"><SPAN STYLE="font-size: 64%">1</SPAN></SPAN></SUB> 
and &quot;=&quot;<SUB><SPAN STYLE="font-size: 140%"><SPAN STYLE="font-size: 64%">2</SPAN></SPAN></SUB>, 
respectively. Therefore, the copies of these names in the instances denote 
&quot;=&quot;<SUB><SPAN STYLE="font-size: 140%"><SPAN STYLE="font-size: 64%">1i</SPAN></SPAN></SUB> 
and &quot;=&quot;<SUB><SPAN STYLE="font-size: 140%"><SPAN STYLE="font-size: 64%">2i</SPAN></SPAN></SUB>, 
respectively. Thus, the initialization of I.Bool_1 and I.Bool_2 call 
the predefined equality operator of My_Int; they will not call &quot;=&quot;<SUB><SPAN STYLE="font-size: 140%"><SPAN STYLE="font-size: 64%">4</SPAN></SPAN></SUB>.</DIV>
<DIV Class="paranum">22.m</DIV>
<DIV Class="Annotations">The declarations &quot;=&quot;<SUB><SPAN STYLE="font-size: 140%"><SPAN STYLE="font-size: 64%">1i</SPAN></SPAN></SUB> 
and &quot;=&quot;<SUB><SPAN STYLE="font-size: 140%"><SPAN STYLE="font-size: 64%">2i</SPAN></SPAN></SUB> 
are hidden from all visibility. This prevents them from being called 
from outside the instance.</DIV>
<DIV Class="paranum">22.n</DIV>
<DIV Class="Annotations">The declaration of Bool_3 calls &quot;=&quot;<SUB><SPAN STYLE="font-size: 140%"><SPAN STYLE="font-size: 64%">4</SPAN></SPAN></SUB>.</DIV>
<DIV Class="paranum">22.o</DIV>
<DIV Class="Annotations">The instance I also contains implicit declarations 
of the primitive operators of T2, such as &quot;=&quot; (call it &quot;=&quot;<SUB><SPAN STYLE="font-size: 140%"><SPAN STYLE="font-size: 64%">5</SPAN></SPAN></SUB>) 
and &quot;+&quot;. These operations cannot be called from within the 
instance, but the declaration of Bool_4 calls &quot;=&quot;<SUB><SPAN STYLE="font-size: 140%"><SPAN STYLE="font-size: 64%">5</SPAN></SPAN></SUB>. 
</DIV>

<H4 Class="centered">Examples</H4>
<DIV Class="paranum">23</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em"><I>Examples of generic 
instantiations (see <A HREF="AA-12-1.html">12.1</A>):</I>&nbsp;</DIV>
<DIV Class="paranum">24</DIV>
<DIV Class="Examples"><B>procedure</B>&nbsp;Swap&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Exchange(Elem&nbsp;=&gt;&nbsp;Integer);<BR>
<B>procedure</B>&nbsp;Swap&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Exchange(Character);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;&nbsp;Swap&nbsp;is&nbsp;overloaded&nbsp;</I></SPAN><BR>
<B>function</B>&nbsp;Square&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Squaring(Integer);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;&nbsp;&quot;*&quot;&nbsp;of&nbsp;Integer&nbsp;used&nbsp;by&nbsp;default</I></SPAN><BR>
<B>function</B>&nbsp;Square&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Squaring(Item&nbsp;=&gt;&nbsp;Matrix,&nbsp;&quot;*&quot;&nbsp;=&gt;&nbsp;Matrix_Product);<BR>
<B>function</B>&nbsp;Square&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Squaring(Matrix,&nbsp;Matrix_Product);&nbsp;--<SPAN Class="roman"><I>&nbsp;same&nbsp;as&nbsp;previous&nbsp;&nbsp;&nbsp;&nbsp;</I></SPAN></DIV>
<DIV Class="paranum">25</DIV>
<DIV Class="Examples"><B>package</B>&nbsp;Int_Vectors&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;On_Vectors(Integer,&nbsp;Table,&nbsp;&quot;+&quot;);</DIV>
<DIV Class="paranum">26</DIV>
<DIV Class="Wide" Style="margin-bottom: 0.4em"><I>Examples of uses of 
instantiated units:</I>&nbsp;</DIV>
<DIV Class="paranum">27</DIV>
<DIV Class="Examples">Swap(A,&nbsp;B);<BR>
A&nbsp;:=&nbsp;Square(A);</DIV>
<DIV Class="paranum">28</DIV>
<DIV Class="Examples">T&nbsp;:&nbsp;Table(1&nbsp;..&nbsp;5)&nbsp;:=&nbsp;(10,&nbsp;20,&nbsp;30,&nbsp;40,&nbsp;50);<BR>
N&nbsp;:&nbsp;Integer&nbsp;:=&nbsp;Int_Vectors.Sigma(T);&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;&nbsp;150&nbsp;(see&nbsp;<A HREF="AA-12-2.html">12.2</A>, 
&ldquo;<A HREF="AA-12-2.html">Generic Bodies</A>&rdquo;&nbsp;for&nbsp;the&nbsp;body&nbsp;of&nbsp;Sigma)</I></SPAN></DIV>
<DIV Class="paranum">29</DIV>
<DIV Class="Examples"><B>use</B>&nbsp;Int_Vectors;<BR>
M&nbsp;:&nbsp;Integer&nbsp;:=&nbsp;Sigma(T);&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;&nbsp;150</I></SPAN></DIV>

<H4 Class="centered">Inconsistencies With Ada 83</H4>
<DIV Class="paranum">29.a</DIV>
<DIV Class="Annotations">{<I>inconsistencies with Ada 83</I>} <A NAME="I4746"></A>In 
Ada 83, all explicit actuals are evaluated before all defaults, and the 
defaults are evaluated in the order of the formal declarations. This 
ordering requirement is relaxed in Ada 95.&nbsp;</DIV>

<H4 Class="centered">Incompatibilities With Ada 83</H4>
<DIV Class="paranum">29.b</DIV>
<DIV Class="Annotations">{<I>incompatibilities with Ada 83</I>} <A NAME="I4747"></A>We 
have attempted to remove every violation of the contract model. Any remaining 
contract model violations should be considered bugs in the RM95. The 
unfortunate property of reverting to the predefined operators of the 
actual types is retained for upward compatibility. (Note that fixing 
this would require subtype conformance rules.) However, tagged types 
do not revert in this sense.&nbsp;</DIV>

<H4 Class="centered">Extensions to Ada 83</H4>
<DIV Class="paranum">29.c</DIV>
<DIV Class="Annotations">{<I>extensions to Ada 83</I>} <A NAME="I4748"></A>The 
syntax rule for <SPAN Class="swiss"><A HREF="AA-12-3.html#S0260">explicit_generic_actual_parameter</A></SPAN> 
is modified to allow a <I>package_instance_</I><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>. 
</DIV>

<H4 Class="centered">Wording Changes from Ada 83</H4>
<DIV Class="paranum">29.d</DIV>
<DIV Class="Annotations">The fact that named associations cannot be used 
for two formal subprograms with the same defining name is moved to AARM-only 
material, because it is a ramification of other rules, and because it 
is not of interest to the average user.</DIV>
<DIV Class="paranum">29.e/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00114.TXT">AI95-00114-01</A></I>} 
The rule that &ldquo;An explicit <SPAN Class="swiss"><A HREF="AA-12-3.html#S0260">explicit_generic_actual_parameter</A></SPAN> 
shall not be supplied more than once for a given <SPAN class="insert2">generic 
formal parameter</SPAN><SPAN class="delete2"><SPAN Class="swiss">&nbsp;generic_formal_parameter</SPAN></SPAN>&rdquo; 
seems to be missing from RM83, although it was clearly the intent.</DIV>
<DIV Class="paranum">29.f</DIV>
<DIV Class="Annotations">In the explanation that the instance is a copy 
of the template, we have left out RM83-12.3(5)'s &ldquo;apart from the 
generic formal part&rdquo;, because it seems that things in the formal 
part still need to exist in instances. This is particularly true for 
generic formal packages, where you're sometimes allowed to reach in and 
denote the formals of the formal package from outside it. This simplifies 
the explanation of what each name in an instance denotes: there are just 
two cases: the declaration can be inside or outside (where inside needs 
to include the generic unit itself). Note that the RM83 approach of listing 
many cases (see RM83-12.5(5-14)) would have become even more unwieldy 
with the addition of generic formal packages, and the declarations that 
occur therein.</DIV>
<DIV Class="paranum">29.g</DIV>
<DIV Class="Annotations">We have corrected the definition of the elaboration 
of a <SPAN Class="swiss"><A HREF="AA-12-3.html#S0257">generic_instantiation</A></SPAN> 
(RM83-12.3(17)); we don't elaborate entities, and the instance is not 
&ldquo;implicit.&rdquo;</DIV>
<DIV Class="paranum">29.h</DIV>
<DIV Class="Annotations">In RM83, there is a rule saying the formal and 
actual shall match, and then there is much text defining what it means 
to match. Here, we simply state all the latter text as rules. For example, 
&ldquo;A formal foo is matched by an actual greenish bar&rdquo; becomes 
&ldquo;For a formal foo, the actual shall be a greenish bar.&rdquo; This 
is necessary to split the Name Resolution Rules from the Legality Rules. 
Besides, there's really no need to define the concept of matching for 
generic parameters.&nbsp;</DIV>

<H4 Class="centered">Extensions to Ada 95</H4>
<DIV Class="paranum">29.i/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-20218.TXT">AI95-00218-03</A></I>} 
<SPAN class="insert2">{<I>extensions to Ada 95</I>} <A NAME="I4749"></A>An 
<SPAN Class="swiss"><A HREF="AA-8-3-1.html#S0178">overriding_indicator</A></SPAN> 
(see <A HREF="AA-8-3-1.html">8.3.1</A>) is allowed on a subprogram instantiation.</SPAN> 
</DIV>

<HR>
<DIV Style="margin-top: 0.0em; margin-bottom: 0.6em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-12-2.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-12-4.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<DIV Style="margin-top:0.0em"><IMG SRC="AE_logo.gif" height=100 width=113 align=right ALT="Ada-Europe">
<SPAN Style="font-size: 125%">Sponsored by <SPAN Style="font-size: 125%"><A HREF="http://www.ada-europe.org/"><B>Ada-Europe</B></A></SPAN></SPAN></DIV>
</BODY>
</HTML>
