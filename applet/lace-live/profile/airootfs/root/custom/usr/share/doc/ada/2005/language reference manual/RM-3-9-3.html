<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Abstract Types and Subprograms</TITLE>
    <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    H4.centered {text-align: center}
    SPAN.swiss {font-family: Arial, Helvetica, sans-serif; font-size: 92%}
    SPAN.roman {font-family: "Times New Roman", Times, serif}
    DIV.paranum {float: left; font-family: Arial, Helvetica, sans-serif; font-size: 64%; width: 2.8em; margin-left: -0.4em; margin-right: -3.0em; margin-top: 0.2em}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    DIV.Normal {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.2em; margin-bottom: 0.6em}
    DIV.Notes {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em; margin-bottom: 0.6em}
    DIV.NotesHeader {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em}
    DIV.SyntaxIndented {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-bottom: 0.4em}
    DIV.Examples {font-family: "Courier New", monospace; font-size: 90%; line-height: 122%; margin-left: 3.4em; margin-bottom: 0.6em}
    UL.Bulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#000080" VLINK="#330033" ALINK="#0000FF">
<DIV><SPAN Style="font-size:200%; color: rgb(0,0,153)"><B>Ada Reference Manual</B></SPAN> &mdash; <A HREF="RM-TTL.html"><B>Legal Information</B></A></DIV>
<DIV Style="margin-top: 0.6em; margin-bottom: 0.0em"><A HREF="RM-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RM-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RM-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RM-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RM-3-9-2.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RM-3-9-4.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<HR>
<H1>3.9.3 Abstract Types and Subprograms</H1>
<DIV Class="paranum">1/2</DIV>
<DIV Class="Normal"><A NAME="I2100"></A><A NAME="I2101"></A><A NAME="I2102"></A><A NAME="I2103"></A>An 
<I>abstract type</I> is a tagged type intended for use as an ancestor 
of other types, but which is not allowed to have objects of its own. 
<A NAME="I2104"></A><A NAME="I2105"></A>An <I>abstract subprogram</I> 
is a subprogram that has no body, but is intended to be overridden at 
some point when inherited. Because objects of an abstract type cannot 
be created, a dispatching call to an abstract subprogram always dispatches 
to some overriding body.&nbsp;</DIV>

<H4 Class="centered">Syntax</H4>
<DIV Class="paranum">1.1/2</DIV>
<DIV Class="SyntaxIndented"><SPAN Class="swiss">abstract_subprogram_declaration</SPAN><A NAME="I2106"></A><A NAME="S0076"></A><SPAN Class="swiss">&nbsp;::=&nbsp;</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;[<A NAME="I2107"></A><SPAN Class="swiss"><A HREF="RM-8-3-1.html#S0178">overriding_indicator</A></SPAN>]<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="I2108"></A><SPAN Class="swiss"><A HREF="RM-6-1.html#S0149">subprogram_specification</A></SPAN>&nbsp;<B>is</B>&nbsp;<B>abstract</B>;</DIV>

<H4 Class="centered">Static Semantics</H4>
<DIV Class="paranum">1.2/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;<A NAME="I2109"></A><A NAME="I2110"></A>Interface 
types (see <A HREF="RM-3-9-4.html">3.9.4</A>) are abstract types. In 
addition, a tagged type that has the reserved word <B>abstract</B> in 
its declaration is an abstract type. The class-wide type (see <A HREF="RM-3-4-1.html">3.4.1</A>) 
rooted at an abstract type is not itself an abstract type.&nbsp;</DIV>

<H4 Class="centered">Legality Rules</H4>
<DIV Class="paranum">2/2</DIV>
<DIV Class="Normal">Only a tagged type shall have the reserved word <B>abstract</B> 
in its declaration.&nbsp;</DIV>
<DIV Class="paranum">3/2</DIV>
<DIV Class="Normal"><A NAME="I2111"></A><A NAME="I2112"></A>A subprogram 
declared by an <SPAN Class="swiss"><A HREF="RM-3-9-3.html#S0076">abstract_subprogram_declaration</A></SPAN> 
or a <SPAN Class="swiss"><A HREF="RM-12-6.html#S0277">formal_abstract_subprogram_declaration</A></SPAN> 
(see <A HREF="RM-12-6.html">12.6</A>) is an <I>abstract subprogram</I>. 
If it is a primitive subprogram of a tagged type, then the tagged type 
shall be abstract.&nbsp;</DIV>
<DIV Class="paranum">4/2</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">If a type has an implicitly 
declared primitive subprogram that is inherited or is the predefined 
equality operator, and the corresponding primitive subprogram of the 
parent or ancestor type is abstract or is a function with a controlling 
access result, or if a type other than a null extension inherits a function 
with a controlling result, then:&nbsp;</DIV>
<DIV Class="paranum">5/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>If the type is abstract or untagged, 
the implicitly declared subprogram is <I>abstract</I>.&nbsp;</LI></UL>
<DIV Class="paranum">6/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>Otherwise, the subprogram shall be 
overridden with a nonabstract subprogram or, in the case of a private 
extension inheriting a function with a controlling result, have a full 
type that is a null extension; for a type declared in the visible part 
of a package, the overriding may be either in the visible or the private 
part. Such a subprogram is said to <I>require overriding</I>.<A NAME="I2113"></A> 
However, if the type is a generic formal type, the subprogram need not 
be overridden for the formal type itself; a nonabstract version will 
necessarily be provided by the actual type.&nbsp;</LI></UL>
<DIV Class="paranum">7</DIV>
<DIV Class="Normal">A call on an abstract subprogram shall be a dispatching 
call; nondispatching calls to an abstract subprogram are not allowed. 
</DIV>
<DIV Class="paranum">8</DIV>
<DIV Class="Normal">The type of an <SPAN Class="swiss"><A HREF="RM-4-3.html#S0104">aggregate</A></SPAN>, 
or of an object created by an <SPAN Class="swiss"><A HREF="RM-3-3-1.html#S0032">object_declaration</A></SPAN> 
or an <SPAN Class="swiss"><A HREF="RM-4-8.html#S0129">allocator</A></SPAN>, 
or a generic formal object of mode <B>in</B>, shall not be abstract. 
The type of the target of an assignment operation (see <A HREF="RM-5-2.html">5.2</A>) 
shall not be abstract. The type of a component shall not be abstract. 
If the result type of a function is abstract, then the function shall 
be abstract.&nbsp;</DIV>
<DIV Class="paranum">9</DIV>
<DIV Class="Normal">If a partial view is not abstract, the corresponding 
full view shall not be abstract. If a generic formal type is abstract, 
then for each primitive subprogram of the formal that is not abstract, 
the corresponding primitive subprogram of the actual shall not be abstract. 
</DIV>
<DIV Class="paranum">10</DIV>
<DIV Class="Normal">For an abstract type declared in a visible part, 
an abstract primitive subprogram shall not be declared in the private 
part, unless it is overriding an abstract subprogram implicitly declared 
in the visible part. For a tagged type declared in a visible part, a 
primitive function with a controlling result shall not be declared in 
the private part, unless it is overriding a function implicitly declared 
in the visible part.&nbsp;</DIV>
<DIV Class="paranum">11/2</DIV>
<DIV Class="Normal">&nbsp;A generic actual subprogram shall not be an abstract 
subprogram unless the generic formal subprogram is declared by a <SPAN Class="swiss"><A HREF="RM-12-6.html#S0277">formal_abstract_subprogram_declaration</A></SPAN>. 
The <SPAN Class="swiss"><A HREF="RM-4-1.html#S0093">prefix</A></SPAN> 
of an <SPAN Class="swiss"><A HREF="RM-4-1-4.html#S0100">attribute_reference</A></SPAN> 
for the Access, Unchecked_Access, or Address attributes shall not denote 
an abstract subprogram.&nbsp;</DIV>

<H4 Class="centered">Dynamic Semantics</H4>
<DIV Class="paranum">11.1/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;<A NAME="I2114"></A>The elaboration of an <SPAN Class="swiss"><A HREF="RM-3-9-3.html#S0076">abstract_subprogram_declaration</A></SPAN> 
has no effect.&nbsp;</DIV>
<DIV Class="NotesHeader">NOTES</DIV>
<DIV Class="paranum">12</DIV>
<DIV Class="Notes">76&nbsp;&nbsp;Abstractness is not inherited; to declare 
an abstract type, the reserved word <B>abstract</B> has to be used in 
the declaration of the type extension.&nbsp;</DIV>
<DIV Class="paranum">13</DIV>
<DIV Class="Notes">77&nbsp;&nbsp;A class-wide type is never abstract. 
Even if a class is rooted at an abstract type, the class-wide type for 
the class is not abstract, and an object of the class-wide type can be 
created; the tag of such an object will identify some nonabstract type 
in the class.&nbsp;</DIV>

<H4 Class="centered">Examples</H4>
<DIV Class="paranum">14</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em"><I>Example of an abstract 
type representing a set of natural numbers:</I>&nbsp;</DIV>
<DIV Class="paranum">15</DIV>
<DIV Class="Examples"><B>package</B>&nbsp;Sets&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>subtype</B>&nbsp;Element_Type&nbsp;<B>is</B>&nbsp;Natural;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Set&nbsp;<B>is&nbsp;abstract&nbsp;tagged&nbsp;null&nbsp;record</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;Empty&nbsp;<B>return</B>&nbsp;Set&nbsp;<B>is&nbsp;abstract</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;Union(Left,&nbsp;Right&nbsp;:&nbsp;Set)&nbsp;<B>return</B>&nbsp;Set&nbsp;<B>is&nbsp;abstract</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;Intersection(Left,&nbsp;Right&nbsp;:&nbsp;Set)&nbsp;<B>return</B>&nbsp;Set&nbsp;<B>is&nbsp;abstract</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;Unit_Set(Element&nbsp;:&nbsp;Element_Type)&nbsp;<B>return</B>&nbsp;Set&nbsp;<B>is&nbsp;abstract</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Take(Element&nbsp;:&nbsp;<B>out</B>&nbsp;Element_Type;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;From&nbsp;:&nbsp;<B>in&nbsp;out</B>&nbsp;Set)&nbsp;<B>is&nbsp;abstract</B>;<BR>
<B>end</B>&nbsp;Sets;</DIV>
<DIV Class="NotesHeader">NOTES</DIV>
<DIV Class="paranum">16</DIV>
<DIV Class="Notes">78&nbsp;&nbsp;<I>Notes on the example:</I> Given the 
above abstract type, one could then derive various (nonabstract) extensions 
of the type, representing alternative implementations of a set. One might 
use a bit vector, but impose an upper bound on the largest element representable, 
while another might use a hash table, trading off space for flexibility. 
</DIV>

<HR>
<DIV Style="margin-top: 0.0em; margin-bottom: 0.6em"><A HREF="RM-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RM-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RM-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RM-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RM-3-9-2.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RM-3-9-4.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<DIV Style="margin-top:0.0em"><IMG SRC="AE_logo.gif" height=100 width=113 align=right ALT="Ada-Europe">
<SPAN Style="vertical-align: middle">Sponsored by <SPAN Style="font-size: 125%"><A HREF="http://www.ada-europe.org/"><B>Ada-Europe</B></A></SPAN></SPAN></DIV>
</BODY>
</HTML>
