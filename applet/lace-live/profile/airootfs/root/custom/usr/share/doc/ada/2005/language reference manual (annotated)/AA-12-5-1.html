<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Formal Private and Derived Types</TITLE>
    <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    H4.centered {text-align: center}
    SPAN.swiss {font-family: Arial, Helvetica, sans-serif; font-size: 92%}
    SPAN.roman {font-family: "Times New Roman", Times, serif}
    DIV.paranum {float: left; font-family: Arial, Helvetica, sans-serif; font-size: 64%; width: 2.8em; margin-left: -0.4em; margin-right: -3.0em; margin-top: 0.2em}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    SPAN.insert1 {text-decoration: underline; color: rgb(0,51,51) }
    SPAN.delete1 {text-decoration: line-through; color: rgb(0,51,51) }
    SPAN.insert2 {text-decoration: underline; color: rgb(0,102,0) }
    SPAN.delete2 {text-decoration: line-through; color: rgb(0,102,0) }
    DIV.Normal {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.2em; margin-bottom: 0.6em}
    DIV.Annotations {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 6.2em; margin-bottom: 0.6em}
    DIV.Notes {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em; margin-bottom: 0.6em}
    DIV.NotesHeader {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em}
    DIV.SyntaxIndented {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-bottom: 0.4em}
    DIV.SmallExamples {font-family: "Courier New", monospace; font-size: 72%; line-height: 122%; margin-left: 9.6em; margin-bottom: 0.6em}
    UL.Bulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.NotesBulleted {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 6.2em; margin-right: 2.5em; margin-top: 0em; margin-bottom: 0.5em}
    DIV.Hanging-Body {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 7.2em; margin-top: 0em; margin-bottom: 0.6em}
    DIV.Hanging-Term {float: left; font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.2em; margin-top: 0em; margin-bottom: 0em}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#000080" VLINK="#330033" ALINK="#0000FF">
<DIV><B><SPAN Style="font-size:200%; color: rgb(0,51,153)">Annotated</SPAN><SPAN Style="font-size:200%; color: rgb(0,0,102)">&nbsp;Ada Reference Manual</SPAN></B> &mdash; <A HREF="AA-TTL.html"><B>Legal Information</B></A></DIV>
<DIV Style="margin-top: 0.6em; margin-bottom: 0.0em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-12-5.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-12-5-2.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<HR>
<H1>12.5.1 Formal Private and Derived Types</H1>
<DIV Class="paranum">1/2</DIV>
<DIV Class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00442.TXT">AI95-00442-01</A></I>} 
[<SPAN class="insert2">In its most general form, the category</SPAN><SPAN class="delete2">&nbsp;The 
class</SPAN> determined for a formal private type <SPAN class="insert2">is 
all types, but it can be restricted to only nonlimited types or to only 
tagged types</SPAN><SPAN class="delete2">&nbsp;can be either limited or nonlimited, 
and either tagged or untagged; no more specific class is known for such 
a type</SPAN>. The <SPAN class="insert2">category</SPAN><SPAN class="delete2">&nbsp;class</SPAN> 
determined for a formal derived type is the derivation class rooted at 
the ancestor type.]&nbsp;</DIV>
<DIV Class="paranum">1.a/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Proof:&nbsp;</B></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00442.TXT">AI95-00442-01</A></I>} 
<SPAN class="insert2">The first rule is given normatively below, and 
the second rule is given normatively in <A HREF="AA-12-5.html">12.5</A>; 
they are repeated here to give a capsule summary of what this subclause 
is about.</SPAN>&nbsp;</DIV>

<H4 Class="centered">Syntax</H4>
<DIV Class="paranum">2</DIV>
<DIV Class="SyntaxIndented"><SPAN Class="swiss">formal_private_type_definition</SPAN><A NAME="I4807"></A><A NAME="S0264"></A><SPAN Class="swiss">&nbsp;::=&nbsp;</SPAN>[[<B>abstract</B>]&nbsp;<B>tagged</B>]&nbsp;[<B>limited</B>]&nbsp;<B>private</B></DIV>
<DIV Class="paranum">3/2</DIV>
<DIV Class="SyntaxIndented">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00419.TXT">AI95-00419-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00443.TXT">AI95-00443-01</A></I>} 
<SPAN Class="swiss">formal_derived_type_definition</SPAN><A NAME="I4808"></A><A NAME="S0265"></A><SPAN Class="swiss">&nbsp;::=&nbsp;</SPAN><SPAN class="insert2"><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN>[<B>abstract</B>]&nbsp;<SPAN class="insert2">[<B>limited</B>&nbsp;|&nbsp;<B>synchronized</B>]&nbsp;</SPAN><B>new</B>&nbsp;<A NAME="I4809"></A><SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0028">subtype_mark</A></SPAN>&nbsp;[<SPAN class="insert2">[<B>and</B>&nbsp;<A NAME="I4810"></A><SPAN Class="swiss"><A HREF="AA-3-9-4.html#S0078">interface_list</A></SPAN>]</SPAN><B>&nbsp;with</B>&nbsp;<B>private</B>]</DIV>

<H4 Class="centered">Legality Rules</H4>
<DIV Class="paranum">4</DIV>
<DIV Class="Normal">If a generic formal type declaration has a <SPAN Class="swiss"><A HREF="AA-3-7.html#S0061">known_discriminant_part</A></SPAN>, 
then it shall not include a <SPAN Class="swiss"><A HREF="AA-3-7.html#S0063">default_expression</A></SPAN> 
for a discriminant.&nbsp;</DIV>
<DIV Class="paranum">4.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>Consequently, a generic 
formal subtype with a <SPAN Class="swiss"><A HREF="AA-3-7.html#S0061">known_discriminant_part</A></SPAN> 
is an indefinite subtype, so the declaration of a stand-alone variable 
has to provide a constraint on such a subtype, either explicitly, or 
by its initial value.&nbsp;</DIV>
<DIV Class="paranum">5/2</DIV>
<DIV Class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00401.TXT">AI95-00401-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00419.TXT">AI95-00419-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00443.TXT">AI95-00443-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>ancestor subtype (of a formal derived 
type)</I>}</SPAN> <A NAME="I4811"></A><SPAN STYLE="font-size: 80%">{<I>private 
extension</I> [partial]}</SPAN> <A NAME="I4812"></A>The <I>ancestor subtype</I> 
of a formal derived type is the subtype denoted by the <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0028">subtype_mark</A></SPAN> 
of the <SPAN Class="swiss"><A HREF="AA-12-5-1.html#S0265">formal_derived_type_definition</A></SPAN>. 
For a formal derived type declaration, the reserved words <B>with private</B> 
shall appear if and only if the ancestor type is a tagged type; in this 
case the formal derived type is a private extension of the ancestor type 
and the ancestor shall not be a class-wide type. [Similarly, <SPAN class="insert2">an 
<SPAN Class="swiss"><A HREF="AA-3-9-4.html#S0078">interface_list</A></SPAN> 
or&nbsp;</SPAN>the optional reserved <SPAN class="insert2">words</SPAN><SPAN class="delete2">&nbsp;word</SPAN> 
<B>abstract</B> <SPAN class="insert2">or <B>synchronized</B>&nbsp;</SPAN>shall 
appear only if the ancestor type is a tagged type].<SPAN class="insert2">&nbsp;The reserved word <B>limited</B> or <B>synchronized</B> shall appear 
only if the ancestor type [and any progenitor types] are limited types. 
The reserved word <B>synchronized</B> shall appear (rather than <B>limited</B>) 
if the ancestor type or any of the progenitor types are synchronized 
interfaces.</SPAN></DIV>
<DIV Class="paranum">5.a</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>We use the term &ldquo;ancestor&rdquo; 
here instead of &ldquo;parent&rdquo; because the actual can be any descendant 
of the ancestor, not necessarily a direct descendant.</DIV>
<DIV Class="paranum">5.b/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00419.TXT">AI95-00419-01</A></I>} 
<SPAN class="insert2">We require the ancestor type to be limited when 
<B>limited</B> appears so that we avoid oddies like limited integer types. 
Normally, <B>limited</B> means &ldquo;match anything&rdquo; for a generic 
formal, but it was felt that allowing limited elementary types to be 
declared was just too weird. Integer still matches a formal limited private 
type; it is only a problem when the type is known to be elementary. Note 
that the progenitors are required to be limited by rules in <A HREF="AA-3-9-4.html">3.9.4</A>, 
thus that part of the rule is redundant.</SPAN></DIV>
<DIV Class="paranum">5.c/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00443.TXT">AI95-00443-01</A></I>} 
<SPAN class="insert2">We require that <B>synchronized</B> appear if the 
ancestor or any of the progenitors are synchronized, so that property 
is explicitly given in the program text &ndash; it is not automatically 
inherited from the ancestors. However, it can be given even if neither 
the ancestor nor the progenitors are synchronized.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">5.1/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00401.TXT">AI95-00401-01</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00443.TXT">AI95-00443-01</A></I>} 
<SPAN class="insert2">The actual type for a formal derived type shall 
be a descendant of [the ancestor type and] every progenitor of the formal 
type. If the reserved word <B>synchronized</B> appears in the declaration 
of the formal derived type, the actual type shall be a synchronized tagged 
type.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">5.d/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Proof:&nbsp;</B>The actual 
type has to be a descendant of the ancestor type, in order that it be 
in the correct class. Thus, that part of the rule is redundant.</SPAN> 
</DIV>
<DIV Class="paranum">5.e/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Discussion:&nbsp;</B>For 
a non-formal private extension, we require the partial view to be synchronized 
if the full view is synchronized tagged. This does not apply to a formal 
private extension &mdash; it is OK if the formal is not synchronized. 
Any attempt to extend the formal type will be rechecked in the instance, 
where the rule disallowing extending a sychronized non-interface type 
will be enforced. This is consistent with the &ldquo;no hidden interfaces&rdquo; 
rule also applying only to non-formal private extensions, as well as 
the rule that a limited non-formal private extension implies a limited 
full type. Formal private extensions are exempted from all these rules 
to enable the construction of generics that can be used with the widest 
possible range of types. In particular, an indefinite tagged limited 
formal private type can match any &ldquo;concrete&rdquo; actual tagged 
type.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">6</DIV>
<DIV Class="Normal">If the formal subtype is definite, then the actual 
subtype shall also be definite.&nbsp;</DIV>
<DIV Class="paranum">6.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>On the other hand, for 
an indefinite formal subtype, the actual can be either definite or indefinite. 
</DIV>
<DIV Class="paranum">7</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">For a generic formal 
derived type with no <SPAN Class="swiss"><A HREF="AA-3-7.html#S0059">discriminant_part</A></SPAN>: 
</DIV>
<DIV Class="paranum">8</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>If the ancestor subtype is constrained, 
the actual subtype shall be constrained, and shall be statically compatible 
with the ancestor;&nbsp;</LI></UL>
<DIV Class="paranum">8.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>In other words, any constraint 
on the ancestor subtype is considered part of the &ldquo;contract.&rdquo; 
</DIV>
<DIV Class="paranum">9</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>If the ancestor subtype is an unconstrained 
access or composite subtype, the actual subtype shall be unconstrained. 
</LI></UL>
<DIV Class="paranum">9.a</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>This rule ensures that if a composite 
constraint is allowed on the formal, one is also allowed on the actual. 
If the ancestor subtype is an unconstrained scalar subtype, the actual 
is allowed to be constrained, since a scalar constraint does not cause 
further constraints to be illegal.&nbsp;</DIV>
<DIV Class="paranum">10</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>If the ancestor subtype is an unconstrained 
discriminated subtype, then the actual shall have the same number of 
discriminants, and each discriminant of the actual shall correspond to 
a discriminant of the ancestor, in the sense of <A HREF="AA-3-7.html">3.7</A>.</LI></UL>
<DIV Class="paranum">10.a</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>This ensures that if a discriminant 
constraint is given on the formal subtype, the corresponding constraint 
in the instance will make sense, without additional run-time checks. 
This is not necessary for arrays, since the bounds cannot be overridden 
in a type extension. An <SPAN Class="swiss"><A HREF="AA-3-7.html#S0060">unknown_discriminant_part</A></SPAN> 
may be used to relax these matching requirements.&nbsp;</DIV>
<DIV Class="paranum">10.1/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00231.TXT">AI95-00231-01</A></I>} 
<SPAN class="insert2">If the ancestor subtype is an access subtype, the 
actual subtype shall exclude null if and only if the ancestor subtype 
excludes null.</SPAN>&nbsp;</LI></UL>
<DIV Class="paranum">10.b/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Reason:&nbsp;</B>We require 
that the &ldquo;excludes null&rdquo; property match, because it would 
be difficult to write a correct generic for a formal access type without 
knowing this property. Many typical algorithms and techniques will not 
work for a subtype that excludes null (setting an unused component to 
<B>null</B>, default-initialized objects, and so on). We want this sort 
of requirement to be reflected in the contract of the generic.</SPAN></DIV>
<DIV Class="paranum">11</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">The declaration of 
a formal derived type shall not have a <SPAN Class="swiss"><A HREF="AA-3-7.html#S0061">known_discriminant_part</A></SPAN>. 
For a generic formal private type with a <SPAN Class="swiss"><A HREF="AA-3-7.html#S0061">known_discriminant_part</A></SPAN>: 
</DIV>
<DIV Class="paranum">12</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>The actual type shall be a type with 
the same number of discriminants.</LI></UL>
<DIV Class="paranum">13</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>The actual subtype shall be unconstrained.</LI></UL>
<DIV Class="paranum">14</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>The subtype of each discriminant of 
the actual type shall statically match the subtype of the corresponding 
discriminant of the formal type. <SPAN STYLE="font-size: 80%">{<I>statically 
matching (required)</I> [partial]}</SPAN> <A NAME="I4813"></A></LI></UL>
<DIV Class="paranum">14.a</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>We considered defining the first 
and third rule to be called &ldquo;subtype conformance&rdquo; for <SPAN Class="swiss"><A HREF="AA-3-7.html#S0059">discriminant_part</A></SPAN>s. 
We rejected that idea, because it would require implicit (inherited) 
<SPAN Class="swiss"><A HREF="AA-3-7.html#S0059">discriminant_part</A></SPAN>s, 
which seemed like too much mechanism.&nbsp;</DIV>
<DIV Class="paranum">15</DIV>
<DIV Class="Normal">[For a generic formal type with an <SPAN Class="swiss"><A HREF="AA-3-7.html#S0060">unknown_discriminant_part</A></SPAN>, 
the actual may, but need not, have discriminants, and may be definite 
or indefinite.]</DIV>

<H4 Class="centered">Static Semantics</H4>
<DIV Class="paranum">16/2</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00442.TXT">AI95-00442-01</A></I>} 
The <SPAN class="insert2">category</SPAN><SPAN class="delete2">&nbsp;class</SPAN> 
determined for a formal private type is as follows:&nbsp;</DIV>
<DIV Class="paranum">17/2</DIV>
<DIV Class="SyntaxIndented"><I>Type&nbsp;Definition</I>&nbsp;&nbsp;<I>Determined&nbsp;</I><SPAN class="insert2"><I>Category</I></SPAN><I></I><SPAN class="delete2"><I>&nbsp;Class</I></SPAN><I></I><BR>
<BR>
<B>limited&nbsp;private</B>&nbsp;&nbsp;the&nbsp;<SPAN class="insert2">category</SPAN><SPAN class="delete2">&nbsp;class</SPAN>&nbsp;of&nbsp;all&nbsp;types<BR>
<B>private</B>&nbsp;&nbsp;the&nbsp;<SPAN class="insert2">category</SPAN><SPAN class="delete2">&nbsp;class</SPAN>&nbsp;of&nbsp;all&nbsp;nonlimited&nbsp;types<BR>
<B>tagged&nbsp;limited&nbsp;private</B>&nbsp;&nbsp;the&nbsp;<SPAN class="insert2">category</SPAN><SPAN class="delete2">&nbsp;class</SPAN>&nbsp;of&nbsp;all&nbsp;tagged&nbsp;types<BR>
<B>tagged&nbsp;private</B>&nbsp;&nbsp;the&nbsp;<SPAN class="insert2">category</SPAN><SPAN class="delete2">&nbsp;class</SPAN>&nbsp;of&nbsp;all&nbsp;nonlimited&nbsp;tagged&nbsp;types</DIV>
<DIV Class="paranum">18</DIV>
<DIV Class="Normal">[The presence of the reserved word <B>abstract</B> 
determines whether the actual type may be abstract.]</DIV>
<DIV Class="paranum">19</DIV>
<DIV Class="Normal">A formal private or derived type is a private or 
derived type, respectively. A formal derived tagged type is a private 
extension. [A formal private or derived type is abstract if the reserved 
word <B>abstract</B> appears in its declaration.]</DIV>
<DIV Class="paranum">20/2</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00233.TXT">AI95-00233-01</A></I>} 
If the ancestor type is a composite type that is not an array type, the 
formal type inherits components from the ancestor type (including discriminants 
if a new <SPAN Class="swiss"><A HREF="AA-3-7.html#S0059">discriminant_part</A></SPAN> 
is not specified), as for a derived type defined by a <SPAN Class="swiss"><A HREF="AA-3-4.html#S0035">derived_type_definition</A></SPAN> 
(see <A HREF="AA-3-4.html">3.4</A><SPAN class="insert2">&nbsp;and <A HREF="AA-7-3-1.html">7.3.1</A></SPAN>).</DIV>
<DIV Class="paranum">21/2</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="defect1.html#8652/0038">8652/0038</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00202.TXT">AI95-00202</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00233.TXT">AI95-00233-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00401.TXT">AI95-00401-01</A></I>} 
For a formal derived type, the predefined operators and inherited user-defined 
subprograms are determined by the ancestor type<SPAN class="insert2">&nbsp;and any progenitor types</SPAN>, and are implicitly declared at the earliest 
place, if any, <SPAN class="insert2">immediately within the declarative 
region in which</SPAN><SPAN class="delete2">&nbsp;within the immediate scope 
of</SPAN> the formal type<SPAN class="insert2">&nbsp;is declared</SPAN>, where 
the corresponding primitive subprogram of the ancestor <SPAN class="insert2">or 
progenitor&nbsp;</SPAN>is visible (see <A HREF="AA-7-3-1.html">7.3.1</A>). 
In an instance, the copy of such an implicit declaration declares a view 
of the corresponding primitive subprogram of the ancestor<SPAN class="insert1"></SPAN><SPAN class="insert2">&nbsp;or progenitor</SPAN><SPAN class="insert1">&nbsp;of the formal derived type</SPAN>, 
even if this primitive has been overridden for the actual type. <SPAN class="insert1">When 
the ancestor</SPAN><SPAN class="insert2">&nbsp;or progenitor</SPAN><SPAN class="insert1">&nbsp;of the formal derived type is itself a formal type, the copy of the implicit 
declaration declares a view of the corresponding copied operation of 
the ancestor</SPAN><SPAN class="insert2">&nbsp;or progenitor</SPAN><SPAN class="insert1">.</SPAN> 
[In the case of a formal private extension, however, the tag of the formal 
type is that of the actual type, so if the tag in a call is statically 
determined to be that of the formal type, the body executed will be that 
corresponding to the actual type.]&nbsp;</DIV>
<DIV Class="paranum">21.a/2</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00401.TXT">AI95-00401-01</A></I>} 
The above rule defining the properties of primitive subprograms in an 
instance applies even if the subprogram has been overridden or hidden 
for the actual type. This rule is necessary for untagged types, because 
their primitive subprograms might have been overridden by operations 
that are not subtype-conformant with the operations defined for the class. 
For tagged types, the rule still applies, but the primitive subprograms 
will dispatch to the appropriate implementation based on the type and 
tag of the operands. Even for tagged types, the formal parameter names 
and <SPAN Class="swiss"><A HREF="AA-3-7.html#S0063">default_expression</A></SPAN>s 
are determined by those of the primitive subprograms of the specified 
ancestor type<SPAN class="insert2">&nbsp;(or progenitor type, for subprograms 
inherited from an interface type)</SPAN>.&nbsp;</DIV>
<DIV Class="paranum">22/1</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;For a <SPAN class="insert1"><SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN></SPAN><SPAN class="delete1">&nbsp;prefix</SPAN> 
S that denotes a formal indefinite subtype, the following attribute is 
defined:&nbsp;</DIV>
<DIV Class="paranum">23</DIV>
<DIV Class="Hanging-Term">S'Definite</DIV><DIV Class="Hanging-Body">
<A NAME="I4814"></A><A NAME="I4815"></A>S'Definite yields True if the 
actual subtype corresponding to S is definite; otherwise it yields False. 
The value of this attribute is of the predefined type Boolean.&nbsp;</DIV>
<DIV Class="paranum">23.a/2</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00114.TXT">AI95-00114-01</A></I>} 
Whether an actual subtype is definite or indefinite may have a major 
effect on the algorithm used in a generic. For example, in a generic 
I/O package, whether to use fixed-length or variable-length records could 
depend on whether the actual is definite or indefinite. This attribute 
is essentially a replacement for the Constrained attribute<SPAN class="insert2">,</SPAN> 
which is now considered obsolete.&nbsp;</DIV>

<H4 Class="centered">Dynamic Semantics</H4>
<DIV Class="paranum">23.1/2</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00158.TXT">AI95-00158-01</A></I>} 
<SPAN class="insert2">In the case where a formal type is tagged with 
unknown discriminants, and the actual type is a class-wide type <I>T</I>'Class:</SPAN></DIV>
<DIV Class="paranum">23.2/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00158.TXT">AI95-00158-01</A></I>} 
<SPAN class="insert2">For the purposes of defining the primitive operations 
of the formal type, each of the primitive operations of the actual type 
is considered to be a subprogram (with an intrinsic calling convention 
&mdash; see <A HREF="AA-6-3-1.html">6.3.1</A>) whose body consists of 
a dispatching call upon the corresponding operation of <I>T</I>, with 
its formal parameters as the actual parameters. If it is a function, 
the result of the dispatching call is returned.</SPAN></LI></UL>
<DIV Class="paranum">23.3/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00158.TXT">AI95-00158-01</A></I>} 
<SPAN class="insert2">If the corresponding operation of <I>T</I> has 
no controlling formal parameters, then the controlling tag value is determined 
by the context of the call, according to the rules for tag-indeterminate 
calls (see <A HREF="AA-3-9-2.html">3.9.2</A> and <A HREF="AA-5-2.html">5.2</A>). 
In the case where the tag would be statically determined to be that of 
the formal type, the call raises Program_Error. If such a function is 
renamed, any call on the renaming raises Program_Error. <SPAN STYLE="font-size: 80%">{<I>Program_Error 
(raised by failure of run-time check)</I>}</SPAN> <A NAME="I4816"></A></SPAN></LI></UL>
<DIV Class="paranum">23.b/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Discussion:&nbsp;</B>As 
it states in <A HREF="AA-6-3-1.html">6.3.1</A>, the convention of an 
inherited subprogram of a generic formal tagged type with unknown discriminants 
is intrinsic.</SPAN></DIV>
<DIV Class="paranum">23.c/2</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><SPAN class="insert2">In 
the case of a corresponding primitive of T with no controlling formal 
parameters, the context of the call provides the controlling tag value 
for the dispatch. If no tag is provided by context, Program_Error is 
raised rather than resorting to a nondispatching call. For example:</SPAN></DIV>
<DIV Class="paranum">23.d/2</DIV>
<DIV Class="SmallExamples"><SPAN class="insert2"><B>generic</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;NT(&lt;&gt;)&nbsp;<B>is&nbsp;new</B>&nbsp;T&nbsp;<B>with&nbsp;private</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>Assume&nbsp;T&nbsp;has&nbsp;operation&nbsp;&quot;</I></SPAN><B>function</B>&nbsp;Empty&nbsp;<B>return</B>&nbsp;T;<SPAN Class="roman"><I>&quot;</I></SPAN><BR>
<B>package</B>&nbsp;G&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Test(X&nbsp;:&nbsp;<B>in&nbsp;out</B>&nbsp;NT);<BR>
<B>end</B>&nbsp;G;</SPAN></DIV>
<DIV Class="paranum">23.e/2</DIV>
<DIV Class="SmallExamples"><SPAN class="insert2"><B>package&nbsp;body</B>&nbsp;G&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Test(X&nbsp;:&nbsp;<B>in&nbsp;out</B>&nbsp;NT)&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;:=&nbsp;Empty;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>Dispatching&nbsp;based&nbsp;on&nbsp;X'Tag&nbsp;takes</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>place&nbsp;if&nbsp;actual&nbsp;is&nbsp;class-wide.</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>declare</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y&nbsp;:&nbsp;NT&nbsp;:=&nbsp;Empty;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>If&nbsp;actual&nbsp;is&nbsp;class-wide,&nbsp;this&nbsp;raises&nbsp;Program_Error</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>as&nbsp;there&nbsp;is&nbsp;no&nbsp;tag&nbsp;provided&nbsp;by&nbsp;context.</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;:=&nbsp;Y;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>We&nbsp;never&nbsp;get&nbsp;this&nbsp;far.</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>end</B>;<BR>
&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;Test;<BR>
<B>end</B>&nbsp;G;</SPAN></DIV>
<DIV Class="paranum">23.f/2</DIV>
<DIV Class="SmallExamples"><SPAN class="insert2"><B>type</B>&nbsp;T1&nbsp;<B>is&nbsp;new</B>&nbsp;T&nbsp;<B>with&nbsp;null&nbsp;record</B>;<BR>
<B>package</B>&nbsp;I&nbsp;<B>is&nbsp;new</B>&nbsp;G(T1'Class);</SPAN></DIV>
<DIV Class="NotesHeader">NOTES</DIV>
<DIV Class="paranum">24/2</DIV>
<DIV Class="Notes" Style="margin-bottom: 0.4em">9&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00442.TXT">AI95-00442-01</A></I>} 
In accordance with the general rule that the actual type shall belong 
to the <SPAN class="insert2">category</SPAN><SPAN class="delete2">&nbsp;class</SPAN> 
determined for the formal (see <A HREF="AA-12-5.html">12.5</A>, &ldquo;<A HREF="AA-12-5.html">Formal 
Types</A>&rdquo;):&nbsp;</DIV>
<DIV Class="paranum">25</DIV>
<UL Class="NotesBulleted"><LI TYPE=DISC>If the formal type is nonlimited, 
then so shall be the actual;</LI></UL>
<DIV Class="paranum">26</DIV>
<UL Class="NotesBulleted"><LI TYPE=DISC>For a formal derived type, the 
actual shall be in the class rooted at the ancestor subtype.&nbsp;</LI></UL>
<DIV Class="paranum">27</DIV>
<DIV Class="Notes">10&nbsp;&nbsp;The actual type can be abstract only 
if the formal type is abstract (see <A HREF="AA-3-9-3.html">3.9.3</A>). 
</DIV>
<DIV Class="paranum">27.a</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>This is necessary to avoid contract 
model problems, since one or more of its primitive subprograms are abstract; 
it is forbidden to create objects of the type, or to declare functions 
returning the type.&nbsp;</DIV>
<DIV Class="paranum">27.b</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>On the other hand, it is 
OK to pass a non-abstract actual to an abstract formal &mdash; <B>abstract</B> 
on the formal indicates that the actual might be abstract.&nbsp;</DIV>
<DIV Class="paranum">28</DIV>
<DIV Class="Notes">11&nbsp;&nbsp;If the formal has a <SPAN Class="swiss"><A HREF="AA-3-7.html#S0059">discriminant_part</A></SPAN>, 
the actual can be either definite or indefinite. Otherwise, the actual 
has to be definite.&nbsp;</DIV>

<H4 Class="centered">Incompatibilities With Ada 83</H4>
<DIV Class="paranum">28.a</DIV>
<DIV Class="Annotations">{<I>incompatibilities with Ada 83</I>} <A NAME="I4817"></A>Ada 
83 does not have <SPAN Class="swiss"><A HREF="AA-3-7.html#S0060">unknown_discriminant_part</A></SPAN>s, 
so it allows indefinite subtypes to be passed to definite formals, and 
applies a legality rule to the instance body. This is a contract model 
violation. Ada 95 disallows such cases at the point of the instantiation. 
The workaround is to add (&lt;&gt;) as the <SPAN Class="swiss"><A HREF="AA-3-7.html#S0059">discriminant_part</A></SPAN> 
of any formal subtype if it is intended to be used with indefinite actuals. 
If that's the intent, then there can't be anything in the generic body 
that would require a definite subtype.</DIV>
<DIV Class="paranum">28.b</DIV>
<DIV Class="Annotations">The check for discriminant subtype matching 
is changed from a run-time check to a compile-time check.&nbsp;</DIV>

<H4 Class="centered">Extensions to Ada 95</H4>
<DIV Class="paranum">28.c/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00401.TXT">AI95-00401-01</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00419.TXT">AI95-00419-01</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00443.TXT">AI95-00443-01</A></I>} 
<SPAN class="insert2">{<I>extensions to Ada 95</I>} <A NAME="I4818"></A>A 
generic formal derived type can include progenitors (interfaces) as well 
as a primary ancestor. It also may include <B>limited</B> to indicate 
that it is a limited type, and <B>synchronized</B> to indicate that it 
is a synchronized type.</SPAN>&nbsp;</DIV>

<H4 Class="centered">Wording Changes from Ada 95</H4>
<DIV Class="paranum">28.d/2</DIV>
<DIV Class="Annotations">{<I><A HREF="defect1.html#8652/0038">8652/0038</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00202.TXT">AI95-00202-01</A></I>} 
<SPAN class="insert2"><B>Corrigendum:</B> Corrected wording to define 
the operations that are inherited when the ancestor of a formal type 
is itself a formal type to avoid anomalies.</SPAN></DIV>
<DIV Class="paranum">28.e/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00158.TXT">AI95-00158-01</A></I>} 
<SPAN class="insert2">Added a semantic description of the meaning of 
operations of an actual class-wide type, as such a type does not have 
primitive operations of its own.</SPAN></DIV>
<DIV Class="paranum">28.f/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00231.TXT">AI95-00231-01</A></I>} 
<SPAN class="insert2">Added a matching rule for access subtypes that 
exclude null.</SPAN></DIV>
<DIV Class="paranum">28.g/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00233.TXT">AI95-00233-01</A></I>} 
<SPAN class="insert2">The wording for the declaration of implicit operations 
is corrected to be consistent with <A HREF="AA-7-3-1.html">7.3.1</A> 
as modified by Corrigendum 1.</SPAN></DIV>
<DIV Class="paranum">28.h/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00442.TXT">AI95-00442-01</A></I>} 
<SPAN class="insert2">We change to &ldquo;determines a category&rdquo; 
as that is the new terminology (it avoids confusion, since not all interesting 
properties form a class).</SPAN>&nbsp;</DIV>

<HR>
<DIV Style="margin-top: 0.0em; margin-bottom: 0.6em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-12-5.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-12-5-2.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<DIV Style="margin-top:0.0em"><IMG SRC="AE_logo.gif" height=100 width=113 align=right ALT="Ada-Europe">
<SPAN Style="font-size: 125%">Sponsored by <SPAN Style="font-size: 125%"><A HREF="http://www.ada-europe.org/"><B>Ada-Europe</B></A></SPAN></SPAN></DIV>
</BODY>
</HTML>
