<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Derived Types and Classes</TITLE>
    <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    H4.centered {text-align: center}
    SPAN.swiss {font-family: Arial, Helvetica, sans-serif; font-size: 92%}
    SPAN.roman {font-family: "Times New Roman", Times, serif}
    DIV.paranum {float: left; font-family: Arial, Helvetica, sans-serif; font-size: 64%; width: 2.8em; margin-left: -0.4em; margin-right: -3.0em; margin-top: 0.2em}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    SPAN.insert2 {text-decoration: underline; color: rgb(0,102,0) }
    SPAN.delete2 {text-decoration: line-through; color: rgb(0,102,0) }
    DIV.Normal {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.2em; margin-bottom: 0.6em}
    DIV.Annotations {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 6.2em; margin-bottom: 0.6em}
    DIV.Notes {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em; margin-bottom: 0.6em}
    DIV.NotesHeader {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em}
    DIV.SyntaxIndented {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-bottom: 0.4em}
    DIV.Examples {font-family: "Courier New", monospace; font-size: 90%; line-height: 122%; margin-left: 3.4em; margin-bottom: 0.6em}
    DIV.SmallExamples {font-family: "Courier New", monospace; font-size: 72%; line-height: 122%; margin-left: 9.6em; margin-bottom: 0.6em}
    UL.Bulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.NestedBulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 5.2em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#000080" VLINK="#330033" ALINK="#0000FF">
<DIV><B><SPAN Style="font-size:200%; color: rgb(0,51,153)">Annotated</SPAN><SPAN Style="font-size:200%; color: rgb(0,0,102)">&nbsp;Ada Reference Manual</SPAN></B> &mdash; <A HREF="AA-TTL.html"><B>Legal Information</B></A></DIV>
<DIV Style="margin-top: 0.6em; margin-bottom: 0.0em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-3-3-2.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-3-4-1.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<HR>
<H1>3.4 Derived Types and Classes</H1>
<DIV Class="paranum">1/2</DIV>
<DIV Class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00401.TXT">AI95-00401-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00419.TXT">AI95-00419-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>derived type</I>}</SPAN> <A NAME="I1592"></A>A 
<SPAN Class="swiss"><A HREF="AA-3-4.html#S0035">derived_type_definition</A></SPAN> 
defines a <SPAN class="insert2"><I>derived type</I></SPAN><SPAN class="delete2">&nbsp;new 
type</SPAN> (and its first subtype) whose characteristics are <I>derived</I> 
from those of a <SPAN class="insert2">parent type, and possibly from 
progenitor types</SPAN><SPAN class="delete2"><I>&nbsp;parent type</I></SPAN>. 
<SPAN STYLE="font-size: 80%">{<I>inheritance: See derived types and classes</I>}</SPAN> 
<A NAME="I1593"></A></DIV>
<DIV Class="paranum">1.a/2</DIV>
<DIV Class="Annotations"><B>Glossary entry:&nbsp;</B>{<I>Derived type</I>} 
A derived type is a type defined in terms of <SPAN class="insert2">one 
or more other types given in a derived type definition. The first of 
those types</SPAN><SPAN class="delete2">&nbsp;another type, which</SPAN> is 
the parent type of the derived type<SPAN class="insert2">&nbsp;and any others 
are progenitor types</SPAN>. Each class containing the parent type <SPAN class="insert2">or 
a progenitor type&nbsp;</SPAN>also contains the derived type. The derived 
type inherits properties such as components and primitive operations 
from the parent<SPAN class="insert2">&nbsp;and progenitors</SPAN>. A type 
together with the types derived from it (directly or indirectly) form 
a derivation class.</DIV>
<DIV Class="paranum">1.1/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00442.TXT">AI95-00442-01</A></I>} 
<SPAN class="insert2"><SPAN STYLE="font-size: 80%">{<I>class (of types)</I>}</SPAN> 
<A NAME="I1594"></A><SPAN STYLE="font-size: 80%">{<I>category (of types)</I>}</SPAN> 
<A NAME="I1595"></A>A <I>class of types</I> is a set of types that is 
closed under derivation; that is, if the parent or a progenitor type 
of a derived type belongs to a class, then so does the derived type. 
By saying that a particular group of types forms a class, we are saying 
that all derivatives of a type in the set inherit the characteristics 
that define that set. The more general term <I>category of types</I> 
is used for a set of types whose defining characteristics are not necessarily 
inherited by derivatives; for example, limited, abstract, and interface 
are all categories of types, but not classes of types.</SPAN></DIV>
<DIV Class="paranum">1.b/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Ramification:&nbsp;</B>A 
class of types is also a category of types.</SPAN>&nbsp;</DIV>

<H4 Class="centered">Syntax</H4>
<DIV Class="paranum">2/2</DIV>
<DIV Class="SyntaxIndented">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00419.TXT">AI95-00419-01</A></I>} 
<SPAN Class="swiss">derived_type_definition</SPAN><A NAME="I1596"></A><A NAME="S0035"></A><SPAN Class="swiss">&nbsp;::=&nbsp;</SPAN><SPAN class="insert2"><BR>
&nbsp;&nbsp;&nbsp;&nbsp;</SPAN>[<B>abstract</B>]&nbsp;<SPAN class="insert2">[<B>limited</B>]&nbsp;</SPAN><B>new</B>&nbsp;<I>parent_</I><A NAME="I1597"></A><SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0027">subtype_indication</A></SPAN>&nbsp;[<SPAN class="insert2">[<B>and</B>&nbsp;<A NAME="I1598"></A><SPAN Class="swiss"><A HREF="AA-3-9-4.html#S0078">interface_list</A></SPAN>]&nbsp;</SPAN><A NAME="I1599"></A><SPAN Class="swiss"><A HREF="AA-3-9-1.html#S0075">record_extension_part</A></SPAN>]</DIV>

<H4 Class="centered">Legality Rules</H4>
<DIV Class="paranum">3/2</DIV>
<DIV Class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00401.TXT">AI95-00401-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00419.TXT">AI95-00419-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>parent subtype</I>}</SPAN> <A NAME="I1600"></A><SPAN STYLE="font-size: 80%">{<I>parent 
type</I>}</SPAN> <A NAME="I1601"></A>The <I>parent_</I><SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0027">subtype_indication</A></SPAN> 
defines the <I>parent subtype</I>; its type is the <SPAN class="insert2"><I>parent 
type</I></SPAN><SPAN class="delete2">&nbsp;parent type</SPAN>. <SPAN class="insert2">The 
<SPAN Class="swiss"><A HREF="AA-3-9-4.html#S0078">interface_list</A></SPAN> 
defines the progenitor types (see <A HREF="AA-3-9-4.html">3.9.4</A>). 
A derived type has one parent type and zero or more progenitor types.</SPAN></DIV>
<DIV Class="paranum">3.a/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Glossary entry:&nbsp;</B>{<I>Parent</I>} 
The parent of a derived type is the first type given in the definition 
of the derived type. The parent can be almost any kind of type, including 
an interface type.</SPAN></DIV>
<DIV Class="paranum">4</DIV>
<DIV Class="Normal">A type shall be completely defined (see <A HREF="AA-3-11-1.html">3.11.1</A>) 
prior to being specified as the parent type in a <SPAN Class="swiss"><A HREF="AA-3-4.html#S0035">derived_type_definition</A></SPAN> 
&mdash; [the <SPAN Class="swiss"><A HREF="AA-3-2-1.html#S0024">full_type_declaration</A></SPAN>s 
for the parent type and any of its subcomponents have to precede the 
<SPAN Class="swiss"><A HREF="AA-3-4.html#S0035">derived_type_definition</A></SPAN>.] 
</DIV>
<DIV Class="paranum">4.a</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>This restriction does not 
apply to the ancestor type of a private extension &mdash; see <A HREF="AA-7-3.html">7.3</A>; 
such a type need not be completely defined prior to the <SPAN Class="swiss"><A HREF="AA-7-3.html#S0177">private_extension_declaration</A></SPAN>. 
However, the restriction does apply to record extensions, so the ancestor 
type will have to be completely defined prior to the <SPAN Class="swiss"><A HREF="AA-3-2-1.html#S0024">full_type_declaration</A></SPAN> 
corresponding to the <SPAN Class="swiss"><A HREF="AA-7-3.html#S0177">private_extension_declaration</A></SPAN>. 
</DIV>
<DIV Class="paranum">4.b</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>We originally hoped we could 
relax this restriction. However, we found it too complex to specify the 
rules for a type derived from an incompletely defined limited type that 
subsequently became nonlimited.&nbsp;</DIV>
<DIV Class="paranum">5/2</DIV>
<DIV Class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00401.TXT">AI95-00401-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>record extension</I>}</SPAN> <A NAME="I1602"></A>If 
there is a <SPAN Class="swiss"><A HREF="AA-3-9-1.html#S0075">record_extension_part</A></SPAN>, 
the derived type is called a <I>record extension</I> of the parent type. 
A <SPAN Class="swiss"><A HREF="AA-3-9-1.html#S0075">record_extension_part</A></SPAN> 
shall be provided if and only if the parent type is a tagged type.<SPAN class="insert2">&nbsp;[An <SPAN Class="swiss"><A HREF="AA-3-9-4.html#S0078">interface_list</A></SPAN> 
shall be provided only if the parent type is a tagged type.]</SPAN>&nbsp;</DIV>
<DIV Class="paranum">5.a.1/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Proof:&nbsp;</B></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00401.TXT">AI95-00401-01</A></I>} 
<SPAN class="insert2">The syntax only allows an <SPAN Class="swiss"><A HREF="AA-3-9-4.html#S0078">interface_list</A></SPAN> 
to appear with a <SPAN Class="swiss"><A HREF="AA-3-9-1.html#S0075">record_extension_part</A></SPAN>, 
and a <SPAN Class="swiss"><A HREF="AA-3-9-1.html#S0075">record_extension_part</A></SPAN> 
can only be provided if the parent type is a tagged type. We give the 
last sentence anyway for completeness.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">5.a</DIV>
<DIV Class="Annotations"><B>Implementation Note:&nbsp;</B>We allow a record 
extension to inherit discriminants; an early version of Ada 9X did not. 
If the parent subtype is unconstrained, it can be implemented as though 
its discriminants were repeated in a new <SPAN Class="swiss"><A HREF="AA-3-7.html#S0061">known_discriminant_part</A></SPAN> 
and then used to constrain the old ones one-for-one. However, in an extension 
aggregate, the discriminants in this case do not appear in the component 
association list.&nbsp;</DIV>
<DIV Class="paranum">5.b/2</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><SPAN class="insert2"><B>Ramification: 
</B></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00114.TXT">AI95-00114-01</A></I>} 
<SPAN class="insert2"></SPAN>This rule needs to be rechecked in the visible 
part of an instance of a generic unit<SPAN class="insert2">&nbsp;because of 
the &ldquo;only if&rdquo; part of the rule. For example:</SPAN>&nbsp;</DIV>
<DIV Class="paranum">5.c/2</DIV>
<DIV Class="SmallExamples"><SPAN class="insert2"><B>generic</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T&nbsp;<B>is&nbsp;private</B>;<BR>
<B>package</B>&nbsp;P&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Der&nbsp;<B>is&nbsp;new</B>&nbsp;T;<BR>
<B>end</B>&nbsp;P;</SPAN></DIV>
<DIV Class="paranum">5.d/2</DIV>
<DIV Class="SmallExamples"><SPAN class="insert2"><B>package</B>&nbsp;I&nbsp;<B>is&nbsp;new</B>&nbsp;P&nbsp;(Some_Tagged_Type);&nbsp;--&nbsp;<SPAN Class="roman"><I>illegal</I></SPAN></SPAN></DIV>
<DIV Class="paranum">5.e/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00114.TXT">AI95-00114-01</A></I>} 
<SPAN class="insert2">The instantiation is illegal because a tagged type 
is being extended in the visible part without a <SPAN Class="swiss"><A HREF="AA-3-9-1.html#S0075">record_extension_part</A></SPAN>. 
Note that this is legal in the private part or body of an instance, both 
to avoid a contract model violation, and because no code that can see 
that the type is actually tagged can also see the derived type declaration.</SPAN></DIV>
<DIV Class="paranum">5.f/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2">No recheck is needed for 
derived types with a <SPAN Class="swiss"><A HREF="AA-3-9-1.html#S0075">record_extension_part</A></SPAN>, 
as that has to be derived from something that is known to be tagged (otherwise 
the template is illegal).</SPAN>&nbsp;</DIV>
<DIV Class="paranum">5.1/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00419.TXT">AI95-00419-01</A></I>} 
<SPAN class="insert2">If the reserved word <B>limited</B> appears in 
a <SPAN Class="swiss"><A HREF="AA-3-4.html#S0035">derived_type_definition</A></SPAN>, 
the parent type shall be a limited type.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">5.g/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Reason:&nbsp;</B>We allow 
<B>limited</B> because we don't inherit limitedness from interfaces, 
so we must have a way to derive a limited type from interfaces. The word 
<B>limited</B> has to be legal when the parent <I>could be</I> an interface, 
and that includes generic formal abstract types. Since we have to allow 
it in this case, we might as well allow it everywhere as documentation, 
to make it explicit that the type is limited.</SPAN></DIV>
<DIV Class="paranum">5.h/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2">However, we do not want 
to allow <B>limited</B> when the parent is nonlimited: limitedness cannot 
change in a derivation tree.</SPAN>&nbsp;</DIV>

<H4 Class="centered">Static Semantics</H4>
<DIV Class="paranum">6</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>constrained (subtype)</I>}</SPAN> 
<A NAME="I1603"></A><SPAN STYLE="font-size: 80%">{<I>unconstrained (subtype)</I>}</SPAN> 
<A NAME="I1604"></A>The first subtype of the derived type is unconstrained 
if a <SPAN Class="swiss"><A HREF="AA-3-7.html#S0061">known_discriminant_part</A></SPAN> 
is provided in the declaration of the derived type, or if the parent 
subtype is unconstrained. <SPAN STYLE="font-size: 80%">{<I>corresponding 
constraint</I>}</SPAN> <A NAME="I1605"></A>Otherwise, the constraint 
of the first subtype <I>corresponds</I> to that of the parent subtype 
in the following sense: it is the same as that of the parent subtype 
except that for a range constraint (implicit or explicit), the value 
of each bound of its range is replaced by the corresponding value of 
the derived type.&nbsp;</DIV>
<DIV Class="paranum">6.a</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>A <SPAN Class="swiss"><A HREF="AA-3-5-9.html#S0050">digits_constraint</A></SPAN> 
in a <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0027">subtype_indication</A></SPAN> 
for a decimal fixed point subtype always imposes a range constraint, 
implicitly if there is no explicit one given. See <A HREF="AA-3-5-9.html">3.5.9</A>, 
&ldquo;<A HREF="AA-3-5-9.html">Fixed Point Types</A>&rdquo;.&nbsp;</DIV>
<DIV Class="paranum">6.1/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00231.TXT">AI95-00231-01</A></I>} 
<SPAN class="insert2">The first subtype of the derived type excludes 
null (see <A HREF="AA-3-10.html">3.10</A>) if and only if the parent 
subtype excludes null.</SPAN></DIV>
<DIV Class="paranum">7</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">The characteristics 
of the derived type are defined as follows:&nbsp;</DIV>
<DIV Class="paranum">8/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00401.TXT">AI95-00401-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00442.TXT">AI95-00442-01</A></I>} 
<SPAN class="insert2">[If the parent type or a progenitor type belongs 
to a class of types, then the derived type also belongs to that class.] 
The following sets of types, as well as any higher-level sets composed 
from them, are classes in this sense[, and hence the characteristics 
defining these classes are inherited by derived types from their parent 
or progenitor types]: signed integer, modular integer, ordinary fixed, 
decimal fixed, floating point, enumeration, boolean, character, access-to-constant, 
general access-to-variable, pool-specific access-to-variable, access-to-subprogram, 
array, string, non-array composite, nonlimited, untagged record, tagged, 
task, protected, and synchronized tagged</SPAN><SPAN class="delete2">&nbsp;Each 
class of types that includes the parent type also includes the derived 
type</SPAN>.&nbsp;</LI></UL>
<DIV Class="paranum">8.a</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>This is inherent in our notion 
of a &ldquo;class&rdquo; of types. It is not mentioned in the initial 
definition of &ldquo;class&rdquo; since at that point type derivation 
has not been defined. In any case, this rule ensures that every class 
of types is closed under derivation.&nbsp;</DIV>
<DIV Class="paranum">9</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>If the parent type is an elementary 
type or an array type, then the set of possible values of the derived 
type is a copy of the set of possible values of the parent type. For 
a scalar type, the base range of the derived type is the same as that 
of the parent type.&nbsp;</LI></UL>
<DIV Class="paranum">9.a</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>The base range of a type 
defined by an <SPAN Class="swiss"><A HREF="AA-3-5-4.html#S0041">integer_type_definition</A></SPAN> 
or a <SPAN Class="swiss"><A HREF="AA-3-5-6.html#S0044">real_type_definition</A></SPAN> 
is determined by the <SPAN Class="swiss">_definition</SPAN>, and is not 
necessarily the same as that of the corresponding root numeric type from 
which the newly defined type is implicitly derived. Treating numerics 
types as implicitly derived from one of the two root numeric types is 
simply to link them into a type hierarchy; such an implicit derivation 
does not follow all the rules given here for an explicit <SPAN Class="swiss"><A HREF="AA-3-4.html#S0035">derived_type_definition</A></SPAN>. 
</DIV>
<DIV Class="paranum">10</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>If the parent type is a composite 
type other than an array type, then the components, protected subprograms, 
and entries that are declared for the derived type are as follows:&nbsp;</LI></UL>
<DIV Class="paranum">11</DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>The discriminants specified 
by a new <SPAN Class="swiss"><A HREF="AA-3-7.html#S0061">known_discriminant_part</A></SPAN>, 
if there is one; otherwise, each discriminant of the parent type (implicitly 
declared in the same order with the same specifications) &mdash; <SPAN STYLE="font-size: 80%">{<I>inherited 
discriminant</I>}</SPAN> <A NAME="I1606"></A><SPAN STYLE="font-size: 80%">{<I>inherited 
component</I>}</SPAN> <A NAME="I1607"></A>in the latter case, the discriminants 
are said to be <I>inherited</I>, or if unknown in the parent, are also 
unknown in the derived type;</LI></UL>
<DIV Class="paranum">12</DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>Each nondiscriminant component, 
entry, and protected subprogram of the parent type, implicitly declared 
in the same order with the same declarations; <SPAN STYLE="font-size: 80%">{<I>inherited 
component</I>}</SPAN> <A NAME="I1608"></A><SPAN STYLE="font-size: 80%">{<I>inherited 
protected subprogram</I>}</SPAN> <A NAME="I1609"></A><SPAN STYLE="font-size: 80%">{<I>inherited 
entry</I>}</SPAN> <A NAME="I1610"></A>these components, entries, and 
protected subprograms are said to be <I>inherited</I>;&nbsp;</LI></UL>
<DIV Class="paranum">12.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>The profiles of entries 
and protected subprograms do not change upon type derivation, although 
the type of the &ldquo;implicit&rdquo; parameter identified by the <SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN> 
of the <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
in a call does.</DIV>
<DIV Class="paranum">12.b</DIV>
<DIV Class="Annotations"><B>To be honest:&nbsp;</B>Any name in the parent 
<SPAN Class="swiss"><A HREF="AA-3-2-1.html#S0023">type_declaration</A></SPAN> 
that denotes the current instance of the type is replaced with a name 
denoting the current instance of the derived type, converted to the parent 
type.</DIV>
<DIV Class="paranum">13</DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>Each component declared in a 
<SPAN Class="swiss"><A HREF="AA-3-9-1.html#S0075">record_extension_part</A></SPAN>, 
if any.&nbsp;</LI></UL>
<DIV Class="paranum">14</DIV>
<UL Class="Bulleted">Declarations of components, protected subprograms, 
and entries, whether implicit or explicit, occur immediately within the 
declarative region of the type, in the order indicated above, following 
the parent <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0027">subtype_indication</A></SPAN>. 
</UL>
<DIV Class="paranum">14.a</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>The order of declarations 
within the region matters for <SPAN Class="swiss"><A HREF="AA-4-3-1.html#S0105">record_aggregate</A></SPAN>s 
and <SPAN Class="swiss"><A HREF="AA-4-3-2.html#S0109">extension_aggregate</A></SPAN>s. 
</DIV>
<DIV Class="paranum">14.b</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>In most cases, these things 
are implicitly declared <I>immediately</I> following the parent <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0027">subtype_indication</A></SPAN>. 
However, <A HREF="AA-7-3-1.html">7.3.1</A>, &ldquo;<A HREF="AA-7-3-1.html">Private 
Operations</A>&rdquo; defines some cases in which they are implicitly 
declared later, and some cases in which the are not declared at all. 
</DIV>
<DIV Class="paranum">14.c</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>The place of the implicit 
declarations of inherited components matters for visibility &mdash; they 
are not visible in the <SPAN Class="swiss"><A HREF="AA-3-7.html#S0061">known_discriminant_part</A></SPAN> 
nor in the parent <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0027">subtype_indication</A></SPAN>, 
but are usually visible within the <SPAN Class="swiss"><A HREF="AA-3-9-1.html#S0075">record_extension_part</A></SPAN>, 
if any (although there are restrictions on their use). Note that a discriminant 
specified in a new <SPAN Class="swiss"><A HREF="AA-3-7.html#S0061">known_discriminant_part</A></SPAN> 
is not considered &ldquo;inherited&rdquo; even if it has the same name 
and subtype as a discriminant of the parent type.&nbsp;</DIV>
<DIV Class="paranum">15/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN STYLE="font-size: 80%"><I>This 
paragraph was deleted.</I></SPAN><SPAN class="delete2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00419.TXT">AI95-00419-01</A></I>} 
<SPAN class="delete2">The derived type is limited if and only if the 
parent type is limited.</SPAN>&nbsp;</LI></UL>
<DIV Class="paranum">15.a/2</DIV>
<DIV Class="Annotations"><SPAN class="delete2"><B>To be honest:&nbsp;</B></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00419.TXT">AI95-00419-01</A></I>} 
<SPAN class="delete2">The derived type can become nonlimited if the derivation 
takes place in the visible part of a child package, and the parent type 
is nonlimited as viewed from the private part of the child package &mdash; 
see <A HREF="AA-7-5.html">7.5</A>.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">16</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>[For each predefined operator of the 
parent type, there is a corresponding predefined operator of the derived 
type.]&nbsp;</LI></UL>
<DIV Class="paranum">16.a</DIV>
<DIV Class="Annotations"><B>Proof:&nbsp;</B>This is a ramification of the 
fact that each class that includes the parent type also includes the 
derived type, and the fact that the set of predefined operators that 
is defined for a type, as described in <A HREF="AA-4-5.html">4.5</A>, 
is determined by the classes to which it belongs.&nbsp;</DIV>
<DIV Class="paranum">16.b</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>Predefined operators are handled 
separately because they follow a slightly different rule than user-defined 
primitive subprograms. In particular the systematic replacement described 
below does not apply fully to the relational operators for Boolean and 
the exponentiation operator for Integer. The relational operators for 
a type derived from Boolean still return Standard.Boolean. The exponentiation 
operator for a type derived from Integer still expects Standard.Integer 
for the right operand. In addition, predefined operators &quot;reemerge&quot; 
when a type is the actual type corresponding to a generic formal type, 
so they need to be well defined even if hidden by user-defined primitive 
subprograms.&nbsp;</DIV>
<DIV Class="paranum">17/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00401.TXT">AI95-00401-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>inherited subprogram</I>}</SPAN> <A NAME="I1611"></A>For 
each user-defined primitive subprogram (other than a user-defined equality 
operator &mdash; see below) of the parent type<SPAN class="insert2">&nbsp;or of a progenitor type</SPAN> that already exists at the place of the 
<SPAN Class="swiss"><A HREF="AA-3-4.html#S0035">derived_type_definition</A></SPAN>, 
there exists a corresponding <I>inherited</I> primitive subprogram of 
the derived type with the same defining name. <SPAN STYLE="font-size: 80%">{<I>equality 
operator (special inheritance rule for tagged types)</I>}</SPAN> <A NAME="I1612"></A>Primitive 
user-defined equality operators of the parent type<SPAN class="insert2">&nbsp;and any progenitor types</SPAN> are also inherited by the derived type, 
except when the derived type is a nonlimited record extension, and the 
inherited operator would have a profile that is type conformant with 
the profile of the corresponding predefined equality operator; in this 
case, the user-defined equality operator is not inherited, but is rather 
incorporated into the implementation of the predefined equality operator 
of the record extension (see <A HREF="AA-4-5-2.html">4.5.2</A>). <SPAN STYLE="font-size: 80%">{<I>type 
conformance</I> [partial]}</SPAN> <A NAME="I1613"></A></LI></UL>
<DIV Class="paranum">17.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>We say &ldquo;...already 
exists...&rdquo; rather than &ldquo;is visible&rdquo; or &ldquo;has been 
declared&rdquo; because there are certain operations that are declared 
later, but still exist at the place of the <SPAN Class="swiss"><A HREF="AA-3-4.html#S0035">derived_type_definition</A></SPAN>, 
and there are operations that are never declared, but still exist. These 
cases are explained in <A HREF="AA-7-3-1.html">7.3.1</A>.</DIV>
<DIV Class="paranum">17.b</DIV>
<DIV Class="Annotations">Note that nonprivate extensions can appear only 
after the last primitive subprogram of the parent &mdash; the freezing 
rules ensure this.&nbsp;</DIV>
<DIV Class="paranum">17.c</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>A special case is made for the 
equality operators on nonlimited record extensions because their predefined 
equality operators are already defined in terms of the primitive equality 
operator of their parent type (and of the tagged components of the extension 
part). Inheriting the parent's equality operator as is would be undesirable, 
because it would ignore any components of the extension part. On the 
other hand, if the parent type is limited, then any user-defined equality 
operator is inherited as is, since there is no predefined equality operator 
to take its place.&nbsp;</DIV>
<DIV Class="paranum">17.d/2</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00114.TXT">AI95-00114-01</A></I>} 
Because user-defined equality operators are not inherited by <SPAN class="insert2">nonlimited 
</SPAN>record extensions, the formal parameter names of = and /= revert 
to Left and Right, even if different formal parameter names were used 
in the user-defined equality operators of the parent type.&nbsp;</DIV>
<DIV Class="paranum">17.e/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Discussion:&nbsp;</B></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00401.TXT">AI95-00401-01</A></I>} 
<SPAN class="insert2">This rule only describes what operations are inherited; 
the rules that describe what happens when there are conflicting inherited 
subprograms are found in <A HREF="AA-8-3.html">8.3</A>.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">18/2</DIV>
<UL Class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00401.TXT">AI95-00401-01</A></I>} 
The profile of an inherited subprogram (including an inherited enumeration 
literal) is obtained from the profile of the corresponding (user-defined) 
primitive subprogram of the parent<SPAN class="insert2">&nbsp;or progenitor</SPAN> 
type, after systematic replacement of each subtype of its profile (see 
<A HREF="AA-6-1.html">6.1</A>) that is of the parent<SPAN class="insert2">&nbsp;or progenitor</SPAN> type with a <I>corresponding subtype</I> of the 
derived type. <SPAN STYLE="font-size: 80%">{<I>corresponding subtype</I>}</SPAN> 
<A NAME="I1614"></A>For a given subtype of the parent<SPAN class="insert2">&nbsp;or progenitor</SPAN> type, the corresponding subtype of the derived type 
is defined as follows:&nbsp;</UL>
<DIV Class="paranum">19</DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>If the declaration of the derived 
type has neither a <SPAN Class="swiss"><A HREF="AA-3-7.html#S0061">known_discriminant_part</A></SPAN> 
nor a <SPAN Class="swiss"><A HREF="AA-3-9-1.html#S0075">record_extension_part</A></SPAN>, 
then the corresponding subtype has a constraint that corresponds (as 
defined above for the first subtype of the derived type) to that of the 
given subtype.</LI></UL>
<DIV Class="paranum">20</DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>If the derived type is a record 
extension, then the corresponding subtype is the first subtype of the 
derived type.</LI></UL>
<DIV Class="paranum">21</DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>If the derived type has a new 
<SPAN Class="swiss"><A HREF="AA-3-7.html#S0061">known_discriminant_part</A></SPAN> 
but is not a record extension, then the corresponding subtype is constrained 
to those values that when converted to the parent type belong to the 
given subtype (see <A HREF="AA-4-6.html">4.6</A>). <SPAN STYLE="font-size: 80%">{<I>implicit 
subtype conversion (derived type discriminants)</I> [partial]}</SPAN> 
<A NAME="I1615"></A></LI></UL>
<DIV Class="paranum">21.a</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>An inherited subprogram of an 
untagged type has an Intrinsic calling convention, which precludes the 
use of the Access attribute. We preclude 'Access because correctly performing 
all required constraint checks on an indirect call to such an inherited 
subprogram was felt to impose an undesirable implementation burden.&nbsp;</DIV>
<DIV Class="paranum">22/2</DIV>
<UL Class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00401.TXT">AI95-00401-01</A></I>} 
The same formal parameters have <SPAN Class="swiss"><A HREF="AA-3-7.html#S0063">default_expression</A></SPAN>s 
in the profile of the inherited subprogram. [Any type mismatch due to 
the systematic replacement of the parent<SPAN class="insert2">&nbsp;or progenitor</SPAN> 
type by the derived type is handled as part of the normal type conversion 
associated with parameter passing &mdash; see <A HREF="AA-6-4-1.html">6.4.1</A>.] 
</UL>
<DIV Class="paranum">22.a/2</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00401.TXT">AI95-00401-01</A></I>} 
We don't introduce the type conversion explicitly here since conversions 
to record extensions or on access parameters are not generally legal. 
Furthermore, any type conversion would just be &quot;undone&quot; since 
the <SPAN class="delete2">parent's&nbsp;</SPAN>subprogram <SPAN class="insert2">of 
the parent or progenitor&nbsp;</SPAN>is ultimately being called anyway.<SPAN class="insert2">&nbsp;(Null procedures can be inherited from a progenitor without being overridden, 
so it is possible to call subprograms of an interface.)</SPAN>&nbsp;</DIV>
<DIV Class="paranum">23/2</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00401.TXT">AI95-00401-01</A></I>} 
If a primitive subprogram of the parent<SPAN class="insert2">&nbsp;or progenitor</SPAN> 
type is visible at the place of the <SPAN Class="swiss"><A HREF="AA-3-4.html#S0035">derived_type_definition</A></SPAN>, 
then the corresponding inherited subprogram is implicitly declared immediately 
after the <SPAN Class="swiss"><A HREF="AA-3-4.html#S0035">derived_type_definition</A></SPAN>. 
Otherwise, the inherited subprogram is implicitly declared later or not 
at all, as explained in <A HREF="AA-7-3-1.html">7.3.1</A>.</DIV>
<DIV Class="paranum">24</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>derived type</I> 
[partial]}</SPAN> <A NAME="I1616"></A>A derived type can also be defined 
by a <SPAN Class="swiss"><A HREF="AA-7-3.html#S0177">private_extension_declaration</A></SPAN> 
(see <A HREF="AA-7-3.html">7.3</A>) or a <SPAN Class="swiss"><A HREF="AA-12-5-1.html#S0265">formal_derived_type_definition</A></SPAN> 
(see <A HREF="AA-12-5-1.html">12.5.1</A>). Such a derived type is a partial 
view of the corresponding full or actual type.</DIV>
<DIV Class="paranum">25</DIV>
<DIV Class="Normal">All numeric types are derived types, in that they 
are implicitly derived from a corresponding root numeric type (see <A HREF="AA-3-5-4.html">3.5.4</A> 
and <A HREF="AA-3-5-6.html">3.5.6</A>).</DIV>

<H4 Class="centered">Dynamic Semantics</H4>
<DIV Class="paranum">26</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>elaboration (derived_type_definition)</I> 
[partial]}</SPAN> <A NAME="I1617"></A>The elaboration of a <SPAN Class="swiss"><A HREF="AA-3-4.html#S0035">derived_type_definition</A></SPAN> 
creates the derived type and its first subtype, and consists of the elaboration 
of the <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0027">subtype_indication</A></SPAN> 
and the <SPAN Class="swiss"><A HREF="AA-3-9-1.html#S0075">record_extension_part</A></SPAN>, 
if any. If the <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0027">subtype_indication</A></SPAN> 
depends on a discriminant, then only those expressions that do not depend 
on a discriminant are evaluated.&nbsp;</DIV>
<DIV Class="paranum">26.a/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Discussion:&nbsp;</B></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
<SPAN class="insert2">We don't mention the <SPAN Class="swiss"><A HREF="AA-3-9-4.html#S0078">interface_list</A></SPAN>, 
because it does not need elaboration (see <A HREF="AA-3-9-4.html">3.9.4</A>. 
This is consistent with the handling of <SPAN Class="swiss"><A HREF="AA-3-7.html#S0059">discriminant_part</A></SPAN>s, 
which aren't elaborated either.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">27/2</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00391.TXT">AI95-00391-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00401.TXT">AI95-00401-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>execution (call on an inherited subprogram)</I> 
[partial]}</SPAN> <A NAME="I1618"></A>For the execution of a call on 
an inherited subprogram, a call on the corresponding primitive subprogram 
of the parent<SPAN class="insert2">&nbsp;or progenitor</SPAN> type is performed; 
the normal conversion of each actual parameter to the subtype of the 
corresponding formal parameter (see <A HREF="AA-6-4-1.html">6.4.1</A>) 
performs any necessary type conversion as well. If the result type of 
the inherited subprogram is the derived type, the result of calling the 
<SPAN class="delete2">parent's&nbsp;</SPAN>subprogram<SPAN class="insert2">&nbsp;of the parent or progenitor</SPAN> is converted to the derived type<SPAN class="insert2">, 
or in the case of a null extension, extended to the derived type using 
the equivalent of an <SPAN Class="swiss"><A HREF="AA-4-3-2.html#S0109">extension_aggregate</A></SPAN> 
with the original result as the <SPAN Class="swiss"><A HREF="AA-4-3-2.html#S0110">ancestor_part</A></SPAN> 
and <B>null record</B> as the <SPAN Class="swiss"><A HREF="AA-4-3-1.html#S0106">record_component_association_list</A></SPAN></SPAN>. 
<SPAN STYLE="font-size: 80%">{<I>implicit subtype conversion (result 
of inherited function)</I> [partial]}</SPAN> <A NAME="I1619"></A></DIV>
<DIV Class="paranum">27.a/2</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00391.TXT">AI95-00391-01</A></I>} 
If an inherited function returns the derived type, and the type is a 
<SPAN class="insert2">non-null&nbsp;</SPAN>record extension, then the inherited 
function <SPAN class="insert2">shall be overridden, unless the type is 
abstract (in which case the function&nbsp;</SPAN>is abstract, and (unless 
overridden) cannot be called except via a dispatching call<SPAN class="insert2">)</SPAN>. 
See <A HREF="AA-3-9-3.html">3.9.3</A>.&nbsp;</DIV>
<DIV Class="NotesHeader">NOTES</DIV>
<DIV Class="paranum">28</DIV>
<DIV Class="Notes">10&nbsp;&nbsp;<SPAN STYLE="font-size: 80%">{<I>closed 
under derivation</I>}</SPAN> <A NAME="I1620"></A>Classes are closed under 
derivation &mdash; any class that contains a type also contains its derivatives. 
Operations available for a given class of types are available for the 
derived types in that class.</DIV>
<DIV Class="paranum">29</DIV>
<DIV Class="Notes">11&nbsp;&nbsp;Evaluating an inherited enumeration 
literal is equivalent to evaluating the corresponding enumeration literal 
of the parent type, and then converting the result to the derived type. 
This follows from their equivalence to parameterless functions. <SPAN STYLE="font-size: 80%">{<I>implicit 
subtype conversion (inherited enumeration literal)</I> [partial]}</SPAN> 
<A NAME="I1621"></A></DIV>
<DIV Class="paranum">30</DIV>
<DIV Class="Notes">12&nbsp;&nbsp;A generic subprogram is not a subprogram, 
and hence cannot be a primitive subprogram and cannot be inherited by 
a derived type. On the other hand, an instance of a generic subprogram 
can be a primitive subprogram, and hence can be inherited.</DIV>
<DIV Class="paranum">31</DIV>
<DIV Class="Notes">13&nbsp;&nbsp;If the parent type is an access type, 
then the parent and the derived type share the same storage pool; there 
is a <B>null</B> access value for the derived type and it is the implicit 
initial value for the type. See <A HREF="AA-3-10.html">3.10</A>.</DIV>
<DIV Class="paranum">32</DIV>
<DIV Class="Notes">14&nbsp;&nbsp;If the parent type is a boolean type, 
the predefined relational operators of the derived type deliver a result 
of the predefined type Boolean (see <A HREF="AA-4-5-2.html">4.5.2</A>). 
If the parent type is an integer type, the right operand of the predefined 
exponentiation operator is of the predefined type Integer (see <A HREF="AA-4-5-6.html">4.5.6</A>).</DIV>
<DIV Class="paranum">33</DIV>
<DIV Class="Notes">15&nbsp;&nbsp;Any discriminants of the parent type 
are either all inherited, or completely replaced with a new set of discriminants.</DIV>
<DIV Class="paranum">34</DIV>
<DIV Class="Notes">16&nbsp;&nbsp;For an inherited subprogram, the subtype 
of a formal parameter of the derived type need not have any value in 
common with the first subtype of the derived type.&nbsp;</DIV>
<DIV Class="paranum">34.a</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><B>Proof:&nbsp;</B>This 
happens when the parent subtype is constrained to a range that does not 
overlap with the range of a subtype of the parent type that appears in 
the profile of some primitive subprogram of the parent type. For example: 
</DIV>
<DIV Class="paranum">34.b</DIV>
<DIV Class="SmallExamples"><B>type</B>&nbsp;T1&nbsp;<B>is&nbsp;range</B>&nbsp;1..100;<BR>
<B>subtype</B>&nbsp;S1&nbsp;<B>is</B>&nbsp;T1&nbsp;<B>range</B>&nbsp;1..10;<BR>
<B>procedure</B>&nbsp;P(X&nbsp;:&nbsp;<B>in</B>&nbsp;S1);&nbsp;&nbsp;<SPAN Class="roman"><I>--&nbsp;P&nbsp;is&nbsp;a&nbsp;primitive&nbsp;subprogram</I></SPAN><BR>
<B>type</B>&nbsp;T2&nbsp;<B>is&nbsp;new</B>&nbsp;T1&nbsp;<B>range</B>&nbsp;11..20;<BR>
<SPAN Class="roman"><I>--&nbsp;implicitly&nbsp;declared:</I></SPAN><BR>
<SPAN Class="roman"><I>--&nbsp;<B>procedure</B>&nbsp;P(X&nbsp;:&nbsp;<B>in</B>&nbsp;T2'Base&nbsp;<B>range</B>&nbsp;1..10);</I></SPAN><BR>
<SPAN Class="roman"><I>--&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;cannot&nbsp;be&nbsp;in&nbsp;T2'First&nbsp;..&nbsp;T2'Last</I></SPAN></DIV>
<DIV Class="paranum">35</DIV>
<DIV Class="Notes">17&nbsp;&nbsp;If the reserved word <B>abstract</B> 
is given in the declaration of a type, the type is abstract (see <A HREF="AA-3-9-3.html">3.9.3</A>).</DIV>
<DIV Class="paranum">35.1/2</DIV>
<DIV Class="Notes">18&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00401.TXT">AI95-00401-01</A></I>} 
<SPAN class="insert2">An interface type that has a progenitor type &ldquo;is 
derived from&rdquo; that type. A <SPAN Class="swiss"><A HREF="AA-3-4.html#S0035">derived_type_definition</A></SPAN>, 
however, never defines an interface type.</SPAN></DIV>
<DIV Class="paranum">35.2/2</DIV>
<DIV Class="Notes">19&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00345.TXT">AI95-00345-01</A></I>} 
<SPAN class="insert2">It is illegal for the parent type of a <SPAN Class="swiss"><A HREF="AA-3-4.html#S0035">derived_type_definition</A></SPAN> 
to be a synchronized tagged type.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">35.a/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Proof:&nbsp;</B><A HREF="AA-3-9-1.html">3.9.1</A> 
prohibits record extensions whose parent type is a synchronized tagged 
type, and this clause requires tagged types to have a record extension. 
Thus there are no legal derivations. Note that a synchronized interface 
can be used as a progenitor in an <SPAN Class="swiss"><A HREF="AA-3-9-4.html#S0077">interface_type_definition</A></SPAN> 
as well as in task and protected types, but we do not allow concrete 
extensions of any synchronized tagged type.</SPAN>&nbsp;</DIV>

<H4 Class="centered">Examples</H4>
<DIV Class="paranum">36</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em"><I>Examples of derived 
type declarations:</I>&nbsp;</DIV>
<DIV Class="paranum">37</DIV>
<DIV Class="Examples"><B>type</B>&nbsp;Local_Coordinate&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Coordinate;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;&nbsp;two&nbsp;different&nbsp;types</I></SPAN><BR>
<B>type</B>&nbsp;Midweek&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Day&nbsp;<B>range</B>&nbsp;Tue&nbsp;..&nbsp;Thu;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;&nbsp;see&nbsp;<A HREF="AA-3-5-1.html">3.5.1</A></I></SPAN><BR>
<B>type</B>&nbsp;Counter&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Positive;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;&nbsp;same&nbsp;range&nbsp;as&nbsp;Positive&nbsp;</I></SPAN></DIV>
<DIV Class="paranum">38</DIV>
<DIV Class="Examples"><B>type</B>&nbsp;Special_Key&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Key_Manager.Key;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;&nbsp;see&nbsp;<A HREF="AA-7-3-1.html">7.3.1</A></I></SPAN><BR>
&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;the&nbsp;inherited&nbsp;subprograms&nbsp;have&nbsp;the&nbsp;following&nbsp;specifications:&nbsp;</I></SPAN><BR>
&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;Get_Key(K&nbsp;:&nbsp;out&nbsp;Special_Key);</I></SPAN><BR>
&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;&quot;&lt;&quot;(X,Y&nbsp;:&nbsp;Special_Key)&nbsp;return&nbsp;Boolean;</I></SPAN></DIV>

<H4 Class="centered">Inconsistencies With Ada 83</H4>
<DIV Class="paranum">38.a</DIV>
<DIV Class="Annotations">{<I>inconsistencies with Ada 83</I>} <A NAME="I1622"></A>When 
deriving from a (nonprivate, nonderived) type in the same visible part 
in which it is defined, if a predefined operator had been overridden 
prior to the derivation, the derived type will inherit the user-defined 
operator rather than the predefined operator. The work-around (if the 
new behavior is not the desired behavior) is to move the definition of 
the derived type prior to the overriding of any predefined operators.</DIV>

<H4 Class="centered">Incompatibilities With Ada 83</H4>
<DIV Class="paranum">38.b</DIV>
<DIV Class="Annotations">{<I>incompatibilities with Ada 83</I>} <A NAME="I1623"></A>When 
deriving from a (nonprivate, nonderived) type in the same visible part 
in which it is defined, a primitive subprogram of the parent type declared 
before the derived type will be inherited by the derived type. This can 
cause upward incompatibilities in cases like this:&nbsp;</DIV>
<DIV Class="paranum">38.c</DIV>
<DIV Class="SmallExamples" Style="margin-bottom: 0.4em">&nbsp;&nbsp;&nbsp;<B>package</B>&nbsp;P&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T&nbsp;<B>is</B>&nbsp;(A,&nbsp;B,&nbsp;C,&nbsp;D);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;F(&nbsp;X&nbsp;:&nbsp;T&nbsp;:=&nbsp;A&nbsp;)&nbsp;<B>return</B>&nbsp;Integer;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;NT&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;T;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;inherits&nbsp;F&nbsp;as</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;function&nbsp;F(&nbsp;X&nbsp;:&nbsp;NT&nbsp;:=&nbsp;A&nbsp;)&nbsp;return&nbsp;Integer;</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;in&nbsp;Ada&nbsp;95&nbsp;only</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<BR>
&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;P;<BR>
&nbsp;&nbsp;&nbsp;...<BR>
&nbsp;&nbsp;&nbsp;<B>use</B>&nbsp;P;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;Only&nbsp;one&nbsp;declaration&nbsp;of&nbsp;F&nbsp;from&nbsp;P&nbsp;is&nbsp;use-visible&nbsp;in</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;Ada&nbsp;83;&nbsp;&nbsp;two&nbsp;declarations&nbsp;of&nbsp;F&nbsp;are&nbsp;use-visible&nbsp;in</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;Ada&nbsp;95.</I></SPAN><BR>
<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;...<BR>
&nbsp;&nbsp;&nbsp;<B>if</B>&nbsp;F&nbsp;&gt;&nbsp;1&nbsp;<B>then</B>&nbsp;...&nbsp;--<SPAN Class="roman"><I>&nbsp;legal&nbsp;in&nbsp;Ada&nbsp;83,&nbsp;ambiguous&nbsp;in&nbsp;Ada&nbsp;95</I></SPAN></DIV>

<H4 Class="centered">Extensions to Ada 83</H4>
<DIV Class="paranum">38.d</DIV>
<DIV Class="Annotations">{<I>extensions to Ada 83</I>} <A NAME="I1624"></A>The 
syntax for a <SPAN Class="swiss"><A HREF="AA-3-4.html#S0035">derived_type_definition</A></SPAN> 
is amended to include an optional <SPAN Class="swiss"><A HREF="AA-3-9-1.html#S0075">record_extension_part</A></SPAN> 
(see <A HREF="AA-3-9-1.html">3.9.1</A>).</DIV>
<DIV Class="paranum">38.e</DIV>
<DIV Class="Annotations">A derived type may override the discriminants 
of the parent by giving a new <SPAN Class="swiss"><A HREF="AA-3-7.html#S0059">discriminant_part</A></SPAN>.</DIV>
<DIV Class="paranum">38.f</DIV>
<DIV Class="Annotations">The parent type in a <SPAN Class="swiss"><A HREF="AA-3-4.html#S0035">derived_type_definition</A></SPAN> 
may be a derived type defined in the same visible part.</DIV>
<DIV Class="paranum">38.g</DIV>
<DIV Class="Annotations">When deriving from a type in the same visible 
part in which it is defined, the primitive subprograms declared prior 
to the derivation are inherited as primitive subprograms of the derived 
type. See <A HREF="AA-3-2-3.html">3.2.3</A>.&nbsp;</DIV>

<H4 Class="centered">Wording Changes from Ada 83</H4>
<DIV Class="paranum">38.h</DIV>
<DIV Class="Annotations">We now talk about the classes to which a type 
belongs, rather than a single class.</DIV>
<DIV Class="paranum">38.i</DIV>
<DIV Class="Annotations">As explained in Section 13, the concept of &quot;storage 
pool&quot; replaces the Ada 83 concept of &quot;collection.&quot; These 
concepts are similar, but not the same.&nbsp;</DIV>

<H4 Class="centered">Extensions to Ada 95</H4>
<DIV Class="paranum">38.j/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00401.TXT">AI95-00401-01</A></I>} 
<SPAN class="insert2">{<I>extensions to Ada 95</I>} <A NAME="I1625"></A>A 
derived type may inherit from multiple (interface) progenitors, as well 
as the parent type &mdash; see <A HREF="AA-3-9-4.html">3.9.4</A>, &ldquo;<A HREF="AA-3-9-4.html">Interface 
Types</A>&rdquo;.</SPAN></DIV>
<DIV Class="paranum">38.k/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00419.TXT">AI95-00419-01</A></I>} 
<SPAN class="insert2">A derived type may specify that it is a limited 
type. This is required for interface ancestors (from which limitedness 
is not inherited), but it is generally useful as documentation of limitedness.</SPAN> 
</DIV>

<H4 Class="centered">Wording Changes from Ada 95</H4>
<DIV Class="paranum">38.l/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00391.TXT">AI95-00391-01</A></I>} 
<SPAN class="insert2">Defined the result of functions for null extensions 
(which we no longer require to be overridden - see <A HREF="AA-3-9-3.html">3.9.3</A>).</SPAN></DIV>
<DIV Class="paranum">38.m/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00442.TXT">AI95-00442-01</A></I>} 
<SPAN class="insert2">Defined the term &ldquo;category of types&rdquo; 
and used it in wording elsewhere; also specified the language-defined 
categories that form classes of types (this was never normatively specified 
in Ada 95.</SPAN>&nbsp;</DIV>

<HR>
<DIV Style="margin-top: 0.0em; margin-bottom: 0.6em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-3-3-2.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-3-4-1.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<DIV Style="margin-top:0.0em"><IMG SRC="AE_logo.gif" height=100 width=113 align=right ALT="Ada-Europe">
<SPAN Style="font-size: 125%">Sponsored by <SPAN Style="font-size: 125%"><A HREF="http://www.ada-europe.org/"><B>Ada-Europe</B></A></SPAN></SPAN></DIV>
</BODY>
</HTML>
