<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Sets</TITLE>
    <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    H4.centered {text-align: center}
    SPAN.swiss {font-family: Arial, Helvetica, sans-serif; font-size: 92%}
    SPAN.roman {font-family: "Times New Roman", Times, serif}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    DIV.Normal {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-bottom: 0.6em}
    DIV.SwissExamples {font-family: Arial, Helvetica, sans-serif; font-size: 90%; line-height: 122%; margin-left: 2.2em; margin-bottom: 0.6em}
    </STYLE>
<!-- BEGIN Google Analytics -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-117428-5']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
<!-- END Google Analytics -->
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">
<H1 Style='font-family: "Rockwell", "Times New Roman", Times, serif; font-size: 240%'><B><SPAN Style="color:rgb(0,0,153)">Rationale</SPAN> for <SPAN Style="color:rgb(204,0,0)">Ada 2005</SPAN></B></H1>
<DIV Class="Normal"><FONT SIZE="+1"><I><A HREF="Rat-TTL.html">John Barnes</A></I></FONT></DIV>
<div style="margin-top: 0.6em; margin-bottom: 0.0em"><A HREF="Rat-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="Rat-0-3.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="Rat-0-2.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="Rat-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="Rat-8-3.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="Rat-8-5.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</div>
<HR>
<H1>8.4 Sets</H1>
<div class="Normal">Sets, like maps, come in two forms: hashed and ordered. 
Sets are of course just collections of values and there is no question 
of a key (we can perhaps think of the value as being its own key). Thus 
in the case of an ordered set the values are stored in order whereas 
in the case of a map, it is the keys that are stored in order. As well 
as the usual operations of inserting elements into a set and searching 
and so on, there are also many operations on sets as a whole that do 
not apply to the other containers &ndash; these are the familiar set 
operations such as union and intersection.<A NAME="I1405"></A><A NAME="I1406"></A></div>
<div class="Normal">Here is the specification of the ordered sets package 
giving just those facilities that are common to both kinds of sets.<A NAME="I1407"></A><A NAME="I1408"></A><A NAME="I1409"></A> 
</div>
<div class="SwissExamples"><B>generic</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Element_Type&nbsp;<B>is&nbsp;private</B>;<BR>
&nbsp;&nbsp;&nbsp;<B>with&nbsp;function</B>&nbsp;&quot;&lt;&quot;&nbsp;(Left,&nbsp;Right:&nbsp;Element_Type)&nbsp;<B>return</B>&nbsp;Boolean&nbsp;<B>is</B>&nbsp;&lt;&gt;;<BR>
&nbsp;&nbsp;&nbsp;<B>with&nbsp;function</B>&nbsp;&quot;=&quot;&nbsp;(Left,&nbsp;Right:&nbsp;Element_Type)&nbsp;<B>return</B>&nbsp;Boolean&nbsp;<B>is</B>&nbsp;&lt;&gt;;<BR>
<B>package</B>&nbsp;Ada.Containers.Ordered_Sets&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>pragma</B>&nbsp;Preelaborate(Ordered_Sets);</div>
<div class="SwissExamples">&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;Equivalent_Elements(Left,&nbsp;Right:&nbsp;Element_Type)&nbsp;<B>return</B>&nbsp;Boolean;</div>
<div class="SwissExamples">&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Set&nbsp;<B>is&nbsp;tagged&nbsp;private</B>;<BR>
&nbsp;&nbsp;&nbsp;<B>pragma</B>&nbsp;Preelaborable_Initialization(Set);<BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Cursor&nbsp;<B>is&nbsp;private</B>;<BR>
&nbsp;&nbsp;&nbsp;<B>pragma</B>&nbsp;Preelaborable_Initialization(Cursor);<BR>
&nbsp;&nbsp;&nbsp;Empty_Set:&nbsp;<B>constant</B>&nbsp;Set;<BR>
&nbsp;&nbsp;&nbsp;No_Element:&nbsp;<B>constant</B>&nbsp;Cursor;</div>
<div class="Normal">The only differences from the maps package (apart 
from the identifiers) are that there is no key type and both <SPAN Class="swiss">&quot;&lt;&quot;</SPAN> 
and <SPAN Class="swiss">&quot;=&quot;</SPAN> apply to the element type 
(whereas in the case of maps, the operation <SPAN Class="swiss">&quot;&lt;&quot;</SPAN> 
applies to the key type). Thus the ordering relationship <SPAN Class="swiss">&quot;&lt;&quot;</SPAN> 
defined on elements defines equivalence between the elements whereas 
<SPAN Class="swiss">&quot;=&quot;</SPAN> defines equality.</div>
<div class="Normal">It is possible for two elements to be equivalent 
but not equal. For example if they were strings then we might decide 
that the ordering (and thus equivalence) ignored the case of letters 
but that equality should take the case into account. (They could also 
be equal but not equivalent but that is perhaps less likely.)</div>
<div class="Normal">And as in the case of the maps package, the equality 
operation on elements is only used by the function <SPAN Class="swiss">&quot;=&quot;</SPAN> 
for comparing two sets.</div>
<div class="Normal">Again we have the usual rules as explained for maps. 
Thus if <SPAN Class="swiss">x &lt; y</SPAN> is true then <SPAN Class="swiss">y 
&lt; x</SPAN> must be false; <SPAN Class="swiss">x &lt; y</SPAN> and 
<SPAN Class="swiss">y &lt; z</SPAN> must imply <SPAN Class="swiss">x 
&lt; z</SPAN>; and <SPAN Class="swiss">x = y</SPAN> and <SPAN Class="swiss">y 
= x</SPAN> must be the same.</div>
<div class="Normal">For the convenience of the user the function <SPAN Class="swiss">Equivalent_Elements</SPAN> 
is declared explicitly. It is equivalent to&nbsp;</div>
<div class="SwissExamples"><B>function</B>&nbsp;Equivalent_Elements(Left,&nbsp;Right:&nbsp;Element_Type)&nbsp;<B>return</B>&nbsp;Boolean&nbsp;<B>is</B><BR>
<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;<B>return</B>&nbsp;<B>not</B>&nbsp;(Left&nbsp;&lt;&nbsp;Right)&nbsp;<B>and&nbsp;not</B>&nbsp;(Right&nbsp;&lt;&nbsp;Left);<BR>
<B>end</B>&nbsp;Equivalent_Elements;</div>
<div class="Normal">This function <SPAN Class="swiss">Equivalent_Elements</SPAN> 
corresponds to the formal generic parameter of the same name in the hashed 
sets package discussed below. This should make it easier to convert between 
the two forms of packages.</div>
<div class="SwissExamples"><B>function</B>&nbsp;&quot;=&quot;&nbsp;(Left,&nbsp;Right:&nbsp;Set)&nbsp;<B>return</B>&nbsp;Boolean;<BR>
<B>function</B>&nbsp;Equivalent_Sets(Left,&nbsp;Right:&nbsp;Set)&nbsp;<B>return</B>&nbsp;Boolean;<BR>
<B>function</B>&nbsp;To_Set(New_Item:&nbsp;Element_Type)&nbsp;<B>return</B>&nbsp;Set;<BR>
<B>function</B>&nbsp;Length(Container:&nbsp;Set)&nbsp;<B>return</B>&nbsp;Count_Type;<BR>
<B>function</B>&nbsp;Is_Empty(Container:&nbsp;Set)&nbsp;<B>return</B>&nbsp;Boolean;<BR>
<B>procedure</B>&nbsp;Clear(Container:&nbsp;<B>in&nbsp;out</B>&nbsp;Set);</div>
<div class="Normal">Note the addition of <SPAN Class="swiss">Equivalent_Sets</SPAN> 
and <SPAN Class="swiss">To_Set</SPAN>. Two sets are equivalent if they 
have the same number of elements and the pairs of elements are equivalent. 
This contrasts with the function <SPAN Class="swiss">&quot;=&quot;</SPAN> 
where the pairs of elements have to be equal rather than equivalent. 
Remember that elements might be equivalent but not equal (as in the example 
of a string mentioned above). The function <SPAN Class="swiss">To_Set</SPAN> 
takes a single element and creates a set. It is particularly convenient 
when used in conjunction with operations such as <SPAN Class="swiss">Union</SPAN> 
described below. The other subprograms are as in the other containers.</div>
<div class="SwissExamples"><B>function</B>&nbsp;Element(Position:&nbsp;Cursor)&nbsp;<B>return</B>&nbsp;Element_Type;</div>
<div class="SwissExamples"><B>procedure</B>&nbsp;Replace_Element(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Container:&nbsp;<B>in&nbsp;out</B>&nbsp;Set;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Position:&nbsp;<B>in</B>&nbsp;Cursor;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;New_Item:&nbsp;<B>in</B>&nbsp;Element_Type);</div>
<div class="SwissExamples"><B>procedure</B>&nbsp;Query_Element(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Position:&nbsp;<B>in</B>&nbsp;Cursor;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Process:&nbsp;<B>not&nbsp;null&nbsp;access&nbsp;procedure</B>&nbsp;(Element:&nbsp;<B>in</B>&nbsp;Element_Type));</div>
<div class="Normal">Again these are much as expected except that there 
is no procedure <SPAN Class="swiss">Update_Element</SPAN>. This is because 
the elements are arranged in terms of their own value (either by order 
or through the hash function) and if we just change an element <I>in 
situ</I> then it might become out of place (this problem does not arise 
with the other containers). This also means that <SPAN Class="swiss">Replace_Element</SPAN> 
has to ensure that the value <SPAN Class="swiss">New_Item</SPAN> is not 
equivalent to an element in a different position; if it is then <SPAN Class="swiss">Program_Error</SPAN> 
is raised. We will return to the problem of the missing <SPAN Class="swiss">Update_Element</SPAN> 
later.</div>
<div class="SwissExamples"><B>procedure</B>&nbsp;Move(Target,&nbsp;Source:&nbsp;<B>in&nbsp;out</B>&nbsp;Set);</div>
<div class="Normal">This is just as for the other containers.</div>
<div class="SwissExamples"><B>procedure</B>&nbsp;Insert(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Container:&nbsp;<B>in&nbsp;out</B>&nbsp;Set;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;New_Item:&nbsp;<B>in</B>&nbsp;Element_Type;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Position:&nbsp;<B>out</B>&nbsp;Cursor;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Inserted:&nbsp;<B>out</B>&nbsp;Boolean);</div>
<div class="SwissExamples"><B>procedure</B>&nbsp;Insert(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Container:&nbsp;<B>in&nbsp;out</B>&nbsp;Set;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;New_Item:&nbsp;<B>in</B>&nbsp;Element_Type);</div>
<div class="Normal">These insert a new element into the set unless an 
equivalent element already exists. If it does exist then the first one 
returns with <SPAN Class="swiss">Inserted</SPAN> set to <SPAN Class="swiss">False</SPAN> 
and <SPAN Class="swiss">Position</SPAN> indicating the element whereas 
the second raises <SPAN Class="swiss">Constraint_Error</SPAN> (the element 
value is not changed). If an equivalent element is not in the set then 
it is added and <SPAN Class="swiss">Position</SPAN> is set accordingly.</div>
<div class="SwissExamples"><B>procedure</B>&nbsp;Include(Container:&nbsp;<B>in&nbsp;out</B>&nbsp;Set;&nbsp;New_Item:&nbsp;<B>in</B>&nbsp;Element_Type);</div>
<div class="Normal">This is somewhat like the last <SPAN Class="swiss">Insert</SPAN> 
except that if an equivalent element is already in the set then it is 
replaced (rather than raising <SPAN Class="swiss">Constraint_Error</SPAN>).</div>
<div class="SwissExamples"><B>procedure</B>&nbsp;Replace(Container:&nbsp;<B>in&nbsp;out</B>&nbsp;Set;&nbsp;New_Item:&nbsp;<B>in</B>&nbsp;Element_Type);</div>
<div class="Normal">In this case, <SPAN Class="swiss">Constraint_Error</SPAN> 
is raised if an equivalent element does not already exist.</div>
<div class="SwissExamples"><B>procedure</B>&nbsp;Exclude(Container:&nbsp;<B>in&nbsp;out</B>&nbsp;Set;&nbsp;Item:&nbsp;<B>in</B>&nbsp;Element_Type);</div>
<div class="Normal">If an element equivalent to <SPAN Class="swiss">Item</SPAN> 
is already in the set, then it is deleted.</div>
<div class="SwissExamples"><B>procedure</B>&nbsp;Delete(Container:&nbsp;<B>in&nbsp;out</B>&nbsp;Set;&nbsp;Item:&nbsp;<B>in</B>&nbsp;Element_Type);</div>
<div class="SwissExamples"><B>procedure</B>&nbsp;Delete(Container:&nbsp;<B>in&nbsp;out</B>&nbsp;Set;&nbsp;Position:&nbsp;<B>in&nbsp;out</B>&nbsp;Cursor);</div>
<div class="Normal">These delete an element. In the first case if there 
is no such equivalent element then <SPAN Class="swiss">Constraint_Error</SPAN> 
is raised. In the second case if the cursor is <SPAN Class="swiss">No_Element</SPAN> 
then again <SPAN Class="swiss">Constraint_Error</SPAN> is also raised 
&ndash; there is also a check to ensure that the cursor otherwise does 
designate an element in the correct set (remember that cursors designate 
both an entity and the container); if this check fails then <SPAN Class="swiss">Program_Error</SPAN> 
is raised.</div>
<div class="Normal">And now some new stuff, the usual set operations.</div>
<div class="SwissExamples"><B>procedure</B>&nbsp;Union(Target:&nbsp;<B>in&nbsp;out</B>&nbsp;Set;&nbsp;Source:&nbsp;<B>in</B>&nbsp;Set);<BR>
<B>function</B>&nbsp;Union(Left,&nbsp;Right:&nbsp;Set)&nbsp;<B>return</B>&nbsp;Set;<BR>
<B>function</B>&nbsp;&quot;or&quot;&nbsp;(Left,&nbsp;Right:&nbsp;Set)&nbsp;<B>return</B>&nbsp;Set&nbsp;<B>renames</B>&nbsp;Union;</div>
<div class="SwissExamples"><B>procedure</B>&nbsp;Intersection(Target:&nbsp;<B>in&nbsp;out</B>&nbsp;Set;&nbsp;Source:&nbsp;<B>in</B>&nbsp;Set);<BR>
<B>function</B>&nbsp;Intersection(Left,&nbsp;Right:&nbsp;Set)&nbsp;<B>return</B>&nbsp;Set;<BR>
<B>function</B>&nbsp;&quot;<B>and</B>&quot;&nbsp;(Left,&nbsp;Right:&nbsp;Set)&nbsp;<B>return</B>&nbsp;Set&nbsp;<B>renames</B>&nbsp;Intersection;</div>
<div class="SwissExamples"><B>procedure</B>&nbsp;Difference(Target:&nbsp;<B>in&nbsp;out</B>&nbsp;Set;&nbsp;Source:&nbsp;<B>in</B>&nbsp;Set);<BR>
<B>function</B>&nbsp;Difference(Left,&nbsp;Right:&nbsp;Set)&nbsp;<B>return</B>&nbsp;Set;<BR>
<B>function</B>&nbsp;&quot;&ndash;&quot;&nbsp;(Left,&nbsp;Right:&nbsp;Set)&nbsp;<B>return</B>&nbsp;Set&nbsp;<B>renames</B>&nbsp;Difference;</div>
<div class="SwissExamples"><B>procedure</B>&nbsp;Symmetric_Difference(Target:&nbsp;<B>in&nbsp;out</B>&nbsp;Set;&nbsp;Source:&nbsp;<B>in</B>&nbsp;Set);<BR>
<B>function</B>&nbsp;Symmetric_Difference&nbsp;(Left,&nbsp;Right:&nbsp;Set)&nbsp;<B>return</B>&nbsp;Set;<BR>
<B>function</B>&nbsp;&quot;<B>xor</B>&quot;&nbsp;(Left,&nbsp;Right:&nbsp;Set)&nbsp;<B>return</B>&nbsp;Set&nbsp;<B>renames</B>&nbsp;Symmetric_Difference;</div>
<div class="Normal">These all do exactly what one would expect using 
the equivalence relation on the elements.</div>
<div class="SwissExamples"><B>function</B>&nbsp;Overlap(Left,&nbsp;Right:&nbsp;Set)&nbsp;<B>return</B>&nbsp;Boolean;<BR>
<B>function</B>&nbsp;Is_Subset(Subset:&nbsp;Set;&nbsp;Of_Set:&nbsp;Set)&nbsp;<B>return</B>&nbsp;Boolean;</div>
<div class="Normal">These are self-evident as well.</div>
<div class="SwissExamples"><B>function</B>&nbsp;First(Container:&nbsp;Set)&nbsp;<B>return</B>&nbsp;Cursor;<BR>
<B>function</B>&nbsp;Last(Container:&nbsp;Set)&nbsp;<B>return</B>&nbsp;Cursor;<BR>
<B>function</B>&nbsp;Next(Position:&nbsp;Cursor)&nbsp;<B>return</B>&nbsp;Cursor;<BR>
<B>procedure</B>&nbsp;Next(Position:&nbsp;<B>in&nbsp;out</B>&nbsp;Cursor);<BR>
<B>function</B>&nbsp;Find(Container:&nbsp;Set;&nbsp;Item:&nbsp;Element_Type)&nbsp;<B>return</B>&nbsp;Cursor;<BR>
<B>function</B>&nbsp;Contains(Container:&nbsp;Set;&nbsp;Item:&nbsp;Element_Type)&nbsp;<B>return</B>&nbsp;Boolean;</div>
<div class="Normal">These should be self-evident and are very similar 
to the corresponding operations on maps. Again unlike the operations 
on vectors and lists, <SPAN Class="swiss">Find</SPAN> logically searches 
the whole set and not just starting at some point (there is also no <SPAN Class="swiss">Reverse_Find</SPAN>). 
Moreover, <SPAN Class="swiss">Find</SPAN> uses the equivalence relation 
based on the <SPAN Class="swiss">&quot;&lt;&quot;</SPAN> parameter.</div>
<div class="SwissExamples"><B>function</B>&nbsp;Has_Element(Position:&nbsp;Cursor)&nbsp;<B>return</B>&nbsp;Boolean;</div>
<div class="SwissExamples"><B>procedure</B>&nbsp;Iterate(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Container:&nbsp;<B>in</B>&nbsp;Set;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Process:&nbsp;<B>not&nbsp;null&nbsp;access&nbsp;procedure</B>&nbsp;(Position:&nbsp;<B>in</B>&nbsp;Cursor));</div>
<div class="Normal">These are also as for other containers.</div>
<div class="Normal">The sets packages conclude with an internal generic 
package called <SPAN Class="swiss">Generic_Keys</SPAN>. This package 
enables some set operations to be performed in terms of keys where the 
key is a function of the element. Note carefully that in the case of 
a map, the element is defined in terms of the key whereas here the situation 
is reversed. An equivalence relationship is defined for these keys as 
well; this is defined by a generic parameter <SPAN Class="swiss">&quot;&lt;&quot;</SPAN> 
for ordered sets and <SPAN Class="swiss">Equivalent_Keys</SPAN> for hashed 
sets.</div>
<div class="Normal" style="margin-bottom: 0.4em">In the case of ordered 
sets the formal parameters are&nbsp;</div>
<div class="SwissExamples"><B>generic</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Key_Type(&lt;&gt;)&nbsp;<B>is&nbsp;private</B>;<BR>
&nbsp;&nbsp;&nbsp;<B>with&nbsp;function</B>&nbsp;Key(Element:&nbsp;Element_Type)&nbsp;<B>return</B>&nbsp;Key_Type;<BR>
&nbsp;&nbsp;&nbsp;<B>with&nbsp;function</B>&nbsp;&quot;&lt;&quot;&nbsp;(Left,&nbsp;Right:&nbsp;Key_Type)&nbsp;<B>return</B>&nbsp;Boolean&nbsp;<B>is</B>&nbsp;&lt;&gt;;<BR>
<B>package</B>&nbsp;Generic_Keys&nbsp;<B>is</B></div>
<div class="Normal">The following are then common to the package <SPAN Class="swiss">Generic_Keys</SPAN> 
for both hashed and ordered sets.</div>
<div class="SwissExamples"><B>function</B>&nbsp;Key(Position:&nbsp;Cursor)&nbsp;<B>return</B>&nbsp;Key_Type;<BR>
<B>function</B>&nbsp;Element(Container:&nbsp;Set;&nbsp;Key:&nbsp;Key_Type)&nbsp;<B>return</B>&nbsp;Element_Type;</div>
<div class="SwissExamples"><B>procedure</B>&nbsp;Replace(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Container:&nbsp;<B>in&nbsp;out</B>&nbsp;Set;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key:&nbsp;<B>in</B>&nbsp;Key_Type;&nbsp;New_Item:&nbsp;<B>in</B>&nbsp;Element_Type);</div>
<div class="SwissExamples"><B>procedure</B>&nbsp;Exclude(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Container:&nbsp;<B>in&nbsp;out</B>&nbsp;Set;&nbsp;Key:&nbsp;<B>in</B>&nbsp;Key_Type);<BR>
<B>procedure</B>&nbsp;Delete(Container:&nbsp;<B>in&nbsp;out</B>&nbsp;Set;&nbsp;Key:&nbsp;<B>in</B>&nbsp;Key_Type);</div>
<div class="SwissExamples"><B>function</B>&nbsp;Find(Container:&nbsp;Set;&nbsp;Key:&nbsp;Key_Type)&nbsp;<B>return</B>&nbsp;Cursor;<BR>
<B>function</B>&nbsp;Contains(Container:&nbsp;Set;&nbsp;Key:&nbsp;Key_Type)&nbsp;<B>return</B>&nbsp;Boolean;</div>
<div class="SwissExamples"><B>procedure</B>&nbsp;Update_Element_Preserving_Key(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Container:&nbsp;<B>in&nbsp;out</B>&nbsp;Set;&nbsp;Position:&nbsp;<B>in</B>&nbsp;Cursor;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Process:&nbsp;<B>not&nbsp;null&nbsp;access&nbsp;procedure</B>&nbsp;(Element:&nbsp;<B>in&nbsp;out</B>&nbsp;Element_Type));</div>
<div class="Normal" style="margin-bottom: 0.4em">and then finally</div>
<div class="SwissExamples"><B>end</B>&nbsp;Generic_Keys;</div>
<div class="SwissExamples"><B>private</B><BR>
&nbsp;&nbsp;&nbsp;...&nbsp;--&nbsp;<SPAN Class="roman"><I>not&nbsp;specified&nbsp;by&nbsp;the&nbsp;language</I></SPAN><BR>
<B>end</B>&nbsp;Ada.Containers.Ordered_Sets;</div>
<div class="Normal">It is expected that most user of sets will use them 
in a straightforward manner and that the operations specific to sets 
such as <SPAN Class="swiss">Union</SPAN> and <SPAN Class="swiss">Intersection</SPAN> 
will be dominant.</div>
<div class="Normal" style="margin-bottom: 0.4em">However, sets can be 
used as sort of economy class maps by using the inner package <SPAN Class="swiss">Generic_Keys</SPAN>. 
Although this is certainly not for the novice we will illustrate how 
this might be done by reconsidering the stock problem using sets rather 
than maps. We declare&nbsp;</div>
<div class="SwissExamples"><B>type</B>&nbsp;Part_Type&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>record</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Part_Number:&nbsp;Integer;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Year:&nbsp;Integer;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Shelf:&nbsp;Character&nbsp;<B>range</B>&nbsp;'A'&nbsp;..&nbsp;'T';<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stock:&nbsp;Integer;<BR>
&nbsp;&nbsp;&nbsp;<B>end&nbsp;record</B>;</div>
<div class="Normal">Here we have put all the information in the one type.</div>
<div class="Normal" style="margin-bottom: 0.4em">We then declare <SPAN Class="swiss">&quot;&lt;&quot;</SPAN> 
much as before&nbsp;</div>
<div class="SwissExamples"><B>function</B>&nbsp;&quot;&lt;&quot;&nbsp;(Left,&nbsp;Right:&nbsp;Part_Type)&nbsp;<B>return</B>&nbsp;Boolean&nbsp;<B>is</B><BR>
<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;<B>return</B>&nbsp;Left.Part_Number&nbsp;&lt;&nbsp;Right.Part_Number;<BR>
<B>end</B>&nbsp;&quot;&lt;&quot;;</div>
<div class="Normal" style="margin-bottom: 0.4em">and then instantiate 
the package thus&nbsp;</div>
<div class="SwissExamples"><B>package</B>&nbsp;Store_Sets&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Ordered_Sets(Element_Type&nbsp;=&gt;&nbsp;Part_Type);</div>
<div class="SwissExamples">The_Store:&nbsp;Store_Sets.Set;</div>
<div class="Normal">We have used the default generic parameter mechanism 
for <SPAN Class="swiss">&quot;&lt;&quot;</SPAN> this time by way of illustration.</div>
<div class="Normal" style="margin-bottom: 0.4em">In this case we add 
items to the store by calling&nbsp;</div>
<div class="SwissExamples">The_Store.Insert((34618,&nbsp;1998,&nbsp;'F',&nbsp;25));<BR>
The_Store.Insert((27134,&nbsp;2004,&nbsp;'C',&nbsp;45));<BR>
...</div>
<div class="Normal" style="margin-bottom: 0.4em">The procedure for checking 
the stock could now become&nbsp;</div>
<div class="SwissExamples"><B>procedure</B>&nbsp;Request(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Part:&nbsp;<B>in</B>&nbsp;Integer:&nbsp;OK:&nbsp;<B>out</B>&nbsp;Boolean;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Year:&nbsp;<B>out</B>&nbsp;Integer;&nbsp;Shelf:&nbsp;<B>out</B>&nbsp;Character)&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;C:&nbsp;Cursor;<BR>
&nbsp;&nbsp;&nbsp;E:&nbsp;Part_Type;<BR>
<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;C&nbsp;:=&nbsp;The_Store.Find((Part,&nbsp;<B>others</B>&nbsp;=&gt;&nbsp;&lt;&gt;));<BR>
&nbsp;&nbsp;&nbsp;<B>if</B>&nbsp;C&nbsp;=&nbsp;No_Element&nbsp;<B>then</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OK&nbsp;:=&nbsp;False;&nbsp;<B>return</B>;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>no&nbsp;such&nbsp;item</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;<B>end&nbsp;if</B>;<BR>
&nbsp;&nbsp;&nbsp;E&nbsp;:=&nbsp;Element(C);<BR>
&nbsp;&nbsp;&nbsp;Year&nbsp;:=&nbsp;E.Year;<BR>
&nbsp;&nbsp;&nbsp;Shelf&nbsp;:=&nbsp;E.Shelf;<BR>
&nbsp;&nbsp;&nbsp;<B>if</B>&nbsp;E.Stock&nbsp;=&nbsp;0&nbsp;<B>then</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OK&nbsp;:=&nbsp;False;&nbsp;<B>return</B>;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>out&nbsp;of&nbsp;stock</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;<B>end&nbsp;if</B>;<BR>
&nbsp;&nbsp;&nbsp;Replace_Element(C,&nbsp;(E.Part_Number,&nbsp;Year;&nbsp;Shelf,&nbsp;E.Stock&ndash;1));<BR>
&nbsp;&nbsp;&nbsp;OK&nbsp;:=&nbsp;True;<BR>
<B>end</B>&nbsp;Request;</div>
<div class="Normal">This works but is somewhat unsatisfactory. For one 
thing we have had to make up dummy components in the call of <SPAN Class="swiss">Find</SPAN> 
(using <SPAN Class="swiss">&lt;&gt;</SPAN>) and moreover we have had 
to replace the whole of the element although we only wanted to update 
the <SPAN Class="swiss">Stock</SPAN> component. Moreover, we cannot use 
<SPAN Class="swiss">Update_Element</SPAN> because it is not defined for 
sets at all. Remember that this is because it might make things out of 
order; that wouldn't be a problem in this case because we don't want 
to change the part number and our ordering is just by the part number.</div>
<div class="Normal" style="margin-bottom: 0.4em">A better approach is 
to use the part number as a key. We define&nbsp;</div>
<div class="SwissExamples"><B>type</B>&nbsp;Part_Key&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Integer;</div>
<div class="SwissExamples"><B>function</B>&nbsp;Part_No(P:&nbsp;Part_Type)&nbsp;<B>return</B>&nbsp;Part_Key&nbsp;<B>is</B><BR>
<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;<B>return</B>&nbsp;Part_Key(P.Part_Number);<BR>
<B>end</B>&nbsp;Part_No;</div>
<div class="Normal" style="margin-bottom: 0.4em">and then</div>
<div class="SwissExamples"><B>package</B>&nbsp;Party&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Generic_Keys(Key_Type&nbsp;=&gt;&nbsp;Part_Key,&nbsp;Key&nbsp;=&gt;&nbsp;Part_No);<BR>
<B>use</B>&nbsp;Party;</div>
<div class="Normal">Note that we do not have to define <SPAN Class="swiss">&quot;&lt;&quot;</SPAN> 
on the type <SPAN Class="swiss">Part_Key</SPAN> at all because it already 
exists since <SPAN Class="swiss">Part_Key</SPAN> is an integer type. 
And the instantiation uses it by default.</div>
<div class="Normal" style="margin-bottom: 0.4em">And now we can rewrite 
the <SPAN Class="swiss">Request</SPAN> procedure as follows</div>
<div class="SwissExamples"><B>procedure</B>&nbsp;Request(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Part:&nbsp;<B>in</B>&nbsp;Part_Key;&nbsp;OK:&nbsp;<B>out</B>&nbsp;Boolean;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Year:&nbsp;<B>out</B>&nbsp;Integer;&nbsp;Shelf:&nbsp;<B>out</B>&nbsp;Character)&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;C:&nbsp;Cursor;<BR>
&nbsp;&nbsp;&nbsp;E:&nbsp;Part_Type;<BR>
<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;C&nbsp;:=&nbsp;Find(The_Store,&nbsp;Part);<BR>
&nbsp;&nbsp;&nbsp;<B>if</B>&nbsp;C&nbsp;=&nbsp;No_Element&nbsp;<B>then</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OK&nbsp;:=&nbsp;False;&nbsp;<B>return</B>;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>no&nbsp;such&nbsp;item</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;<B>end&nbsp;if</B>;<BR>
&nbsp;&nbsp;&nbsp;E&nbsp;:=&nbsp;Element(C);<BR>
&nbsp;&nbsp;&nbsp;Year&nbsp;:=&nbsp;E.Year;&nbsp;&nbsp;Shelf&nbsp;:=&nbsp;E.Shelf;<BR>
&nbsp;&nbsp;&nbsp;<B>if</B>&nbsp;E.Stock&nbsp;=&nbsp;0&nbsp;<B>then</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OK&nbsp;:=&nbsp;False;&nbsp;<B>return</B>;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>out&nbsp;of&nbsp;stock</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;<B>end&nbsp;if</B>;</div>
<div class="SwissExamples">&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>we&nbsp;are&nbsp;now&nbsp;going&nbsp;to&nbsp;update&nbsp;the&nbsp;stock&nbsp;level</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;<B>declare</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Do_It(E:&nbsp;<B>in&nbsp;out</B>&nbsp;Part_Type)&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E.Stock&nbsp;:=&nbsp;E.Stock&nbsp;&ndash;&nbsp;1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;Do_It;<BR>
&nbsp;&nbsp;&nbsp;<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Update_Element_Preserving_Key(The_Store,&nbsp;C,&nbsp;Do_It'Access);<BR>
&nbsp;&nbsp;&nbsp;<B>end</B>;<BR>
&nbsp;&nbsp;&nbsp;OK&nbsp;:=&nbsp;True;<BR>
<B>end</B>&nbsp;Request;</div>
<div class="Normal">This seems hard work but has a number of advantages. 
The first is that the call of <SPAN Class="swiss">Find</SPAN> is more 
natural and only involves the part number (the key) &ndash; note that 
this is a call of the function <SPAN Class="swiss">Find</SPAN> in the 
instantiation of <SPAN Class="swiss">Generic_Keys</SPAN> and takes just 
the part number. And the other is that the update only involves the component 
being changed.</div>
<div class="Normal">We mentioned earlier that there was no <SPAN Class="swiss">Update_Element</SPAN> 
for sets because of the danger of creating a value that was in the wrong 
place. In the case of the richly named <SPAN Class="swiss">Update_Element_Preserving_Key</SPAN> 
it also checks to ensure that the element is indeed still in the correct 
place (by checking that the key is still the same); if it isn't it removes 
the element and raises <SPAN Class="swiss">Program_Error</SPAN>.</div>
<div class="Normal">But the user is warned to take care when using the 
package <SPAN Class="swiss">Generic_Keys</SPAN>. It is absolutely vital 
that the relational operation and the function (<SPAN Class="swiss">Part_No</SPAN>) 
used to instantiate <SPAN Class="swiss">Generic_Keys</SPAN> are compatible 
with the ordering used to instantiate the parent package <SPAN Class="swiss">Containers.Ordered_Sets</SPAN> 
itself. If this is not the case then the sky might fall in.</div>
<div class="Normal" style="margin-bottom: 0.4em">Incidentally, the procedure 
for checking the stock which previously used the maps package now becomes 
</div>
<div class="SwissExamples"><B>procedure</B>&nbsp;Check_Stock(Low:&nbsp;<B>in</B>&nbsp;Integer)&nbsp;<B>is</B></div>
<div class="SwissExamples">&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Check_It(C:&nbsp;<B>in</B>&nbsp;Cursor)&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>if</B>&nbsp;Element(C).Stock&nbsp;&lt;&nbsp;Low&nbsp;<B>then</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>print&nbsp;a&nbsp;message&nbsp;perhaps</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Put(&quot;Low&nbsp;stock&nbsp;of&nbsp;part&nbsp;&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Put_Line(Element(C).Part_Number);&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>changed</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>end&nbsp;if</B>;<BR>
&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;Check_It;</div>
<div class="SwissExamples"><B>begin</B><BR>
&nbsp;&nbsp;&nbsp;The_Store.Iterate(Check_It'Access);<BR>
<B>end</B>&nbsp;Check_Stock;</div>
<div class="Normal" style="margin-bottom: 0.4em">The only change is 
that the call of <SPAN Class="swiss">Key</SPAN> in&nbsp;</div>
<div class="SwissExamples">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Put_Line(Key(C).Part_Number);</div>
<div class="Normal" style="margin-bottom: 0.4em">when using the maps 
package has been replaced by <SPAN Class="swiss">Element</SPAN>. A minor 
point is that we could avoid calling <SPAN Class="swiss">Element</SPAN> 
twice by declaring a constant <SPAN Class="swiss">E</SPAN> in <SPAN Class="swiss">Check_It</SPAN> 
thus&nbsp;</div>
<div class="SwissExamples">E:&nbsp;<B>constant</B>&nbsp;Part_Type&nbsp;:=&nbsp;Element(C);</div>
<div class="Normal">and then writing <SPAN Class="swiss">E.Stock &lt; 
Low</SPAN> and calling <SPAN Class="swiss">Put_Line</SPAN> with <SPAN Class="swiss">E.Part_Number</SPAN>.</div>
<div class="Normal">A more important point is that if we have instantiated 
the <SPAN Class="swiss">Generic_Keys</SPAN> inner package as illustrated 
above then we can leave <SPAN Class="swiss">Check_It</SPAN> unchanged 
to call <SPAN Class="swiss">Key</SPAN>. But it is important to realise 
that we are then calling the function <SPAN Class="swiss">Key</SPAN> 
internal to the instantiation of <SPAN Class="swiss">Generic_Keys</SPAN> 
(flippantly called <SPAN Class="swiss">Party</SPAN>) and not that from 
the instantiation of the parent ordered sets package (<SPAN Class="swiss">Store_Sets</SPAN>) 
because that has no such function. This illustrates the close affinity 
between the sets and maps packages.</div>
<div class="Normal">And finally there is a hashed sets package which 
has strong similarities to both the ordered sets package and the hashed 
maps package. We can introduce this much as for hashed maps by giving 
the differences between the two sets packages, the extra facilities in 
each and the impact on the part number example.</div>
<div class="Normal">The specification of the hashed sets package starts<A NAME="I1410"></A><A NAME="I1411"></A><A NAME="I1412"></A></div>
<div class="SwissExamples"><B>generic</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Element_Type&nbsp;<B>is&nbsp;private</B>;<BR>
&nbsp;&nbsp;&nbsp;<B>with&nbsp;function</B>&nbsp;Hash(Element:&nbsp;Element_Type)&nbsp;<B>return</B>&nbsp;Hash_Type;<BR>
&nbsp;&nbsp;&nbsp;<B>with&nbsp;function</B>&nbsp;Equivalent_Elements(Left,&nbsp;Right:&nbsp;Element_Type)<BR>
<B>return</B>&nbsp;Boolean;<BR>
&nbsp;&nbsp;&nbsp;<B>with&nbsp;function</B>&nbsp;&quot;=&quot;&nbsp;(Left,&nbsp;Right:&nbsp;Element_Type)&nbsp;<B>return</B><BR>
Boolean&nbsp;<B>is</B>&nbsp;&lt;&gt;;<BR>
<B>package</B>&nbsp;Ada.Containers.Hashed_Sets&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>pragma</B>&nbsp;Preelaborate(Hashed_Sets);</div>
<div class="Normal">The differences from the ordered sets package are 
that there is an extra generic parameter <SPAN Class="swiss">Hash</SPAN> 
and the ordering parameter <SPAN Class="swiss">&quot;&lt;&quot;</SPAN> 
has been replaced by the function <SPAN Class="swiss">Equivalent_Elements</SPAN>.</div>
<div class="Normal" style="margin-bottom: 0.4em">So if we have&nbsp;</div>
<div class="SwissExamples"><B>function</B>&nbsp;Equivalent_Parts(Left,&nbsp;Right:&nbsp;Part_Type)&nbsp;<B>return</B>&nbsp;Boolean&nbsp;<B>is</B><BR>
<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;<B>return</B>&nbsp;Left.Part_Number&nbsp;=&nbsp;Right.Part_Number;<BR>
<B>end</B>&nbsp;Equivalent_Parts;</div>
<div class="SwissExamples"><B>function</B>&nbsp;Part_Hash(P:&nbsp;Part_Type)&nbsp;<B>return</B>&nbsp;Hash_Type&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;M31:&nbsp;<B>constant</B>&nbsp;:=&nbsp;2**31&ndash;1;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>a&nbsp;nice&nbsp;Mersenne&nbsp;prime</I></SPAN><BR>
<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;<B>return</B>&nbsp;Hash_Type(P.Part_Number)&nbsp;*&nbsp;M31;<BR>
<B>end</B>&nbsp;Part_Hash;</div>
<div class="Normal" style="margin-bottom: 0.4em">(which are very similar 
to the hashed map example &ndash; the only changes are to the parameter 
type name) then we can instantiate the hashed sets package as follows 
</div>
<div class="SwissExamples"><B>package</B>&nbsp;Store_Sets&nbsp;<B>is&nbsp;new</B>&nbsp;Hashed_Sets(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Element_Type&nbsp;=&gt;&nbsp;Part_Type,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hash&nbsp;=&gt;&nbsp;Part_Hash,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent_Elements&nbsp;=&gt;&nbsp;Equivalent_Parts);</div>
<div class="SwissExamples">The_Store:&nbsp;Store_Sets.Set;</div>
<div class="Normal">and then the rest of our example will be exactly 
as before. It is thus easy to convert from an ordered set to a hashed 
set and vice versa provided of course that we only use the facilities 
common to both.</div>
<div class="Normal" style="margin-bottom: 0.4em">It should also be mentioned 
that the inner package <SPAN Class="swiss">Generic_Keys</SPAN> for hashed 
sets has the following formal parameters&nbsp;</div>
<div class="SwissExamples"><B>generic</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Key_Type(&lt;&gt;)&nbsp;<B>is&nbsp;private</B>;<BR>
&nbsp;&nbsp;&nbsp;<B>with&nbsp;function</B>&nbsp;Key(Element:&nbsp;Element_Type)&nbsp;<B>return</B>&nbsp;Key_Type<BR>
&nbsp;&nbsp;&nbsp;<B>with&nbsp;function</B>&nbsp;Hash(Key:&nbsp;Key_Type)&nbsp;<B>return</B>&nbsp;Hash_Type;<BR>
&nbsp;&nbsp;&nbsp;<B>with&nbsp;function</B>&nbsp;Equivalent_Keys(Left,&nbsp;Right:&nbsp;Key_Type)&nbsp;<B>return</B>&nbsp;Boolean;<BR>
<B>package</B>&nbsp;Generic_Keys&nbsp;<B>is</B></div>
<div class="Normal">The differences from that for ordered sets are the 
addition of the function <SPAN Class="swiss">Hash</SPAN> and the replacement 
of the comparison operator <SPAN Class="swiss">&quot;&lt;&quot;</SPAN> 
by <SPAN Class="swiss">Equivalent_Keys</SPAN>.</div>
<div class="Normal">(Incidentally the package <SPAN Class="swiss">Generic_Keys</SPAN> 
for ordered sets also exports a function <SPAN Class="swiss">Equivalent_Keys</SPAN> 
for uniformity with the hashed sets package.)</div>
<div class="Normal" style="margin-bottom: 0.4em">Although our example 
itself is unchanged we do have to change the instantiation of <SPAN Class="swiss">Generic_Keys</SPAN> 
thus&nbsp;</div>
<div class="SwissExamples"><B>type</B>&nbsp;Part_Key&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Integer;</div>
<div class="SwissExamples"><B>function</B>&nbsp;Part_No(P:&nbsp;Part_Type)&nbsp;<B>return</B>&nbsp;Part_Key&nbsp;<B>is</B><BR>
<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;<B>return</B>&nbsp;Part_Key(P.Part_Number);<BR>
<B>end</B>&nbsp;Part_No;</div>
<div class="SwissExamples"><B>function</B>&nbsp;Part_Hash(P:&nbsp;Part_Key)&nbsp;<B>return</B>&nbsp;Hash_Type&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;M31:&nbsp;<B>constant</B>&nbsp;:=&nbsp;2**31&ndash;1;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;<SPAN Class="roman"><I>a&nbsp;nice&nbsp;Mersenne&nbsp;prime</I></SPAN><BR>
<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;<B>return</B>&nbsp;Hash_Type(P)&nbsp;*&nbsp;M31;<BR>
<B>end</B>&nbsp;Part_Hash;</div>
<div class="SwissExamples"><B>function</B>&nbsp;Equivalent_Parts(Left:&nbsp;Right:&nbsp;Part_Key)&nbsp;<B>return</B>&nbsp;Boolean&nbsp;<B>is</B><BR>
<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;<B>return</B>&nbsp;Left&nbsp;=&nbsp;Right;<BR>
<B>end</B>&nbsp;Equivalent_Parts;</div>
<div class="Normal" style="margin-bottom: 0.4em">and then</div>
<div class="SwissExamples"><B>package</B>&nbsp;Party&nbsp;<B>is&nbsp;new</B>&nbsp;Generic_Key(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key_Type&nbsp;=&gt;&nbsp;Part_Key,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key&nbsp;=&gt;&nbsp;Part_No;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hash&nbsp;=&gt;&nbsp;Part_Hash<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent_Keys&nbsp;=&gt;&nbsp;Equivalent_Parts);<BR>
<B>use</B>&nbsp;Party;</div>
<div class="Normal">The hash function is similar to that used with hashed 
maps. The type <SPAN Class="swiss">Part_Key</SPAN> and function <SPAN Class="swiss">Part_No</SPAN> 
are the same as for ordered sets. We don't really need to declare the 
function <SPAN Class="swiss">Equivalent_Parts</SPAN> since we could use 
<SPAN Class="swiss">&quot;=&quot;</SPAN> as the actual parameter for 
<SPAN Class="swiss">Equivalent_Keys</SPAN>.</div>
<div class="Normal">We will finish this discussion of sets by briefly 
considering the additional facilities in the two sets packages (and their 
inner generic keys packages) just as we did for the two maps packages 
(the discussion is almost identical).</div>
<div class="Normal" style="margin-bottom: 0.4em">The ordered sets package 
has the following additional subprograms&nbsp;</div>
<div class="SwissExamples"><B>procedure</B>&nbsp;Delete_First(Container:&nbsp;<B>in&nbsp;out</B>&nbsp;Set);<BR>
<B>procedure</B>&nbsp;Delete_Last(Container:&nbsp;<B>in&nbsp;out</B>&nbsp;Set);</div>
<div class="SwissExamples"><B>function</B>&nbsp;First_Element(Container:&nbsp;Set)&nbsp;<B>return</B>&nbsp;Element_Type;<BR>
<B>function</B>&nbsp;Last_Element(Container:&nbsp;Set)&nbsp;<B>return</B>&nbsp;Element_Type;<BR>
<B>function</B>&nbsp;Previous(Position:&nbsp;Cursor)&nbsp;<B>return</B>&nbsp;Cursor;<BR>
<B>procedure</B>&nbsp;Previous(Position:&nbsp;<B>in&nbsp;out</B>&nbsp;Cursor);</div>
<div class="SwissExamples"><B>function</B>&nbsp;Floor(Container:&nbsp;Set;&nbsp;Item:&nbsp;Element_Type)&nbsp;<B>return</B>&nbsp;Cursor;<BR>
<B>function</B>&nbsp;Ceiling(Container:&nbsp;Set;&nbsp;Item:&nbsp;Element_Type)&nbsp;<B>return</B>&nbsp;Cursor;</div>
<div class="SwissExamples"><B>function</B>&nbsp;&quot;&lt;&quot;&nbsp;(Left,&nbsp;Right:&nbsp;Cursor)&nbsp;<B>return</B>&nbsp;Boolean;<BR>
<B>function</B>&nbsp;&quot;&gt;&quot;&nbsp;(Left,&nbsp;Right:&nbsp;Cursor)&nbsp;<B>return</B>&nbsp;Boolean;<BR>
<B>function</B>&nbsp;&quot;&lt;&quot;&nbsp;(Left:&nbsp;Cursor;&nbsp;Right:&nbsp;Element_Type)&nbsp;<B>return</B>&nbsp;Boolean;<BR>
<B>function</B>&nbsp;&quot;&gt;&quot;&nbsp;(Left:&nbsp;Cursor;&nbsp;Right:&nbsp;Element_Type)&nbsp;<B>return</B>&nbsp;Boolean;<BR>
<B>function</B>&nbsp;&quot;&lt;&quot;&nbsp;(Left:&nbsp;Element_Type;&nbsp;Right:&nbsp;Cursor)&nbsp;<B>return</B>&nbsp;Boolean;<BR>
<B>function</B>&nbsp;&quot;&gt;&quot;&nbsp;(Left:&nbsp;Element_Type;&nbsp;Right:&nbsp;Cursor)&nbsp;<B>return</B>&nbsp;Boolean;</div>
<div class="SwissExamples"><B>procedure</B>&nbsp;Reverse_Iterate(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Container:&nbsp;<B>in</B>&nbsp;Set;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Process:&nbsp;<B>not&nbsp;null&nbsp;access&nbsp;procedure</B>&nbsp;(Position:&nbsp;<B>in</B>&nbsp;Cursor));</div>
<div class="Normal">These are again largely self-evident. The functions 
<SPAN Class="swiss">Floor</SPAN> and <SPAN Class="swiss">Ceiling</SPAN> 
are similar to those for ordered maps &ndash; <SPAN Class="swiss">Floor</SPAN> 
searches for the last element which is not greater than <SPAN Class="swiss">Item</SPAN> 
and <SPAN Class="swiss">Ceiling</SPAN> searches for the first element 
which is not less than <SPAN Class="swiss">Item</SPAN> &ndash; they return 
<SPAN Class="swiss">No_Element</SPAN> if there is not one.</div>
<div class="Normal" style="margin-bottom: 0.4em">The functions <SPAN Class="swiss">&quot;&lt;&quot;</SPAN> 
and <SPAN Class="swiss">&quot;&gt;&quot;</SPAN> are very important for 
ordered sets. The first is equivalent to&nbsp;</div>
<div class="SwissExamples"><B>function</B>&nbsp;&quot;&lt;&quot;&nbsp;(Left,&nbsp;Right:&nbsp;Cursor)&nbsp;<B>return</B>&nbsp;Boolean&nbsp;<B>is</B><BR>
<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;<B>return</B>&nbsp;Element(Left)&nbsp;&lt;&nbsp;Element(Right);<BR>
<B>end</B>&nbsp;&quot;&lt;&quot;;</div>
<div class="Normal">There is a general philosophy that the container 
packages should work efficiently even if the elements themselves are 
very large &ndash; perhaps even other containers. We should therefore 
avoid copying elements. (Passing them as parameters is of course no problem 
since they will be passed by reference if they are large structures.) 
So in this case the built-in comparison is valuable because it can avoid 
the copying which would occur if we wrote the function ourselves with 
the explicit internal calls of the function <SPAN Class="swiss">Element</SPAN>.</div>
<div class="Normal">On the other hand, there is a general expectation 
that keys will be small and so there is no corresponding problem with 
copying keys. Thus such built-in functions are less important for maps 
than sets but they are provided for maps for uniformity.</div>
<div class="Normal" style="margin-bottom: 0.4em">The following are additional 
in the package <SPAN Class="swiss">Generic_Keys</SPAN> for ordered sets</div>
<div class="SwissExamples"><B>function</B>&nbsp;Equivalent_Keys(Left,&nbsp;Right:&nbsp;Key_Type)&nbsp;<B>return</B>&nbsp;Boolean;</div>
<div class="Normal">This corresponds to the formal generic parameter 
of the same name in the package <SPAN Class="swiss">Generic_Keys</SPAN> 
for hashed sets as mentioned earlier.</div>
<div class="SwissExamples"><B>function</B>&nbsp;Floor(Container:&nbsp;Set;&nbsp;Key:&nbsp;Key_Type)&nbsp;<B>return</B>&nbsp;Cursor;<BR>
<B>function</B>&nbsp;Ceiling(Container:&nbsp;Set;&nbsp;Key:&nbsp;Key_Type)&nbsp;<B>return</B>&nbsp;Cursor;</div>
<div class="Normal">These are much as the corresponding functions in 
the parent package except that they use the formal parameter <SPAN Class="swiss">&quot;&lt;&quot;</SPAN> 
of <SPAN Class="swiss">Generic_Keys</SPAN> for the search.</div>
<div class="Normal" style="margin-bottom: 0.4em">Hashed sets, like hashed 
maps also have the facility to specify a capacity as for the vectors 
package. Thus we have&nbsp;</div>
<div class="SwissExamples"><B>procedure</B>&nbsp;Reserve_Capacity(Container:&nbsp;<B>in&nbsp;out</B>&nbsp;Set;&nbsp;Capacity:&nbsp;<B>in</B>&nbsp;Count_Type);</div>
<div class="SwissExamples"><B>function</B>&nbsp;Capacity(Container:&nbsp;Set)&nbsp;<B>return</B>&nbsp;Count_Type;</div>
<div class="Normal">The behaviour is much as for vectors and hashed maps. 
We don't have to set the capacity ourselves since it will be automatically 
extended as necessary but it might significantly improve performance 
to do so. Note again that <SPAN Class="swiss">Length(S)</SPAN> cannot 
exceed <SPAN Class="swiss">Capacity(S)</SPAN> but might be much less.</div>
<div class="Normal" style="margin-bottom: 0.4em">The other additional 
subprograms for hashed sets are&nbsp;</div>
<div class="SwissExamples"><B>function</B>&nbsp;Equivalent_Elements(Left,&nbsp;Right:&nbsp;Cursor)&nbsp;<B>return</B>&nbsp;Boolean;<BR>
<B>function</B>&nbsp;Equivalent_Elements(Left:&nbsp;Cursor;&nbsp;Right:&nbsp;Element_Type)&nbsp;<B>return</B>&nbsp;Boolean;<BR>
<B>function</B>&nbsp;Equivalent_Elements(Left:&nbsp;Element_Type;&nbsp;Right:&nbsp;Cursor)&nbsp;<B>return</B>&nbsp;Boolean;</div>
<div class="Normal" style="margin-bottom: 0.4em">Again, these are very 
important for sets. The first is equivalent to&nbsp;</div>
<div class="SwissExamples"><B>function</B>&nbsp;Equivalent_Elements(Left,&nbsp;Right:&nbsp;Cursor)&nbsp;<B>return</B>&nbsp;Boolean&nbsp;<B>is</B><BR>
<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;<B>return</B>&nbsp;Equivalent_Elements(Element(Left),&nbsp;Element(Right));<BR>
<B>end</B>&nbsp;Equivalent_Elements;</div>
<div class="Normal">and once more we see that the built-in functions 
can avoid the copying of the type <SPAN Class="swiss">Element</SPAN> 
that would occur if we wrote the functions ourselves.</div>

<HR>
<div style="margin-top: 0.0em; margin-bottom: 0.6em"><A HREF="Rat-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="Rat-0-3.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="Rat-0-2.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="Rat-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="Rat-8-3.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="Rat-8-5.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</div>
<DIV Class="Normal">&copy; 2005, 2006, 2007 John Barnes Informatics.</DIV>
<DIV Class="Normal">Sponsored in part by:</DIV>
<TABLE Summary="Sponsors" Width="710">
<TR><TD VAlign="Top" Width="490">
<SPAN Style="font-family: Arial, Helvetica, sans-serif; font-size: 92%">The <A HREF="http://www.adaic.org/community/">Ada Resource Association</A> and its member companies:</SPAN>
<img src="http://www.adaic.org/resources/images/sponsors/ARA-members-5.gif" alt="ARA Members" usemap="#member-map" border=1>
<map name="member-map">
  <AREA href="http://www.adacore.com/" alt="AdaCore"
          shape="rect"          coords="0,0,222,66">
  <AREA href="http://www.polyspace.com/" alt="Polyspace Technologies"
          shape="rect"          coords="0,66,155,179">
	<AREA href="http://www.sparkada.com/" alt="Praxis Critical Systems"
	         shape="rect"         coords="156,66,295,179">
	<AREA href="http://www-306.ibm.com/software/awdtools/developer/ada/" alt="IBM Rational"
	         shape="rect"         coords="222,0,480,66">
	<AREA href="http://www.sofcheck.com/" alt="Sofcheck"
	         shape="rect"         coords="296,66,480,130">
</map>
<TD Width="220" Align="Center" VAlign="Top">
<SPAN Style="font-family: Arial, Helvetica, sans-serif; font-size: 92%">and &nbsp; <A HREF="http://www.ada-europe.org">Ada-Europe</A>:<BR>
<A HREF="http://www.ada-europe.org"><IMG SRC="AE_logo.gif" ALT="Ada-Europe" Height="200" Border="0"></A></SPAN>
</TABLE>
</BODY>
</HTML>
