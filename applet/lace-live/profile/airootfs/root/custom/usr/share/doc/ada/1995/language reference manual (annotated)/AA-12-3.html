<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Generic Instantiation</TITLE>
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    DIV.paranum {position: absolute; font-family: Arial, Helvetica, sans-serif; left: 0.5em; top: auto}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    DIV.Normal {font-family: "Times New Roman", Times, serif; margin-bottom: 0.6em}
    DIV.Wide {font-family: "Times New Roman", Times, serif; margin-top: 0.6em; margin-bottom: 0.6em}
    DIV.Annotations {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-bottom: 0.6em}
    DIV.WideAnnotations {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-top: 0.6em; margin-bottom: 0.6em}
    DIV.Index {font-family: "Times New Roman", Times, serif}
    DIV.SyntaxSummary {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-bottom: 0.4em}
    DIV.Notes {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-bottom: 0.6em}
    DIV.NotesHeader {font-family: "Times New Roman", Times, serif; margin-left: 2.0em}
    DIV.SyntaxIndented {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-bottom: 0.4em}
    DIV.Indented {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-bottom: 0.6em}
    DIV.CodeIndented {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-bottom: 0.6em}
    DIV.SmallIndented {font-family: "Times New Roman", Times, serif; margin-left:  10.0em; margin-bottom: 0.6em}
    DIV.SmallCodeIndented {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-bottom: 0.6em}
    DIV.Examples {font-family: "Courier New", monospace; margin-left: 2.0em; margin-bottom: 0.6em}
    DIV.SmallExamples {font-family: "Courier New", monospace; font-size: 80%; margin-left: 7.5em; margin-bottom: 0.6em}
    DIV.IndentedExamples {font-family: "Courier New", monospace; margin-left: 8.0em; margin-bottom: 0.6em}
    DIV.SmallIndentedExamples {font-family: "Courier New", monospace; font-size: 80%; margin-left:  15.0em; margin-bottom: 0.6em}
    UL.Bulleted {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.SmallBulleted {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.NestedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-right: 4.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.SmallNestedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-right: 8.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.IndentedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-right: 8.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.CodeIndentedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.CodeIndentedNestedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-right: 8.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.SyntaxIndentedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-right: 4.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.NotesBulleted {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-right: 4.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.NotesNestedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    DL.Hanging {font-family: "Times New Roman", Times, serif; margin-top: 0em; margin-bottom: 0.6em}
    DD.Hanging {margin-left: 6.0em}
    DL.IndentedHanging {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-top: 0em; margin-bottom: 0.6em}
    DD.IndentedHanging {margin-left: 2.0em}
    DL.HangingInBulleted {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    DD.HangingInBulleted {margin-left: 4.0em}
    DL.SmallHanging {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-top: 0em; margin-bottom: 0.6em}
    DD.SmallHanging {margin-left: 7.5em}
    DL.SmallIndentedHanging {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-top: 0em; margin-bottom: 0.6em}
    DD.SmallIndentedHanging {margin-left: 2.0em}
    DL.SmallHangingInBulleted {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    DD.SmallHangingInBulleted {margin-left: 5.0em}
    DL.Enumerated {font-family: "Times New Roman", Times, serif; margin-right: 0.0em; margin-top: 0em; margin-bottom: 0.5em}
    DD.Enumerated {margin-left: 2.0em}
    DL.SmallEnumerated {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-right: 4.0em; margin-top: 0em; margin-bottom: 0.5em}
    DD.SmallEnumerated {margin-left: 2.5em}
    DL.NestedEnumerated {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    DL.SmallNestedEnumerated {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">
<P><A HREF="AA-TOC.html">Contents</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-0-29.html">Index</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-SRCH.html">Search</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-12-2.html">Previous</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-12-4.html">Next</A></P>
<HR>
<H1> 12.3 Generic Instantiation</H1>
<DIV Class="Paranum"><FONT SIZE=-2>1</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;[<FONT SIZE="-1">{<I>instance (of a generic unit)</I>}</FONT>
<A NAME="I4196"></A>An instance of a generic unit is declared by a <FONT FACE="Arial, Helvetica">generic_instantiation</FONT>.]
</DIV>

<H4 ALIGN=CENTER>Language Design Principles</H4>
<DIV Class="Paranum"><FONT SIZE=-2>1.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">{<I>generic contract model</I>}
<A NAME="I4197"></A>{<I>contract model of generics</I>} <A NAME="I4198"></A>The
legality of an instance should be determinable without looking at the
generic body. Likewise, the legality of a generic body should be determinable
without looking at any instances. Thus, the <FONT FACE="Arial, Helvetica">generic_declaration</FONT>
forms a contract between the body and the instances; if each obeys the
rules with respect to the <FONT FACE="Arial, Helvetica">generic_declaration</FONT>,
then no legality problems will arise. This is really a special case of
the ``legality determinable via semantic dependences'' Language Design
Principle (see Section 10), given that a <FONT FACE="Arial, Helvetica">generic_instantiation</FONT>
does not depend semantically upon the generic body, nor vice-versa.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>1.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">Run-time issues are another
story. For example, whether parameter passing is by copy or by reference
is determined in part by the properties of the generic actuals, and thus
cannot be determined at compile time of the generic body. Similarly,
the contract model does not apply to Post-Compilation Rules. </FONT></DIV>

<H4 ALIGN=CENTER>Syntax</H4>
<DIV Class="Paranum"><FONT SIZE=-2>2</FONT></DIV>
<DIV Class="SyntaxIndented"><FONT FACE="Arial, Helvetica">generic_instantiation</FONT><FONT FACE="Arial, Helvetica"><A NAME="I4199"></A>
::= </FONT><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>package</B>&nbsp;<A NAME="I4200"></A><FONT FACE="Arial, Helvetica">defining_program_unit_name</FONT>&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>new</B>&nbsp;<I>generic_package_</I><A NAME="I4201"></A><FONT FACE="Arial, Helvetica">name</FONT>&nbsp;[<A NAME="I4202"></A><FONT FACE="Arial, Helvetica">generic_actual_part</FONT>];<BR>
&nbsp;&nbsp;&nbsp;|&nbsp;<B>procedure</B>&nbsp;<A NAME="I4203"></A><FONT FACE="Arial, Helvetica">defining_program_unit_name</FONT>&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>new</B>&nbsp;<I>generic_procedure_</I><A NAME="I4204"></A><FONT FACE="Arial, Helvetica">name</FONT>&nbsp;[<A NAME="I4205"></A><FONT FACE="Arial, Helvetica">generic_actual_part</FONT>];<BR>
&nbsp;&nbsp;&nbsp;|&nbsp;<B>function</B>&nbsp;<A NAME="I4206"></A><FONT FACE="Arial, Helvetica">defining_designator</FONT>&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>new</B>&nbsp;<I>generic_function_</I><A NAME="I4207"></A><FONT FACE="Arial, Helvetica">name</FONT>&nbsp;[<A NAME="I4208"></A><FONT FACE="Arial, Helvetica">generic_actual_part</FONT>];</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>3</FONT></DIV>
<DIV Class="SyntaxIndented"><FONT FACE="Arial, Helvetica">generic_actual_part</FONT><FONT FACE="Arial, Helvetica"><A NAME="I4209"></A>
::= </FONT><BR>
&nbsp;&nbsp;&nbsp;(<A NAME="I4210"></A><FONT FACE="Arial, Helvetica">generic_association</FONT>&nbsp;{,&nbsp;<A NAME="I4211"></A><FONT FACE="Arial, Helvetica">generic_association</FONT>})</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>4</FONT></DIV>
<DIV Class="SyntaxIndented"><FONT FACE="Arial, Helvetica">generic_association</FONT><FONT FACE="Arial, Helvetica"><A NAME="I4212"></A>
::= </FONT><BR>
&nbsp;&nbsp;&nbsp;[<I>generic_formal_parameter_</I><A NAME="I4213"></A><FONT FACE="Arial, Helvetica">selector_name</FONT>&nbsp;=&gt;]&nbsp;<A NAME="I4214"></A><FONT FACE="Arial, Helvetica">explicit_generic_actual_parameter</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>5</FONT></DIV>
<DIV Class="SyntaxIndented"><FONT FACE="Arial, Helvetica">explicit_generic_actual_parameter</FONT><FONT FACE="Arial, Helvetica"><A NAME="I4215"></A>
::= </FONT><A NAME="I4216"></A><FONT FACE="Arial, Helvetica">expression</FONT>&nbsp;|&nbsp;<I>variable_</I><A NAME="I4217"></A><FONT FACE="Arial, Helvetica">name</FONT><BR>
&nbsp;&nbsp;&nbsp;|&nbsp;<I>subprogram_</I><A NAME="I4218"></A><FONT FACE="Arial, Helvetica">name</FONT>&nbsp;|&nbsp;<I>entry_</I><A NAME="I4219"></A><FONT FACE="Arial, Helvetica">name</FONT>&nbsp;|&nbsp;<A NAME="I4220"></A><FONT FACE="Arial, Helvetica">subtype_mark</FONT><BR>
&nbsp;&nbsp;&nbsp;|&nbsp;<I>package_instance_</I><A NAME="I4221"></A><FONT FACE="Arial, Helvetica">name</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>6</FONT></DIV>
<DIV Class="SyntaxIndented"><FONT SIZE="-1">{<I>named association</I>}</FONT>
<A NAME="I4222"></A><FONT SIZE="-1">{<I>positional association</I>}</FONT>
<A NAME="I4223"></A>A <FONT FACE="Arial, Helvetica">generic_association</FONT>
is <I>named</I> or <I>positional</I> according to whether or not the
<I>generic_formal_parameter_</I><FONT FACE="Arial, Helvetica">selector_name</FONT>
is specified. Any positional associations shall precede any named associations.
</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>7</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>generic actual parameter</I>}</FONT>
<A NAME="I4224"></A><FONT SIZE="-1">{<I>generic actual</I>}</FONT> <A NAME="I4225"></A><FONT SIZE="-1">{<I>actual</I>}</FONT>
<A NAME="I4226"></A>The <I>generic actual parameter</I> is either the
<FONT FACE="Arial, Helvetica">explicit_generic_actual_parameter</FONT>
given in a <FONT FACE="Arial, Helvetica">generic_parameter_association</FONT>
for each formal, or the corresponding <FONT FACE="Arial, Helvetica">default_expression</FONT>
or <FONT FACE="Arial, Helvetica">default_name</FONT> if no <FONT FACE="Arial, Helvetica">generic_parameter_association</FONT>
is given for the formal. When the meaning is clear from context, the
term ``generic actual,'' or simply ``actual,'' is used as a synonym for
``generic actual parameter'' and also for the view denoted by one, or
the value of one. </DIV>

<H4 ALIGN=CENTER>Legality Rules</H4>
<DIV Class="Paranum"><FONT SIZE=-2>8</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;In a <FONT FACE="Arial, Helvetica">generic_instantiation</FONT>
for a particular kind of program unit [(package, procedure, or function)],
the <FONT FACE="Arial, Helvetica">name</FONT> shall denote a generic
unit of the corresponding kind [(generic package, generic procedure,
or generic function, respectively)].</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>9</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;The <I>generic_formal_parameter_</I><FONT FACE="Arial, Helvetica">selector_name</FONT>
of a <FONT FACE="Arial, Helvetica">generic_association</FONT> shall denote
a <FONT FACE="Arial, Helvetica">generic_formal_parameter_declaration</FONT>
of the generic unit being instantiated. If two or more formal subprograms
have the same defining name, then named associations are not allowed
for the corresponding actuals.</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>10</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;A <FONT FACE="Arial, Helvetica">generic_instantiation</FONT>
shall contain at most one <FONT FACE="Arial, Helvetica">generic_association</FONT>
for each formal. Each formal without an association shall have a <FONT FACE="Arial, Helvetica">default_expression</FONT>
or <FONT FACE="Arial, Helvetica">subprogram_default</FONT>.</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>11</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;In a generic unit Legality Rules are enforced
at compile time of the <FONT FACE="Arial, Helvetica">generic_declaration</FONT>
and generic body, given the properties of the formals. In the visible
part and formal part of an instance, Legality Rules are enforced at compile
time of the <FONT FACE="Arial, Helvetica">generic_instantiation</FONT>,
given the properties of the actuals. In other parts of an instance, Legality
Rules are not enforced; this rule does not apply when a given rule explicitly
specifies otherwise. </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>11.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Reason: </B>Since rules are
checked using the properties of the formals, and since these properties
do not always carry over to the actuals, we need to check the rules again
in the visible part of the instance. For example, only if a tagged type
is limited may an extension of it have limited components in the <FONT FACE="Arial, Helvetica">extension_part</FONT>.
A formal tagged limited type is limited, but the actual might be nonlimited.
Hence any rule that requires a tagged type to be limited runs into this
problem. Such rules are rare; in most cases, the rules for matching of
formals and actuals guarantee that if the rule is obeyed in the generic
unit, then it has to be obeyed in the instance. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>11.b</FONT></DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><FONT SIZE="-1"><B>Ramification:
</B>The ``properties'' of the formals are determined without knowing
anything about the actuals: </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>11.c/1</FONT></DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC><FONT SIZE="-1">{<I><A HREF="defect2.html#8652/0095">8652/0095</A></I>}
A formal derived subtype is constrained if and only if the ancestor subtype
is constrained. A formal array type is constrained if and only if the
declarations say<S>s</S> so. <U>A formal private type is constrained
if it does not have a discriminant part.</U>  Other formal subtypes are
unconstrained, even though they might be constrained in an instance.</FONT></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>11.d</FONT></DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC><FONT SIZE="-1">A formal subtype
can be indefinite, even though the copy might be definite in an instance.</FONT></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>11.e</FONT></DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC><FONT SIZE="-1">A formal object
of mode <B>in</B> is not a static constant; in an instance, the copy
is static if the actual is.</FONT></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>11.f</FONT></DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC><FONT SIZE="-1">A formal subtype
is not static, even though the actual might be.</FONT></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>11.g</FONT></DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC><FONT SIZE="-1">Formal types
are specific, even though the actual can be class-wide.</FONT></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>11.h</FONT></DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC><FONT SIZE="-1">The subtype of
a formal object of mode <B>in out</B> is not static. (This covers the
case of AI83-00878.)</FONT></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>11.i</FONT></DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC><FONT SIZE="-1">The subtype of
a formal parameter of a formal subprogram does not provide an applicable
index constraint.</FONT></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>11.j</FONT></DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC><FONT SIZE="-1">The profile of
a formal subprogram is not subtype-conformant with any other profile.
{<I>subtype conformance</I>} <A NAME="I4227"></A></FONT></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>11.k</FONT></DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC><FONT SIZE="-1">A generic formal
function is not static. </FONT></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>11.l</FONT></DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><FONT SIZE="-1"><B>Ramification:
</B>The exceptions to the above rule about when legality rules are enforced
fall into these categories: </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>11.m</FONT></DIV>
<UL Class="SmallBulleted" Style="margin-bottom: 0.3em"><LI TYPE=DISC><FONT SIZE="-1">Some
rules are checked in the generic declaration, and then again in both
the visible and private parts of the instance: </FONT></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>11.n</FONT></DIV>
<UL Class="SmallNestedBulleted"><LI TYPE=DISC><FONT SIZE="-1">The parent
type of a record extension has to be specific (see <A HREF="AA-3-9-1.html">3.9.1</A>).
This rule is not checked in the instance body.</FONT></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>11.o</FONT></DIV>
<UL Class="SmallNestedBulleted"><LI TYPE=DISC><FONT SIZE="-1">The parent
type of a private extension has to be specific (see <A HREF="AA-7-3.html">7.3</A>).
This rule is not checked in the instance body.</FONT></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>11.p</FONT></DIV>
<UL Class="SmallNestedBulleted"><LI TYPE=DISC><FONT SIZE="-1">A type
with an access discriminant has to be a descendant of a type declared
with <B>limited</B>, or be a task or protected type. This rule is irrelevant
in the instance body.</FONT></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>11.q</FONT></DIV>
<UL Class="SmallNestedBulleted"><LI TYPE=DISC><FONT SIZE="-1">In the
declaration of a record extension, if the parent type is nonlimited,
then each of the components of the <FONT FACE="Arial, Helvetica">record_extension_part</FONT>
have to be nonlimited (see <A HREF="AA-3-9-1.html">3.9.1</A>). In the
generic body, this rule is checked in an assume-the-worst manner.</FONT></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>11.r</FONT></DIV>
<UL Class="SmallNestedBulleted"><LI TYPE=DISC><FONT SIZE="-1">A preelaborated
library unit has to be preelaborable (see <A HREF="AA-10-2-1.html">10.2.1</A>).
In the generic body, this rule is checked in an assume-the-worst manner.
</FONT></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>11.s</FONT></DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC><FONT SIZE="-1">{<I>accessibility
rule (checking in generic units)</I> [partial]} <A NAME="I4228"></A>For
the accessibility rules, the formals have nothing to say about the property
in question. Like the above rules, these rules are checked in the generic
declaration, and then again in both the visible and private parts of
the instance. In the generic body, we have explicit rules that essentially
assume the worst (in the cases of type extensions and access-to-subprogram
types), and we have run-time checks (in the case of access-to-object
types). See <A HREF="AA-3-9-1.html">3.9.1</A>, <A HREF="AA-3-10-2.html">3.10.2</A>,
and <A HREF="AA-4-6.html">4.6</A>.</FONT></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>11.t</FONT></DIV>
<UL Class="SmallBulleted"><FONT SIZE="-1">We considered run-time checks
for access-to-subprogram types as well. However, this would present difficulties
for implementations that share generic bodies.</FONT></UL>
<DIV Class="Paranum"><FONT SIZE=-2>11.u</FONT></DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC><FONT SIZE="-1">The rules requiring
``reasonable'' values for static expressions are ignored when the expected
type for the expression is a descendant of a generic formal type other
than a generic formal derived type, and do not apply in an instance.</FONT></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>11.v</FONT></DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC><FONT SIZE="-1">The rule forbidding
two explicit homographs in the same declarative region does not apply
in an instance of a generic unit, except that it <I>does</I> apply in
the declaration of a record extension that appears in the visible part
of an instance.</FONT></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>11.w</FONT></DIV>
<UL Class="SmallBulleted" Style="margin-bottom: 0.3em"><LI TYPE=DISC><FONT SIZE="-1">Some
rules do not apply at all in an instance, not even in the visible part:
</FONT></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>11.x</FONT></DIV>
<UL Class="SmallNestedBulleted"><LI TYPE=DISC><FONT SIZE="-1"><FONT FACE="Arial, Helvetica">Body_stub</FONT>s
are not normally allowed to be multiply nested, but they can be in instances.
</FONT></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>11.y</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">{<I>generic contract issue</I>
[distributed]} <A NAME="I4229"></A>Each rule that is an exception is
marked with ``generic contract issue;'' look that up in the index to
find them all. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>11.z</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>The Legality
Rules are the ones labeled Legality Rules. We are talking about all Legality
Rules in the entire language here. Note that, with some exceptions, the
legality of a generic unit is checked even if there are no instantiations
of the generic unit. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>11.aa</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>The Legality
Rules are described here, and the overloading rules were described earlier
in this clause. Presumably, every Static Semantic Item is sucked in by
one of those. Thus, we have covered all the compile-time rules of the
language. There is no need to say anything special about the Post-Compilation
Rules or the Dynamic Semantic Items. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>11.bb</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Discussion: </B>Here is an
example illustrating how this rule is checked: ``In the declaration of
a record extension, if the parent type is nonlimited, then each of the
components of the <FONT FACE="Arial, Helvetica">record_extension_part</FONT>
shall be nonlimited.'' </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>11.cc</FONT></DIV>
<DIV Class="SmallExamples"><TT><B>generic</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Parent&nbsp;<B>is</B>&nbsp;<B>tagged</B>&nbsp;<B>private</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Comp&nbsp;<B>is</B>&nbsp;<B>limited</B>&nbsp;<B>private</B>;<BR>
<B>package</B>&nbsp;G1&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Extension&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Parent&nbsp;<B>with</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>record</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C&nbsp;:&nbsp;Comp;&nbsp;--<I>&nbsp;Illegal!</I><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;<B>record</B>;<BR>
<B>end</B>&nbsp;G1;</TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>11.dd/1</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">The parent type is nonlimited,
and the component type is limited, which is illegal. It doesn't matter
that <S>an </S>one could imagine writing an instantiation with the actual
for Comp being nonlimited -- we never get to the instance, because the
generic itself is illegal.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>11.ee</FONT></DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><FONT SIZE="-1">On
the other hand: </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>11.ff</FONT></DIV>
<DIV Class="SmallExamples"><TT><B>generic</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Parent&nbsp;<B>is</B>&nbsp;<B>tagged</B>&nbsp;<B>limited</B>&nbsp;<B>private</B>;&nbsp;--<I>&nbsp;Parent&nbsp;is&nbsp;limited.</I><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Comp&nbsp;<B>is</B>&nbsp;<B>limited</B>&nbsp;<B>private</B>;<BR>
<B>package</B>&nbsp;G2&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Extension&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Parent&nbsp;<B>with</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>record</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C&nbsp;:&nbsp;Comp;&nbsp;--<I>&nbsp;OK.</I><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;<B>record</B>;<BR>
<B>end</B>&nbsp;G2;</TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>11.gg</FONT></DIV>
<DIV Class="SmallExamples"><TT><B>type</B>&nbsp;Limited_Tagged&nbsp;<B>is</B>&nbsp;<B>tagged</B>&nbsp;<B>limited</B>&nbsp;<B>null</B>&nbsp;<B>record</B>;<BR>
<B>type</B>&nbsp;Non_Limited_Tagged&nbsp;<B>is</B>&nbsp;<B>tagged</B>&nbsp;<B>null</B>&nbsp;<B>record</B>;</TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>11.hh</FONT></DIV>
<DIV Class="SmallExamples"><TT><B>type</B>&nbsp;Limited_Untagged&nbsp;<B>is</B>&nbsp;<B>limited</B>&nbsp;<B>null</B>&nbsp;<B>record</B>;<BR>
<B>type</B>&nbsp;Non_Limited_Untagged&nbsp;<B>is</B>&nbsp;<B>null</B>&nbsp;<B>record</B>;</TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>11.ii</FONT></DIV>
<DIV Class="SmallExamples"><TT><B>package</B>&nbsp;Good_1&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;G2(Parent&nbsp;=&gt;&nbsp;Limited_Tagged,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Comp&nbsp;=&gt;&nbsp;Limited_Untagged);<BR>
<B>package</B>&nbsp;Good_2&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;G2(Parent&nbsp;=&gt;&nbsp;Non_Limited_Tagged,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Comp&nbsp;=&gt;&nbsp;Non_Limited_Untagged);<BR>
<B>package</B>&nbsp;Bad&nbsp;&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;G2(Parent&nbsp;=&gt;&nbsp;Non_Limited_Tagged,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Comp&nbsp;=&gt;&nbsp;Limited_Untagged);&nbsp;--<I>&nbsp;Illegal!</I></TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>11.jj</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">The first instantiation is legal,
because in the instance the parent is limited, so the rule is not violated.
Likewise, in the second instantiation, the rule is not violated in the
instance. However, in the Bad instance, the parent type is nonlimited,
and the component type is limited, so this instantiation is illegal.
</FONT></DIV>

<H4 ALIGN=CENTER>Static Semantics</H4>
<DIV Class="Paranum"><FONT SIZE=-2>12</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;A <FONT FACE="Arial, Helvetica">generic_instantiation</FONT>
declares an instance; it is equivalent to the instance declaration (a
<FONT FACE="Arial, Helvetica">package_declaration</FONT> or <FONT FACE="Arial, Helvetica">subprogram_declaration</FONT>)
immediately followed by the instance body, both at the place of the instantiation.
</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>12.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>The declaration
and the body of the instance are not ``implicit'' in the technical sense,
even though you can't see them in the program text. Nor are declarations
within an instance ``implicit'' (unless they are implicit by other rules).
This is necessary because implicit declarations have special semantics
that should not be attached to instances. For a generic subprogram, the
profile of a <FONT FACE="Arial, Helvetica">generic_instantiation</FONT>
is that of the instance declaration, by the stated equivalence. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>12.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>{<I>visible
part (of an instance)</I> [partial]} <A NAME="I4230"></A>{<I>private
part (of a package)</I> [partial]} <A NAME="I4231"></A>The visible and
private parts of a package instance are defined in <A HREF="AA-7-1.html">7.1</A>,
``<A HREF="AA-7-1.html">Package Specifications and Declarations</A>''
and <A HREF="AA-12-7.html">12.7</A>, ``<A HREF="AA-12-7.html">Formal
Packages</A>''. The visible and private parts of a subprogram instance
are defined in <A HREF="AA-8-2.html">8.2</A>, ``<A HREF="AA-8-2.html">Scope
of Declarations</A>''. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>13</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;The instance is a copy of the text of the template.
[Each use of a formal parameter becomes (in the copy) a use of the actual,
as explained below.] <FONT SIZE="-1">{<I>package instance</I>}</FONT>
<A NAME="I4232"></A><FONT SIZE="-1">{<I>subprogram instance</I>}</FONT>
<A NAME="I4233"></A><FONT SIZE="-1">{<I>procedure instance</I>}</FONT>
<A NAME="I4234"></A><FONT SIZE="-1">{<I>function instance</I>}</FONT>
<A NAME="I4235"></A><FONT SIZE="-1">{<I>instance (of a generic package)</I>}</FONT>
<A NAME="I4236"></A><FONT SIZE="-1">{<I>instance (of a generic subprogram)</I>}</FONT>
<A NAME="I4237"></A><FONT SIZE="-1">{<I>instance (of a generic procedure)</I>}</FONT>
<A NAME="I4238"></A><FONT SIZE="-1">{<I>instance (of a generic function)</I>}</FONT>
<A NAME="I4239"></A>An instance of a generic package is a package, that
of a generic procedure is a procedure, and that of a generic function
is a function. </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>13.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>An instance
is a package or subprogram (because we say so), even though it contains
a copy of the <FONT FACE="Arial, Helvetica">generic_formal_part</FONT>,
and therefore doesn't look like one. This is strange, but it's OK, since
the syntax rules are overloading rules, and therefore do not apply in
an instance. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>13.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Discussion: </B>We use a
macro-expansion model, with some explicitly-stated exceptions (see below).
The main exception is that the interpretation of each construct in a
generic unit (especially including the denotation of each name) is determined
when the declaration and body of the generic unit (as opposed to the
instance) are compiled, and in each instance this interpretation is (a
copy of) the template interpretation. In other words, if a construct
is interpreted as a <FONT FACE="Arial, Helvetica">name</FONT> denoting
a declaration D, then in an instance, the copy of the construct will
still be a name, and will still denote D (or a copy of D). From an implementation
point of view, overload resolution is performed on the template, and
not on each copy.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>13.c</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">We describe the substitution
of generic actual parameters by saying (in most cases) that the copy
of each generic formal parameter declares a view of the actual. Suppose
a name in a generic unit denotes a <FONT FACE="Arial, Helvetica">generic_formal_parameter_declaration</FONT>.
The copy of that name in an instance will denote the copy of that <FONT FACE="Arial, Helvetica">generic_formal_parameter_declaration</FONT>
in the instance. Since the <FONT FACE="Arial, Helvetica">generic_formal_parameter_declaration</FONT>
in the instance declares a view of the actual, the name will denote a
view of the actual.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>13.d</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">Other properties of the copy
(for example, staticness, classes to which types belong) are recalculated
for each instance; this is implied by the fact that it's a copy.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>13.e</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">Although the <FONT FACE="Arial, Helvetica">generic_formal_part</FONT>
is included in an instance, the declarations in the <FONT FACE="Arial, Helvetica">generic_formal_part</FONT>
are only visible outside the instance in the case of a generic formal
package whose <FONT FACE="Arial, Helvetica">formal_package_actual_part</FONT>
is (&lt;&gt;) -- see <A HREF="AA-12-7.html">12.7</A>. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>14</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;The interpretation of each construct within a
generic declaration or body is determined using the overloading rules
when that generic declaration or body is compiled. In an instance, the
interpretation of each (copied) construct is the same, except in the
case of a name that denotes the <FONT FACE="Arial, Helvetica">generic_declaration</FONT>
or some declaration within the generic unit; the corresponding name in
the instance then denotes the corresponding copy of the denoted declaration.
The overloading rules do not apply in the instance. </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>14.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>See <A HREF="AA-8-6.html">8.6</A>,
``<A HREF="AA-8-6.html">The Context of Overload Resolution</A>'' for
definitions of ``interpretation'' and ``overloading rule.''</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>14.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">Even the <FONT FACE="Arial, Helvetica">generic_formal_parameter_declaration</FONT>s
have corresponding declarations in the instance, which declare views
of the actuals.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>14.c</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">Although the declarations in
the instance are copies of those in the generic unit, they often have
quite different properties, as explained below. For example a constant
declaration in the generic unit might declare a nonstatic constant, whereas
the copy of that declaration might declare a static constant. This can
happen when the staticness depends on some generic formal.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>14.d</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">This rule is partly a ramification
of the ``current instance'' rule in <A HREF="AA-8-6.html">8.6</A>, ``<A HREF="AA-8-6.html">The
Context of Overload Resolution</A>''. Note that that rule doesn't cover
the <FONT FACE="Arial, Helvetica">generic_formal_part</FONT>.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>14.e</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">Although the overloading rules
are not observed in the instance, they are, of course, observed in the
<FONT FACE="Arial, Helvetica">_instantiation</FONT> in order to determine
the interpretation of the constituents of the <FONT FACE="Arial, Helvetica">_instantiation</FONT>.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>14.f</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">Since children are considered
to occur within their parent's declarative region, the above rule applies
to a name that denotes a child of a generic unit, or a declaration inside
such a child.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>14.g</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">Since the Syntax Rules are overloading
rules, it is possible (legal) to violate them in an instance. For example,
it is possible for an instance body to occur in a <FONT FACE="Arial, Helvetica">package_specification</FONT>,
even though the Syntax Rules forbid bodies in <FONT FACE="Arial, Helvetica">package_specification</FONT>s.
</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>15</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;In an instance, a <FONT FACE="Arial, Helvetica">generic_formal_parameter_declaration</FONT>
declares a view whose properties are identical to those of the actual,
except as specified in <A HREF="AA-12-4.html">12.4</A>, ``<A HREF="AA-12-4.html">Formal
Objects</A>'' and <A HREF="AA-12-6.html">12.6</A>, ``<A HREF="AA-12-6.html">Formal
Subprograms</A>''. Similarly, for a declaration within a <FONT FACE="Arial, Helvetica">generic_formal_parameter_declaration</FONT>,
the corresponding declaration in an instance declares a view whose properties
are identical to the corresponding declaration within the declaration
of the actual. </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>15.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>In an instance,
there are no ``properties'' of types and subtypes that come from the
formal. The primitive operations of the type come from the formal, but
these are declarations in their own right, and are therefore handled
separately.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>15.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">Note that certain properties
that come from the actuals are irrelevant in the instance. For example,
if an actual type is of a class deeper in the derived-type hierarchy
than the formal, it is impossible to call the additional operations of
the deeper class in the instance, because any such call would have to
be a copy of some corresponding call in the generic unit, which would
have been illegal. However, it is sometimes possible to reach into the
specification of the instance from outside, and notice such properties.
For example, one could pass an object declared in the instance specification
to one of the additional operations of the deeper type.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>15.c</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">A <FONT FACE="Arial, Helvetica">formal_type_declaration</FONT>
can contain <FONT FACE="Arial, Helvetica">discriminant_specification</FONT>s,
a <FONT FACE="Arial, Helvetica">formal_subprogram_declaration</FONT>
can contain <FONT FACE="Arial, Helvetica">formal_parameter_specification</FONT>s,
and a <FONT FACE="Arial, Helvetica">formal_package_declaration</FONT>
can contain many kinds of declarations. These are all inside the generic
unit, and have corresponding declarations in the instance.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>15.d</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">This rule implies, for example,
that if a subtype in a generic unit is a subtype of a generic formal
subtype, then the corresponding subtype in the instance is a subtype
of the corresponding actual subtype.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>15.e</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">For a <FONT FACE="Arial, Helvetica">generic_instantiation</FONT>,
if a generic actual is a static [(scalar or string)] subtype, then each
use of the corresponding formal parameter within the specification of
the instance is considered to be static. (See AI83-00409.)</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>15.f</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">Similarly, if a generic actual
is a static expression and the corresponding formal parameter has a static
[(scalar or string)] subtype, then each use of the formal parameter in
the specification of the instance is considered to be static. (See AI83-00505.)</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>15.g</FONT></DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><FONT SIZE="-1">If
a primitive subprogram of a type derived from a generic formal derived
tagged type is not overriding (that is, it is a new subprogram), it is
possible for the copy of that subprogram in an instance to override a
subprogram inherited from the actual. For example: </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>15.h</FONT></DIV>
<DIV Class="SmallExamples"><TT><B>type</B>&nbsp;T1&nbsp;<B>is</B>&nbsp;<B>tagged</B>&nbsp;<B>record</B>&nbsp;...&nbsp;<B>end</B>&nbsp;<B>record</B>;</TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>15.i</FONT></DIV>
<DIV Class="SmallExamples"><TT><B>generic</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Formal&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;T1;<BR>
<B>package</B>&nbsp;G&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Derived_From_Formal&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Formal&nbsp;<B>with</B>&nbsp;<B>record</B>&nbsp;...&nbsp;<B>end</B>&nbsp;<B>record</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Foo(X&nbsp;:&nbsp;<B>in</B>&nbsp;Derived_From_Formal);&nbsp;--<I>&nbsp;Does&nbsp;not&nbsp;override&nbsp;anything.</I><BR>
<B>end</B>&nbsp;G;</TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>15.j</FONT></DIV>
<DIV Class="SmallExamples"><TT><B>type</B>&nbsp;T2&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;T1&nbsp;<B>with</B>&nbsp;<B>record</B>&nbsp;...&nbsp;<B>end</B>&nbsp;<B>record</B>;<BR>
<B>procedure</B>&nbsp;Foo(X&nbsp;:&nbsp;<B>in</B>&nbsp;T2);</TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>15.k</FONT></DIV>
<DIV Class="SmallExamples"><TT><B>package</B>&nbsp;Inst&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;G(Formal&nbsp;=&gt;&nbsp;T2);</TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>15.l</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">In the instance Inst, the declaration
of Foo for Derived_From_Formal overrides the Foo inherited from T2. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>15.m/1</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Implementation Note: </B>{<I><A HREF="defect1.html#8652/0009">8652/0009</A></I>}
For formal types, an implementation that shares the code among multiple
instances of the same generic unit needs to beware that things like parameter
passing mechanisms (by-copy vs. by-reference) and <U><FONT FACE="Arial, Helvetica">aspect_clause</FONT>s</U> <S><FONT FACE="Arial, Helvetica">representation_clause</FONT>s</S>
are determined by the actual. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>16</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;[Implicit declarations are also copied, and a
name that denotes an implicit declaration in the generic denotes the
corresponding copy in the instance. However, for a type declared within
the visible part of the generic, a whole new set of primitive subprograms
is implicitly declared for use outside the instance, and may differ from
the copied set if the properties of the type in some way depend on the
properties of some actual type specified in the instantiation. For example,
if the type in the generic is derived from a formal private type, then
in the instance the type will inherit subprograms from the corresponding
actual type.</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>17</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>override</I>}</FONT> <A NAME="I4240"></A>These
new implicit declarations occur immediately after the type declaration
in the instance, and override the copied ones. The copied ones can be
called only from within the instance; the new ones can be called only
from outside the instance, although for tagged types, the body of a new
one can be executed by a call to an old one.] </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>17.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Proof: </B>This rule is stated
officially in <A HREF="AA-8-3.html">8.3</A>, ``<A HREF="AA-8-3.html">Visibility</A>''.
</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>17.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>The new
ones follow from the class(es) of the formal types. For example, for
a type T derived from a generic formal private type, if the actual is
Integer, then the copy of T in the instance has a &quot;+&quot; primitive
operator, which can be called from outside the instance (assuming T is
declared in the visible part of the instance).</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>17.c</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">AI83-00398.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>17.d</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">Since an actual type is always
in the class determined for the formal, the new subprograms hide all
of the copied ones, except for a declaration of &quot;/=&quot; that corresponds
to an explicit declaration of &quot;=&quot;. Such &quot;/=&quot; operators
are special, because unlike other implicit declarations of primitive
subprograms, they do not appear by virtue of the class, but because of
an explicit declaration of &quot;=&quot;. If the declaration of &quot;=&quot;
is implicit (and therefore overridden in the instance), then a corresponding
implicitly declared &quot;/=&quot; is also overridden. But if the declaration
of &quot;=&quot; is explicit (and therefore not overridden in the instance),
then a corresponding implicitly declared &quot;/=&quot; is not overridden
either, even though it's implicit.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>17.e</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">Note that the copied ones can
be called from inside the instance, even though they are hidden from
all visibility, because the names are resolved in the generic unit --
visibility is irrelevant for calls in the instance. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>18</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;[In the visible part of an instance, an explicit
declaration overrides an implicit declaration if they are homographs,
as described in <A HREF="AA-8-3.html">8.3</A>.] On the other hand, an
explicit declaration in the private part of an instance overrides an
implicit declaration in the instance, only if the corresponding explicit
declaration in the generic overrides a corresponding implicit declaration
in the generic. Corresponding rules apply to the other kinds of overriding
described in <A HREF="AA-8-3.html">8.3</A>. </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>18.a</FONT></DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><FONT SIZE="-1"><B>Ramification:
</B>For example: </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>18.b</FONT></DIV>
<DIV Class="SmallExamples"><TT><B>type</B>&nbsp;Ancestor&nbsp;<B>is</B>&nbsp;<B>tagged</B>&nbsp;<B>null</B>&nbsp;<B>record</B>;</TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>18.c</FONT></DIV>
<DIV Class="SmallExamples"><TT><B>generic</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Formal&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Ancestor&nbsp;<B>with</B>&nbsp;<B>private</B>;<BR>
<B>package</B>&nbsp;G&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Formal&nbsp;<B>with</B>&nbsp;<B>null</B>&nbsp;<B>record</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;P(X&nbsp;:&nbsp;<B>in</B>&nbsp;T);&nbsp;--<I>&nbsp;(1)</I><BR>
<B>private</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Q(X&nbsp;:&nbsp;<B>in</B>&nbsp;T);&nbsp;--<I>&nbsp;(2)</I><BR>
<B>end</B>&nbsp;G;</TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>18.d</FONT></DIV>
<DIV Class="SmallExamples"><TT><B>type</B>&nbsp;Actual&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Ancestor&nbsp;<B>with</B>&nbsp;<B>null</B>&nbsp;<B>record</B>;<BR>
<B>procedure</B>&nbsp;P(X&nbsp;:&nbsp;<B>in</B>&nbsp;Actual);<BR>
<B>procedure</B>&nbsp;Q(X&nbsp;:&nbsp;<B>in</B>&nbsp;Actual);</TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>18.e</FONT></DIV>
<DIV Class="SmallExamples"><TT><B>package</B>&nbsp;Instance&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;G(Formal&nbsp;=&gt;&nbsp;Actual);</TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>18.f</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">In the instance, the copy of
P at (1) overrides Actual's P, whereas the copy of Q at (2) does not
override anything; in implementation terms, it occupies a separate slot
in the type descriptor. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>18.g</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Reason: </B>The reason for
this rule is so a programmer writing an <FONT FACE="Arial, Helvetica">_instantiation</FONT>
need not look at the private part of the generic in order to determine
which subprograms will be overridden. </FONT></DIV>

<H4 ALIGN=CENTER>Post-Compilation Rules</H4>
<DIV Class="Paranum"><FONT SIZE=-2>19</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;Recursive generic instantiation is not allowed
in the following sense: if a given generic unit includes an instantiation
of a second generic unit, then the instance generated by this instantiation
shall not include an instance of the first generic unit [(whether this
instance is generated directly, or indirectly by intermediate instantiations)].
</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>19.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Discussion: </B>Note that
this rule is not a violation of the generic contract model, because it
is not a Legality Rule. Some implementations may be able to check this
rule at compile time, but that requires access to all the bodies, so
we allow implementations to check the rule at link time. </FONT></DIV>

<H4 ALIGN=CENTER>Dynamic Semantics</H4>
<DIV Class="Paranum"><FONT SIZE=-2>20</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>elaboration (generic_instantiation)</I>
[partial]}</FONT> <A NAME="I4241"></A>For the elaboration of a <FONT FACE="Arial, Helvetica">generic_instantiation</FONT>,
each <FONT FACE="Arial, Helvetica">generic_association</FONT> is first
evaluated. If a default is used, an implicit <FONT FACE="Arial, Helvetica">generic_association</FONT>
is assumed for this rule. These evaluations are done in an arbitrary
order, except that the evaluation for a default actual takes place after
the evaluation for another actual if the default includes a <FONT FACE="Arial, Helvetica">name</FONT>
that denotes the other one. Finally, the instance declaration and body
are elaborated. </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>20.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>Note that
if the evaluation of a default depends on some side-effect of some other
evaluation, the order is still arbitrary. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>21</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>evaluation (generic_association)</I>
[partial]}</FONT> <A NAME="I4242"></A>For the evaluation of a <FONT FACE="Arial, Helvetica">generic_association</FONT>
the generic actual parameter is evaluated. Additional actions are performed
in the case of a formal object of mode <B>in</B> (see <A HREF="AA-12-4.html">12.4</A>).
</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>21.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>To be honest: </B>Actually,
the actual is evaluated only if evaluation is defined for that kind of
construct -- we don't actually ``evaluate'' <FONT FACE="Arial, Helvetica">subtype_mark</FONT>s.
</FONT></DIV>
<DIV Class="NotesHeader"><FONT SIZE="-1">NOTES</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>22</FONT></DIV>
<DIV Class="Notes"><FONT SIZE="-1">5&nbsp;&nbsp;If a formal type is not
tagged, then the type is treated as an untagged type within the generic
body. Deriving from such a type in a generic body is permitted; the new
type does not get a new tag value, even if the actual is tagged. Overriding
operations for such a derived type cannot be dispatched to from outside
the instance. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>22.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>If two
overloaded subprograms declared in a generic package specification differ
only by the (formal) type of their parameters and results, then there
exist legal instantiations for which all calls of these subprograms from
outside the instance are ambiguous. For example: </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>22.b</FONT></DIV>
<DIV Class="SmallExamples"><TT><B>generic</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;A&nbsp;<B>is</B>&nbsp;(&lt;&gt;);<BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;B&nbsp;<B>is</B>&nbsp;<B>private</B>;<BR>
<B>package</B>&nbsp;G&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;Next(X&nbsp;:&nbsp;A)&nbsp;<B>return</B>&nbsp;A;<BR>
&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;Next(X&nbsp;:&nbsp;B)&nbsp;<B>return</B>&nbsp;B;<BR>
<B>end</B>&nbsp;G;</TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>22.c</FONT></DIV>
<DIV Class="SmallExamples"><TT><B>package</B>&nbsp;P&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;G(A&nbsp;=&gt;&nbsp;Boolean,&nbsp;B&nbsp;=&gt;&nbsp;Boolean);<BR>
--<I>&nbsp;All&nbsp;calls&nbsp;of&nbsp;P.Next&nbsp;are&nbsp;ambiguous.</I></TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>22.d</FONT></DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><FONT SIZE="-1"><B>Ramification:
</B>The following example illustrates some of the subtleties of the substitution
of formals and actuals: </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>22.e</FONT></DIV>
<DIV Class="SmallExamples"><TT><B>generic</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T1&nbsp;<B>is</B>&nbsp;<B>private</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;--<I>&nbsp;A&nbsp;predefined&nbsp;&quot;=&quot;&nbsp;operator&nbsp;is&nbsp;implicitly&nbsp;declared&nbsp;here:</I><BR>
&nbsp;&nbsp;&nbsp;&nbsp;--<I>&nbsp;function&nbsp;&quot;=&quot;(Left,&nbsp;Right&nbsp;:&nbsp;T1)&nbsp;return&nbsp;Boolean;</I><BR>
&nbsp;&nbsp;&nbsp;&nbsp;--<I>&nbsp;Call&nbsp;this&nbsp;&quot;=&quot;<SUB><FONT SIZE="+1"><FONT SIZE="-2">1</FONT></FONT></SUB>.</I><BR>
<B>package</B>&nbsp;G&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>subtype</B>&nbsp;S1&nbsp;<B>is</B>&nbsp;T1;&nbsp;--<I>&nbsp;So&nbsp;we&nbsp;can&nbsp;get&nbsp;our&nbsp;hands&nbsp;on&nbsp;the&nbsp;type&nbsp;from</I><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<I>&nbsp;outside&nbsp;an&nbsp;instance.</I><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T2&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;T1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;--<I>&nbsp;An&nbsp;inherited&nbsp;&quot;=&quot;&nbsp;operator&nbsp;is&nbsp;implicitly&nbsp;declared&nbsp;here:</I><BR>
&nbsp;&nbsp;&nbsp;&nbsp;--<I>&nbsp;function&nbsp;&quot;=&quot;(Left,&nbsp;Right&nbsp;:&nbsp;T2)&nbsp;return&nbsp;Boolean;</I><BR>
&nbsp;&nbsp;&nbsp;&nbsp;--<I>&nbsp;Call&nbsp;this&nbsp;&quot;=&quot;<SUB><FONT SIZE="+1"><FONT SIZE="-2">2</FONT></FONT></SUB>.</I></TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>22.f</FONT></DIV>
<DIV Class="SmallExamples"><TT>&nbsp;&nbsp;&nbsp;&nbsp;T1_Obj&nbsp;:&nbsp;T1&nbsp;:=&nbsp;...;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Bool_1&nbsp;:&nbsp;Boolean&nbsp;:=&nbsp;T1_Obj&nbsp;=&nbsp;T1_Obj;</TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>22.g</FONT></DIV>
<DIV Class="SmallExamples"><TT>&nbsp;&nbsp;&nbsp;&nbsp;T2_Obj&nbsp;:&nbsp;T2&nbsp;:=&nbsp;...;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Bool_2&nbsp;:&nbsp;Boolean&nbsp;:=&nbsp;T2_Obj&nbsp;=&nbsp;T2_Obj;<BR>
<B>end</B>&nbsp;G;<BR>
...</TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>22.h</FONT></DIV>
<DIV Class="SmallExamples"><TT><B>package</B>&nbsp;P&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;My_Int&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Integer;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;--<I>&nbsp;A&nbsp;predefined&nbsp;&quot;=&quot;&nbsp;operator&nbsp;is&nbsp;implicitly&nbsp;declared&nbsp;here:</I><BR>
&nbsp;&nbsp;&nbsp;&nbsp;--<I>&nbsp;function&nbsp;&quot;=&quot;(Left,&nbsp;Right&nbsp;:&nbsp;My_Int)&nbsp;return&nbsp;Boolean;</I><BR>
&nbsp;&nbsp;&nbsp;&nbsp;--<I>&nbsp;Call&nbsp;this&nbsp;&quot;=&quot;<SUB><FONT SIZE="+1"><FONT SIZE="-2">3</FONT></FONT></SUB>.</I><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;&quot;=&quot;(X,&nbsp;Y&nbsp;:&nbsp;My_Int)&nbsp;<B>return</B>&nbsp;Boolean;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;--<I>&nbsp;Call&nbsp;this&nbsp;&quot;=&quot;<SUB><FONT SIZE="+1"><FONT SIZE="-2">4</FONT></FONT></SUB>.</I><BR>
&nbsp;&nbsp;&nbsp;&nbsp;--<I>&nbsp;&quot;=&quot;<SUB><FONT SIZE="+1"><FONT SIZE="-2">3</FONT></FONT></SUB>&nbsp;is&nbsp;hidden&nbsp;from&nbsp;all&nbsp;visibility&nbsp;by&nbsp;&quot;=&quot;<SUB><FONT SIZE="+1"><FONT SIZE="-2">4</FONT></FONT></SUB>.</I><BR>
&nbsp;&nbsp;&nbsp;&nbsp;--<I>&nbsp;Nonetheless,&nbsp;&quot;=&quot;<SUB><FONT SIZE="+1"><FONT SIZE="-2">3</FONT></FONT></SUB>&nbsp;can&nbsp;``reemerge''&nbsp;in&nbsp;certain&nbsp;circumstances.</I><BR>
<B>end</B>&nbsp;P;<BR>
<B>use</B>&nbsp;P;<BR>
...<BR>
<B>package</B>&nbsp;I&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;G(T1&nbsp;=&gt;&nbsp;My_Int);&nbsp;--<I>&nbsp;&quot;=&quot;<SUB><FONT SIZE="+1"><FONT SIZE="-2">5</FONT></FONT></SUB>&nbsp;is&nbsp;declared&nbsp;in&nbsp;I&nbsp;(see&nbsp;below).</I><BR>
<B>use</B>&nbsp;I;</TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>22.i</FONT></DIV>
<DIV Class="SmallExamples"><TT>Another_T1_Obj&nbsp;:&nbsp;S1&nbsp;:=&nbsp;13;&nbsp;--<I>&nbsp;Can't&nbsp;denote&nbsp;T1,&nbsp;but&nbsp;S1&nbsp;will&nbsp;do.</I><BR>
Bool_3&nbsp;:&nbsp;Boolean&nbsp;:=&nbsp;Another_T1_Obj&nbsp;=&nbsp;Another_T1_Obj;</TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>22.j</FONT></DIV>
<DIV Class="SmallExamples"><TT>Another_T2_Obj&nbsp;:&nbsp;T2&nbsp;:=&nbsp;45;<BR>
Bool_4&nbsp;:&nbsp;Boolean&nbsp;:=&nbsp;Another_T2_Obj&nbsp;=&nbsp;Another_T2_Obj;</TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>22.k</FONT></DIV>
<DIV Class="SmallExamples"><TT>Double&nbsp;:&nbsp;T2&nbsp;:=&nbsp;T2_Obj&nbsp;+&nbsp;Another_T2_Obj;</TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>22.l</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">In the instance I, there is
a copy of &quot;=&quot;<SUB><FONT SIZE="+1"><FONT SIZE="-2">1</FONT></FONT></SUB>
(call it &quot;=&quot;<SUB><FONT SIZE="+1"><FONT SIZE="-2">1i</FONT></FONT></SUB>)
and &quot;=&quot;<SUB><FONT SIZE="+1"><FONT SIZE="-2">2</FONT></FONT></SUB>
(call it &quot;=&quot;<SUB><FONT SIZE="+1"><FONT SIZE="-2">2i</FONT></FONT></SUB>).
The &quot;=&quot;<SUB><FONT SIZE="+1"><FONT SIZE="-2">1i</FONT></FONT></SUB>
and &quot;=&quot;<SUB><FONT SIZE="+1"><FONT SIZE="-2">2i</FONT></FONT></SUB>
declare views of the predefined &quot;=&quot; of My_Int (that is, &quot;=&quot;<SUB><FONT SIZE="+1"><FONT SIZE="-2">3</FONT></FONT></SUB>).
In the initialization of Bool_1 and Bool_2 in the generic unit G, the
names &quot;=&quot; denote &quot;=&quot;<SUB><FONT SIZE="+1"><FONT SIZE="-2">1</FONT></FONT></SUB>
and &quot;=&quot;<SUB><FONT SIZE="+1"><FONT SIZE="-2">2</FONT></FONT></SUB>,
respectively. Therefore, the copies of these names in the instances denote
&quot;=&quot;<SUB><FONT SIZE="+1"><FONT SIZE="-2">1i</FONT></FONT></SUB>
and &quot;=&quot;<SUB><FONT SIZE="+1"><FONT SIZE="-2">2i</FONT></FONT></SUB>,
respectively. Thus, the initialization of I.Bool_1 and I.Bool_2 call
the predefined equality operator of My_Int; they will not call &quot;=&quot;<SUB><FONT SIZE="+1"><FONT SIZE="-2">4</FONT></FONT></SUB>.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>22.m</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">The declarations &quot;=&quot;<SUB><FONT SIZE="+1"><FONT SIZE="-2">1i</FONT></FONT></SUB>
and &quot;=&quot;<SUB><FONT SIZE="+1"><FONT SIZE="-2">2i</FONT></FONT></SUB>
are hidden from all visibility. This prevents them from being called
from outside the instance.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>22.n</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">The declaration of Bool_3 calls
&quot;=&quot;<SUB><FONT SIZE="+1"><FONT SIZE="-2">4</FONT></FONT></SUB>.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>22.o</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">The instance I also contains
implicit declarations of the primitive operators of T2, such as &quot;=&quot;
(call it &quot;=&quot;<SUB><FONT SIZE="+1"><FONT SIZE="-2">5</FONT></FONT></SUB>)
and &quot;+&quot;. These operations cannot be called from within the
instance, but the declaration of Bool_4 calls &quot;=&quot;<SUB><FONT SIZE="+1"><FONT SIZE="-2">5</FONT></FONT></SUB>.
</FONT></DIV>

<H4 ALIGN=CENTER>Examples</H4>
<DIV Class="Paranum"><FONT SIZE=-2>23</FONT></DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;&nbsp;&nbsp;&nbsp;<I>Examples of
generic instantiations (see <A HREF="AA-12-1.html">12.1</A>):</I> </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>24</FONT></DIV>
<DIV Class="Examples"><TT><B>procedure</B>&nbsp;Swap&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Exchange(Elem&nbsp;=&gt;&nbsp;Integer);<BR>
<B>procedure</B>&nbsp;Swap&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Exchange(Character);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<I>&nbsp;&nbsp;Swap&nbsp;is&nbsp;overloaded&nbsp;</I><BR>
<B>function</B>&nbsp;Square&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Squaring(Integer);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<I>&nbsp;&nbsp;&quot;*&quot;&nbsp;of&nbsp;Integer&nbsp;used&nbsp;by&nbsp;default</I><BR>
<B>function</B>&nbsp;Square&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Squaring(Item&nbsp;=&gt;&nbsp;Matrix,&nbsp;&quot;*&quot;&nbsp;=&gt;&nbsp;Matrix_Product);<BR>
<B>function</B>&nbsp;Square&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Squaring(Matrix,&nbsp;Matrix_Product);&nbsp;--<I>&nbsp;same&nbsp;as&nbsp;previous&nbsp;&nbsp;&nbsp;&nbsp;</I></TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>25</FONT></DIV>
<DIV Class="Examples"><TT><B>package</B>&nbsp;Int_Vectors&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;On_Vectors(Integer,&nbsp;Table,&nbsp;&quot;+&quot;);</TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>26</FONT></DIV>
<DIV Class="Wide" Style="margin-bottom: 0.4em">&nbsp;&nbsp;&nbsp;&nbsp;<I>Examples of uses
of instantiated units:</I> </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>27</FONT></DIV>
<DIV Class="Examples"><TT>Swap(A,&nbsp;B);<BR>
A&nbsp;:=&nbsp;Square(A);</TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>28</FONT></DIV>
<DIV Class="Examples"><TT>T&nbsp;:&nbsp;Table(1&nbsp;..&nbsp;5)&nbsp;:=&nbsp;(10,&nbsp;20,&nbsp;30,&nbsp;40,&nbsp;50);<BR>
N&nbsp;:&nbsp;Integer&nbsp;:=&nbsp;Int_Vectors.Sigma(T);&nbsp;&nbsp;--<I>&nbsp;&nbsp;150&nbsp;(see&nbsp;<A HREF="AA-12-2.html">12.2</A>,
``<A HREF="AA-12-2.html">Generic Bodies</A>''&nbsp;for&nbsp;the&nbsp;body&nbsp;of&nbsp;Sigma)</I></TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>29</FONT></DIV>
<DIV Class="Examples"><TT><B>use</B>&nbsp;Int_Vectors;<BR>
M&nbsp;:&nbsp;Integer&nbsp;:=&nbsp;Sigma(T);&nbsp;&nbsp;--<I>&nbsp;&nbsp;150</I></TT></DIV>

<H4 ALIGN=CENTER>Inconsistencies With Ada 83</H4>
<DIV Class="Paranum"><FONT SIZE=-2>29.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">{<I>inconsistencies with Ada
83</I>} <A NAME="I4243"></A>In Ada 83, all explicit actuals are evaluated
before all defaults, and the defaults are evaluated in the order of the
formal declarations. This ordering requirement is relaxed in Ada 95.
</FONT></DIV>

<H4 ALIGN=CENTER>Incompatibilities With Ada 83</H4>
<DIV Class="Paranum"><FONT SIZE=-2>29.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">{<I>incompatibilities with Ada
83</I>} <A NAME="I4244"></A>We have attempted to remove every violation
of the contract model. Any remaining contract model violations should
be considered bugs in the RM95. The unfortunate property of reverting
to the predefined operators of the actual types is retained for upward
compatibility. (Note that fixing this would require subtype conformance
rules.) However, tagged types do not revert in this sense. </FONT></DIV>

<H4 ALIGN=CENTER>Extensions to Ada 83</H4>
<DIV Class="Paranum"><FONT SIZE=-2>29.c</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">{<I>extensions to Ada 83</I>}
<A NAME="I4245"></A>The syntax rule for <FONT FACE="Arial, Helvetica">explicit_generic_actual_parameter</FONT>
is modified to allow a <I>package_instance_</I><FONT FACE="Arial, Helvetica">name</FONT>.
</FONT></DIV>

<H4 ALIGN=CENTER>Wording Changes from Ada 83</H4>
<DIV Class="Paranum"><FONT SIZE=-2>29.d</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">The fact that named associations
cannot be used for two formal subprograms with the same defining name
is moved to AARM-only material, because it is a ramification of other
rules, and because it is not of interest to the average user.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>29.e</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">The rule that ``An explicit
<FONT FACE="Arial, Helvetica">explicit_generic_actual_parameter</FONT>
shall not be supplied more than once for a given <FONT FACE="Arial, Helvetica">generic_formal_parameter</FONT>''
seems to be missing from RM83, although it was clearly the intent.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>29.f</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">In the explanation that the
instance is a copy of the template, we have left out RM83-12.3(5)'s ``apart
from the generic formal part'', because it seems that things in the formal
part still need to exist in instances. This is particularly true for
generic formal packages, where you're sometimes allowed to reach in and
denote the formals of the formal package from outside it. This simplifies
the explanation of what each name in an instance denotes: there are just
two cases: the declaration can be inside or outside (where inside needs
to include the generic unit itself). Note that the RM83 approach of listing
many cases (see RM83-12.5(5-14)) would have become even more unwieldy
with the addition of generic formal packages, and the declarations that
occur therein.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>29.g</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">We have corrected the definition
of the elaboration of a <FONT FACE="Arial, Helvetica">generic_instantiation</FONT>
(RM83-12.3(17)); we don't elaborate entities, and the instance is not
``implicit.''</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>29.h</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">In RM83, there is a rule saying
the formal and actual shall match, and then there is much text defining
what it means to match. Here, we simply state all the latter text as
rules. For example, ``A formal foo is matched by an actual greenish bar''
becomes ``For a formal foo, the actual shall be a greenish bar.'' This
is necessary to split the Name Resolution Rules from the Legality Rules.
Besides, there's really no need to define the concept of matching for
generic parameters. </FONT></DIV>

<HR>
<P><A HREF="AA-TOC.html">Contents</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-0-29.html">Index</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-SRCH.html">Search</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-12-2.html">Previous</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-12-4.html">Next</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-TTL.html">Legal</A></P>
</BODY>
</HTML>
