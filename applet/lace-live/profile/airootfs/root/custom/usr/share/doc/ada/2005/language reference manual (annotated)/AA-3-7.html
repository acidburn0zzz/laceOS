<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Discriminants</TITLE>
    <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    H4.centered {text-align: center}
    SPAN.swiss {font-family: Arial, Helvetica, sans-serif; font-size: 92%}
    SPAN.roman {font-family: "Times New Roman", Times, serif}
    DIV.paranum {float: left; font-family: Arial, Helvetica, sans-serif; font-size: 64%; width: 2.8em; margin-left: -0.4em; margin-right: -3.0em; margin-top: 0.2em}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    SPAN.insert1 {text-decoration: underline; color: rgb(0,51,51) }
    SPAN.delete1 {text-decoration: line-through; color: rgb(0,51,51) }
    SPAN.insert2 {text-decoration: underline; color: rgb(0,102,0) }
    SPAN.delete2 {text-decoration: line-through; color: rgb(0,102,0) }
    DIV.Normal {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.2em; margin-bottom: 0.6em}
    DIV.Annotations {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 6.2em; margin-bottom: 0.6em}
    DIV.Notes {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em; margin-bottom: 0.6em}
    DIV.NotesHeader {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em}
    DIV.SyntaxIndented {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-bottom: 0.4em}
    DIV.Examples {font-family: "Courier New", monospace; font-size: 90%; line-height: 122%; margin-left: 3.4em; margin-bottom: 0.6em}
    UL.Bulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.SmallBulleted {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 8.7em; margin-right: 2.5em; margin-top: 0em; margin-bottom: 0.5em}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#000080" VLINK="#330033" ALINK="#0000FF">
<DIV><B><SPAN Style="font-size:200%; color: rgb(0,51,153)">Annotated</SPAN><SPAN Style="font-size:200%; color: rgb(0,0,102)">&nbsp;Ada Reference Manual</SPAN></B> &mdash; <A HREF="AA-TTL.html"><B>Legal Information</B></A></DIV>
<DIV Style="margin-top: 0.6em; margin-bottom: 0.0em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-3-6-3.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-3-7-1.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<HR>
<H1>3.7 Discriminants</H1>
<DIV Class="paranum">1/2</DIV>
<DIV Class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00326.TXT">AI95-00326-01</A></I>} 
[<SPAN STYLE="font-size: 80%">{<I>discriminant</I>}</SPAN> <A NAME="I2049"></A><SPAN STYLE="font-size: 80%">{<I>type 
parameter: See discriminant</I>}</SPAN> <A NAME="I2050"></A><SPAN STYLE="font-size: 80%">{<I>parameter: 
See also discriminant</I>}</SPAN> <A NAME="I2051"></A>A composite type 
(other than an array<SPAN class="insert2">&nbsp;or interface</SPAN> type) 
can have discriminants, which parameterize the type. A <SPAN Class="swiss"><A HREF="AA-3-7.html#S0061">known_discriminant_part</A></SPAN> 
specifies the discriminants of a composite type. A discriminant of an 
object is a component of the object, and is either of a discrete type 
or an access type. An <SPAN Class="swiss"><A HREF="AA-3-7.html#S0060">unknown_discriminant_part</A></SPAN> 
in the declaration of a<SPAN class="delete2">&nbsp;partial</SPAN> view of 
a type specifies that the discriminants of the type are unknown for the 
given view; all subtypes of such a<SPAN class="delete2">&nbsp;partial</SPAN> 
view are indefinite subtypes.]&nbsp;</DIV>
<DIV Class="paranum">1.a/2</DIV>
<DIV Class="Annotations"><B>Glossary entry:&nbsp;</B>{<I>Discriminant</I>} 
A discriminant is a parameter <SPAN class="insert2">for</SPAN><SPAN class="delete2">&nbsp;of</SPAN> 
a composite type. It can control, for example, the bounds of a component 
of the type if <SPAN class="insert2">the component is</SPAN><SPAN class="delete2">&nbsp;that 
type is</SPAN> an array<SPAN class="delete2">&nbsp;type</SPAN>. A discriminant 
<SPAN class="insert2">for</SPAN><SPAN class="delete2">&nbsp;of</SPAN> a task 
type can be used to pass data to a task of the type upon creation.</DIV>
<DIV Class="paranum">1.b/2</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00114.TXT">AI95-00114-01</A></I>} 
{<I>unknown discriminants</I> [partial]} <A NAME="I2052"></A>{<I>discriminants 
(unknown)</I> [partial]} <A NAME="I2053"></A>A <SPAN class="insert2">view 
of a&nbsp;</SPAN>type, and all <SPAN class="delete2">of its&nbsp;</SPAN>subtypes<SPAN class="insert2">&nbsp;of the view</SPAN>, have <I>unknown discriminants</I> when the number 
or names of the discriminants, if any, are unknown at the point of the 
type declaration<SPAN class="insert2">&nbsp;for the view</SPAN>. A <SPAN Class="swiss"><A HREF="AA-3-7.html#S0059">discriminant_part</A></SPAN> 
of (&lt;&gt;) is used to indicate unknown discriminants.&nbsp;</DIV>

<H4 Class="centered">Language Design Principles</H4>
<DIV Class="paranum">1.c/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00402.TXT">AI95-00402-01</A></I>} 
<SPAN class="insert2">When an access discriminant is initialized at the 
time of object creation with an allocator of an anonymous type, the allocated 
object and the object with the discriminant are tied together for their 
lifetime. They should be allocated out of the same storage pool, and 
then at the end of the lifetime of the enclosing object, finalized and 
reclaimed together. In this case, the allocated object is called a coextension 
(see <A HREF="AA-3-10-2.html">3.10.2</A>).</SPAN>&nbsp;</DIV>
<DIV Class="paranum">1.d/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Discussion:&nbsp;</B>The 
above principle when applied to a nonlimited type implies that such an 
object may be copied only to a shorter-lived object, because attempting 
to assign it to a longer-lived object would fail because the access discriminants 
would not match. In a copy, the lifetime connection between the enclosing 
object and the allocated object does not exist. The allocated object 
is tied in the above sense only to the original object. Other copies 
have only secondary references to it.</SPAN></DIV>
<DIV Class="paranum">1.e/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2">Note that when an <SPAN Class="swiss"><A HREF="AA-4-8.html#S0129">allocator</A></SPAN> 
appears as a constraint on an access discriminant in a <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0027">subtype_indication</A></SPAN> 
that is elaborated independently from object creation, no such connection 
exists. For example, if a named constrained subtype is declared via &quot;<B>subtype</B> 
Constr <B>is</B> Rec(Acc_Discrim =&gt; <B>new</B> T);&quot; or if such 
an <SPAN Class="swiss"><A HREF="AA-4-8.html#S0129">allocator</A></SPAN> 
appears in the <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0027">subtype_indication</A></SPAN> 
for a component, the allocator is evaluated when the <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0027">subtype_indication</A></SPAN> 
is elaborated, and hence its lifetime is typically longer than the objects 
or components that will later be subject to the constraint. In these 
cases, the allocated object should not be reclaimed until the <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0027">subtype_indication</A></SPAN> 
goes out of scope.</SPAN>&nbsp;</DIV>

<H4 Class="centered">Syntax</H4>
<DIV Class="paranum">2</DIV>
<DIV Class="SyntaxIndented"><SPAN Class="swiss">discriminant_part</SPAN><A NAME="I2054"></A><A NAME="S0059"></A><SPAN Class="swiss">&nbsp;::=&nbsp;</SPAN><A NAME="I2055"></A><SPAN Class="swiss"><A HREF="AA-3-7.html#S0060">unknown_discriminant_part</A></SPAN>&nbsp;|&nbsp;<A NAME="I2056"></A><SPAN Class="swiss"><A HREF="AA-3-7.html#S0061">known_discriminant_part</A></SPAN></DIV>
<DIV Class="paranum">3</DIV>
<DIV Class="SyntaxIndented"><SPAN Class="swiss">unknown_discriminant_part</SPAN><A NAME="I2057"></A><A NAME="S0060"></A><SPAN Class="swiss">&nbsp;::=&nbsp;</SPAN>(&lt;&gt;)</DIV>
<DIV Class="paranum">4</DIV>
<DIV Class="SyntaxIndented"><SPAN Class="swiss">known_discriminant_part</SPAN><A NAME="I2058"></A><A NAME="S0061"></A><SPAN Class="swiss">&nbsp;::=&nbsp;</SPAN><BR>
&nbsp;&nbsp;&nbsp;(<A NAME="I2059"></A><SPAN Class="swiss"><A HREF="AA-3-7.html#S0062">discriminant_specification</A></SPAN>&nbsp;{;&nbsp;<A NAME="I2060"></A><SPAN Class="swiss"><A HREF="AA-3-7.html#S0062">discriminant_specification</A></SPAN>})</DIV>
<DIV Class="paranum">5/2</DIV>
<DIV Class="SyntaxIndented">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00231.TXT">AI95-00231-01</A></I>} 
<SPAN Class="swiss">discriminant_specification</SPAN><A NAME="I2061"></A><A NAME="S0062"></A><SPAN Class="swiss">&nbsp;::=&nbsp;</SPAN><BR>
&nbsp;&nbsp;&nbsp;<A NAME="I2062"></A><SPAN Class="swiss"><A HREF="AA-3-3-1.html#S0033">defining_identifier_list</A></SPAN>&nbsp;:&nbsp;<SPAN class="insert2">[<A NAME="I2063"></A><SPAN Class="swiss"><A HREF="AA-3-10.html#S0083">null_exclusion</A></SPAN>]&nbsp;</SPAN><A NAME="I2064"></A><SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0028">subtype_mark</A></SPAN>&nbsp;[:=&nbsp;<A NAME="I2065"></A><SPAN Class="swiss"><A HREF="AA-3-7.html#S0063">default_expression</A></SPAN>]<BR>
&nbsp;|&nbsp;<A NAME="I2066"></A><SPAN Class="swiss"><A HREF="AA-3-3-1.html#S0033">defining_identifier_list</A></SPAN>&nbsp;:&nbsp;<A NAME="I2067"></A><SPAN Class="swiss"><A HREF="AA-3-10.html#S0084">access_definition</A></SPAN>&nbsp;[:=&nbsp;<A NAME="I2068"></A><SPAN Class="swiss"><A HREF="AA-3-7.html#S0063">default_expression</A></SPAN>]</DIV>
<DIV Class="paranum">6</DIV>
<DIV Class="SyntaxIndented"><SPAN Class="swiss">default_expression</SPAN><A NAME="I2069"></A><A NAME="S0063"></A><SPAN Class="swiss">&nbsp;::=&nbsp;</SPAN><A NAME="I2070"></A><SPAN Class="swiss"><A HREF="AA-4-4.html#S0115">expression</A></SPAN></DIV>

<H4 Class="centered">Name Resolution Rules</H4>
<DIV Class="paranum">7</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>expected type (discriminant 
default_expression)</I> [partial]}</SPAN> <A NAME="I2071"></A>The expected 
type for the <SPAN Class="swiss"><A HREF="AA-3-7.html#S0063">default_expression</A></SPAN> 
of a <SPAN Class="swiss"><A HREF="AA-3-7.html#S0062">discriminant_specification</A></SPAN> 
is that of the corresponding discriminant.&nbsp;</DIV>

<H4 Class="centered">Legality Rules</H4>
<DIV Class="paranum">8/2</DIV>
<DIV Class="Normal">{<I><A HREF="defect1.html#8652/0007">8652/0007</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00098.TXT">AI95-00098-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
A <SPAN class="insert1"><SPAN Class="swiss"><A HREF="AA-3-7.html#S0059">discriminant_part</A></SPAN></SPAN><SPAN class="delete1"><SPAN Class="swiss"><A HREF="AA-3-7.html#S0061">&nbsp;known_discriminant_part</A></SPAN></SPAN> 
is only permitted in a declaration for a composite type that is not an 
array<SPAN class="insert2">&nbsp;or interface</SPAN> type [(this includes 
generic formal types)]<SPAN class="insert1">. A</SPAN><SPAN class="delete1">; 
a</SPAN> type declared with a <SPAN Class="swiss"><A HREF="AA-3-7.html#S0061">known_discriminant_part</A></SPAN> 
is called a <I>discriminated</I> type,<SPAN STYLE="font-size: 80%">{<I>discriminated 
type</I>}</SPAN> <A NAME="I2072"></A> as is a type that inherits (known) 
discriminants.&nbsp;</DIV>
<DIV Class="paranum">8.a</DIV>
<DIV Class="Annotations"><B>Implementation Note:&nbsp;</B>Discriminants on 
array types were considered, but were omitted to ease (existing) implementations. 
</DIV>
<DIV Class="paranum">8.b</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>Note that the above definition 
for &ldquo;discriminated type&rdquo; does not include types declared 
with an <SPAN Class="swiss"><A HREF="AA-3-7.html#S0060">unknown_discriminant_part</A></SPAN>. 
This seems consistent with Ada 83, where such types (in a generic formal 
part) would not be considered discriminated types. Furthermore, the full 
type for a type with unknown discriminants need not even be composite, 
much less have any discriminants.</DIV>
<DIV Class="paranum">8.b.1/1</DIV>
<DIV Class="Annotations">{<I><A HREF="defect1.html#8652/0007">8652/0007</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00098.TXT">AI95-00098-01</A></I>} 
<SPAN class="insert1">On the other hand, <SPAN Class="swiss"><A HREF="AA-3-7.html#S0060">unknown_discriminant_part</A></SPAN>s 
cannot be applied to type declarations that cannot have a <SPAN Class="swiss"><A HREF="AA-3-7.html#S0061">known_discriminant_part</A></SPAN>. 
There is no point in having unknown discriminants on a type that can 
never have discriminants (for instance, a formal modular type), even 
when these are allowed syntactically.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">9/2</DIV>
<DIV Class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00231.TXT">AI95-00231-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00254.TXT">AI95-00254-01</A></I>} 
The subtype of a discriminant may be defined by<SPAN class="insert2">&nbsp;an optional <SPAN Class="swiss"><A HREF="AA-3-10.html#S0083">null_exclusion</A></SPAN> 
and</SPAN> a <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0028">subtype_mark</A></SPAN>, 
in which case the <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0028">subtype_mark</A></SPAN> 
shall denote a discrete or access subtype, or it may be defined by an 
<SPAN Class="swiss"><A HREF="AA-3-10.html#S0084">access_definition</A></SPAN><SPAN class="delete2">&nbsp;[(in which case the <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0028">subtype_mark</A></SPAN> 
of the <SPAN Class="swiss"><A HREF="AA-3-10.html#S0084">access_definition</A></SPAN> 
may denote any kind of subtype)]</SPAN>. <SPAN STYLE="font-size: 80%">{<I>access 
discriminant</I>}</SPAN> <A NAME="I2073"></A>A discriminant that is defined 
by an <SPAN Class="swiss"><A HREF="AA-3-10.html#S0084">access_definition</A></SPAN> 
is called an <I>access discriminant</I> and is of an anonymous <SPAN class="insert2">access</SPAN><SPAN class="delete2">&nbsp;general 
access-to-variable</SPAN> type<SPAN class="delete2">&nbsp;whose designated 
subtype is denoted by the <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0028">subtype_mark</A></SPAN> 
of the <SPAN Class="swiss"><A HREF="AA-3-10.html#S0084">access_definition</A></SPAN></SPAN>. 
</DIV>
<DIV Class="paranum">9.a/2</DIV>
<DIV Class="Annotations"><SPAN STYLE="font-size: 80%"><I>This paragraph 
was deleted.</I></SPAN><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00230.TXT">AI95-00230-01</A></I>} 
<SPAN class="delete2">In an early version of Ada 9X, we allowed access 
discriminants on nonlimited types, but this created unpleasant complexities. 
It turned out to be simpler and more uniform to allow discriminants of 
a named access type on any discriminated type, and keep access discriminants 
just for limited types.</SPAN></DIV>
<DIV Class="paranum">9.b</DIV>
<DIV Class="Annotations">Note that discriminants of a named access type 
are not considered &ldquo;access discriminants.&rdquo; Similarly, &ldquo;access 
parameter&rdquo; only refers to a formal parameter defined by an <SPAN Class="swiss"><A HREF="AA-3-10.html#S0084">access_definition</A></SPAN>. 
</DIV>
<DIV Class="paranum">9.1/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00402.TXT">AI95-00402-01</A></I>} 
<SPAN class="insert2"><SPAN Class="swiss"><A HREF="AA-3-7.html#S0063">Default_expression</A></SPAN>s 
shall be provided either for all or for none of the discriminants of 
a <SPAN Class="swiss"><A HREF="AA-3-7.html#S0061">known_discriminant_part</A></SPAN>. 
No <SPAN Class="swiss"><A HREF="AA-3-7.html#S0063">default_expression</A></SPAN>s 
are permitted in a <SPAN Class="swiss"><A HREF="AA-3-7.html#S0061">known_discriminant_part</A></SPAN> 
in a declaration of a tagged type [or a generic formal type].</SPAN></DIV>
<DIV Class="paranum">9.c/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Reason:&nbsp;</B>The all-or-none 
rule is related to the rule that a discriminant constraint shall specify 
values for all discriminants. One could imagine a different rule that 
allowed a constraint to specify only some of the discriminants, with 
the others provided by default. Having defaults for discriminants has 
a special significance &mdash; it allows objects of the type to be unconstrained, 
with the discriminants alterable as part of assigning to the object.</SPAN></DIV>
<DIV Class="paranum">9.d/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2">Defaults for discriminants 
of tagged types are disallowed so that every object of a tagged type 
is constrained, either by an explicit constraint, or by its initial discriminant 
values. This substantially simplifies the semantic rules and the implementation 
of inherited dispatching operations. For generic formal types, the restriction 
simplifies the type matching rules. If one simply wants a &quot;default&quot; 
value for the discriminants, a constrained subtype can be declared for 
future use.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">10/2</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00230.TXT">AI95-00230-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00402.TXT">AI95-00402-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00419.TXT">AI95-00419-01</A></I>} 
A <SPAN Class="swiss"><A HREF="AA-3-7.html#S0062">discriminant_specification</A></SPAN> 
for an access discriminant <SPAN class="insert2">may have a <SPAN Class="swiss"><A HREF="AA-3-7.html#S0063">default_expression</A></SPAN></SPAN><SPAN class="delete2">&nbsp;shall 
appear</SPAN> only in the declaration for a task or protected type, or 
for a type <SPAN class="insert2">that is a descendant of an explicitly 
limited record type</SPAN><SPAN class="delete2">&nbsp;with the reserved word 
<B>limited</B> in its [(full)] definition or in that of one of its ancestors</SPAN>. 
In addition to the places where Legality Rules normally apply (see <A HREF="AA-12-3.html">12.3</A>), 
this rule applies also in the private part of an instance of a generic 
unit.<SPAN STYLE="font-size: 80%">{<I>generic contract issue</I> [partial]}</SPAN> 
<A NAME="I2074"></A></DIV>
<DIV Class="paranum">10.a/2</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>This rule implies that a 
type can have <SPAN class="insert2">a default for&nbsp;</SPAN>an access discriminant 
if the type is limited, but not if the only reason it's limited is because 
of a limited component. Compare with the definition of limited type in 
<A HREF="AA-7-5.html">7.5</A>.<SPAN class="insert2">&nbsp;Also, recall that 
a &ldquo;descendant&rsquo; includes the type itself, so an explicitly 
limited record type can have defaults.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">10.b/2</DIV>
<DIV Class="Annotations"><SPAN STYLE="font-size: 80%"><I>This paragraph 
was deleted.</I></SPAN><SPAN class="delete2"><B>Ramification:&nbsp;</B>It 
is a consequence of this rule that only a return-by-reference type can 
have an access discriminant (see <A HREF="AA-6-5.html">6.5</A>). This 
is important to avoid dangling references to local variables.</SPAN> 
</DIV>
<DIV Class="paranum">10.c/2</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00230.TXT">AI95-00230-01</A></I>} 
We <SPAN class="delete2">also&nbsp;</SPAN>considered the following rules<SPAN class="insert2">&nbsp;for access discriminants</SPAN>:&nbsp;</DIV>
<DIV Class="paranum">10.d</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>If a type has an access discriminant, 
this automatically makes it limited, just like having a limited component 
automatically makes a type limited. This was rejected because it decreases 
program readability, and because it seemed error prone (two bugs in a 
previous version of the RM9X were attributable to this rule).</LI></UL>
<DIV Class="paranum">10.e/2</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>A type with an access discriminant 
shall be limited. This is equivalent to the rule we actually chose<SPAN class="insert2">&nbsp;for Ada 95</SPAN>, except that it allows a type to have an access discriminant 
if it is limited just because of a limited component. For example, any 
record containing a task would be allowed to have an access discriminant, 
whereas the actual rule requires &ldquo;<B>limited</B> <B>record</B>&rdquo;. 
This rule was also rejected due to readability concerns, and because 
would interact badly with the rules for limited types that &ldquo;become 
nonlimited&rdquo;.</LI></UL>
<DIV Class="paranum">10.f/2</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC><SPAN class="insert2">A type 
may have an access discriminant if it is a limited partial view, or a 
task, protected, or explicitly limited record type. This was the rule 
chosen for Ada 95.</SPAN></LI></UL>
<DIV Class="paranum">10.g/2</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC><SPAN class="insert2">Any type 
may have an access discriminant. For nonlimited type, there is no special 
accessibility for access discriminants; they're the same as any other 
anonymous access component. For a limited type, they have the special 
accessibility of Ada 95. However, this doesn't work because a limited 
partial view can have a nonlimited full view -- giving the two views 
different accessibility.</SPAN></LI></UL>
<DIV Class="paranum">10.h/2</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC><SPAN class="insert2">Any type 
may have an access discriminant, as above. However, special accessibility 
rules only apply to types that are &ldquo;really&rdquo; limited (task, 
protected, and explicitly limited records). However, this breaks privacy; 
worse, Legality Rules depend on the definition of accessibility.</SPAN></LI></UL>
<DIV Class="paranum">10.i/2</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC><SPAN class="insert2">Any type 
may have an access discriminant, as above. Limited types have special 
accessibility, while nonlimited types have normal accessibility. However, 
a limited partial view with an access discriminant can only be completed 
by a task, protected, or explicitly limited record type. That prevents 
accessibility from changing. A runtime accessibility check is required 
on generic formal types with access discriminants. However, changing 
between limited and nonlimited types would have far-reaching consequences 
for access discriminants &mdash; which is uncomfortable.</SPAN></LI></UL>
<DIV Class="paranum">10.j/2</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC><SPAN class="insert2">Any type 
may have an access discriminant. All types have special accessibility. 
This was considered early during the Ada 9X process, but was dropped 
for &ldquo;unpleasant complexities&rdquo;, which unfortunately aren't 
recorded. It does seem that an accessibility check would be needed on 
assignment of such a type, to avoid copying an object with a discriminant 
pointing to a local object into a more global object (and thus creating 
a dangling pointer).</SPAN></LI></UL>
<DIV Class="paranum">10.k/2</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC><SPAN class="insert2">Any type 
may have an access discriminant, but access discriminants cannot have 
defaults. All types have special accessibility. This gets rid of the 
problems on assignment (you couldn't change such a discriminant), but 
it would be horribly incompatible with Ada 95.</SPAN></LI></UL>
<DIV Class="paranum">10.l/2</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC><SPAN class="insert2">Any type 
may have an access discriminant, but access discriminants may have defaults 
only if they are a &ldquo;really&rdquo; limited type. This is the rule 
chosen for Ada 2005, as it is not incompatible, and it doesn't require 
weird accessibility checks.</SPAN>&nbsp;</LI></UL>
<DIV Class="paranum">11/2</DIV>
<DIV Class="Normal">&nbsp;<SPAN STYLE="font-size: 80%"><I>This paragraph was 
deleted.</I></SPAN><SPAN class="delete2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00402.TXT">AI95-00402-01</A></I>} 
<SPAN class="delete2"><SPAN Class="swiss"><A HREF="AA-3-7.html#S0063">Default_expression</A></SPAN>s 
shall be provided either for all or for none of the discriminants of 
a <SPAN Class="swiss"><A HREF="AA-3-7.html#S0061">known_discriminant_part</A></SPAN>. 
No <SPAN Class="swiss"><A HREF="AA-3-7.html#S0063">default_expression</A></SPAN>s 
are permitted in a <SPAN Class="swiss"><A HREF="AA-3-7.html#S0061">known_discriminant_part</A></SPAN> 
in a declaration of a tagged type [or a generic formal type].</SPAN> 
</DIV>
<DIV Class="paranum">11.a/2</DIV>
<DIV Class="Annotations"><SPAN class="delete2"><B>Reason:&nbsp;</B>The all-or-none 
rule is related to the rule that a discriminant constraint shall specify 
values for all discriminants. One could imagine a different rule that 
allowed a constraint to specify only some of the discriminants, with 
the others provided by default. Having defaults for discriminants has 
a special significance &mdash; it allows objects of the type to be unconstrained, 
with the discriminants alterable as part of assigning to the object.</SPAN></DIV>
<DIV Class="paranum">11.b/2</DIV>
<DIV Class="Annotations"><SPAN class="delete2">Defaults for discriminants 
of tagged types are disallowed so that every object of a tagged type 
is constrained, either by an explicit constraint, or by its initial discriminant 
values. This substantially simplifies the semantic rules and the implementation 
of inherited dispatching operations. For generic formal types, the restriction 
simplifies the type matching rules. If one simply wants a &quot;default&quot; 
value for the discriminants, a constrained subtype can be declared for 
future use.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">12</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">For a type defined 
by a <SPAN Class="swiss"><A HREF="AA-3-4.html#S0035">derived_type_definition</A></SPAN>, 
if a <SPAN Class="swiss"><A HREF="AA-3-7.html#S0061">known_discriminant_part</A></SPAN> 
is provided in its declaration, then:&nbsp;</DIV>
<DIV Class="paranum">13</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>The parent subtype shall be constrained;</LI></UL>
<DIV Class="paranum">14</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>If the parent type is not a tagged 
type, then each discriminant of the derived type shall be used in the 
constraint defining the parent subtype;</LI></UL>
<DIV Class="paranum">14.a</DIV>
<DIV Class="Annotations"><B>Implementation Note:&nbsp;</B>This ensures that 
the new discriminant can share storage with an existing discriminant.</DIV>
<DIV Class="paranum">15</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>If a discriminant is used in the constraint 
defining the parent subtype, the subtype of the discriminant shall be 
statically compatible (see <A HREF="AA-4-9-1.html">4.9.1</A>) with the 
subtype of the corresponding parent discriminant.&nbsp;</LI></UL>
<DIV Class="paranum">15.a</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>This ensures that on conversion 
(or extension via an extension aggregate) to a distantly related type, 
if the discriminants satisfy the target type's requirements they satisfy 
all the intermediate types' requirements as well.&nbsp;</DIV>
<DIV Class="paranum">15.b</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>There is no requirement 
that the new discriminant have the same (or any) <SPAN Class="swiss"><A HREF="AA-3-7.html#S0063">default_expression</A></SPAN> 
as the parent's discriminant.&nbsp;</DIV>
<DIV Class="paranum">16</DIV>
<DIV Class="Normal">The type of the <SPAN Class="swiss"><A HREF="AA-3-7.html#S0063">default_expression</A></SPAN>, 
if any, for an access discriminant shall be convertible to the anonymous 
access type of the discriminant (see <A HREF="AA-4-6.html">4.6</A>). 
<SPAN STYLE="font-size: 80%">{<I>convertible (required)</I> [partial]}</SPAN> 
<A NAME="I2075"></A></DIV>
<DIV Class="paranum">16.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>This requires convertibility 
of the designated subtypes.&nbsp;</DIV>

<H4 Class="centered">Static Semantics</H4>
<DIV Class="paranum">17</DIV>
<DIV Class="Normal">A <SPAN Class="swiss"><A HREF="AA-3-7.html#S0062">discriminant_specification</A></SPAN> 
declares a discriminant; the <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0028">subtype_mark</A></SPAN> 
denotes its subtype unless it is an access discriminant, in which case 
the discriminant's subtype is the anonymous access-to-variable subtype 
defined by the <SPAN Class="swiss"><A HREF="AA-3-10.html#S0084">access_definition</A></SPAN>.</DIV>
<DIV Class="paranum">18</DIV>
<DIV Class="Normal">[For a type defined by a <SPAN Class="swiss"><A HREF="AA-3-4.html#S0035">derived_type_definition</A></SPAN>, 
each discriminant of the parent type is either inherited, constrained 
to equal some new discriminant of the derived type, or constrained to 
the value of an expression.] <SPAN STYLE="font-size: 80%">{<I>corresponding 
discriminants</I>}</SPAN> <A NAME="I2076"></A>When inherited or constrained 
to equal some new discriminant, the parent discriminant and the discriminant 
of the derived type are said to <I>correspond</I>. Two discriminants 
also correspond if there is some common discriminant to which they both 
correspond. A discriminant corresponds to itself as well. <SPAN STYLE="font-size: 80%">{<I>specified 
discriminant</I>}</SPAN> <A NAME="I2077"></A>If a discriminant of a parent 
type is constrained to a specific value by a <SPAN Class="swiss"><A HREF="AA-3-4.html#S0035">derived_type_definition</A></SPAN>, 
then that discriminant is said to be <I>specified</I> by that <SPAN Class="swiss"><A HREF="AA-3-4.html#S0035">derived_type_definition</A></SPAN>. 
</DIV>
<DIV Class="paranum">18.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>The correspondence relationship 
is transitive, symmetric, and reflexive. That is, if A corresponds to 
B, and B corresponds to C, then A, B, and C each corresponds to A, B, 
and C in all combinations.</DIV>
<DIV Class="paranum">19</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>depend on a discriminant 
(for a constraint or component_definition)</I>}</SPAN> <A NAME="I2078"></A>A 
<SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0029">constraint</A></SPAN> 
that appears within the definition of a discriminated type <I>depends 
on a discriminant</I> of the type if it names the discriminant as a bound 
or discriminant value. A <SPAN Class="swiss"><A HREF="AA-3-6.html#S0056">component_definition</A></SPAN> 
depends on a discriminant if its <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0029">constraint</A></SPAN> 
depends on the discriminant, or on a discriminant that corresponds to 
it.&nbsp;</DIV>
<DIV Class="paranum">19.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>A <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0029">constraint</A></SPAN> 
in a <SPAN Class="swiss"><A HREF="AA-9-1.html#S0192">task_body</A></SPAN> 
is not considered to <I>depend</I> on a discriminant of the task type, 
even if it names it. It is only the <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0029">constraint</A></SPAN>s 
in the type definition itself that are considered dependents. Similarly 
for protected types.&nbsp;</DIV>
<DIV Class="paranum">20</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em"><SPAN STYLE="font-size: 80%">{<I>depend 
on a discriminant (for a component)</I>}</SPAN> <A NAME="I2079"></A>A 
component <I>depends on a discriminant</I> if:&nbsp;</DIV>
<DIV Class="paranum">21</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>Its <SPAN Class="swiss"><A HREF="AA-3-6.html#S0056">component_definition</A></SPAN> 
depends on the discriminant; or&nbsp;</LI></UL>
<DIV Class="paranum">21.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>A component does <I>not</I> 
depend on a discriminant just because its <SPAN Class="swiss"><A HREF="AA-3-7.html#S0063">default_expression</A></SPAN> 
refers to the discriminant.</DIV>
<DIV Class="paranum">22</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>It is declared in a <SPAN Class="swiss"><A HREF="AA-3-8-1.html#S0071">variant_part</A></SPAN> 
that is governed by the discriminant; or</LI></UL>
<DIV Class="paranum">23</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>It is a component inherited as part 
of a <SPAN Class="swiss"><A HREF="AA-3-4.html#S0035">derived_type_definition</A></SPAN>, 
and the <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0029">constraint</A></SPAN> 
of the <I>parent_</I><SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0027">subtype_indication</A></SPAN> 
depends on the discriminant; or&nbsp;</LI></UL>
<DIV Class="paranum">23.a</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>When the parent subtype depends 
on a discriminant, the parent part of the derived type is treated like 
a discriminant-dependent component.&nbsp;</DIV>
<DIV Class="paranum">23.b</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>Because of this rule, we 
don't really need to worry about &ldquo;corresponding&rdquo; discriminants, 
since all the inherited components will be discriminant-dependent if 
there is a new <SPAN Class="swiss"><A HREF="AA-3-7.html#S0061">known_discriminant_part</A></SPAN> 
whose discriminants are used to constrain the old discriminants.&nbsp;</DIV>
<DIV Class="paranum">24</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>It is a subcomponent of a component 
that depends on the discriminant.&nbsp;</LI></UL>
<DIV Class="paranum">24.a</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>The concept of discriminant-dependent 
(sub)components is primarily used in various rules that disallow renaming 
or 'Access, or specify that certain discriminant-changing assignments 
are erroneous. The goal is to allow implementations to move around or 
change the size of discriminant-dependent subcomponents upon a discriminant-changing 
assignment to an enclosing object. The above definition specifies that 
all subcomponents of a discriminant-dependent component or parent part 
are themselves discriminant-dependent, even though their presence or 
size does not in fact depend on a discriminant. This is because it is 
likely that they will move in a discriminant-changing assignment if they 
are a component of one of several discriminant-dependent parts of the 
same record.&nbsp;</DIV>
<DIV Class="paranum">25</DIV>
<DIV Class="Normal">Each value of a discriminated type includes a value 
for each component of the type that does not depend on a discriminant[; 
this includes the discriminants themselves]. The values of discriminants 
determine which other component values are present in the value of the 
discriminated type.&nbsp;</DIV>
<DIV Class="paranum">25.a</DIV>
<DIV Class="Annotations"><B>To be honest:&nbsp;</B>Which values are present 
might depend on discriminants of some ancestor type that are constrained 
in an intervening <SPAN Class="swiss"><A HREF="AA-3-4.html#S0035">derived_type_definition</A></SPAN>. 
That's why we say &quot;values of discriminants&quot; instead of &quot;values 
of <I>the</I> discriminants&quot; &mdash; a subtle point.</DIV>
<DIV Class="paranum">26</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>known discriminants</I>}</SPAN> 
<A NAME="I2080"></A><SPAN STYLE="font-size: 80%">{<I>discriminants (known)</I>}</SPAN> 
<A NAME="I2081"></A><SPAN STYLE="font-size: 80%">{<I>constrained (subtype)</I>}</SPAN> 
<A NAME="I2082"></A><SPAN STYLE="font-size: 80%">{<I>unconstrained (subtype)</I>}</SPAN> 
<A NAME="I2083"></A>A type declared with a <SPAN Class="swiss"><A HREF="AA-3-7.html#S0061">known_discriminant_part</A></SPAN> 
is said to have <I>known discriminants</I>; its first subtype is unconstrained. 
<SPAN STYLE="font-size: 80%">{<I>unknown discriminants</I>}</SPAN> <A NAME="I2084"></A><SPAN STYLE="font-size: 80%">{<I>discriminants 
(unknown)</I>}</SPAN> <A NAME="I2085"></A>A type declared with an <SPAN Class="swiss"><A HREF="AA-3-7.html#S0060">unknown_discriminant_part</A></SPAN> 
is said to have <I>unknown discriminants</I>. A type declared without 
a <SPAN Class="swiss"><A HREF="AA-3-7.html#S0059">discriminant_part</A></SPAN> 
has no discriminants, unless it is a derived type; if derived, such a 
type has the same sort of discriminants (known, unknown, or none) as 
its parent (or ancestor) type. A tagged class-wide type also has unknown 
discriminants. <SPAN STYLE="font-size: 80%">{<I>class-wide type</I>}</SPAN> 
<A NAME="I2086"></A><SPAN STYLE="font-size: 80%">{<I>indefinite subtype</I>}</SPAN> 
<A NAME="I2087"></A>[Any subtype of a type with unknown discriminants 
is an unconstrained and indefinite subtype (see <A HREF="AA-3-2.html">3.2</A> 
and <A HREF="AA-3-3.html">3.3</A>).]&nbsp;</DIV>
<DIV Class="paranum">26.a/2</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00114.TXT">AI95-00114-01</A></I>} 
An <SPAN Class="swiss"><A HREF="AA-3-7.html#S0060">unknown_discriminant_part</A></SPAN> 
&ldquo;(&lt;&gt;)&rdquo; is only permitted in the declaration of a (generic 
or nongeneric) private type, private extension, <SPAN class="insert2">incomplete 
type,&nbsp;</SPAN>or formal derived type. Hence, only such types, descendants 
thereof, and class-wide types can have unknown discriminants. An <SPAN Class="swiss"><A HREF="AA-3-7.html#S0060">unknown_discriminant_part</A></SPAN> 
is used to indicate that the corresponding actual or full type might 
have discriminants without defaults, or be an unconstrained array subtype. 
Tagged class-wide types are also considered to have unknown discriminants 
because discriminants can be added by type extensions, so the total number 
of discriminants of any given value of a tagged class-wide type is not 
known at compile time.</DIV>
<DIV Class="paranum">26.b/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00287.TXT">AI95-00287-01</A></I>} 
A subtype with unknown discriminants is indefinite, and hence an object 
of such a subtype needs explicit initialization.<SPAN class="delete2">&nbsp;If the subtype is limited, no (stand-alone) objects can be declared since 
initialization is not permitted (though formal parameters are permitted, 
and objects of the actual/full type will generally be declarable).</SPAN> 
A limited private type with unknown discriminants is &ldquo;extremely&rdquo; 
limited;<SPAN class="insert2">&nbsp;objects of</SPAN> such a type <SPAN class="insert2">&nbsp;can be initialized only by subprograms (either procedures with a parameter 
of the type, or a function returning the type) declared in the package. 
Subprograms declared elsewhere can operate on and even return the type, 
but they can only initialize the object by calling (ultimately) a subprogram 
in the package declaring the type. Such a type</SPAN> is useful for keeping 
complete control over object creation within the package declaring the 
type.</DIV>
<DIV Class="paranum">26.c</DIV>
<DIV Class="Annotations">A partial view of a type might have unknown 
discriminants, while the full view of the same type might have known, 
unknown, or no discriminants<SPAN class="insert1">.</SPAN><SPAN class="delete1">,</SPAN> 
</DIV>

<H4 Class="centered">Dynamic Semantics</H4>
<DIV Class="paranum">27/2</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00230.TXT">AI95-00230-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00416.TXT">AI95-00416-01</A></I>} 
<SPAN class="insert2">For an access discriminant, its</SPAN><SPAN class="delete2">&nbsp;An</SPAN> 
<SPAN Class="swiss"><A HREF="AA-3-10.html#S0084">access_definition</A></SPAN> 
is elaborated when the value of <SPAN class="insert2">the</SPAN><SPAN class="delete2">&nbsp;a 
corresponding</SPAN> access discriminant is defined<SPAN class="insert2">:</SPAN><SPAN class="delete2">, 
either</SPAN> by evaluation of its <SPAN Class="swiss"><A HREF="AA-3-7.html#S0063">default_expression</A></SPAN><SPAN class="insert2">,</SPAN><SPAN class="delete2">&nbsp;or</SPAN> by elaboration of a <SPAN Class="swiss"><A HREF="AA-3-7-1.html#S0064">discriminant_constraint</A></SPAN><SPAN class="insert2">, 
or by an assignment that initializes the enclosing object.</SPAN><SPAN class="delete2">. 
[The elaboration of an <SPAN Class="swiss"><A HREF="AA-3-10.html#S0084">access_definition</A></SPAN> 
creates the anonymous access type. When the expression defining the access 
discriminant is evaluated, it is converted to this anonymous access type 
(see <A HREF="AA-4-6.html">4.6</A>).]</SPAN> <SPAN STYLE="font-size: 80%">{<I>implicit 
subtype conversion (access discriminant)</I> [partial]}</SPAN> <A NAME="I2088"></A></DIV>
<DIV Class="paranum">27.a/2</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00231.TXT">AI95-00231-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00416.TXT">AI95-00416-01</A></I>} 
<SPAN class="insert2">The</SPAN><SPAN class="delete2">&nbsp;This</SPAN> conversion<SPAN class="insert2">&nbsp;of the <SPAN Class="swiss"><A HREF="AA-4-4.html#S0115">expression</A></SPAN> 
defining the access discriminant to the anonymous access type</SPAN> 
raises <SPAN class="insert2">Program_Error</SPAN><SPAN class="delete2">&nbsp;Constraint_Error 
if the initial value is <B>null</B>, or,</SPAN> for an object created 
by an allocator of an access type T, if the initial value is an access 
parameter that designates a view whose accessibility level is deeper 
than that of T.&nbsp;</DIV>
<DIV Class="NotesHeader">NOTES</DIV>
<DIV Class="paranum">28</DIV>
<DIV Class="Notes">52&nbsp;&nbsp;If a discriminated type has <SPAN Class="swiss"><A HREF="AA-3-7.html#S0063">default_expression</A></SPAN>s 
for its discriminants, then unconstrained variables of the type are permitted, 
and the values of the discriminants can be changed by an assignment to 
such a variable. If defaults are not provided for the discriminants, 
then all variables of the type are constrained, either by explicit constraint 
or by their initial value; the values of the discriminants of such a 
variable cannot be changed after initialization.&nbsp;</DIV>
<DIV Class="paranum">28.a</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>This connection between discriminant 
defaults and unconstrained variables can be a source of confusion. For 
Ada 95, we considered various ways to break the connection between defaults 
and unconstrainedness, but ultimately gave up for lack of a sufficiently 
simple and intuitive alternative.</DIV>
<DIV Class="paranum">28.b</DIV>
<DIV Class="Annotations">{<I>mutable</I>} <A NAME="I2089"></A>An unconstrained 
discriminated subtype with defaults is called a <I>mutable</I> subtype, 
and a variable of such a subtype is called a mutable variable, because 
the discriminants of such a variable can change. There are no mutable 
arrays (that is, the bounds of an array object can never change), because 
there is no way in the language to define default values for the bounds. 
Similarly, there are no mutable class-wide subtypes, because there is 
no way to define the default tag, and defaults for discriminants are 
not allowed in the tagged case. Mutable tags would also require a way 
for the maximum possible size of such a class-wide subtype to be known. 
(In some implementations, all mutable variables are allocated with the 
maximum possible size. This approach is appropriate for real-time applications 
where implicit use of the heap is inappropriate.)</DIV>
<DIV Class="paranum">29</DIV>
<DIV Class="Notes">53&nbsp;&nbsp;The <SPAN Class="swiss"><A HREF="AA-3-7.html#S0063">default_expression</A></SPAN> 
for a discriminant of a type is evaluated when an object of an unconstrained 
subtype of the type is created.</DIV>
<DIV Class="paranum">30</DIV>
<DIV Class="Notes">54&nbsp;&nbsp;Assignment to a discriminant of an object 
(after its initialization) is not allowed, since the name of a discriminant 
is a constant; neither <SPAN Class="swiss"><A HREF="AA-5-2.html#S0137">assignment_statement</A></SPAN>s 
nor assignments inherent in passing as an <B>in out</B> or <B>out</B> 
parameter are allowed. Note however that the value of a discriminant 
can be changed by assigning to the enclosing object, presuming it is 
an unconstrained variable.&nbsp;</DIV>
<DIV Class="paranum">30.a/2</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00114.TXT">AI95-00114-01</A></I>} 
An <SPAN Class="swiss"><A HREF="AA-3-7.html#S0060">unknown_discriminant_part</A></SPAN> 
is permitted only in the declaration of a private type (including generic 
formal private), private extension, <SPAN class="insert2">incomplete 
type,&nbsp;</SPAN>or generic formal derived type. These are the things that 
will have a corresponding completion or generic actual, which will either 
define the discriminants, or say there are none. The (&lt;&gt;) indicates 
that the actual/full subtype might be an indefinite subtype. An <SPAN Class="swiss"><A HREF="AA-3-7.html#S0060">unknown_discriminant_part</A></SPAN> 
is not permitted in a normal untagged derived type declaration, because 
there is no separate full type declaration for such a type. Note that 
(&lt;&gt;) allows unconstrained array bounds; those are somewhat like 
undefaulted discriminants.</DIV>
<DIV Class="paranum">30.b</DIV>
<DIV Class="Annotations">For a derived type, either the discriminants 
are inherited as is, or completely respecified in a new <SPAN Class="swiss"><A HREF="AA-3-7.html#S0059">discriminant_part</A></SPAN>. 
In this latter case, each discriminant of the parent type shall be constrained, 
either to a specific value, or to equal one of the new discriminants. 
Constraining a parent type's discriminant to equal one of the new discriminants 
is like a renaming of the discriminant, except that the subtype of the 
new discriminant can be more restrictive than that of the parent's one. 
In any case, the new discriminant can share storage with the parent's 
discriminant.&nbsp;</DIV>
<DIV Class="paranum">31</DIV>
<DIV Class="Notes">55&nbsp;&nbsp;A discriminant that is of a named access 
type is not called an access discriminant; that term is used only for 
discriminants defined by an <SPAN Class="swiss"><A HREF="AA-3-10.html#S0084">access_definition</A></SPAN>. 
</DIV>

<H4 Class="centered">Examples</H4>
<DIV Class="paranum">32</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em"><I>Examples of discriminated 
types:</I>&nbsp;</DIV>
<DIV Class="paranum">33</DIV>
<DIV Class="Examples"><B>type</B>&nbsp;Buffer(Size&nbsp;:&nbsp;Buffer_Size&nbsp;:=&nbsp;100)&nbsp;&nbsp;<B>is</B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;see&nbsp;<A HREF="AA-3-5-4.html">3.5.4</A></I></SPAN><BR>
&nbsp;&nbsp;&nbsp;<B>record</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pos&nbsp;&nbsp;&nbsp;:&nbsp;Buffer_Size&nbsp;:=&nbsp;0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Value&nbsp;:&nbsp;String(1&nbsp;..&nbsp;Size);<BR>
&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;<B>record</B>;</DIV>
<DIV Class="paranum">34</DIV>
<DIV Class="Examples"><B>type</B>&nbsp;Matrix_Rec(Rows,&nbsp;Columns&nbsp;:&nbsp;Integer)&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>record</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mat&nbsp;:&nbsp;Matrix(1&nbsp;..&nbsp;Rows,&nbsp;1&nbsp;..&nbsp;Columns);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;see&nbsp;<A HREF="AA-3-6.html">3.6</A></I></SPAN><BR>
&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;<B>record</B>;</DIV>
<DIV Class="paranum">35</DIV>
<DIV Class="Examples"><B>type</B>&nbsp;Square(Side&nbsp;:&nbsp;Integer)&nbsp;<B>is</B>&nbsp;<B>new</B><BR>
&nbsp;&nbsp;&nbsp;Matrix_Rec(Rows&nbsp;=&gt;&nbsp;Side,&nbsp;Columns&nbsp;=&gt;&nbsp;Side);</DIV>
<DIV Class="paranum">36</DIV>
<DIV Class="Examples"><B>type</B>&nbsp;Double_Square(Number&nbsp;:&nbsp;Integer)&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>record</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Left&nbsp;&nbsp;:&nbsp;Square(Number);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Right&nbsp;:&nbsp;Square(Number);<BR>
&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;<B>record</B>;</DIV>
<DIV Class="paranum">37/2</DIV>
<DIV Class="Examples">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00433.TXT">AI95-00433-01</A></I>} 
<SPAN class="insert2"><B>task&nbsp;type</B>&nbsp;Worker(Prio&nbsp;:&nbsp;System.Priority;&nbsp;Buf&nbsp;:&nbsp;<B>access</B>&nbsp;Buffer)&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;discriminants&nbsp;used&nbsp;to&nbsp;parameterize&nbsp;the&nbsp;task&nbsp;type&nbsp;(see&nbsp;<A HREF="AA-9-1.html">9.1</A>)</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;<B>pragma</B>&nbsp;Priority(Prio);&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;see&nbsp;<A HREF="AA-D-1.html">D.1</A></I></SPAN><BR>
&nbsp;&nbsp;&nbsp;<B>entry</B>&nbsp;Fill;<BR>
&nbsp;&nbsp;&nbsp;<B>entry</B>&nbsp;Drain;<BR>
<B>end</B>&nbsp;Worker;</SPAN><SPAN class="delete2"><B>&nbsp;type</B>&nbsp;Item(Number&nbsp;:&nbsp;Positive)&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>record</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Content&nbsp;:&nbsp;Integer;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;&nbsp;no&nbsp;component&nbsp;depends&nbsp;on&nbsp;the&nbsp;discriminant</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;<B>record</B>;</SPAN></DIV>

<H4 Class="centered">Extensions to Ada 83</H4>
<DIV Class="paranum">37.a</DIV>
<DIV Class="Annotations">{<I>extensions to Ada 83</I>} <A NAME="I2090"></A>The 
syntax for a <SPAN Class="swiss"><A HREF="AA-3-7.html#S0062">discriminant_specification</A></SPAN> 
is modified to allow an <I>access discriminant</I>, with a type specified 
by an <SPAN Class="swiss"><A HREF="AA-3-10.html#S0084">access_definition</A></SPAN> 
(see <A HREF="AA-3-10.html">3.10</A>).</DIV>
<DIV Class="paranum">37.b/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
Discriminants are allowed on all composite types other than array<SPAN class="insert2">&nbsp;and interface</SPAN> types.</DIV>
<DIV Class="paranum">37.c</DIV>
<DIV Class="Annotations">Discriminants may be of an access type.&nbsp;</DIV>

<H4 Class="centered">Wording Changes from Ada 83</H4>
<DIV Class="paranum">37.d</DIV>
<DIV Class="Annotations"><SPAN Class="swiss"><A HREF="AA-3-7.html#S0059">Discriminant_part</A></SPAN>s 
are not elaborated, though an <SPAN Class="swiss"><A HREF="AA-3-10.html#S0084">access_definition</A></SPAN> 
is elaborated when the discriminant is initialized.</DIV>

<H4 Class="centered">Extensions to Ada 95</H4>
<DIV Class="paranum">37.e/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00230.TXT">AI95-00230-01</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00402.TXT">AI95-00402-01</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00416.TXT">AI95-00416-01</A></I>} 
<SPAN class="insert2">Access discriminants (anonymous access types used 
as a discriminant) can be used on any type allowing discriminants. Defaults 
aren't allowed on discriminants of non-limited types, however, so that 
accessibility problems don't happen on assignment.</SPAN></DIV>
<DIV Class="paranum">37.f/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00231.TXT">AI95-00231-01</A></I>} 
<SPAN class="insert2"><SPAN Class="swiss"><A HREF="AA-3-10.html#S0083">null_exclusion</A></SPAN> 
can be used in the declaration of a discriminant.</SPAN>&nbsp;</DIV>

<H4 Class="centered">Wording Changes from Ada 95</H4>
<DIV Class="paranum">37.g/2</DIV>
<DIV Class="Annotations">{<I><A HREF="defect1.html#8652/0007">8652/0007</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00098.TXT">AI95-00098-01</A></I>} 
<SPAN class="insert2"><B>Corrigendum:</B> The wording was clarified so 
that types that cannot have discriminants cannot have an <SPAN Class="swiss"><A HREF="AA-3-7.html#S0060">unknown_discriminant_part</A></SPAN>.</SPAN></DIV>
<DIV Class="paranum">37.h/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
<SPAN class="insert2">Added wording to prevent interfaces from having 
discriminants. We don't want interfaces to have any components.</SPAN></DIV>
<DIV Class="paranum">37.i/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00254.TXT">AI95-00254-01</A></I>} 
<SPAN class="insert2">Removed wording which implied or required an access 
discriminant to have an access-to-object type (anonymous access types 
can now be access-to-subprogram types as well).</SPAN></DIV>
<DIV Class="paranum">37.j/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00326.TXT">AI95-00326-01</A></I>} 
<SPAN class="insert2">Fixed the wording of the introduction to this clause 
to reflect that both incomplete and partial views can have unknown discriminants. 
That was always true, but for some reason this wording specified partial 
views.</SPAN></DIV>
<DIV Class="paranum">37.k/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00419.TXT">AI95-00419-01</A></I>} 
<SPAN class="insert2">Changed the wording to use the new term &ldquo;explicitly 
limited record&rdquo;, which makes the intent much clearer (and eliminates 
confusion with derived types that happen to contain the reserved word 
<B>limited</B>.</SPAN>&nbsp;</DIV>

<HR>
<DIV Style="margin-top: 0.0em; margin-bottom: 0.6em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-3-6-3.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-3-7-1.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<DIV Style="margin-top:0.0em"><IMG SRC="AE_logo.gif" height=100 width=113 align=right ALT="Ada-Europe">
<SPAN Style="font-size: 125%">Sponsored by <SPAN Style="font-size: 125%"><A HREF="http://www.ada-europe.org/"><B>Ada-Europe</B></A></SPAN></SPAN></DIV>
</BODY>
</HTML>
