<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML><HEAD>
<TITLE>Ada 83 LRM, Sec 3.3: Types and Subtypes</TITLE>
</HEAD><BODY>
<hr><a href="ada_lrm.html"><IMG SRC="adass.gif" align=LEFT hspace=6 vspace=6 alt="Lady Ada"></a><H1>Ada '83 Language Reference Manual</H1>
<h6><a href="ada_legal.html">Copyright</a> 1980, 1982, 1983 owned by the United States Government. Direct reproduction and usage requests to the <a href="mailto://adainfo@sw-eng.falls-church.va.us">Ada Information Clearinghouse</a>.</h6>
<br clear=LEFT>
<hr>

<H2><A NAME="3.3">3.3</A>.  Types and Subtypes  </H2>
<A HREF="lrm-03-02.html#3.2"><img src="lrm-prev.gif" alt="[PREVIOUS]"></A><A HREF="lrm-03.html#3"><img src="lrm-up.gif" alt="[UP]"></A><A HREF="lrm-03-04.html#3.4"><img src="lrm-next.gif" alt="[NEXT]"></A>
<P>
A type is characterized by a set of values and a set of operations. 
<P>
There exist several classes of types.  Scalar types are integer types, real
types,  and  types defined by enumeration of their values;  values of these
types have no components.   Array and record types are composite;  a  value
of a composite type consists of component values.  An access type is a type
whose  values provide access to objects.  Private types are types for which
the set of possible values is well defined, but not directly  available  to
the  users  of  such types.  Finally, there are task types.  (Private types
are described in <a href="lrm-07.html#7">chapter 7</a>, task types are  described  in  <a href="lrm-09.html#9">chapter  9</a>,  the
other classes of types are described in this chapter.) 
<P>
Certain   record   and   private   types  have  special  components  called
discriminants whose values distinguish alternative forms of values  of  one
of  these  types.   If  a private type has discriminants, they are known to
users of the type.  Hence a private type is only known  by  its  name,  its
discriminants if any, and by the corresponding set of operations. 
<P>
The  set  of possible values for an object of a given type can be subjected
to a condition that is called a constraint (the case where  the  constraint
imposes  no  restriction  is  also included);  a value is said to satisfy a
constraint if it satisfies the corresponding condition.   A  subtype  is  a
type together with a constraint;  a value is said to belong to a subtype of
a  given  type if it belongs to the type and satisfies the constraint;  the  
given type is called the base type of the subtype.  A type is a subtype  of
itself;   such  a subtype is said to be unconstrained:  it corresponds to a
condition that imposes no restriction.  The base type of a type is the type
itself. 
<P>
The set of operations defined for a subtype of a given  type  includes  the
operations that are defined for the type;  however the assignment operation
to a variable having a given subtype only assigns values that belong to the
subtype.   Additional  operations,  such  as  qualification (in a qualified
expression), are implicitly defined by a subtype declaration. 
<P>
Certain types have default initial values defined for objects of the  type;
certain  other  types  have  default expressions defined for some or all of
their components.  Certain operations of  types  and  subtypes  are  called
attributes;   these operations are denoted by the form of name described in
<a href="lrm-04-01.html#4.1.4">section 4.1.4</a>. 
<P>
The term subcomponent is used in this manual in place of the term component
to indicate either a component, or a  component  of  another  component  or
subcomponent.   Where  other subcomponents are excluded, the term component
is used instead. 
<P>
A given type must not have a subcomponent whose  type  is  the  given  type
itself. 
<P>
The  name  of  a  class  of types is used in this manual as a qualifier for
objects and values that have a type of the class considered.  For  example,
the  term "array object" is used for an object whose type is an array type;  
similarly, the term "access value" is used for a value of an  access  type.
<P>
Note: 
<P>
The  set of values of a subtype is a subset of the values of the base type.
This subset need not be a proper subset;  it can be an empty subset. 
<P>
<b>References:</b>  <A HREF="lrm-03-08.html#3.8">access type</A>,
<A HREF="lrm-03-06.html#3.6">array type</A>,
<A HREF="lrm-05-02.html#5.2">assignment</A>,
<A HREF="lrm-04-01.html#4.1.4">attribute</A>,
<A HREF="lrm-03-06.html#3.6">component  of an array</A>,
<A HREF="lrm-03-07.html#3.7">component of a record</A>,
<A HREF="lrm-03-07.html#3.7.2">discriminant constraint</A>,
<A HREF="lrm-03-05.html#3.5.1">enumeration type</A>,
<A HREF="lrm-03-05.html#3.5.4">integer type</A>,
<A HREF="lrm-03-02.html#3.2.1">object</A>,
<A HREF="lrm-07-04.html#7.4">private type</A>,
<A HREF="lrm-04-07.html#4.7">qualified expression</A>,
<A HREF="lrm-03-05.html#3.5.6">real type</A>,
<A HREF="lrm-03-07.html#3.7">record  type</A>,
<A HREF="#3.3.2">subtype declaration</A>,
<A HREF="lrm-09-01.html#9.1">task type</A>,
<A HREF="#3.3.1">type declaration</A>.
<P>
<b>Rationale references:</b> 
<a href="http://archive.adaic.com/standards/83rat/html/ratl-04-01.html#4.1">4.1&nbsp;Introduction</a>,
<a href="http://archive.adaic.com/standards/83rat/html/ratl-04-02.html#4.2">4.2&nbsp;The Concept of Type</a>,
<a href="http://archive.adaic.com/standards/83rat/html/ratl-04-03.html#4.3">4.3&nbsp;Type Equivalence</a>,
<a href="http://archive.adaic.com/standards/83rat/html/ratl-04-04.html#4.4">4.4&nbsp;Constraints and Subtypes</a>
<p>
<b>Style Guide references:</b> 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-03-02.html#3.2.2">3.2.2&nbsp;Type Names</a>, 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-03-04.html#3.4.1">3.4.1&nbsp;Declaring Types</a>, 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-04-01.html#4.1.5">4.1.5&nbsp;Cohesion</a>, 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-07-02.html#7.2.7">7.2.7&nbsp;Subexpression Evaluation</a>, 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-08-02.html#8.2.3">8.2.3&nbsp;Assumptions</a>, 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-09-01.html#9.1.5">9.1.5&nbsp;Constraint Checking</a>
<p>
<b>Sub-topics:</b>
<ul>
<li><A HREF="#3.3.1">3.3.1</A> Type Declarations  
<li><A HREF="#3.3.2">3.3.2</A> Subtype Declarations  
<li><A HREF="#3.3.3">3.3.3</A> Classification of Operations  
</ul>
<H3><A NAME="3.3.1">3.3.1</A>.  Type Declarations  </H3>
<A HREF="#3.3"><img src="lrm-up.gif" alt="[UP]"></A><A HREF="#3.3.2"><img src="lrm-next.gif" alt="[NEXT]"></A>
<P>
A type declaration declares a type. 
<pre>
    type_declaration ::=  full_type_declaration
       | incomplete_type_declaration | private_type_declaration 

    full_type_declaration ::=
         type identifier [discriminant_part] is type_definition; 

    type_definition ::=
         enumeration_type_definition | integer_type_definition
       | real_type_definition        | array_type_definition
       | record_type_definition      | access_type_definition
       | derived_type_definition 
</pre>
<P>
The  elaboration  of a full type declaration consists of the elaboration of
the discriminant part, if  any  (except  in  the  case  of  the  full  type
declaration  for  an  incomplete  or  private type declaration), and of the
elaboration of the type definition. 
<P>
The types created by the  elaboration  of  distinct  type  definitions  are
distinct  types.   Moreover,  the  elaboration of the type definition for a
numeric or derived type creates both a base type and a subtype of the  base
type;   the  same  holds for a constrained array definition (one of the two
forms of array type definition). 
<P>
The simple name declared by a full type declaration  denotes  the  declared
type,  unless  the type declaration declares both a base type and a subtype
of the base type, in which case the simple name denotes  the  subtype,  and 
the  base  type  is anonymous.  A type is said to be anonymous if it has no
simple name.  For explanatory purposes,  this  reference  manual  sometimes
refers  to an anonymous type by a pseudo-name, written in italics, and uses
such  pseudo-names  at  places  where  the  syntax  normally  requires   an
identifier. 
<P>
Examples of type definitions: 
<pre>
    (WHITE, RED, YELLOW, GREEN, BLUE, BROWN, BLACK)
    range1 .. 72
    array(1 .. 10) of INTEGER 
</pre>
<P>
Examples of type declarations: 
<pre>
    type COLOR  is (WHITE, RED, YELLOW, GREEN, BLUE, BROWN, BLACK);
    type COLUMN is range 1 .. 72;
    type TABLE  is array(1 .. 10) of INTEGER; 
</pre>
<P>
Notes: 
<P>
Two  type  definitions  always  define two distinct types, even if they are
textually identical.   Thus,  the  array  type  definitions  given  in  the
declarations of A and B below define distinct types.   
<pre>
    A : array(1 .. 10) of BOOLEAN;
    B : array(1 .. 10) of BOOLEAN; 
</pre>
<P>
If  A  and  B are declared by a multiple object declaration as below, their
types are nevertheless different, since the multiple object declaration  is
equivalent to the above two single object declarations. 
<pre>
    A, B : array(1 .. 10) of BOOLEAN;                                                 
</pre>
<P>
Incomplete  type  declarations are used for the definition of recursive and
mutually dependent types (see <a href="lrm-03-08.html#3.8.1">3.8.1</a>).  Private type declarations  are  used
in  package  specifications  and in generic parameter declarations (see <a href="lrm-07-04.html#7.4">7.4</a>
and <a href="lrm-12-01.html#12.1">12.1</a>). 
<P>
<b>References:</b>  <A HREF="lrm-03-08.html#3.8">access type definition</A>,
<A HREF="lrm-03-06.html#3.6">array type  definition</A>,
<A HREF="#3.3">base type</A>,
<A HREF="lrm-03-06.html#3.6">constrained  array  definition</A>,
<A HREF="#3.3">constrained  subtype</A>,
<A HREF="lrm-03-01.html#3.1">declaration</A>,
<A HREF="lrm-03-04.html#3.4">derived  type</A>,
<A HREF="lrm-03-04.html#3.4">derived   type   definition</A>,
<A HREF="lrm-03-07.html#3.7.1">discriminant  part</A>,
<A HREF="lrm-03-09.html#3.9">elaboration</A>,
<A HREF="lrm-03-05.html#3.5.1">enumeration  type definition</A>,
<A HREF="lrm-02-03.html#2.3">identifier</A>,
<A HREF="lrm-03-08.html#3.8.1">incomplete  type  declaration</A>,
<A HREF="lrm-03-05.html#3.5.4">integer  type definition</A>,
<A HREF="lrm-03-02.html#3.2">multiple  object  declaration</A>,
<A HREF="lrm-03-05.html#3.5">numeric  type</A>,
<A HREF="lrm-07-04.html#7.4">private type declaration</A>,
<A HREF="lrm-03-05.html#3.5.6">real type  definition</A>,
<A HREF="lrm-02-09.html#2.9">reserved  word</A>,
<A HREF="#3.3">type</A>.
<P>
<b>Style Guide references:</b> 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-03-03.html#3.3.5">3.3.5&nbsp;Data Comments</a>

<H3><A NAME="3.3.2">3.3.2</A>.  Subtype Declarations  </H3>
<A HREF="#3.3.1"><img src="lrm-prev.gif" alt="[PREVIOUS]"></A><A HREF="#3.3"><img src="lrm-up.gif" alt="[UP]"></A><A HREF="#3.3.3"><img src="lrm-next.gif" alt="[NEXT]"></A>
<P>
A subtype declaration declares a subtype. 
<pre>
    subtype_declaration ::=
       subtype identifier is subtype_indication; 

    subtype_indication ::=  type_mark [constraint] 

    type_mark ::= type_name | subtype_name 

    constraint ::=
         range_constraint | floating_point_constraint | fixed_point_constraint
       | index_constraint | discriminant_constraint 
</pre>
<P>
A  type  mark denotes a type or a subtype.  If a type mark is the name of a
type,  the  type  mark  denotes  this  type  and  also  the   corresponding
unconstrained subtype.  The base type of a type mark is, by definition, the
base type of the type or subtype denoted by the type mark. 
<P>
A  subtype  indication defines a subtype of the base type of the type mark. 
If an index constraint appears after a type mark in a  subtype  indication,
the  type mark must not already impose an index constraint.  Likewise for a
discriminant  constraint,  the  type  mark  must  not  already   impose   a
discriminant constraint. 
<P>
The elaboration of a subtype declaration consists of the elaboration of the
subtype  indication.   The  elaboration  of  a subtype indication creates a
subtype.  If the subtype indication does  not  include  a  constraint,  the
subtype is the same as that denoted by the type mark.  The elaboration of a
subtype indication that includes a constraint proceeds as follows: 
<ol>
<li>The constraint is first elaborated. 
<li>A check is then made that the constraint is compatible with  the  type  
or subtype denoted by the type mark.   
</ol>
The  condition  imposed  by  a  constraint  is the condition obtained after
elaboration of the constraint.  (The rules of  constraint  elaboration  are
such  that  the expressions and  ranges of constraints are evaluated by the
elaboration of these constraints.)  The rules  defining  compatibility  are
given  for each form of constraint in the appropriate section.  These rules
are such that if a constraint  is  compatible  with  a  subtype,  then  the
condition imposed by the constraint cannot contradict any condition already
imposed  by  the  subtype on its values.  The exception CONSTRAINT_ERROR is
raised if any check of compatibility fails.                                                
<P>
Examples of subtype declarations:  
<pre>
    subtype RAINBOW   is COLOR range RED .. BLUE;        --  see <a href="lrm-03-03.html#3.3.1">3.3.1</a>
    subtype RED_BLUE  is RAINBOW;
    subtype INT       is INTEGER;
    subtype SMALL_INT is INTEGER range -10 .. 10;
    subtype UP_TO_K   is COLUMN range 1 .. K;            --  see <a href="lrm-03-03.html#3.3.1">3.3.1</a>
    subtype SQUARE    is MATRIX(1 .. 10, 1 .. 10);       --  see <a href="lrm-03-06.html#3.6">3.6</a>
    subtype MALE      is PERSON(SEX =&gt; M);               --  see <a href="lrm-03-08.html#3.8">3.8</a>
</pre>
<P>
Note: 
<P>
A subtype declaration does not define a new type. 
<P>
<b>References:</b>  <A HREF="#3.3">base  type</A>,
<A HREF="lrm-03-07.html#3.7.2">compatibility  of  discriminant  constraints</A>,
<A HREF="lrm-03-05.html#3.5.9">compatibility  of  fixed  point constraints</A>,
<A HREF="lrm-03-05.html#3.5.7">compatibility of floating point constraints</A>,
<A HREF="lrm-03-06.html#3.6.1">compatibility of index constraints</A>,
<A HREF="lrm-03-05.html#3.5">compatibility of range constraints</A>,
<A HREF="lrm-11-01.html#11.1">constraint_error  exception</A>,
<A HREF="lrm-03-01.html#3.1">declaration</A>,
<A HREF="#3.3">discriminant</A>,
<A HREF="lrm-03-07.html#3.7.2">discriminant  constraint</A>,
<A HREF="lrm-03-09.html#3.9">elaboration</A>,
<A HREF="lrm-04-05.html#4.5">evaluation</A>,
<A HREF="lrm-04-04.html#4.4">expression</A>,
<A HREF="lrm-03-05.html#3.5.7">floating point  constraint</A>,
<A HREF="lrm-03-05.html#3.5.9">fixed  point  constraint</A>,
<A HREF="lrm-03-06.html#3.6.1">index  constraint</A>,
<A HREF="lrm-03-05.html#3.5">range constraint</A>,
<A HREF="lrm-02-09.html#2.9">reserved word</A>,
<A HREF="#3.3">subtype</A>,
<A HREF="#3.3">type</A>,
<A HREF="#3.3.1">type name</A>,
<A HREF="#3.3">unconstrained subtype</A>.
<P>
<b>Style Guide references:</b> 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-05-03.html#5.3.1">5.3.1&nbsp;Derived Types and Subtypes</a>, 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-05-05.html#5.5.1">5.5.1&nbsp;Range Values</a>, 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-05-06.html#5.6.3">5.6.3&nbsp;Case Statements</a>, 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-05-07.html#5.7.2">5.7.2&nbsp;The Renames Clause</a>, 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-07-02.html#7.2.7">7.2.7&nbsp;Subexpression Evaluation</a>, 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-09-01.html#9.1.5">9.1.5&nbsp;Constraint Checking</a>

<H3><A NAME="3.3.3">3.3.3</A>.  Classification of Operations  </H3>
<A HREF="#3.3.2"><img src="lrm-prev.gif" alt="[PREVIOUS]"></A><A HREF="#3.3"><img src="lrm-up.gif" alt="[UP]"></A>
<P>
The   set  of  operations  of  a  type  includes  the  explicitly  declared
subprograms that have a parameter or result of the type;  such  subprograms
are necessarily declared after the type declaration. 
<P>
The  remaining  operations  are  each  implicitly declared for a given type
declaration, immediately  after  the  type  definition.   These  implicitly
declared operations comprise the basic operations, the predefined operators
(see  <a href="lrm-04-05.html#4.5">4.5</a>),  and  enumeration  literals.   In  the  case  of a derived type
declaration,  the  implicitly  declared  operations  include  any   derived
subprograms.    The   operations  implicitly  declared  for  a  given  type
declaration occur after the type declaration and before the  next  explicit
declaration,  if  any.   The  implicit  declarations of derived subprograms
occur last. 
<P>
A basic operation is an operation that is inherent in one of the following: 
<ul>
<li>An assignment  (in  assignment  statements  and  initializations),  an
allocator, a membership test, or a short-circuit control form.
<br><br>
<li>A selected component, an indexed component, or a slice. 
<br><br>
<li>A  qualification  (in  qualified  expressions),   an   explicit   type
conversion,  or  an  implicit  type  conversion  of  a  value  of type
universal_integer or universal_real  to  the  corresponding  value  of
another numeric type.  
<br><br>
<li>A numeric literal (for a universal type), the  literal  null  (for  an
access type), a string literal, an aggregate, or an attribute. 
</ul>
<P>
For every type or subtype T, the following attribute is defined: 
<ul>
<li> T'BASE     
The base type of T.  This  attribute  is  allowed  only  as  the
prefix   of   the  name  of  another  attribute:   for  example,
T'BASE'FIRST.                                                 
</ul>
<P>
Note: 
<P>
Each literal is an operation  whose  evaluation  yields  the  corresponding
value  (see  <a href="lrm-04-02.html#4.2">4.2</a>).  Likewise, an aggregate is an operation whose evaluation
yields a value of a composite type (see <a href="lrm-04-03.html#4.3">4.3</a>).  Some operations  of  a  type
operate  on  values  of  the  type,  for  example, predefined operators and
certain subprograms and attributes.  The evaluation of some operations of a
type returns a value  of  the  type,  for  example,  literals  and  certain
functions,   attributes,   and  predefined  operators.   Assignment  is  an
operation that operates on an object and a value.  The  evaluation  of  the
operation corresponding to a selected component, an indexed component, or a
slice, yields the object or value denoted by this form of name.  
<P>
<b>References:</b>  <A HREF="lrm-04-03.html#4.3">aggregate</A>,
<A HREF="lrm-04-08.html#4.8">allocator</A>,
<A HREF="lrm-05-02.html#5.2">assignment</A>,
<A HREF="lrm-04-01.html#4.1.4">attribute</A>,
<A HREF="lrm-02-05.html#2.5">character   literal</A>,
<A HREF="#3.3">composite  type</A>,
<A HREF="lrm-04-06.html#4.6">conversion</A>,
<A HREF="lrm-03-04.html#3.4">derived subprogram</A>,
<A HREF="lrm-03-05.html#3.5.1">enumeration literal</A>,
<A HREF="lrm-06-01.html#6.1">formal parameter</A>,
<A HREF="lrm-06-05.html#6.5">function</A>,
<A HREF="lrm-04-01.html#4.1.1">indexed component</A>,
<A HREF="lrm-03-02.html#3.2.1">initial value</A>,
<A HREF="lrm-04-02.html#4.2">literal</A>,
<A HREF="lrm-04-05.html#4.5">membership test</A>,
 and <A HREF="lrm-04-05.html#4.5.2">4.5.2</A>,
<A HREF="lrm-03-08.html#3.8">null literal</A>,
<A HREF="lrm-02-04.html#2.4">numeric literal</A>,
<A HREF="lrm-03-05.html#3.5">numeric  type</A>,
<A HREF="lrm-03-02.html#3.2.1">object</A>,
 and <A HREF="lrm-06-01.html#6.1">6.1</A>,
<A HREF="lrm-04-05.html#4.5">predefined  operator</A>,
<A HREF="lrm-04-07.html#4.7">qualified expression</A>,
<A HREF="lrm-04-01.html#4.1.3">selected component</A>,
<A HREF="lrm-04-05.html#4.5">short-circuit  control  form</A>,
 and <A HREF="lrm-04-05.html#4.5.1">4.5.1</A>,
<A HREF="lrm-04-01.html#4.1.2">slice</A>,
<A HREF="lrm-02-06.html#2.6">string  literal</A>,
<A HREF="lrm-06.html#6">subprogram</A>,
<A HREF="#3.3">subtype</A>,
<A HREF="#3.3">type</A>,
<A HREF="#3.3.1">type declaration</A>,
<A HREF="lrm-03-05.html#3.5.4">universal_integer type</A>,
<A HREF="lrm-03-05.html#3.5.6">universal_real type</A>,
<A HREF="lrm-04-01.html#4.1">universal type</A>,
 and <A HREF="lrm-04.html#4">4</A>.
<P>


<A HREF="lrm-IDX.html"><img src="lrm-idx.gif" alt="[INDEX]"></A><A HREF="lrm-TOC.html"><img src="lrm-toc.gif" alt="[CONTENTS]"></A>

<hr>
<address><a href="htttp://www.adaic.com/"><IMG SRC="small_adaic_logo.gif" ALT="[Ada Information Clearinghouse]"></a><p>
Address any questions or comments to
<A HREF="mailto://adainfo@sw-eng.falls-church.va.us">adainfo@sw-eng.falls-church.va.us</A>.</address>
</BODY></HTML>
