<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Shared Variable Control</TITLE>
    <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    H4.centered {text-align: center}
    SPAN.swiss {font-family: Arial, Helvetica, sans-serif; font-size: 92%}
    SPAN.roman {font-family: "Times New Roman", Times, serif}
    DIV.paranum {float: left; font-family: Arial, Helvetica, sans-serif; font-size: 64%; width: 2.8em; margin-left: -0.4em; margin-right: -3.0em; margin-top: 0.2em}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    SPAN.insert2 {text-decoration: underline; color: rgb(0,102,0) }
    SPAN.delete2 {text-decoration: line-through; color: rgb(0,102,0) }
    DIV.Normal {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.2em; margin-bottom: 0.6em}
    DIV.Annotations {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 6.2em; margin-bottom: 0.6em}
    DIV.Notes {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em; margin-bottom: 0.6em}
    DIV.NotesHeader {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em}
    DIV.SyntaxIndented {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-bottom: 0.4em}
    UL.SmallBulleted {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 8.7em; margin-right: 2.5em; margin-top: 0em; margin-bottom: 0.5em}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#000080" VLINK="#330033" ALINK="#0000FF">
<DIV><B><SPAN Style="font-size:200%; color: rgb(0,51,153)">Annotated</SPAN><SPAN Style="font-size:200%; color: rgb(0,0,102)">&nbsp;Ada Reference Manual</SPAN></B> &mdash; <A HREF="AA-TTL.html"><B>Legal Information</B></A></DIV>
<DIV Style="margin-top: 0.6em; margin-bottom: 0.0em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-C-5.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-C-7.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<HR>
<H1>C.6 Shared Variable Control</H1>
<DIV Class="paranum">1</DIV>
<DIV Class="Normal">[This clause specifies representation pragmas that 
control the use of shared variables.]&nbsp;</DIV>

<H4 Class="centered">Syntax</H4>
<DIV Class="paranum">2</DIV>
<DIV Class="SyntaxIndented" Style="margin-bottom: 0.2em">The form for 
pragmas Atomic, Volatile, Atomic_Components, and Volatile_Components 
is as follows:&nbsp;</DIV>
<DIV Class="paranum">3</DIV>
<DIV Class="SyntaxIndented">&nbsp;&nbsp;<B>pragma</B> <A NAME="I7322"></A><A NAME="I7323"></A>Atomic(<A NAME="I7324"></A><SPAN Class="swiss"><A HREF="AA-13-1.html#S0285">local_name</A></SPAN>);</DIV>
<DIV Class="paranum">4</DIV>
<DIV Class="SyntaxIndented">&nbsp;&nbsp;<B>pragma</B> <A NAME="I7325"></A><A NAME="I7326"></A>Volatile(<A NAME="I7327"></A><SPAN Class="swiss"><A HREF="AA-13-1.html#S0285">local_name</A></SPAN>);</DIV>
<DIV Class="paranum">5</DIV>
<DIV Class="SyntaxIndented">&nbsp;&nbsp;<B>pragma</B> <A NAME="I7328"></A><A NAME="I7329"></A>Atomic_Components(<I>array_</I><A NAME="I7330"></A><SPAN Class="swiss"><A HREF="AA-13-1.html#S0285">local_name</A></SPAN>);</DIV>
<DIV Class="paranum">6</DIV>
<DIV Class="SyntaxIndented">&nbsp;&nbsp;<B>pragma</B> <A NAME="I7331"></A><A NAME="I7332"></A>Volatile_Components(<I>array_</I><A NAME="I7333"></A><SPAN Class="swiss"><A HREF="AA-13-1.html#S0285">local_name</A></SPAN>);</DIV>
<DIV Class="paranum">7/2</DIV>
<DIV Class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00272.TXT">AI95-00272-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>atomic</I>}</SPAN> <A NAME="I7334"></A>An 
<I>atomic</I> type is one to which a pragma Atomic applies. An <I>atomic</I> 
object (including a component) is one to which a pragma Atomic applies, 
or a component of an array to which a pragma Atomic_Components applies, 
or any object of an atomic type<SPAN class="insert2">, other than objects 
obtained by evaluating a slice</SPAN>.</DIV>
<DIV Class="paranum">7.a/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Ramification:&nbsp;</B></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00272.TXT">AI95-00272-01</A></I>} 
<SPAN class="insert2">A slice of an atomic array object is not itself 
atomic. That's necessary as executing a read or write of a dynamic number 
of components in a single instruction is not possible on many targets.</SPAN> 
</DIV>
<DIV Class="paranum">8</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>volatile</I>}</SPAN> 
<A NAME="I7335"></A>A <I>volatile</I> type is one to which a pragma Volatile 
applies. A <I>volatile</I> object (including a component) is one to which 
a pragma Volatile applies, or a component of an array to which a pragma 
Volatile_Components applies, or any object of a volatile type. In addition, 
every atomic type or object is also defined to be volatile. Finally, 
if an object is volatile, then so are all of its subcomponents [(the 
same does not apply to atomic)].&nbsp;</DIV>

<H4 Class="centered">Name Resolution Rules</H4>
<DIV Class="paranum">9</DIV>
<DIV Class="Normal">The <SPAN Class="swiss"><A HREF="AA-13-1.html#S0285">local_name</A></SPAN> 
in an Atomic or Volatile pragma shall resolve to denote either an <SPAN Class="swiss"><A HREF="AA-3-3-1.html#S0032">object_declaration</A></SPAN>, 
a non-inherited <SPAN Class="swiss"><A HREF="AA-3-8.html#S0070">component_declaration</A></SPAN>, 
or a <SPAN Class="swiss"><A HREF="AA-3-2-1.html#S0024">full_type_declaration</A></SPAN>. 
The <I>array_</I><SPAN Class="swiss"><A HREF="AA-13-1.html#S0285">local_name</A></SPAN> 
in an Atomic_Components or Volatile_Components pragma shall resolve to 
denote the declaration of an array type or an array object of an anonymous 
type.</DIV>

<H4 Class="centered">Legality Rules</H4>
<DIV Class="paranum">10</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>indivisible</I>}</SPAN> 
<A NAME="I7336"></A>It is illegal to apply either an Atomic or Atomic_Components 
pragma to an object or type if the implementation cannot support the 
indivisible reads and updates required by the pragma (see below).</DIV>
<DIV Class="paranum">11</DIV>
<DIV Class="Normal">It is illegal to specify the Size attribute of an 
atomic object, the Component_Size attribute for an array type with atomic 
components, or the layout attributes of an atomic component, in a way 
that prevents the implementation from performing the required indivisible 
reads and updates.</DIV>
<DIV Class="paranum">12</DIV>
<DIV Class="Normal">If an atomic object is passed as a parameter, then 
the type of the formal parameter shall either be atomic or allow pass 
by copy [(that is, not be a nonatomic by-reference type)]. If an atomic 
object is used as an actual for a generic formal object of mode <B>in 
out</B>, then the type of the generic formal object shall be atomic. 
If the <SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN> 
of an <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0100">attribute_reference</A></SPAN> 
for an Access attribute denotes an atomic object [(including a component)], 
then the designated type of the resulting access type shall be atomic. 
If an atomic type is used as an actual for a generic formal derived type, 
then the ancestor of the formal type shall be atomic or allow pass by 
copy. Corresponding rules apply to volatile objects and types.</DIV>
<DIV Class="paranum">13</DIV>
<DIV Class="Normal">If a pragma Volatile, Volatile_Components, Atomic, 
or Atomic_Components applies to a stand-alone constant object, then a 
pragma Import shall also apply to it.&nbsp;</DIV>
<DIV Class="paranum">13.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>Hence, no initialization 
expression is allowed for such a constant. Note that a constant that 
is atomic or volatile because of its type is allowed.&nbsp;</DIV>
<DIV Class="paranum">13.b</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>Stand-alone constants that are 
explicitly specified as Atomic or Volatile only make sense if they are 
being manipulated outside the Ada program. From the Ada perspective the 
object is read-only. Nevertheless, if imported and atomic or volatile, 
the implementation should presume it might be altered externally. For 
an imported stand-alone constant that is not atomic or volatile, the 
implementation can assume that it will not be altered.&nbsp;</DIV>

<H4 Class="centered">Static Semantics</H4>
<DIV Class="paranum">14</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>representation pragma 
(Atomic)</I> [partial]}</SPAN> <A NAME="I7337"></A><SPAN STYLE="font-size: 80%">{<I>pragma, 
representation (Atomic)</I> [partial]}</SPAN> <A NAME="I7338"></A><SPAN STYLE="font-size: 80%">{<I>representation 
pragma (Volatile)</I> [partial]}</SPAN> <A NAME="I7339"></A><SPAN STYLE="font-size: 80%">{<I>pragma, 
representation (Volatile)</I> [partial]}</SPAN> <A NAME="I7340"></A><SPAN STYLE="font-size: 80%">{<I>representation 
pragma (Atomic_Components)</I> [partial]}</SPAN> <A NAME="I7341"></A><SPAN STYLE="font-size: 80%">{<I>pragma, 
representation (Atomic_Components)</I> [partial]}</SPAN> <A NAME="I7342"></A><SPAN STYLE="font-size: 80%">{<I>representation 
pragma (Volatile_Components)</I> [partial]}</SPAN> <A NAME="I7343"></A><SPAN STYLE="font-size: 80%">{<I>pragma, 
representation (Volatile_Components)</I> [partial]}</SPAN> <A NAME="I7344"></A>These 
<SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN>s are 
representation pragmas (see <A HREF="AA-13-1.html">13.1</A>).</DIV>

<H4 Class="centered">Dynamic Semantics</H4>
<DIV Class="paranum">15</DIV>
<DIV Class="Normal">For an atomic object (including an atomic component) 
all reads and updates of the object as a whole are indivisible.</DIV>
<DIV Class="paranum">16</DIV>
<DIV Class="Normal">For a volatile object all reads and updates of the 
object as a whole are performed directly to memory.&nbsp;</DIV>
<DIV Class="paranum">16.a</DIV>
<DIV Class="Annotations"><B>Implementation Note:&nbsp;</B>This precludes any 
use of register temporaries, caches, and other similar optimizations 
for that object.&nbsp;</DIV>
<DIV Class="paranum">17</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>sequential (actions)</I>}</SPAN> 
<A NAME="I7345"></A>Two actions are sequential (see <A HREF="AA-9-10.html">9.10</A>) 
if each is the read or update of the same atomic object.</DIV>
<DIV Class="paranum">18</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>by-reference type 
(atomic or volatile)</I> [partial]}</SPAN> <A NAME="I7346"></A>If a type 
is atomic or volatile and it is not a by-copy type, then the type is 
defined to be a by-reference type. If any subcomponent of a type is atomic 
or volatile, then the type is defined to be a by-reference type.</DIV>
<DIV Class="paranum">19</DIV>
<DIV Class="Normal">If an actual parameter is atomic or volatile, and 
the corresponding formal parameter is not, then the parameter is passed 
by copy.&nbsp;</DIV>
<DIV Class="paranum">19.a</DIV>
<DIV Class="Annotations"><B>Implementation Note:&nbsp;</B>Note that in the 
case where such a parameter is normally passed by reference, a copy of 
the actual will have to be produced at the call-site, and a pointer to 
the copy passed to the formal parameter. If the actual is atomic, any 
copying has to use indivisible read on the way in, and indivisible write 
on the way out.&nbsp;</DIV>
<DIV Class="paranum">19.b</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>It has to be known at compile 
time whether an atomic or a volatile parameter is to be passed by copy 
or by reference. For some types, it is unspecified whether parameters 
are passed by copy or by reference. The above rules further specify the 
parameter passing rules involving atomic and volatile types and objects. 
</DIV>

<H4 Class="centered">Implementation Requirements</H4>
<DIV Class="paranum">20</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>external effect 
(volatile/atomic objects)</I> [partial]}</SPAN> <A NAME="I7347"></A>The 
external effect of a program (see <A HREF="AA-1-1-3.html">1.1.3</A>) 
is defined to include each read and update of a volatile or atomic object. 
The implementation shall not generate any memory reads or updates of 
atomic or volatile objects other than those specified by the program. 
</DIV>
<DIV Class="paranum">20.a</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>The presumption is that volatile 
or atomic objects might reside in an &ldquo;active&rdquo; part of the 
address space where each read has a potential side-effect, and at the 
very least might deliver a different value.</DIV>
<DIV Class="paranum">20.b</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em">The rule above 
and the definition of external effect are intended to prevent (at least) 
the following incorrect optimizations, where V is a volatile variable: 
</DIV>
<DIV Class="paranum">20.c</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>X:= V; Y:=V; cannot be allowed 
to be translated as Y:=V; X:=V;</LI></UL>
<DIV Class="paranum">20.d</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>Deleting redundant loads: X:= 
V; X:= V; shall read the value of V from memory twice.</LI></UL>
<DIV Class="paranum">20.e</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>Deleting redundant stores: V:= 
X; V:= X; shall write into V twice.</LI></UL>
<DIV Class="paranum">20.f</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>Extra stores: V:= X+Y; should 
not translate to something like V:= X; V:= V+Y;</LI></UL>
<DIV Class="paranum">20.g</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>Extra loads: X:= V; Y:= X+Z; 
X:=X+B; should not translate to something like Y:= V+Z; X:= V+B;</LI></UL>
<DIV Class="paranum">20.h</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>Reordering of loads from volatile 
variables: X:= V1; Y:= V2; (whether or not V1 = V2) should not translate 
to Y:= V2; X:= V1;</LI></UL>
<DIV Class="paranum">20.i</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>Reordering of stores to volatile 
variables: V1:= X; V2:= X; should not translate to V2:=X; V1:= X;&nbsp;</LI></UL>
<DIV Class="paranum">21</DIV>
<DIV Class="Normal">If a pragma Pack applies to a type any of whose subcomponents 
are atomic, the implementation shall not pack the atomic subcomponents 
more tightly than that for which it can support indivisible reads and 
updates.&nbsp;</DIV>
<DIV Class="paranum">21.a</DIV>
<DIV Class="Annotations"><B>Implementation Note:&nbsp;</B>A warning might 
be appropriate if no packing whatsoever can be achieved.&nbsp;</DIV>

<H4 Class="centered">Implementation Advice</H4>
<DIV Class="paranum">22/2</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00259.TXT">AI95-00259-01</A></I>} 
<SPAN class="insert2">A load or store of a volatile object whose size 
is a multiple of System.Storage_Unit and whose alignment is nonzero, 
should be implemented by accessing exactly the bits of the object and 
no others.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">22.a/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Implementation Advice: 
</B></SPAN><SPAN class="insert2">A load or store of a volatile object 
whose size is a multiple of System.Storage_Unit and whose alignment is 
nonzero, should be implemented by accessing exactly the bits of the object 
and no others.</SPAN></DIV>
<DIV Class="paranum">22.b/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Reason:&nbsp;</B>Since any 
object can be a volatile object, including packed array components and 
bit-mapped record components, we require the above only when it is reasonable 
to assume that the machine can avoid accessing bits outside of the object.</SPAN> 
</DIV>
<DIV Class="paranum">22.c/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Ramification:&nbsp;</B>This 
implies that the load or store of a volatile object that meets the above 
requirement should not be combined with that of any other object, nor 
should it access any bits not belonging to any other object. This means 
that the suitability of the implementation for memory-mapped I/O can 
be determined from its documentation, as any cases where the implementation 
does not follow Implementation Advice must be documented.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">23/2</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00259.TXT">AI95-00259-01</A></I>} 
<SPAN class="insert2">A load or store of an atomic object should, where 
possible, be implemented by a single load or store instruction.</SPAN> 
</DIV>
<DIV Class="paranum">23.a/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Implementation Advice: 
</B></SPAN><SPAN class="insert2">A load or store of an atomic object 
should be implemented by a single load or store instruction.</SPAN></DIV>
<DIV Class="NotesHeader">NOTES</DIV>
<DIV Class="paranum">24</DIV>
<DIV Class="Notes">9&nbsp;&nbsp;An imported volatile or atomic constant 
behaves as a constant (i.e. read-only) with respect to other parts of 
the Ada program, but can still be modified by an &ldquo;external source.&rdquo;</DIV>

<H4 Class="centered">Incompatibilities With Ada 83</H4>
<DIV Class="paranum">24.a</DIV>
<DIV Class="Annotations">{<I>incompatibilities with Ada 83</I>} <A NAME="I7348"></A>Pragma 
Atomic replaces Ada 83's pragma Shared. The name &ldquo;Shared&rdquo; 
was confusing, because the pragma was not used to mark variables as shared. 
</DIV>

<H4 Class="centered">Wording Changes from Ada 95</H4>
<DIV Class="paranum">24.b/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00259.TXT">AI95-00259-01</A></I>} 
<SPAN class="insert2">Added Implementation Advice to clarify the meaning 
of Atomic and Volatile in machine terms. The documentation that this 
advice applies will make the use of Ada implementations more predictable 
for low-level (such as device register) programming.</SPAN></DIV>
<DIV Class="paranum">24.c/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00272.TXT">AI95-00272-01</A></I>} 
<SPAN class="insert2">Added wording to clarify that a slice of an object 
of an atomic type is not atomic, just like a component of an atomic type 
is not (necessarily) atomic.</SPAN>&nbsp;</DIV>

<HR>
<DIV Style="margin-top: 0.0em; margin-bottom: 0.6em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-C-5.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-C-7.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<DIV Style="margin-top:0.0em"><IMG SRC="AE_logo.gif" height=100 width=113 align=right ALT="Ada-Europe">
<SPAN Style="font-size: 125%">Sponsored by <SPAN Style="font-size: 125%"><A HREF="http://www.ada-europe.org/"><B>Ada-Europe</B></A></SPAN></SPAN></DIV>
</BODY>
</HTML>
