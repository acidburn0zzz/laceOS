<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Access Types</TITLE>
    <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    H4.centered {text-align: center}
    SPAN.swiss {font-family: Arial, Helvetica, sans-serif; font-size: 92%}
    SPAN.roman {font-family: "Times New Roman", Times, serif}
    DIV.paranum {float: left; font-family: Arial, Helvetica, sans-serif; font-size: 64%; width: 2.8em; margin-left: -0.4em; margin-right: -3.0em; margin-top: 0.2em}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    SPAN.insert1 {text-decoration: underline; color: rgb(0,51,51) }
    SPAN.delete1 {text-decoration: line-through; color: rgb(0,51,51) }
    SPAN.insert2 {text-decoration: underline; color: rgb(0,102,0) }
    SPAN.delete2 {text-decoration: line-through; color: rgb(0,102,0) }
    DIV.Normal {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.2em; margin-bottom: 0.6em}
    DIV.Wide {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.2em; margin-top: 0.6em; margin-bottom: 0.6em}
    DIV.Annotations {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 6.2em; margin-bottom: 0.6em}
    DIV.Notes {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em; margin-bottom: 0.6em}
    DIV.NotesHeader {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em}
    DIV.SyntaxIndented {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-bottom: 0.4em}
    DIV.Examples {font-family: "Courier New", monospace; font-size: 90%; line-height: 122%; margin-left: 3.4em; margin-bottom: 0.6em}
    DIV.SmallExamples {font-family: "Courier New", monospace; font-size: 72%; line-height: 122%; margin-left: 9.6em; margin-bottom: 0.6em}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#000080" VLINK="#330033" ALINK="#0000FF">
<DIV><B><SPAN Style="font-size:200%; color: rgb(0,51,153)">Annotated</SPAN><SPAN Style="font-size:200%; color: rgb(0,0,102)">&nbsp;Ada Reference Manual</SPAN></B> &mdash; <A HREF="AA-TTL.html"><B>Legal Information</B></A></DIV>
<DIV Style="margin-top: 0.6em; margin-bottom: 0.0em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-3-9-4.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-3-10-1.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<HR>
<H1>3.10 Access Types</H1>
<DIV Class="paranum">1</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>access type</I>}</SPAN> 
<A NAME="I2332"></A><SPAN STYLE="font-size: 80%">{<I>access value</I>}</SPAN> 
<A NAME="I2333"></A><SPAN STYLE="font-size: 80%">{<I>designate</I>}</SPAN> 
<A NAME="I2334"></A>A value of an access type (an <I>access value</I>) 
provides indirect access to the object or subprogram it <I>designates</I>. 
Depending on its type, an access value can designate either subprograms, 
objects created by allocators (see <A HREF="AA-4-8.html">4.8</A>), or 
more generally <I>aliased</I> objects of an appropriate type. <SPAN STYLE="font-size: 80%">{<I>pointer: 
See access value</I>}</SPAN> <A NAME="I2335"></A><SPAN STYLE="font-size: 80%">{<I>pointer 
type: See access type</I>}</SPAN> <A NAME="I2336"></A></DIV>
<DIV Class="paranum">1.a</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>A <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
<I>denotes</I> an entity; an access value <I>designates</I> an entity. 
The &ldquo;dereference&rdquo; of an access value X, written &ldquo;X.<B>all</B>&rdquo;, 
is a <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
that denotes the entity designated by X.&nbsp;</DIV>

<H4 Class="centered">Language Design Principles</H4>
<DIV Class="paranum">1.b</DIV>
<DIV Class="Annotations">Access values should always be well defined 
(barring uses of certain unchecked features of Section 13). In particular, 
uninitialized access variables should be prevented by compile-time rules. 
</DIV>

<H4 Class="centered">Syntax</H4>
<DIV Class="paranum">2/2</DIV>
<DIV Class="SyntaxIndented">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00231.TXT">AI95-00231-01</A></I>} 
<SPAN Class="swiss">access_type_definition</SPAN><A NAME="I2337"></A><A NAME="S0079"></A><SPAN Class="swiss">&nbsp;::=&nbsp;</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="insert2">[<A NAME="I2338"></A><SPAN Class="swiss"><A HREF="AA-3-10.html#S0083">null_exclusion</A></SPAN>]&nbsp;</SPAN><A NAME="I2339"></A><SPAN Class="swiss"><A HREF="AA-3-10.html#S0080">access_to_object_definition</A></SPAN><BR>
&nbsp;&nbsp;|&nbsp;<SPAN class="insert2">[<A NAME="I2340"></A><SPAN Class="swiss"><A HREF="AA-3-10.html#S0083">null_exclusion</A></SPAN>]&nbsp;</SPAN><A NAME="I2341"></A><SPAN Class="swiss"><A HREF="AA-3-10.html#S0082">access_to_subprogram_definition</A></SPAN></DIV>
<DIV Class="paranum">3</DIV>
<DIV Class="SyntaxIndented"><SPAN Class="swiss">access_to_object_definition</SPAN><A NAME="I2342"></A><A NAME="S0080"></A><SPAN Class="swiss">&nbsp;::=&nbsp;</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>access</B>&nbsp;[<A NAME="I2343"></A><SPAN Class="swiss"><A HREF="AA-3-10.html#S0081">general_access_modifier</A></SPAN>]&nbsp;<A NAME="I2344"></A><SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0027">subtype_indication</A></SPAN></DIV>
<DIV Class="paranum">4</DIV>
<DIV Class="SyntaxIndented"><SPAN Class="swiss">general_access_modifier</SPAN><A NAME="I2345"></A><A NAME="S0081"></A><SPAN Class="swiss">&nbsp;::=&nbsp;</SPAN><B>all</B>&nbsp;|&nbsp;<B>constant</B></DIV>
<DIV Class="paranum">5</DIV>
<DIV Class="SyntaxIndented"><SPAN Class="swiss">access_to_subprogram_definition</SPAN><A NAME="I2346"></A><A NAME="S0082"></A><SPAN Class="swiss">&nbsp;::=&nbsp;</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>access</B>&nbsp;[<B>protected</B>]&nbsp;<B>procedure</B>&nbsp;<A NAME="I2347"></A><SPAN Class="swiss"><A HREF="AA-6-1.html#S0157">parameter_profile</A></SPAN><BR>
&nbsp;&nbsp;|&nbsp;<B>access</B>&nbsp;[<B>protected</B>]&nbsp;<B>function</B>&nbsp;&nbsp;<A NAME="I2348"></A><SPAN Class="swiss"><A HREF="AA-6-1.html#S0158">parameter_and_result_profile</A></SPAN></DIV>
<DIV Class="paranum">5.1/2</DIV>
<DIV Class="SyntaxIndented">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00231.TXT">AI95-00231-01</A></I>} 
<SPAN Class="swiss"></SPAN><SPAN class="insert2"><SPAN Class="swiss">null_exclusion</SPAN></SPAN><SPAN Class="swiss"></SPAN><A NAME="I2349"></A><A NAME="S0083"></A><SPAN class="insert2"><SPAN Class="swiss">&nbsp;::=&nbsp;</SPAN></SPAN><SPAN class="insert2"><B>not</B>&nbsp;<B>null</B></SPAN></DIV>
<DIV Class="paranum">6/2</DIV>
<DIV Class="SyntaxIndented">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00231.TXT">AI95-00231-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00254.TXT">AI95-00254-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00404.TXT">AI95-00404-01</A></I>} 
<SPAN Class="swiss">access_definition</SPAN><A NAME="I2350"></A><A NAME="S0084"></A><SPAN Class="swiss">&nbsp;::=&nbsp;</SPAN><SPAN class="insert2"><BR>
&nbsp;&nbsp;&nbsp;&nbsp;[<A NAME="I2351"></A><SPAN Class="swiss"><A HREF="AA-3-10.html#S0083">null_exclusion</A></SPAN>]&nbsp;<B>access</B>&nbsp;[<B>constant</B>]&nbsp;<A NAME="I2352"></A><SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0028">subtype_mark</A></SPAN><BR>
&nbsp;&nbsp;|&nbsp;[<A NAME="I2353"></A><SPAN Class="swiss"><A HREF="AA-3-10.html#S0083">null_exclusion</A></SPAN>]&nbsp;<B>access</B>&nbsp;[<B>protected</B>]&nbsp;<B>procedure</B>&nbsp;<A NAME="I2354"></A><SPAN Class="swiss"><A HREF="AA-6-1.html#S0157">parameter_profile</A></SPAN><BR>
&nbsp;&nbsp;|&nbsp;[<A NAME="I2355"></A><SPAN Class="swiss"><A HREF="AA-3-10.html#S0083">null_exclusion</A></SPAN>]&nbsp;<B>access</B>&nbsp;[<B>protected</B>]&nbsp;<B>function</B>&nbsp;<A NAME="I2356"></A><SPAN Class="swiss"><A HREF="AA-6-1.html#S0158">parameter_and_result_profile</A></SPAN></SPAN><SPAN class="delete2"><B>&nbsp;access</B>&nbsp;<A NAME="I2357"></A><SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0028">subtype_mark</A></SPAN></SPAN></DIV>

<H4 Class="centered">Static Semantics</H4>
<DIV Class="paranum">7/1</DIV>
<DIV Class="Normal">{<I><A HREF="defect1.html#8652/0012">8652/0012</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00062.TXT">AI95-00062-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>access-to-object type</I>}</SPAN> <A NAME="I2358"></A><SPAN STYLE="font-size: 80%">{<I>access-to-subprogram 
type</I>}</SPAN> <A NAME="I2359"></A><SPAN STYLE="font-size: 80%">{<I>pool-specific 
access type</I>}</SPAN> <A NAME="I2360"></A><SPAN STYLE="font-size: 80%">{<I>general 
access type</I>}</SPAN> <A NAME="I2361"></A>There are two kinds of access 
types, <I>access-to-object</I> types, whose values designate objects, 
and <I>access-to-subprogram</I> types, whose values designate subprograms. 
<SPAN STYLE="font-size: 80%">{<I>storage pool</I>}</SPAN> <A NAME="I2362"></A>Associated 
with an access-to-object type is a <I>storage pool</I>; several access 
types may share the same storage pool. <SPAN class="insert1">All descendants 
of an access type share the same storage pool.</SPAN> <SPAN STYLE="font-size: 80%">{<I>pool 
element</I>}</SPAN> <A NAME="I2363"></A>A storage pool is an area of 
storage used to hold dynamically allocated objects (called <I>pool elements</I>) 
created by allocators[; storage pools are described further in <A HREF="AA-13-11.html">13.11</A>, 
&ldquo;<A HREF="AA-13-11.html">Storage Management</A>&rdquo;].</DIV>
<DIV Class="paranum">8</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>pool-specific access 
type</I>}</SPAN> <A NAME="I2364"></A><SPAN STYLE="font-size: 80%">{<I>general 
access type</I>}</SPAN> <A NAME="I2365"></A>Access-to-object types are 
further subdivided into <I>pool-specific</I> access types, whose values 
can designate only the elements of their associated storage pool, and 
<I>general</I> access types, whose values can designate the elements 
of any storage pool, as well as aliased objects created by declarations 
rather than allocators, and aliased subcomponents of other objects.&nbsp;</DIV>
<DIV Class="paranum">8.a</DIV>
<DIV Class="Annotations"><B>Implementation Note:&nbsp;</B>The value of an 
access type will typically be a machine address. However, a value of 
a pool-specific access type can be represented as an offset (or index) 
relative to its storage pool, since it can point only to the elements 
of that pool.&nbsp;</DIV>
<DIV Class="paranum">9/2</DIV>
<DIV Class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00225.TXT">AI95-00225-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00363.TXT">AI95-00363-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>aliased</I>}</SPAN> <A NAME="I2366"></A>A 
view of an object is defined to be <I>aliased</I> if it is defined by 
an <SPAN Class="swiss"><A HREF="AA-3-3-1.html#S0032">object_declaration</A></SPAN> 
or <SPAN Class="swiss"><A HREF="AA-3-6.html#S0056">component_definition</A></SPAN> 
with the reserved word <B>aliased</B>, or by a renaming of an aliased 
view. In addition, the dereference of an access-to-object value denotes 
an aliased view, as does a view conversion (see <A HREF="AA-4-6.html">4.6</A>) 
of an aliased view. <SPAN class="insert2">The</SPAN><SPAN class="delete2">&nbsp;Finally, 
the</SPAN> current instance of a limited<SPAN class="insert2">&nbsp;tagged</SPAN> 
type, <SPAN class="insert2">a protected type, a task type, or a type 
that has the reserved word <B>limited</B> in its full definition is also 
defined to be aliased. Finally,</SPAN><SPAN class="delete2">&nbsp;and</SPAN> 
a formal parameter or generic formal object of a tagged type <SPAN class="insert2">is</SPAN><SPAN class="delete2">&nbsp;are</SPAN> 
defined to be aliased. [Aliased views are the ones that can be designated 
by an access value.] <SPAN class="delete2"><SPAN STYLE="font-size: 80%">{<I>constrained 
(object)</I>}</SPAN> <A NAME="I2367"></A><SPAN STYLE="font-size: 80%">{<I>unconstrained 
(object)</I>}</SPAN> <A NAME="I2368"></A><SPAN STYLE="font-size: 80%">{<I>constrained 
by its initial value</I>}</SPAN> <A NAME="I2369"></A>If the view defined 
by an <SPAN Class="swiss"><A HREF="AA-3-3-1.html#S0032">object_declaration</A></SPAN> 
is aliased, and the type of the object has discriminants, then the object 
is constrained; if its nominal subtype is unconstrained, then the object 
is constrained by its initial value. [Similarly, if the object created 
by an <SPAN Class="swiss"><A HREF="AA-4-8.html#S0129">allocator</A></SPAN> 
has discriminants, the object is constrained, either by the designated 
subtype, or by its initial value.]</SPAN>&nbsp;</DIV>
<DIV Class="paranum">9.a</DIV>
<DIV Class="Annotations"><B>Glossary entry:&nbsp;</B>{<I>Aliased</I>} An aliased 
view of an object is one that can be designated by an access value. Objects 
allocated by allocators are aliased. Objects can also be explicitly declared 
as aliased with the reserved word <B>aliased</B>. The Access attribute 
can be used to create an access value designating an aliased object.</DIV>
<DIV Class="paranum">9.b</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>The current instance of 
a nonlimited type is not aliased.</DIV>
<DIV Class="paranum">9.c</DIV>
<DIV Class="Annotations">The object created by an allocator is aliased, 
but not its subcomponents, except of course for those that themselves 
have <B>aliased</B> in their <SPAN Class="swiss"><A HREF="AA-3-6.html#S0056">component_definition</A></SPAN>.</DIV>
<DIV Class="paranum">9.d</DIV>
<DIV Class="Annotations">The renaming of an aliased object is aliased.</DIV>
<DIV Class="paranum">9.e</DIV>
<DIV Class="Annotations">Slices are never aliased. See <A HREF="AA-4-1-2.html">4.1.2</A> 
for more discussion.&nbsp;</DIV>
<DIV Class="paranum">9.f/2</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00225.TXT">AI95-00225-01</A></I>} 
The current instance of a limited type is defined to be aliased so that 
an access discriminant of a component can be initialized with T'Access 
inside the definition of T.<SPAN class="insert2">&nbsp;Note that we don't 
want this to apply to a type that could become nonlimited later within 
its immediate scope, so we require the full definition to be limited.</SPAN></DIV>
<DIV Class="paranum">9.g</DIV>
<DIV Class="Annotations">A formal parameter of a tagged type is defined 
to be aliased so that a (tagged) parameter X may be passed to an access 
parameter P by using P =&gt; X'Access. Access parameters are most important 
for tagged types because of dispatching-on-access-parameters (see <A HREF="AA-3-9-2.html">3.9.2</A>). 
By restricting this to formal parameters, we minimize problems associated 
with allowing components that are not declared aliased to be pointed-to 
from within the same record.</DIV>
<DIV Class="paranum">9.h</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em">A view conversion 
of an aliased view is aliased so that the type of an access parameter 
can be changed without first converting to a named access type. For example: 
</DIV>
<DIV Class="paranum">9.i</DIV>
<DIV Class="SmallExamples"><B>type</B>&nbsp;T1&nbsp;<B>is&nbsp;tagged</B>&nbsp;...;<BR>
<B>procedure</B>&nbsp;P(X&nbsp;:&nbsp;<B>access</B>&nbsp;T1);</DIV>
<DIV Class="paranum">9.j</DIV>
<DIV Class="SmallExamples"><B>type</B>&nbsp;T2&nbsp;<B>is&nbsp;new</B>&nbsp;T1&nbsp;<B>with</B>&nbsp;...;<BR>
<B>procedure</B>&nbsp;P(X&nbsp;:&nbsp;<B>access</B>&nbsp;T2)&nbsp;<B>is</B><BR>
<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;P(T1(X.<B>all</B>)'Access);&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;hand&nbsp;off&nbsp;to&nbsp;T1's&nbsp;P</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;.&nbsp;.&nbsp;.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;now&nbsp;do&nbsp;extra&nbsp;T2-specific&nbsp;processing</I></SPAN><BR>
<B>end</B>&nbsp;P;</DIV>
<DIV Class="paranum">9.k/2</DIV>
<DIV Class="Annotations"><SPAN STYLE="font-size: 80%"><I>This paragraph 
was deleted.</I></SPAN><SPAN class="delete2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00363.TXT">AI95-00363-01</A></I>} 
<SPAN class="delete2">The rule about objects with discriminants is necessary 
because values of a constrained access subtype can designate an object 
whose nominal subtype is unconstrained; without this rule, a check on 
every use of such values would be required to ensure that the discriminants 
of the object had not changed. With this rule (among others), we ensure 
that if there might exist aliased views of a discriminated object, then 
the object is necessarily constrained. Note that this rule is necessary 
only for untagged types, since a discriminant of a tagged type can't 
have a default, so all tagged discriminated objects are always constrained 
anyway.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">9.l/2</DIV>
<DIV Class="Annotations">We considered making more kinds of objects aliased 
by default. In particular, any object of a by-reference type will pretty 
much have to be allocated at an addressable location, so it can be passed 
by reference without using bit-field pointers. Therefore, one might wish 
to allow the Access and <SPAN class="delete2">and&nbsp;</SPAN>Unchecked_Access 
attributes for such objects. However, private parts are transparent to 
the definition of &ldquo;by-reference type&rdquo;, so if we made all 
objects of a by-reference type aliased, we would be violating the privacy 
of private parts. Instead, we would have to define a concept of &ldquo;visibly 
by-reference&rdquo; and base the rule on that. This seemed to complicate 
the rules more than it was worth, especially since there is no way to 
declare an untagged limited private type to be by-reference, since the 
full type might by nonlimited.&nbsp;</DIV>
<DIV Class="paranum">9.m</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>Note that we do not use the 
term &ldquo;aliased&rdquo; to refer to formal parameters that are referenced 
through multiple access paths (see <A HREF="AA-6-2.html">6.2</A>).&nbsp;</DIV>
<DIV Class="paranum">10</DIV>
<DIV Class="Normal">An <SPAN Class="swiss"><A HREF="AA-3-10.html#S0080">access_to_object_definition</A></SPAN> 
defines an access-to-object type and its first subtype; <SPAN STYLE="font-size: 80%">{<I>designated 
subtype (of a named access type)</I>}</SPAN> <A NAME="I2370"></A><SPAN STYLE="font-size: 80%">{<I>designated 
type (of a named access type)</I>}</SPAN> <A NAME="I2371"></A>the <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0027">subtype_indication</A></SPAN> 
defines the <I>designated subtype</I> of the access type. If a <SPAN Class="swiss"><A HREF="AA-3-10.html#S0081">general_access_modifier</A></SPAN> 
appears, then the access type is a general access type. <SPAN STYLE="font-size: 80%">{<I>access-to-constant 
type</I>}</SPAN> <A NAME="I2372"></A>If the modifier is the reserved 
word <B>constant</B>, then the type is an <I>access-to-constant type</I>[; 
a designated object cannot be updated through a value of such a type]. 
<SPAN STYLE="font-size: 80%">{<I>access-to-variable type</I>}</SPAN> 
<A NAME="I2373"></A>If the modifier is the reserved word <B>all</B>, 
then the type is an <I>access-to-variable type</I>[; a designated object 
can be both read and updated through a value of such a type]. If no <SPAN Class="swiss"><A HREF="AA-3-10.html#S0081">general_access_modifier</A></SPAN> 
appears in the <SPAN Class="swiss"><A HREF="AA-3-10.html#S0080">access_to_object_definition</A></SPAN>, 
the access type is a pool-specific access-to-variable type.&nbsp;</DIV>
<DIV Class="paranum">10.a</DIV>
<DIV Class="Annotations"><B>To be honest:&nbsp;</B>The type of the designated 
subtype is called the <I>designated type</I>.&nbsp;</DIV>
<DIV Class="paranum">10.b</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>The modifier <B>all</B> was picked 
to suggest that values of a general access type could point into &ldquo;all&rdquo; 
storage pools, as well as to objects declared aliased, and that &ldquo;all&rdquo; 
access (both read and update) to the designated object was provided. 
We couldn't think of any use for pool-specific access-to-constant types, 
so any access type defined with the modifier <B>constant</B> is considered 
a general access type, and can point into any storage pool or at other 
(appropriate) aliased objects.&nbsp;</DIV>
<DIV Class="paranum">10.c</DIV>
<DIV Class="Annotations"><B>Implementation Note:&nbsp;</B>The predefined generic 
Unchecked_Deallocation can be instantiated for any named access-to-variable 
type. There is no (language-defined) support for deallocating objects 
designated by a value of an access-to-constant type. Because of this, 
an allocator for an access-to-constant type can allocate out of a storage 
pool with no support for deallocation. Frequently, the allocation can 
be done at link-time, if the size and initial value are known then.&nbsp;</DIV>
<DIV Class="paranum">10.d</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>For the purpose of generic 
formal type matching, the relevant subclasses of access types are access-to-subprogram 
types, access-to-constant types, and (named) access-to-variable types, 
with its subclass (named) general access-to-variable types. Pool-specific 
access-to-variable types are not a separately matchable subclass of types, 
since they don't have any &ldquo;extra&rdquo; operations relative to 
all (named) access-to-variable types.&nbsp;</DIV>
<DIV Class="paranum">11</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>access-to-subprogram 
type</I>}</SPAN> <A NAME="I2374"></A>An <SPAN Class="swiss"><A HREF="AA-3-10.html#S0082">access_to_subprogram_definition</A></SPAN> 
defines an access-to-subprogram type and its first subtype; <SPAN STYLE="font-size: 80%">{<I>designated 
profile (of an access-to-subprogram type)</I>}</SPAN> <A NAME="I2375"></A>the 
<SPAN Class="swiss"><A HREF="AA-6-1.html#S0157">parameter_profile</A></SPAN> 
or <SPAN Class="swiss"><A HREF="AA-6-1.html#S0158">parameter_and_result_profile</A></SPAN> 
defines the <I>designated profile</I> of the access type. <SPAN STYLE="font-size: 80%">{<I>calling 
convention (associated with a designated profile)</I>}</SPAN> <A NAME="I2376"></A>There 
is a <I>calling convention</I> associated with the designated profile[; 
only subprograms with this calling convention can be designated by values 
of the access type.] By default, the calling convention is &ldquo;<I>protected</I>&rdquo; 
if the reserved word <B>protected</B> appears, and &ldquo;Ada&rdquo; 
otherwise. [See <A HREF="AA-B.html">Annex B</A> for how to override this 
default.]&nbsp;</DIV>
<DIV Class="paranum">11.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>The calling convention 
<I>protected</I> is in italics to emphasize that it cannot be specified 
explicitly by the user. This is a consequence of it being a reserved 
word.&nbsp;</DIV>
<DIV Class="paranum">11.b/2</DIV>
<DIV Class="Annotations"><B>Implementation Note:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00254.TXT">AI95-00254-01</A></I>} 
For <SPAN class="insert2">a named</SPAN><SPAN class="delete2">&nbsp;an</SPAN> 
access-to-subprogram type, the representation of an access value might 
include implementation-defined information needed to support up-level 
references &mdash; for example, a static link. The accessibility rules 
(see <A HREF="AA-3-10-2.html">3.10.2</A>) ensure that in a &quot;global-display-based&quot; 
implementation model (as opposed to a static-link-based model), <SPAN class="insert2">a 
named</SPAN><SPAN class="delete2">&nbsp;an</SPAN> access-to-(unprotected)-subprogram 
value need consist only of the address of the subprogram. The global 
display is guaranteed to be properly set up any time the designated subprogram 
is called. Even in a static-link-based model, the only time a static 
link is definitely required is for an access-to-subprogram type declared 
in a scope nested at least two levels deep within subprogram or task 
bodies, since values of such a type might designate subprograms nested 
a smaller number of levels. For the normal case of <SPAN class="insert2">a 
named</SPAN><SPAN class="delete2">&nbsp;an</SPAN> access-to-subprogram type 
declared at the outermost (library) level, a code address by itself should 
be sufficient to represent the access value in many implementations.</DIV>
<DIV Class="paranum">11.c</DIV>
<DIV Class="Annotations">For access-to-protected-subprogram, the access 
values will necessarily include both an address (or other identification) 
of the code of the subprogram, as well as the address of the associated 
protected object. This could be thought of as a static link, but it will 
be needed even for global-display-based implementation models. It corresponds 
to the value of the &ldquo;implicit parameter&rdquo; that is passed into 
every call of a protected operation, to identify the current instance 
of the protected type on which they are to operate.</DIV>
<DIV Class="paranum">11.d</DIV>
<DIV Class="Annotations">Any Elaboration_Check is performed when a call 
is made through an access value, rather than when the access value is 
first &quot;created&quot; via a 'Access. For implementation models that 
normally put that check at the call-site, an access value will have to 
point to a separate entry point that does the check. Alternatively, the 
access value could point to a &quot;subprogram descriptor&quot; that 
consisted of two words (or perhaps more), the first being the address 
of the code, the second being the elaboration bit. Or perhaps more efficiently, 
just the address of the code, but using the trick that the descriptor 
is initialized to point to a Raise-Program-Error routine initially, and 
then set to point to the &quot;real&quot; code when the body is elaborated.</DIV>
<DIV Class="paranum">11.e</DIV>
<DIV Class="Annotations">For implementations that share code between 
generic instantiations, the extra level of indirection suggested above 
to support Elaboration_Checks could also be used to provide a pointer 
to the per-instance data area normally required when calling shared code. 
The trick would be to put a pointer to the per-instance data area into 
the subprogram descriptor, and then make sure that the address of the 
subprogram descriptor is loaded into a &quot;known&quot; register whenever 
an indirect call is performed. Once inside the shared code, the address 
of the per-instance data area can be retrieved out of the subprogram 
descriptor, by indexing off the &quot;known&quot; register.</DIV>
<DIV Class="paranum">11.f/2</DIV>
<DIV Class="Annotations"><SPAN STYLE="font-size: 80%"><I>This paragraph 
was deleted.</I></SPAN><SPAN class="delete2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00344.TXT">AI95-00344-01</A></I>} 
<SPAN class="delete2">Essentially the same implementation issues arise 
for calls on dispatching operations of tagged types, except that the 
static link is always known &quot;statically.&quot;</SPAN></DIV>
<DIV Class="paranum">11.g/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00254.TXT">AI95-00254-01</A></I>} 
Note that access parameters of an anonymous access-to-subprogram type 
are <SPAN class="delete2">not&nbsp;</SPAN>permitted. <SPAN class="insert2">Such</SPAN><SPAN class="delete2">&nbsp;If 
there were such</SPAN> parameters<SPAN class="insert2">&nbsp;represent</SPAN><SPAN class="delete2">,</SPAN> 
full &ldquo;downward&rdquo; closures<SPAN class="delete2">would be required</SPAN>, 
meaning that in an implementation that uses a per-task (global) display, 
the display <SPAN class="insert2">will</SPAN><SPAN class="delete2">&nbsp;would</SPAN> 
have to be passed as a hidden parameter, and reconstructed at the point 
of call.<SPAN class="delete2">&nbsp;This was felt to be an undue implementation 
burden, given that an equivalent (actually, more general) capability 
is available via formal subprogram parameters to a generic.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">12/2</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00230.TXT">AI95-00230-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00231.TXT">AI95-00231-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00254.TXT">AI95-00254-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>anonymous access type</I>}</SPAN> <A NAME="I2377"></A><SPAN STYLE="font-size: 80%">{<I>designated 
subtype (of an anonymous access type)</I>}</SPAN> <A NAME="I2378"></A><SPAN STYLE="font-size: 80%">{<I>designated 
type (of an anonymous access type)</I>}</SPAN> <A NAME="I2379"></A>An 
<SPAN Class="swiss"><A HREF="AA-3-10.html#S0084">access_definition</A></SPAN> 
defines an anonymous general <SPAN class="insert2">access type or an 
anonymous access-to-subprogram type. For a general access type,</SPAN><SPAN class="delete2">&nbsp;access-to-variable 
type;</SPAN> the <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0028">subtype_mark</A></SPAN> 
denotes its <I>designated subtype</I><SPAN class="insert2">; if the <SPAN Class="swiss"><A HREF="AA-3-10.html#S0081">general_access_modifier</A></SPAN> 
<B>constant</B> appears, the type is an access-to-constant type; otherwise 
it is an access-to-variable type. For an access-to-subprogram type, the 
<SPAN Class="swiss"><A HREF="AA-6-1.html#S0157">parameter_profile</A></SPAN> 
or <SPAN Class="swiss"><A HREF="AA-6-1.html#S0158">parameter_and_result_profile</A></SPAN> 
denotes its <I>designated profile</I>.<SPAN STYLE="font-size: 80%">{<I>designated 
profile (of an anonymous access type)</I>}</SPAN> <A NAME="I2380"></A></SPAN><SPAN class="delete2">. 
[An <SPAN Class="swiss"><A HREF="AA-3-10.html#S0084">access_definition</A></SPAN> 
is used in the specification of an access discriminant (see <A HREF="AA-3-7.html">3.7</A>) 
or an access parameter (see <A HREF="AA-6-1.html">6.1</A>).]</SPAN></DIV>
<DIV Class="paranum">13/2</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00230.TXT">AI95-00230-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00231.TXT">AI95-00231-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>null value (of an access type)</I>}</SPAN> 
<A NAME="I2381"></A>For each <SPAN class="delete2">(named)&nbsp;</SPAN>access 
type, there is <SPAN class="delete2">a literal <B>null</B> which has 
</SPAN>a null access value designating no entity at all<SPAN class="insert2">, 
which can be obtained by (implicitly) converting the literal <B>null</B> 
to the access type</SPAN>. [The null value of <SPAN class="insert2">an</SPAN><SPAN class="delete2">&nbsp;a 
named</SPAN> access type is the default initial value of the type.] <SPAN class="insert2">Non-null</SPAN><SPAN class="delete2">&nbsp;Other</SPAN> 
values of an access<SPAN class="insert2">-to-object</SPAN> type are obtained 
by evaluating <SPAN class="delete2">an <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0100">attribute_reference</A></SPAN> 
for the Access or Unchecked_Access attribute of an aliased view of an 
object or non-intrinsic subprogram, or, in the case of a named access-to-object 
type,</SPAN> an <SPAN Class="swiss"><A HREF="AA-4-8.html#S0129">allocator</A></SPAN>[, 
which returns an access value designating a newly created object (see 
<A HREF="AA-3-10-2.html">3.10.2</A>)]<SPAN class="insert2">, or in the 
case of a general access-to-object type, evaluating an <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0100">attribute_reference</A></SPAN> 
for the Access or Unchecked_Access attribute of an aliased view of an 
object. Non-null values of an access-to-subprogram type are obtained 
by evaluating an <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0100">attribute_reference</A></SPAN> 
for the Access attribute of a non-intrinsic subprogram.</SPAN>.</DIV>
<DIV Class="paranum">13.a/2</DIV>
<DIV Class="Annotations"><SPAN STYLE="font-size: 80%"><I>This paragraph 
was deleted.</I></SPAN><SPAN class="delete2"><B>Ramification:&nbsp;</B></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00231.TXT">AI95-00231-01</A></I>} 
<SPAN class="delete2">A value of an anonymous access type (that is, the 
value of an access parameter or access discriminant) cannot be null.</SPAN> 
</DIV>
<DIV Class="paranum">13.b/2</DIV>
<DIV Class="Annotations"><SPAN STYLE="font-size: 80%"><I>This paragraph 
was deleted.</I></SPAN><SPAN class="delete2"><B>Reason:&nbsp;</B></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00231.TXT">AI95-00231-01</A></I>} 
<SPAN class="delete2">Access parameters allow dispatching on the tag 
of the object designated by the actual parameter (which gets converted 
to the anonymous access type as part of the call). In order for dispatching 
to work properly, there had better be such an object. Hence, the type 
conversion will raise Constraint_Error if the value of the actual parameter 
is null.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">13.1/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00231.TXT">AI95-00231-01</A></I>} 
<SPAN class="insert2"><SPAN STYLE="font-size: 80%">{<I>excludes null 
(subtype)</I>}</SPAN> <A NAME="I2382"></A>A <SPAN Class="swiss"><A HREF="AA-3-10.html#S0083">null_exclusion</A></SPAN> 
in a construct specifies that the null value does not belong to the access 
subtype defined by the construct, that is, the access subtype <I>excludes 
null</I>. In addition, the anonymous access subtype defined by the <SPAN Class="swiss"><A HREF="AA-3-10.html#S0084">access_definition</A></SPAN> 
for a controlling access parameter (see <A HREF="AA-3-9-2.html">3.9.2</A>) 
excludes null. Finally, for a <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0027">subtype_indication</A></SPAN> 
without a <SPAN Class="swiss"><A HREF="AA-3-10.html#S0083">null_exclusion</A></SPAN>, 
the subtype denoted by the <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0027">subtype_indication</A></SPAN> 
excludes null if and only if the subtype denoted by the <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0028">subtype_mark</A></SPAN> 
in the <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0027">subtype_indication</A></SPAN> 
excludes null.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">13.c/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Reason:&nbsp;</B></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00231.TXT">AI95-00231-01</A></I>} 
<SPAN class="insert2">An <SPAN Class="swiss"><A HREF="AA-3-10.html#S0084">access_definition</A></SPAN> 
used in a controlling parameter excludes null because it is necessary 
to read the tag to dispatch, and null has no tag. We would have preferred 
to require <B>not null</B> to be specified for such parameters, but that 
would have been too incompatible with Ada 95 code to require.</SPAN></DIV>
<DIV Class="paranum">13.d/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00416.TXT">AI95-00416-01</A></I>} 
<SPAN class="insert2">Note that we considered imposing a similar implicit 
null exclusion for controlling access results, but chose not to do that, 
because there is no Ada 95 compatibility issue, and there is no automatic 
null check inherent in the use of a controlling access result. If a null 
check is necessary, it is because there is a dereference of the result, 
or because the value is passed to a parameter whose subtype excludes 
null. If there is no dereference of the result, a null return value is 
perfectly acceptable, and can be a useful indication of a particular 
status of the call.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">14/1</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="defect1.html#8652/0013">8652/0013</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00012.TXT">AI95-00012-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>constrained (subtype)</I> [partial]}</SPAN> 
<A NAME="I2383"></A><SPAN STYLE="font-size: 80%">{<I>unconstrained (subtype)</I> 
[partial]}</SPAN> <A NAME="I2384"></A>[All subtypes of an access-to-subprogram 
type are constrained.] The first subtype of a type defined by an <SPAN class="insert1"><SPAN Class="swiss"><A HREF="AA-3-10.html#S0084">access_definition</A></SPAN></SPAN><SPAN class="delete1"><SPAN Class="swiss"><A HREF="AA-3-10.html#S0079">&nbsp;access_type_definition</A></SPAN></SPAN> 
or an <SPAN Class="swiss"><A HREF="AA-3-10.html#S0080">access_to_object_definition</A></SPAN> 
is unconstrained if the designated subtype is an unconstrained array 
or discriminated <SPAN class="insert1">subtype</SPAN><SPAN class="delete1">&nbsp;type</SPAN>; 
otherwise it is constrained.&nbsp;</DIV>
<DIV Class="paranum">14.a</DIV>
<DIV Class="Annotations"><B>Proof:&nbsp;</B>The Legality Rules on <SPAN Class="swiss"><A HREF="AA-3-5.html#S0036">range_constraint</A></SPAN>s 
(see <A HREF="AA-3-5.html">3.5</A>) do not permit the <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0028">subtype_mark</A></SPAN> 
of the <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0027">subtype_indication</A></SPAN> 
to denote an access-to-scalar type, only a scalar type. The Legality 
Rules on <SPAN Class="swiss"><A HREF="AA-3-6-1.html#S0057">index_constraint</A></SPAN>s 
(see <A HREF="AA-3-6-1.html">3.6.1</A>) and <SPAN Class="swiss"><A HREF="AA-3-7-1.html#S0064">discriminant_constraint</A></SPAN>s 
(see <A HREF="AA-3-7-1.html">3.7.1</A>) both permit access-to-composite 
types in a <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0027">subtype_indication</A></SPAN> 
with such _<SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0029">constraint</A></SPAN>s. 
Note that an access-to-access-to-composite is never permitted in a <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0027">subtype_indication</A></SPAN> 
with a <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0029">constraint</A></SPAN>. 
</DIV>
<DIV Class="paranum">14.b/2</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00363.TXT">AI95-00363-01</A></I>} 
Only <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0031">composite_constraint</A></SPAN>s 
are permitted for an access type, and only on access-to-composite types. 
A constraint on an access-to-scalar or access-to-access type might be 
violated due to assignments via other access paths that were not so constrained. 
By contrast, if the designated subtype is an array or discriminated type<SPAN class="insert2">&nbsp;without defaults</SPAN>, the constraint could not be violated by unconstrained 
assignments, since array objects are always constrained, and <SPAN class="delete2">aliased</SPAN> 
discriminated objects are also constrained <SPAN class="insert2">when 
the type does not have defaults for its discriminants. Constraints are 
not allowed on general access-to-unconstrained discriminated types if 
the type has defaults for its discriminants; constraints on pool-specific 
access types are usually allowed because allocated objects are usually 
constrained by their initial value.</SPAN><SPAN class="delete2">(by fiat, 
see Static Semantics).</SPAN>&nbsp;</DIV>

<H4 Class="centered">Legality Rules</H4>
<DIV Class="paranum">14.1/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00231.TXT">AI95-00231-01</A></I>} 
<SPAN class="insert2">If a <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0027">subtype_indication</A></SPAN>, 
<SPAN Class="swiss"><A HREF="AA-3-7.html#S0062">discriminant_specification</A></SPAN>, 
<SPAN Class="swiss"><A HREF="AA-6-1.html#S0160">parameter_specification</A></SPAN>, 
<SPAN Class="swiss"><A HREF="AA-6-1.html#S0158">parameter_and_result_profile</A></SPAN>, 
<SPAN Class="swiss"><A HREF="AA-8-5-1.html#S0183">object_renaming_declaration</A></SPAN>, 
or <SPAN Class="swiss"><A HREF="AA-12-4.html#S0261">formal_object_declaration</A></SPAN> 
has a <SPAN Class="swiss"><A HREF="AA-3-10.html#S0083">null_exclusion</A></SPAN>, 
the <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0028">subtype_mark</A></SPAN> 
in that construct shall denote an access subtype that does not exclude 
null.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">14.c/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>To be honest:&nbsp;</B></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00231.TXT">AI95-00231-01</A></I>} 
<SPAN class="insert2">This means &ldquo;directly allowed in&rdquo;; we 
are not talking about a <SPAN Class="swiss"><A HREF="AA-3-10.html#S0083">null_exclusion</A></SPAN> 
that occurs in an <SPAN Class="swiss"><A HREF="AA-3-10.html#S0084">access_definition</A></SPAN> 
in one of these constructs (for an <SPAN Class="swiss"><A HREF="AA-3-10.html#S0084">access_definition</A></SPAN>, 
the <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0028">subtype_mark</A></SPAN> 
in such an <SPAN Class="swiss"><A HREF="AA-3-10.html#S0084">access_definition</A></SPAN> 
is not restricted).</SPAN>&nbsp;</DIV>
<DIV Class="paranum">14.d/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Reason:&nbsp;</B></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00231.TXT">AI95-00231-01</A></I>} 
<SPAN class="insert2">This is similar to doubly constraining a composite 
subtype, which we also don't allow.</SPAN>&nbsp;</DIV>

<H4 Class="centered">Dynamic Semantics</H4>
<DIV Class="paranum">15/2</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00231.TXT">AI95-00231-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>compatibility (composite_constraint 
with an access subtype)</I> [partial]}</SPAN> <A NAME="I2385"></A>A <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0031">composite_constraint</A></SPAN> 
is <I>compatible</I> with an unconstrained access subtype if it is compatible 
with the designated subtype.<SPAN class="insert2">&nbsp;A <SPAN Class="swiss"><A HREF="AA-3-10.html#S0083">null_exclusion</A></SPAN> 
is compatible with any access subtype that does not exclude null.</SPAN> 
<SPAN STYLE="font-size: 80%">{<I>satisfies (for an access value)</I> 
[partial]}</SPAN> <A NAME="I2386"></A>An access value <I>satisfies</I> 
a <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0031">composite_constraint</A></SPAN> 
of an access subtype if it equals the null value of its type or if it 
designates an object whose value satisfies the constraint.<SPAN class="insert2">&nbsp;An access value satisfies an exclusion of the null value if it does not 
equal the null value of its type.</SPAN></DIV>
<DIV Class="paranum">16</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>elaboration (access_type_definition)</I> 
[partial]}</SPAN> <A NAME="I2387"></A>The elaboration of an <SPAN Class="swiss"><A HREF="AA-3-10.html#S0079">access_type_definition</A></SPAN> 
creates the access type and its first subtype. For an access-to-object 
type, this elaboration includes the elaboration of the <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0027">subtype_indication</A></SPAN>, 
which creates the designated subtype.</DIV>
<DIV Class="paranum">17/2</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00230.TXT">AI95-00230-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00254.TXT">AI95-00254-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>elaboration (access_definition)</I> 
[partial]}</SPAN> <A NAME="I2388"></A>The elaboration of an <SPAN Class="swiss"><A HREF="AA-3-10.html#S0084">access_definition</A></SPAN> 
creates an anonymous<SPAN class="delete2">&nbsp;general</SPAN> access<SPAN class="delete2">-to-variable</SPAN> 
type<SPAN class="delete2">&nbsp;[(this happens as part of the initialization 
of an access parameter or access discriminant)]</SPAN>.&nbsp;</DIV>
<DIV Class="NotesHeader">NOTES</DIV>
<DIV Class="paranum">18</DIV>
<DIV Class="Notes">81&nbsp;&nbsp;Access values are called &ldquo;pointers&rdquo; 
or &ldquo;references&rdquo; in some other languages.</DIV>
<DIV Class="paranum">19</DIV>
<DIV Class="Notes">82&nbsp;&nbsp;Each access-to-object type has an associated 
storage pool; several access types can share the same pool. An object 
can be created in the storage pool of an access type by an <SPAN Class="swiss"><A HREF="AA-4-8.html#S0129">allocator</A></SPAN> 
(see <A HREF="AA-4-8.html">4.8</A>) for the access type. A storage pool 
(roughly) corresponds to what some other languages call a &ldquo;heap.&rdquo; 
See <A HREF="AA-13-11.html">13.11</A> for a discussion of pools.</DIV>
<DIV Class="paranum">20</DIV>
<DIV Class="Notes">83&nbsp;&nbsp;Only <SPAN Class="swiss"><A HREF="AA-3-6-1.html#S0057">index_constraint</A></SPAN>s 
and <SPAN Class="swiss"><A HREF="AA-3-7-1.html#S0064">discriminant_constraint</A></SPAN>s 
can be applied to access types (see <A HREF="AA-3-6-1.html">3.6.1</A> 
and <A HREF="AA-3-7-1.html">3.7.1</A>).&nbsp;</DIV>

<H4 Class="centered">Examples</H4>
<DIV Class="paranum">21</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em"><I>Examples of access-to-object 
types:</I>&nbsp;</DIV>
<DIV Class="paranum">22/2</DIV>
<DIV Class="Examples">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00433.TXT">AI95-00433-01</A></I>} 
<B>type</B>&nbsp;Peripheral_Ref&nbsp;<B>is&nbsp;</B><SPAN class="insert2"><B>not&nbsp;null&nbsp;</B></SPAN><B>access</B>&nbsp;Peripheral;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;&nbsp;see&nbsp;<A HREF="AA-3-8-1.html">3.8.1</A></I></SPAN><BR>
<B>type</B>&nbsp;Binop_Ptr&nbsp;<B>is&nbsp;access&nbsp;all</B>&nbsp;Binary_Operation'Class;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;general&nbsp;access-to-class-wide,&nbsp;see&nbsp;<A HREF="AA-3-9-1.html">3.9.1</A></I></SPAN></DIV>
<DIV Class="paranum">23</DIV>
<DIV Class="Wide" Style="margin-bottom: 0.4em"><I>Example of an access 
subtype:</I>&nbsp;</DIV>
<DIV Class="paranum">24</DIV>
<DIV Class="Examples"><B>subtype</B>&nbsp;Drum_Ref&nbsp;<B>is</B>&nbsp;Peripheral_Ref(Drum);&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;&nbsp;see&nbsp;<A HREF="AA-3-8-1.html">3.8.1</A></I></SPAN></DIV>
<DIV Class="paranum">25</DIV>
<DIV Class="Wide" Style="margin-bottom: 0.4em"><I>Example of an access-to-subprogram 
type:</I>&nbsp;</DIV>
<DIV Class="paranum">26</DIV>
<DIV Class="Examples"><B>type</B>&nbsp;Message_Procedure&nbsp;<B>is</B>&nbsp;<B>access</B>&nbsp;<B>procedure</B>&nbsp;(M&nbsp;:&nbsp;<B>in</B>&nbsp;String&nbsp;:=&nbsp;&quot;Error!&quot;);<BR>
<B>procedure</B>&nbsp;Default_Message_Procedure(M&nbsp;:&nbsp;<B>in</B>&nbsp;String);<BR>
Give_Message&nbsp;:&nbsp;Message_Procedure&nbsp;:=&nbsp;Default_Message_Procedure'Access;<BR>
...<BR>
<B>procedure</B>&nbsp;Other_Procedure(M&nbsp;:&nbsp;<B>in</B>&nbsp;String);<BR>
...<BR>
Give_Message&nbsp;:=&nbsp;Other_Procedure'Access;<BR>
...<BR>
Give_Message(&quot;File&nbsp;not&nbsp;found.&quot;);&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;call&nbsp;with&nbsp;parameter&nbsp;(.<B>all</B>&nbsp;is&nbsp;optional)</I></SPAN><BR>
Give_Message.<B>all</B>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;call&nbsp;with&nbsp;no&nbsp;parameters</I></SPAN></DIV>

<H4 Class="centered">Extensions to Ada 83</H4>
<DIV Class="paranum">26.a</DIV>
<DIV Class="Annotations">{<I>extensions to Ada 83</I>} <A NAME="I2389"></A>The 
syntax for <SPAN Class="swiss"><A HREF="AA-3-10.html#S0079">access_type_definition</A></SPAN> 
is changed to support general access types (including access-to-constants) 
and access-to-subprograms. The syntax rules for <SPAN Class="swiss"><A HREF="AA-3-10.html#S0081">general_access_modifier</A></SPAN> 
and <SPAN Class="swiss"><A HREF="AA-3-10.html#S0084">access_definition</A></SPAN> 
are new.&nbsp;</DIV>

<H4 Class="centered">Wording Changes from Ada 83</H4>
<DIV Class="paranum">26.b</DIV>
<DIV Class="Annotations">We use the term &quot;storage pool&quot; to 
talk about the data area from which allocation takes place. The term 
&quot;collection&quot; is no longer used. (&quot;Collection&quot; and 
&quot;storage pool&quot; are not the same thing because multiple unrelated 
access types can share the same storage pool; see <A HREF="AA-13-11.html">13.11</A> 
for more discussion.)&nbsp;</DIV>

<H4 Class="centered">Inconsistencies With Ada 95</H4>
<DIV Class="paranum">26.c/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00231.TXT">AI95-00231-01</A></I>} 
<SPAN class="insert2">{<I>inconsistencies with Ada 95</I>} <A NAME="I2390"></A>Access 
discriminants and non-controlling access parameters no longer exclude 
null. A program which passed <B>null</B> to such an access discriminant 
or access parameter and expected it to raise Constraint_Error may fail 
when compiled with Ada 2005. One hopes that there no such programs outside 
of the ACATS. (Of course, a program which actually wants to pass <B>null</B> 
will work, which is far more likely.)</SPAN></DIV>
<DIV Class="paranum">26.d/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00363.TXT">AI95-00363-01</A></I>} 
<SPAN class="insert2">Most unconstrained aliased objects with defaulted 
discriminants are no longer constrained by their initial values. This 
means that a program that raised Constraint_Error from an attempt to 
change the discriminants will no longer do so. The change only affects 
programs that depended on the raising of Constraint_Error in this case, 
so the inconsistency is unlikely to occur outside of the ACATS. This 
change may however cause compilers to implement these objects differently, 
possibly taking additional memory or time. This is unlikely to be worse 
than the differences caused by any major compiler upgrade.</SPAN>&nbsp;</DIV>

<H4 Class="centered">Incompatibilities With Ada 95</H4>
<DIV Class="paranum">26.e/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00225.TXT">AI95-00225-01</A></I>} 
<SPAN class="insert2">{<I>incompatibilities with Ada 95</I>} <A NAME="I2391"></A><B>Amendment 
Correction:</B> The rule defining when a current instance of a limited 
type is considered to be aliased has been tightened to apply only to 
types that cannot become nonlimited. A program that attempts to take 
'Access of the current instance of a limited type that can become nonlimited 
will be illegal in Ada 2005. While original Ada 95 allowed the current 
instance of any limited type to be treated as aliased, this was inconsistently 
implemented in compilers, and was likely to not work as expected for 
types that are ultimately nonlimited.</SPAN>&nbsp;</DIV>

<H4 Class="centered">Extensions to Ada 95</H4>
<DIV Class="paranum">26.f/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00231.TXT">AI95-00231-01</A></I>} 
<SPAN class="insert2">{<I>extensions to Ada 95</I>} <A NAME="I2392"></A>The 
<SPAN Class="swiss"><A HREF="AA-3-10.html#S0083">null_exclusion</A></SPAN> 
is new. It can be used in both anonymous and named access type definitions. 
It is most useful to declare that parameters cannot be <B>null</B>, thus 
eliminating the need for checks on use.</SPAN></DIV>
<DIV Class="paranum">26.g/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00231.TXT">AI95-00231-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00254.TXT">AI95-00254-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00404.TXT">AI95-00404-01</A></I>} 
<SPAN class="insert2">The kinds of anonymous access types allowed were 
increased by adding anonymous access-to-constant and anonymous access-to-subprogram 
types. Anonymous access-to-subprogram types used as parameters allow 
passing of subprograms at any level.</SPAN>&nbsp;</DIV>

<H4 Class="centered">Wording Changes from Ada 95</H4>
<DIV Class="paranum">26.h/2</DIV>
<DIV Class="Annotations">{<I><A HREF="defect1.html#8652/0012">8652/0012</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00062.TXT">AI95-00062-01</A></I>} 
<SPAN class="insert2"><B>Corrigendum:</B> Added accidentally-omitted 
wording that says that a derived access type shares its storage pool 
with its parent type. This was clearly intended, both because of a note 
in <A HREF="AA-3-4.html">3.4</A>, and because anything else would have 
been incompatible with Ada 83.</SPAN></DIV>
<DIV Class="paranum">26.i/2</DIV>
<DIV Class="Annotations">{<I><A HREF="defect1.html#8652/0013">8652/0013</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00012.TXT">AI95-00012-01</A></I>} 
<SPAN class="insert2"><B>Corrigendum:</B> Fixed typographical errors 
in the description of when access types are constrained.</SPAN></DIV>
<DIV Class="paranum">26.j/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00230.TXT">AI95-00230-01</A></I>} 
<SPAN class="insert2">The wording was fixed to allow <SPAN Class="swiss"><A HREF="AA-4-8.html#S0129">allocator</A></SPAN>s 
and the literal <B>null</B> for anonymous access types. The former was 
clearly intended by Ada 95; see the Implementation Advice in <A HREF="AA-13-11.html">13.11</A>.</SPAN></DIV>
<DIV Class="paranum">26.k/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00363.TXT">AI95-00363-01</A></I>} 
<SPAN class="insert2">The rules about aliased objects being constrained 
by their initial values now apply only to allocated objects, and thus 
have been moved to <A HREF="AA-4-8.html">4.8</A>, &ldquo;<A HREF="AA-4-8.html">Allocators</A>&rdquo;.</SPAN> 
</DIV>

<HR>
<DIV Style="margin-top: 0.0em; margin-bottom: 0.6em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-3-9-4.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-3-10-1.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<DIV Style="margin-top:0.0em"><IMG SRC="AE_logo.gif" height=100 width=113 align=right ALT="Ada-Europe">
<SPAN Style="font-size: 125%">Sponsored by <SPAN Style="font-size: 125%"><A HREF="http://www.ada-europe.org/"><B>Ada-Europe</B></A></SPAN></SPAN></DIV>
</BODY>
</HTML>
