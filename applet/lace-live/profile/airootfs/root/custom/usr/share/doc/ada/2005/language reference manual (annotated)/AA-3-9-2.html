<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Dispatching Operations of Tagged Types</TITLE>
    <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    H4.centered {text-align: center}
    SPAN.swiss {font-family: Arial, Helvetica, sans-serif; font-size: 92%}
    SPAN.roman {font-family: "Times New Roman", Times, serif}
    DIV.paranum {float: left; font-family: Arial, Helvetica, sans-serif; font-size: 64%; width: 2.8em; margin-left: -0.4em; margin-right: -3.0em; margin-top: 0.2em}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    SPAN.insert1 {text-decoration: underline; color: rgb(0,51,51) }
    SPAN.delete1 {text-decoration: line-through; color: rgb(0,51,51) }
    SPAN.insert2 {text-decoration: underline; color: rgb(0,102,0) }
    SPAN.delete2 {text-decoration: line-through; color: rgb(0,102,0) }
    DIV.Normal {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.2em; margin-bottom: 0.6em}
    DIV.Annotations {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 6.2em; margin-bottom: 0.6em}
    DIV.Notes {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em; margin-bottom: 0.6em}
    DIV.NotesHeader {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em}
    DIV.SmallExamples {font-family: "Courier New", monospace; font-size: 72%; line-height: 122%; margin-left: 9.6em; margin-bottom: 0.6em}
    UL.Bulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.NestedBulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 5.2em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#000080" VLINK="#330033" ALINK="#0000FF">
<DIV><B><SPAN Style="font-size:200%; color: rgb(0,51,153)">Annotated</SPAN><SPAN Style="font-size:200%; color: rgb(0,0,102)">&nbsp;Ada Reference Manual</SPAN></B> &mdash; <A HREF="AA-TTL.html"><B>Legal Information</B></A></DIV>
<DIV Style="margin-top: 0.6em; margin-bottom: 0.0em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-3-9-1.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-3-9-3.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<HR>
<H1>3.9.2 Dispatching Operations of Tagged Types</H1>
<DIV Class="paranum">1/2</DIV>
<DIV Class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00335.TXT">AI95-00335-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>dispatching operation</I> [distributed]}</SPAN> 
<A NAME="I2253"></A><SPAN STYLE="font-size: 80%">{<I>dispatching call 
(on a dispatching operation)</I>}</SPAN> <A NAME="I2254"></A><SPAN STYLE="font-size: 80%">{<I>nondispatching 
call (on a dispatching operation)</I>}</SPAN> <A NAME="I2255"></A><SPAN STYLE="font-size: 80%">{<I>statically 
determined tag</I>}</SPAN> <A NAME="I2256"></A><SPAN STYLE="font-size: 80%">{<I>dynamically 
determined tag</I>}</SPAN> <A NAME="I2257"></A><SPAN STYLE="font-size: 80%">{<I>polymorphism</I>}</SPAN> 
<A NAME="I2258"></A><SPAN STYLE="font-size: 80%">{<I>run-time polymorphism</I>}</SPAN> 
<A NAME="I2259"></A><SPAN STYLE="font-size: 80%">{<I>controlling tag 
(for a call on a dispatching operation)</I>}</SPAN> <A NAME="I2260"></A>The 
primitive subprograms of a tagged type<SPAN class="insert2">, the subprograms 
declared by <SPAN Class="swiss"><A HREF="AA-12-6.html#S0277">formal_abstract_subprogram_declaration</A></SPAN>s, 
and the stream attributes of a specific tagged type that are available 
(see <A HREF="AA-13-13-2.html">13.13.2</A>) at the end of the declaration 
list where the type is declared</SPAN> are called <I>dispatching operations</I>. 
[A dispatching operation can be called using a statically determined 
<I>controlling</I> tag, in which case the body to be executed is determined 
at compile time. Alternatively, the controlling tag can be dynamically 
determined, in which case the call <I>dispatches</I> to a body that is 
determined at run time;] such a call is termed a <I>dispatching call</I>. 
[As explained below, the properties of the operands and the context of 
a particular call on a dispatching operation determine how the controlling 
tag is determined, and hence whether or not the call is a dispatching 
call. Run-time polymorphism is achieved when a dispatching operation 
is called by a dispatching call.] <SPAN STYLE="font-size: 80%">{<I>object-oriented 
programming (OOP): See dispatching operations of tagged types</I>}</SPAN> 
<A NAME="I2261"></A><SPAN STYLE="font-size: 80%">{<I>OOP (object-oriented 
programming): See dispatching operations of tagged types</I>}</SPAN> 
<A NAME="I2262"></A><SPAN STYLE="font-size: 80%">{<I>message: See dispatching 
call</I>}</SPAN> <A NAME="I2263"></A><SPAN STYLE="font-size: 80%">{<I>method: 
See dispatching subprogram</I>}</SPAN> <A NAME="I2264"></A><SPAN STYLE="font-size: 80%">{<I>virtual 
function: See dispatching subprogram</I>}</SPAN> <A NAME="I2265"></A></DIV>
<DIV Class="paranum">1.a.1/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Reason:&nbsp;</B></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00335.TXT">AI95-00335-01</A></I>} 
<SPAN class="insert2">For the stream attributes of a type declared immediately 
within a <SPAN Class="swiss"><A HREF="AA-7-1.html#S0174">package_specification</A></SPAN> 
that has a partial view, the declaration list to consider is the visible 
part of the package. Stream attributes that are not available in the 
same declaration list are not dispatching as there is no guarantee that 
descendants of the type have available attributes (there is such a guarantee 
for visibly available attributes). If we allowed dispatching for any 
available attribute, then for attributes defined in the private part 
we could end up executing a non-existent body.</SPAN>&nbsp;</DIV>

<H4 Class="centered">Language Design Principles</H4>
<DIV Class="paranum">1.a</DIV>
<DIV Class="Annotations">The controlling tag determination rules are 
analogous to the overload resolution rules, except they deal with run-time 
type identification (tags) rather than compile-time type resolution. 
As with overload resolution, controlling tag determination may depend 
on operands or result context.&nbsp;</DIV>

<H4 Class="centered">Static Semantics</H4>
<DIV Class="paranum">2/2</DIV>
<DIV Class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00416.TXT">AI95-00416-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>call on a dispatching operation</I>}</SPAN> 
<A NAME="I2266"></A><SPAN STYLE="font-size: 80%">{<I>dispatching operation</I>}</SPAN> 
<A NAME="I2267"></A>A <I>call on a dispatching operation</I> is a call 
whose <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
or <SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN> 
denotes the declaration of<SPAN class="delete2">&nbsp;a primitive subprogram 
of a tagged type, that is,</SPAN> a dispatching operation. <SPAN STYLE="font-size: 80%">{<I>controlling 
operand</I>}</SPAN> <A NAME="I2268"></A>A <I>controlling operand</I> 
in a call on a dispatching operation of a tagged type <I>T</I> is one 
whose corresponding formal parameter is of type <I>T</I> or is of an 
anonymous access type with designated type <I>T</I>; <SPAN STYLE="font-size: 80%">{<I>controlling 
formal parameter</I>}</SPAN> <A NAME="I2269"></A>the corresponding formal 
parameter is called a <I>controlling formal parameter</I>. If the controlling 
formal parameter is an access parameter, the controlling operand is the 
object designated by the actual parameter, rather than the actual parameter 
itself. <SPAN STYLE="font-size: 80%">{<I>controlling result</I>}</SPAN> 
<A NAME="I2270"></A>If the call is to a (primitive) function with result 
type <I>T</I>, then the call has a <I>controlling result</I> &mdash; 
the context of the call can control the dispatching.<SPAN class="insert2">&nbsp;Similarly, if the call is to a function with access result type designating 
<I>T</I>, then the call has a <I>controlling access result</I>, and the 
context can similarly control dispatching.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">2.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>This definition implies 
that a call through the dereference of an access-to-subprogram value 
is never considered a call on a dispatching operation. Note also that 
if the <SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN> 
denotes a <SPAN Class="swiss"><A HREF="AA-8-5.html#S0182">renaming_declaration</A></SPAN>, 
the place where the renaming occurs determines whether it is primitive; 
the thing being renamed is irrelevant.&nbsp;</DIV>
<DIV Class="paranum">3</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">A <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
or expression of a tagged type is either <I>statically</I> tagged, <I>dynamically</I> 
tagged, or <I>tag indeterminate</I>, according to whether, when used 
as a controlling operand, the tag that controls dispatching is determined 
statically by the operand's (specific) type, dynamically by its tag at 
run time, or from context. A <SPAN Class="swiss"><A HREF="AA-4-7.html#S0128">qualified_expression</A></SPAN> 
or parenthesized expression is statically, dynamically, or indeterminately 
tagged according to its operand. For other kinds of <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>s 
and expressions, this is determined as follows:&nbsp;</DIV>
<DIV Class="paranum">4/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00416.TXT">AI95-00416-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>statically tagged</I>}</SPAN> <A NAME="I2271"></A>The 
<SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> or expression 
is <I>statically tagged</I> if it is of a specific tagged type and, if 
it is a call with a controlling result<SPAN class="insert2">&nbsp;or controlling 
access result</SPAN>, it has at least one statically tagged controlling 
operand;&nbsp;</LI></UL>
<DIV Class="paranum">4.a</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>It is illegal to have both 
statically tagged and dynamically tagged controlling operands in the 
same call -- see below.&nbsp;</DIV>
<DIV Class="paranum">5/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00416.TXT">AI95-00416-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>dynamically tagged</I>}</SPAN> <A NAME="I2272"></A>The 
<SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> or expression 
is <I>dynamically tagged</I> if it is of a class-wide type, or it is 
a call with a controlling result<SPAN class="insert2">&nbsp;or controlling 
access result</SPAN> and at least one dynamically tagged controlling 
operand;</LI></UL>
<DIV Class="paranum">6/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00416.TXT">AI95-00416-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>tag indeterminate</I>}</SPAN> <A NAME="I2273"></A>The 
<SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> or expression 
is <I>tag indeterminate</I> if it is a call with a controlling result<SPAN class="insert2">&nbsp;or controlling access result</SPAN>, all of whose controlling operands 
(if any) are tag indeterminate.&nbsp;</LI></UL>
<DIV Class="paranum">7/1</DIV>
<DIV Class="Normal">{<I><A HREF="defect1.html#8652/0010">8652/0010</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00127.TXT">AI95-00127-01</A></I>} 
[A <SPAN Class="swiss"><A HREF="AA-4-6.html#S0127">type_conversion</A></SPAN> 
is statically or dynamically tagged according to whether the type determined 
by the <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0028">subtype_mark</A></SPAN> 
is specific or class-wide, respectively.] <SPAN class="insert1">For an 
object that is designated by an expression whose expected type is an 
anonymous access-to-specific tagged type, the object is dynamically tagged 
if the expression, ignoring enclosing parentheses, is of the form X'Access, 
where X is of a class-wide type, or is of the form <B>new</B> T'(...), 
where T denotes a class-wide subtype. Otherwise, the object</SPAN><SPAN class="delete1">&nbsp;For 
a controlling operand that is designated by an actual parameter, the 
controlling operand</SPAN> is statically or dynamically tagged according 
to whether the designated type <SPAN class="insert1">of the type of the 
expression</SPAN><SPAN class="delete1">&nbsp;of the actual parameter</SPAN> 
is specific or class-wide, respectively.&nbsp;</DIV>
<DIV Class="paranum">7.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>A <SPAN Class="swiss"><A HREF="AA-4-6.html#S0127">type_conversion</A></SPAN> 
is never tag indeterminate, even if its operand is. A designated object 
is never tag indeterminate.</DIV>
<DIV Class="paranum">7.a.1/1</DIV>
<DIV Class="Annotations">{<I><A HREF="defect1.html#8652/0010">8652/0010</A></I>} 
<SPAN class="insert1"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00127.TXT">AI95-00127-01</A></I>} 
<SPAN class="insert1">Allocators and access attributes of class-wide 
types can be used as the controlling parameters of dispatching calls.</SPAN> 
</DIV>

<H4 Class="centered">Legality Rules</H4>
<DIV Class="paranum">8</DIV>
<DIV Class="Normal">A call on a dispatching operation shall not have 
both dynamically tagged and statically tagged controlling operands.&nbsp;</DIV>
<DIV Class="paranum">8.a</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>This restriction is intended 
to minimize confusion between whether the dynamically tagged operands 
are implicitly converted to, or tag checked against the specific type 
of the statically tagged operand(s).&nbsp;</DIV>
<DIV Class="paranum">9/1</DIV>
<DIV Class="Normal">{<I><A HREF="defect1.html#8652/0010">8652/0010</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00127.TXT">AI95-00127-01</A></I>} 
If the expected type for an expression or <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
is some specific tagged type, then the expression or <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
shall not be dynamically tagged unless it is a controlling operand in 
a call on a dispatching operation. Similarly, if the expected type for 
an expression is an anonymous access-to-specific tagged type, then the 
<SPAN class="insert1">object designated by the expression shall not be 
dynamically tagged unless it is</SPAN><SPAN class="delete1">&nbsp;expression 
shall not be of an access-to-class-wide type unless it designates</SPAN> 
a controlling operand in a call on a dispatching operation.&nbsp;</DIV>
<DIV Class="paranum">9.a</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>This prevents implicit &quot;truncation&quot; 
of a dynamically-tagged value to the specific type of the target object/formal. 
An explicit conversion is required to request this truncation.&nbsp;</DIV>
<DIV Class="paranum">9.b/2</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00252.TXT">AI95-00252-01</A></I>} 
This rule applies to all expressions or <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>s 
with a specific expected type, not just those that are actual parameters 
to a dispatching call. This rule does not apply to a membership test 
whose <SPAN Class="swiss"><A HREF="AA-4-4.html#S0115">expression</A></SPAN> 
is class-wide, since any type that covers the tested type is explicitly 
allowed. See <A HREF="AA-4-5-2.html">4.5.2</A>.<SPAN class="insert2">&nbsp;This rule also doesn't apply to a <SPAN Class="swiss"><A HREF="AA-4-1-3.html#S0098">selected_component</A></SPAN> 
whose <SPAN Class="swiss"><A HREF="AA-4-1-3.html#S0099">selector_name</A></SPAN> 
is a subprogram, since the rules explicitly say that the prefix may be 
class-wide (see <A HREF="AA-4-1-3.html">4.1.3</A>).</SPAN>&nbsp;</DIV>
<DIV Class="paranum">10/2</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="defect1.html#8652/0011">8652/0011</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00117.TXT">AI95-00117-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00430.TXT">AI95-00430-01</A></I>} 
In the declaration of a dispatching operation of a tagged type, everywhere 
a subtype of the tagged type appears as a subtype of the profile (see 
<A HREF="AA-6-1.html">6.1</A>), it shall statically match the first subtype 
of the tagged type. <SPAN STYLE="font-size: 80%">{<I>statically matching 
(required)</I> [partial]}</SPAN> <A NAME="I2274"></A>If the dispatching 
operation overrides an inherited subprogram, it shall be subtype conformant 
with the inherited subprogram. <SPAN STYLE="font-size: 80%">{<I>subtype 
conformance (required)</I>}</SPAN> <A NAME="I2275"></A><SPAN class="insert1">The 
convention of an inherited&nbsp;</SPAN><SPAN class="insert1"><SPAN class="delete2">or 
overriding&nbsp;</SPAN></SPAN><SPAN class="insert1">dispatching operation 
is the convention of the corresponding primitive operation of the parent 
</SPAN><SPAN class="insert2">or progenitor&nbsp;</SPAN><SPAN class="insert1">type. 
</SPAN><SPAN class="insert2">The default convention of a dispatching 
operation that overrides an inherited primitive operation is the convention 
of the inherited operation; if the operation overrides multiple inherited 
operations, then they shall all have the same convention.&nbsp;</SPAN><SPAN class="insert1">An 
explicitly declared</SPAN><SPAN class="delete1">&nbsp;A</SPAN> dispatching 
operation shall not be of convention Intrinsic.<SPAN class="delete1">&nbsp;If a dispatching operation overrides the predefined equals operator, 
then it shall be of convention Ada [(either explicitly or by default 
&mdash; see <A HREF="AA-6-3-1.html">6.3.1</A>)].</SPAN>&nbsp;</DIV>
<DIV Class="paranum">10.a</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>These rules ensure that constraint 
checks can be performed by the caller in a dispatching call, and parameter 
passing conventions match up properly. A special rule on aggregates prevents 
values of a tagged type from being created that are outside of its first 
subtype.&nbsp;</DIV>
<DIV Class="paranum">11/2</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00416.TXT">AI95-00416-01</A></I>} 
The <SPAN Class="swiss"><A HREF="AA-3-7.html#S0063">default_expression</A></SPAN> 
for a controlling formal parameter of a dispatching operation shall be 
tag indeterminate.<SPAN class="delete2">&nbsp;A controlling formal parameter 
that is an access parameter shall not have a <SPAN Class="swiss"><A HREF="AA-3-7.html#S0063">default_expression</A></SPAN>.</SPAN> 
</DIV>
<DIV Class="paranum">11.a/2</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00416.TXT">AI95-00416-01</A></I>} 
<SPAN class="insert2">This rule</SPAN><SPAN class="delete2">&nbsp;The first 
part</SPAN> ensures that the <SPAN Class="swiss"><A HREF="AA-3-7.html#S0063">default_expression</A></SPAN> 
always produces the &quot;correct&quot; tag when called with or without 
dispatching, or when inherited by a descendant. If it were statically 
tagged, the default would be useless for a dispatching call; if it were 
dynamically tagged, the default would be useless for a nondispatching 
call.</DIV>
<DIV Class="paranum">11.b/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00416.TXT">AI95-00416-01</A></I>} 
<SPAN class="delete2">The second part is consistent with the first part, 
since designated objects are never tag-indeterminate.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">11.1/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00404.TXT">AI95-00404-01</A></I>} 
<SPAN class="insert2">If a dispatching operation is defined by a <SPAN Class="swiss"><A HREF="AA-8-5-4.html#S0186">subprogram_renaming_declaration</A></SPAN> 
or the instantiation of a generic subprogram, any access parameter of 
the renamed subprogram or the generic subprogram that corresponds to 
a controlling access parameter of the dispatching operation, shall have 
a subtype that excludes null.</SPAN></DIV>
<DIV Class="paranum">12</DIV>
<DIV Class="Normal">A given subprogram shall not be a dispatching operation 
of two or more distinct tagged types.&nbsp;</DIV>
<DIV Class="paranum">12.a</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>This restriction minimizes confusion 
since multiple dispatching is not provided. The normal solution is to 
replace all but one of the tagged types with their class-wide types. 
</DIV>
<DIV Class="paranum">12.a.1/1</DIV>
<DIV Class="Annotations"><SPAN class="insert1"><B>Ramification:&nbsp;</B></SPAN>{<I><A HREF="defect2.html#8652/0098">8652/0098</A></I>} 
<SPAN class="insert1"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00183.TXT">AI95-00183-01</A></I>} 
<SPAN class="insert1">This restriction applies even if the partial view 
(see <A HREF="AA-7-3.html">7.3</A>) of one or both of the types is untagged. 
This follows from the definition of dispatching operation: the operation 
is a dispatching operation anywhere the full views of the (tagged) types 
are visible.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">13</DIV>
<DIV Class="Normal">The explicit declaration of a primitive subprogram 
of a tagged type shall occur before the type is frozen (see <A HREF="AA-13-14.html">13.14</A>). 
[For example, new dispatching operations cannot be added after objects 
or values of the type exist, nor after deriving a record extension from 
it, nor after a body.]</DIV>
<DIV Class="paranum">13.a/2</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00344.TXT">AI95-00344-01</A></I>} 
This rule is needed because (1) we don't want people dispatching to things 
that haven't been declared yet, and (2) we want to allow <SPAN class="insert2">the 
static part of&nbsp;</SPAN>tagged type descriptors to be static (allocated 
statically, and initialized to link-time-known symbols). Suppose T2 inherits 
primitive P from T1, and then overrides P. Suppose P is called <I>before</I> 
the declaration of the overriding P. What should it dispatch to? If the 
answer is the new P, we've violated the first principle above. If the 
answer is the old P, we've violated the second principle. (A call to 
the new one necessarily raises Program_Error, but that's beside the point.)</DIV>
<DIV Class="paranum">13.b</DIV>
<DIV Class="Annotations">Note that a call upon a dispatching operation 
of type <I>T</I> will freeze <I>T</I>.</DIV>
<DIV Class="paranum">13.c</DIV>
<DIV Class="Annotations">We considered applying this rule to all derived 
types, for uniformity. However, that would be upward incompatible, so 
we rejected the idea. As in Ada 83, for an untagged type, the above call 
upon P will call the old P (which is arguably confusing).&nbsp;</DIV>
<DIV Class="paranum">13.d/2</DIV>
<DIV Class="Annotations"><B>Implementation Note:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00326.TXT">AI95-00326-01</A></I>} 
Because of this rule, the type descriptor can be created (presumably 
containing linker symbols pointing at the not-yet-compiled bodies) at 
the first freezing point of the type. It also prevents, for a <SPAN class="insert2">(non-incomplete) 
</SPAN>tagged type declared in a <SPAN Class="swiss"><A HREF="AA-7-1.html#S0174">package_specification</A></SPAN>, 
overriding in the body or by a child subprogram.&nbsp;</DIV>
<DIV Class="paranum">13.e/2</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
A consequence is that for a <SPAN class="insert2">tagged type declaration</SPAN><SPAN class="delete2"><SPAN Class="swiss">&nbsp;derived_type_declaration</SPAN></SPAN> 
in a <SPAN Class="swiss"><A HREF="AA-3-11.html#S0086">declarative_part</A></SPAN>, 
only the <SPAN class="insert2">last (overriding)</SPAN><SPAN class="delete2">&nbsp;first</SPAN> 
primitive subprogram can be declared by a <SPAN Class="swiss"><A HREF="AA-6-3.html#S0162">subprogram_body</A></SPAN>.<SPAN class="insert2">&nbsp;(Other overridings must be provided by <SPAN Class="swiss"><A HREF="AA-6-1.html#S0148">subprogram_declaration</A></SPAN>s.)</SPAN> 
</DIV>

<H4 Class="centered">Dynamic Semantics</H4>
<DIV Class="paranum">14</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em"><SPAN STYLE="font-size: 80%">{<I>execution 
(call on a dispatching operation)</I> [partial]}</SPAN> <A NAME="I2276"></A><SPAN STYLE="font-size: 80%">{<I>controlling 
tag value</I>}</SPAN> <A NAME="I2277"></A>For the execution of a call 
on a dispatching operation of a type <I>T</I>, the <I>controlling tag 
value</I> determines which subprogram body is executed. The controlling 
tag value is defined as follows:&nbsp;</DIV>
<DIV Class="paranum">15</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN STYLE="font-size: 80%">{<I>statically 
determined tag</I> [partial]}</SPAN> <A NAME="I2278"></A>If one or more 
controlling operands are statically tagged, then the controlling tag 
value is <I>statically determined</I> to be the tag of <I>T</I>.</LI></UL>
<DIV Class="paranum">16</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>If one or more controlling operands 
are dynamically tagged, then the controlling tag value is not statically 
determined, but is rather determined by the tags of the controlling operands. 
<SPAN STYLE="font-size: 80%">{<I>Tag_Check</I> [partial]}</SPAN> <A NAME="I2279"></A><SPAN STYLE="font-size: 80%">{<I>check, 
language-defined (Tag_Check)</I>}</SPAN> <A NAME="I2280"></A>If there 
is more than one dynamically tagged controlling operand, a check is made 
that they all have the same tag. <SPAN STYLE="font-size: 80%">{<I>Constraint_Error 
(raised by failure of run-time check)</I>}</SPAN> <A NAME="I2281"></A>If 
this check fails, Constraint_Error is raised unless the call is a <SPAN Class="swiss"><A HREF="AA-6-4.html#S0164">function_call</A></SPAN> 
whose <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
denotes the declaration of an equality operator (predefined or user defined) 
that returns Boolean, in which case the result of the call is defined 
to indicate inequality, and no <SPAN Class="swiss"><A HREF="AA-6-3.html#S0162">subprogram_body</A></SPAN> 
is executed. This check is performed prior to evaluating any tag-indeterminate 
controlling operands.&nbsp;</LI></UL>
<DIV Class="paranum">16.a</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>Tag mismatch is considered an 
error (except for &quot;=&quot; and &quot;/=&quot;) since the corresponding 
primitive subprograms in each specific type expect all controlling operands 
to be of the same type. For tag mismatch with an equality operator, rather 
than raising an exception, &quot;=&quot; returns False and &quot;/=&quot; 
returns True. No equality operator is actually invoked, since there is 
no common tag value to control the dispatch. Equality is a special case 
to be consistent with the existing Ada 83 principle that equality comparisons, 
even between objects with different constraints, never raise Constraint_Error. 
</DIV>
<DIV Class="paranum">17/2</DIV>
<UL Class="Bulleted" Style="margin-bottom: 0.3em"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00196.TXT">AI95-00196-01</A></I>} 
If all of the controlling operands <SPAN class="insert2">(if any)&nbsp;</SPAN>are 
tag-indeterminate, then:&nbsp;</LI></UL>
<DIV Class="paranum">18/2</DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00239.TXT">AI95-00239-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00416.TXT">AI95-00416-01</A></I>} 
If the call has a controlling result<SPAN class="insert2">&nbsp;or controlling 
access result</SPAN> and is itself<SPAN class="insert2">, or designates,</SPAN> 
a (possibly parenthesized or qualified) controlling operand of an enclosing 
call on a dispatching operation of <SPAN class="insert2">a descendant 
of&nbsp;</SPAN>type <I>T</I>, then its controlling tag value is determined 
by the controlling tag value of this enclosing call;</LI></UL>
<DIV Class="paranum">18.a/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Discussion:&nbsp;</B></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00239.TXT">AI95-00239-01</A></I>} 
<SPAN class="insert2">For code that a user can write explicitly, the 
only contexts that can control dispatching of a function with a controlling 
result of type T are those that involve controlling operands of the same 
type T: if the two types differ there is an illegality and the dynamic 
semantics are irrelevant.</SPAN></DIV>
<DIV Class="paranum">18.b/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2">In the case of an inherited 
subprogram however, if a default expression is a function call, it may 
be of type T while the parameter is of a type derived from T. To cover 
this case, we talk about &quot;a descendant of T&quot; above. This is 
safe, because if the type of the parameter is descended from the type 
of the function result, it is guaranteed to inherit or override the function, 
and this ensures that there will be an appropriate body to dispatch to. 
Note that abstract functions are not an issue here because the call to 
the function is a dispatching call, so it is guaranteed to always land 
on a concrete body.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">18.1/2</DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00196.TXT">AI95-00196-01</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00416.TXT">AI95-00416-01</A></I>} 
<SPAN class="insert2">If the call has a controlling result or controlling 
access result and (possibly parenthesized, qualified, or dereferenced) 
is the expression of an <SPAN Class="swiss"><A HREF="AA-5-2.html#S0137">assignment_statement</A></SPAN> 
whose target is of a class-wide type, then its controlling tag value 
is determined by the target;</SPAN></LI></UL>
<DIV Class="paranum">19</DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC><SPAN STYLE="font-size: 80%">{<I>statically 
determined tag</I> [partial]}</SPAN> <A NAME="I2282"></A>Otherwise, the 
controlling tag value is statically determined to be the tag of type 
<I>T</I>.&nbsp;</LI></UL>
<DIV Class="paranum">19.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>This includes the cases 
of a tag-indeterminate procedure call, and a tag-indeterminate <SPAN Class="swiss"><A HREF="AA-6-4.html#S0164">function_call</A></SPAN> 
that is used to initialize a class-wide formal parameter or class-wide 
object.&nbsp;</DIV>
<DIV Class="paranum">20/2</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00345.TXT">AI95-00345-01</A></I>} 
<SPAN class="insert2"></SPAN>For the execution of a call on a dispatching 
operation, the <SPAN class="insert2">action performed is determined by 
the properties of the corresponding dispatching operation</SPAN><SPAN class="delete2">&nbsp;body 
executed is the one for the corresponding primitive subprogram</SPAN> 
of the specific type identified by the controlling tag value. <SPAN class="insert2">If 
the corresponding operation is</SPAN><SPAN class="delete2">&nbsp;The body 
for an</SPAN> explicitly declared <SPAN class="insert2">for this type, 
[even if the declaration occurs in a private part], then the action comprises 
an invocation of the</SPAN><SPAN class="delete2">&nbsp;dispatching operation 
is the corresponding</SPAN> explicit body for the <SPAN class="insert2">operation. 
If the corresponding operation is implicitly declared for this type:</SPAN><SPAN class="delete2">&nbsp;subprogram. 
The body for an implicitly declared dispatching operation that is overridden 
is the body for the overriding subprogram, [even if the overriding occurs 
in a private part.] The body for an inherited dispatching operation that 
is not overridden is the body of the corresponding subprogram of the 
parent or ancestor type.</SPAN></DIV>
<DIV Class="paranum">20.1/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00345.TXT">AI95-00345-01</A></I>} 
<SPAN class="insert2">if the operation is implemented by an entry or 
protected subprogram (see <A HREF="AA-9-1.html">9.1</A> and <A HREF="AA-9-4.html">9.4</A>), 
then the action comprises a call on this entry or protected subprogram, 
with the target object being given by the first actual parameter of the 
call, and the actual parameters of the entry or protected subprogram 
being given by the remaining actual parameters of the call, if any;</SPAN></LI></UL>
<DIV Class="paranum">20.2/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00345.TXT">AI95-00345-01</A></I>} 
<SPAN class="insert2">otherwise, the action is the same as the action 
for the corresponding operation of the parent type.</SPAN>&nbsp;</LI></UL>
<DIV Class="paranum">20.a</DIV>
<DIV Class="Annotations"><B>To be honest:&nbsp;</B>In the unusual case in 
which a dispatching subprogram is explicitly declared (overridden) by 
a body (with no preceding <SPAN Class="swiss"><A HREF="AA-6-1.html#S0148">subprogram_declaration</A></SPAN>), 
the body for that dispatching subprogram is that body; that is, the &ldquo;corresponding 
explicit body&rdquo; in the above rule is the body itself.&nbsp;</DIV>
<DIV Class="paranum">20.b</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><B>Reason:&nbsp;</B>The 
wording of the above rule is intended to ensure that the same body is 
executed for a given tag, whether that tag is determined statically or 
dynamically. For a type declared in a package, it doesn't matter whether 
a given subprogram is overridden in the visible part or the private part, 
and it doesn't matter whether the call is inside or outside the package. 
For example:&nbsp;</DIV>
<DIV Class="paranum">20.c</DIV>
<DIV Class="SmallExamples"><B>package</B>&nbsp;P1&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T1&nbsp;<B>is</B>&nbsp;<B>tagged</B>&nbsp;<B>null</B>&nbsp;<B>record</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Op_A(Arg&nbsp;:&nbsp;<B>in</B>&nbsp;T1);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Op_B(Arg&nbsp;:&nbsp;<B>in</B>&nbsp;T1);<BR>
<B>end</B>&nbsp;P1;</DIV>
<DIV Class="paranum">20.d</DIV>
<DIV Class="SmallExamples"><B>with</B>&nbsp;P1;&nbsp;<B>use</B>&nbsp;P1;<BR>
<B>package</B>&nbsp;P2&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T2&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;T1&nbsp;<B>with</B>&nbsp;<B>null</B>&nbsp;<B>record</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Op_A(Param&nbsp;:&nbsp;<B>in</B>&nbsp;T2);<BR>
<B>private</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Op_B(Param&nbsp;:&nbsp;<B>in</B>&nbsp;T2);<BR>
<B>end</B>&nbsp;P2;</DIV>
<DIV Class="paranum">20.e/1</DIV>
<DIV Class="SmallExamples"><B>with</B>&nbsp;P1;&nbsp;<B>with</B>&nbsp;P2;<BR>
<B>procedure</B>&nbsp;Main&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;:&nbsp;<SPAN class="insert1">P2.</SPAN> T2;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Y&nbsp;:&nbsp;<SPAN class="insert1">P1.</SPAN> T1'Class&nbsp;:=&nbsp;X;<BR>
<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;P2.Op_A(Param&nbsp;=&gt;&nbsp;X);&nbsp;--<SPAN Class="roman"><I>&nbsp;Nondispatching&nbsp;call</I></SPAN><SPAN class="insert1"><SPAN Class="roman"><I>&nbsp;to&nbsp;a&nbsp;dispatching&nbsp;operation</I></SPAN></SPAN><SPAN Class="roman"><I>.</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;P1.Op_A(Arg&nbsp;=&gt;&nbsp;Y);&nbsp;--<SPAN Class="roman"><I>&nbsp;Dispatching&nbsp;call.</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;P2.Op_B(Arg&nbsp;=&gt;&nbsp;X);&nbsp;--<SPAN Class="roman"><I>&nbsp;Nondispatching&nbsp;call</I></SPAN><SPAN class="insert1"><SPAN Class="roman"><I>&nbsp;to&nbsp;a&nbsp;dispatching&nbsp;operation</I></SPAN></SPAN><SPAN Class="roman"><I>.</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;P1.Op_B(Arg&nbsp;=&gt;&nbsp;Y);&nbsp;--<SPAN Class="roman"><I>&nbsp;Dispatching&nbsp;call.</I></SPAN><BR>
<B>end</B>&nbsp;Main;</DIV>
<DIV Class="paranum">20.f</DIV>
<DIV Class="Annotations">The two calls to Op_A both execute the body 
of Op_A that has to occur in the body of package P2. Similarly, the two 
calls to Op_B both execute the body of Op_B that has to occur in the 
body of package P2, even though Op_B is overridden in the private part 
of P2. Note, however, that the formal parameter names are different for 
P2.Op_A versus P2.Op_B. The overriding declaration for P2.Op_B is not 
visible in Main, so the name in the call actually denotes the implicit 
declaration of Op_B inherited from T1.</DIV>
<DIV Class="paranum">20.g</DIV>
<DIV Class="Annotations">If a call occurs in the program text before 
an overriding, which can happen only if the call is part of a default 
expression, the overriding will still take effect for that call.</DIV>
<DIV Class="paranum">20.h</DIV>
<DIV Class="Annotations"><B>Implementation Note:&nbsp;</B>Even when a tag 
is not <I>statically determined</I>, a compiler might still be able to 
figure it out and thereby avoid the overhead of run-time dispatching.</DIV>
<DIV Class="NotesHeader">NOTES</DIV>
<DIV Class="paranum">21</DIV>
<DIV Class="Notes">73&nbsp;&nbsp;The body to be executed for a call on 
a dispatching operation is determined by the tag; it does not matter 
whether that tag is determined statically or dynamically, and it does 
not matter whether the subprogram's declaration is visible at the place 
of the call.</DIV>
<DIV Class="paranum">22/2</DIV>
<DIV Class="Notes">74&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
This subclause covers calls on <SPAN class="insert2">dispatching</SPAN><SPAN class="delete2">&nbsp;primitive</SPAN> 
subprograms of a tagged type. Rules for tagged type membership tests 
are described in <A HREF="AA-4-5-2.html">4.5.2</A>. Controlling tag determination 
for an <SPAN Class="swiss"><A HREF="AA-5-2.html#S0137">assignment_statement</A></SPAN> 
is described in <A HREF="AA-5-2.html">5.2</A>.</DIV>
<DIV Class="paranum">23</DIV>
<DIV Class="Notes">75&nbsp;&nbsp;A dispatching call can dispatch to a 
body whose declaration is not visible at the place of the call.</DIV>
<DIV Class="paranum">24</DIV>
<DIV Class="Notes">76&nbsp;&nbsp;A call through an access-to-subprogram 
value is never a dispatching call, even if the access value designates 
a dispatching operation. Similarly a call whose <SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN> 
denotes a <SPAN Class="swiss"><A HREF="AA-8-5-4.html#S0186">subprogram_renaming_declaration</A></SPAN> 
cannot be a dispatching call unless the renaming itself is the declaration 
of a primitive subprogram.&nbsp;</DIV>

<H4 Class="centered">Extensions to Ada 83</H4>
<DIV Class="paranum">24.a</DIV>
<DIV Class="Annotations">{<I>extensions to Ada 83</I>} <A NAME="I2283"></A>The 
concept of dispatching operations is new.&nbsp;</DIV>

<H4 Class="centered">Incompatibilities With Ada 95</H4>
<DIV Class="paranum">24.b/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00404.TXT">AI95-00404-01</A></I>} 
<SPAN class="insert2">{<I>incompatibilities with Ada 95</I>} <A NAME="I2284"></A>If 
a dispatching operation is defined by a <SPAN Class="swiss"><A HREF="AA-8-5-4.html#S0186">subprogram_renaming_declaration</A></SPAN>, 
and it has a controlling access parameter, Ada 2005 requires the subtype 
of the parameter to exclude null. The same applies to instantiations. 
This is required so that all calls to the subprogram operate the same 
way (controlling access parameters have to exclude null so that dispatching 
calls will work). Since Ada 95 didn't have the notion of access subtypes 
that exclude null, and all access parameters excluded null, it had no 
such rules. These rules will require the addition of an explicit <B>not 
null</B> on nondispatching operations that are later renamed to be dispatching, 
or on a generic that is used to define a dispatching operation.</SPAN> 
</DIV>

<H4 Class="centered">Extensions to Ada 95</H4>
<DIV Class="paranum">24.c/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00416.TXT">AI95-00416-01</A></I>} 
<SPAN class="insert2">{<I>extensions to Ada 95</I>} <A NAME="I2285"></A>Functions 
that have an access result type can be dispatching in the same way as 
a function that returns a tagged object directly.</SPAN>&nbsp;</DIV>

<H4 Class="centered">Wording Changes from Ada 95</H4>
<DIV Class="paranum">24.d/2</DIV>
<DIV Class="Annotations">{<I><A HREF="defect1.html#8652/0010">8652/0010</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00127.TXT">AI95-00127-01</A></I>} 
<SPAN class="insert2"><B>Corrigendum:</B> Allocators and access attributes 
of objects of class-wide types can be used as the controlling parameter 
in a dispatching calls. This was an oversight in the definition of Ada 
95. (See <A HREF="AA-3-10-2.html">3.10.2</A> and <A HREF="AA-4-8.html">4.8</A>).</SPAN></DIV>
<DIV Class="paranum">24.e/2</DIV>
<DIV Class="Annotations">{<I><A HREF="defect1.html#8652/0011">8652/0011</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00117.TXT">AI95-00117-01</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00430.TXT">AI95-00430-01</A></I>} 
<SPAN class="insert2"><B>Corrigendum:</B> Corrected the conventions of 
dispatching operations. This is extended in Ada 2005 to cover operations 
inherited from progenitors, and to ensure that the conventions of all 
inherited operations are the same.</SPAN></DIV>
<DIV Class="paranum">24.f/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00196.TXT">AI95-00196-01</A></I>} 
<SPAN class="insert2">Clarified the wording to ensure that functions 
with no controlling operands are tag-indeterminate, and to describe that 
the controlling tag can come from the target of an <SPAN Class="swiss"><A HREF="AA-5-2.html#S0137">assignment_statement</A></SPAN>.</SPAN></DIV>
<DIV Class="paranum">24.g/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00239.TXT">AI95-00239-01</A></I>} 
<SPAN class="insert2">Fixed the wording to cover default expressions 
inherited by derived subprograms. A literal reading of the old wording 
would have implied that operations would be called with objects of the 
wrong type.</SPAN></DIV>
<DIV Class="paranum">24.h/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
<SPAN class="insert2">An abstract formal subprogram is a dispatching 
operation, even though it is not a primitive operation. See <A HREF="AA-12-6.html">12.6</A>, 
&ldquo;<A HREF="AA-12-6.html">Formal Subprograms</A>&rdquo;.</SPAN></DIV>
<DIV Class="paranum">24.i/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00345.TXT">AI95-00345-01</A></I>} 
<SPAN class="insert2">Dispatching calls include operations implemented 
by entries and protected operations, so we have to update the wording 
to reflect that.</SPAN></DIV>
<DIV Class="paranum">24.j/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00335.TXT">AI95-00335-01</A></I>} 
<SPAN class="insert2">A stream attribute of a tagged type is usually 
a dispatching operation, even though it is not a primitive operation. 
If they weren't dispatching, T'Class'Input and T'Class'Output wouldn't 
work.</SPAN>&nbsp;</DIV>

<HR>
<DIV Style="margin-top: 0.0em; margin-bottom: 0.6em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-3-9-1.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-3-9-3.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<DIV Style="margin-top:0.0em"><IMG SRC="AE_logo.gif" height=100 width=113 align=right ALT="Ada-Europe">
<SPAN Style="font-size: 125%">Sponsored by <SPAN Style="font-size: 125%"><A HREF="http://www.ada-europe.org/"><B>Ada-Europe</B></A></SPAN></SPAN></DIV>
</BODY>
</HTML>
