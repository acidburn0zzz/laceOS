<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Tagged Types and Type Extensions</TITLE>
    <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    H4.centered {text-align: center}
    SPAN.swiss {font-family: Arial, Helvetica, sans-serif; font-size: 92%}
    SPAN.roman {font-family: "Times New Roman", Times, serif}
    DIV.paranum {float: left; font-family: Arial, Helvetica, sans-serif; font-size: 64%; width: 2.8em; margin-left: -0.4em; margin-right: -3.0em; margin-top: 0.2em}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    SPAN.insert2 {text-decoration: underline; color: rgb(0,102,0) }
    SPAN.delete2 {text-decoration: line-through; color: rgb(0,102,0) }
    DIV.Normal {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.2em; margin-bottom: 0.6em}
    DIV.Annotations {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 6.2em; margin-bottom: 0.6em}
    DIV.Notes {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em; margin-bottom: 0.6em}
    DIV.NotesHeader {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em}
    DIV.Examples {font-family: "Courier New", monospace; font-size: 90%; line-height: 122%; margin-left: 3.4em; margin-bottom: 0.6em}
    UL.Bulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    DIV.Hanging-Body {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 7.2em; margin-top: 0em; margin-bottom: 0.6em}
    DIV.Hanging-Term {float: left; font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.2em; margin-top: 0em; margin-bottom: 0em}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#000080" VLINK="#330033" ALINK="#0000FF">
<DIV><B><SPAN Style="font-size:200%; color: rgb(0,51,153)">Annotated</SPAN><SPAN Style="font-size:200%; color: rgb(0,0,102)">&nbsp;Ada Reference Manual</SPAN></B> &mdash; <A HREF="AA-TTL.html"><B>Legal Information</B></A></DIV>
<DIV Style="margin-top: 0.6em; margin-bottom: 0.0em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-3-8-1.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-3-9-1.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<HR>
<H1>3.9 Tagged Types and Type Extensions</H1>
<DIV Class="paranum">1</DIV>
<DIV Class="Normal">[<SPAN STYLE="font-size: 80%">{<I>dispatching operation</I> 
[partial]}</SPAN> <A NAME="I2177"></A><SPAN STYLE="font-size: 80%">{<I>polymorphism</I>}</SPAN> 
<A NAME="I2178"></A><SPAN STYLE="font-size: 80%">{<I>dynamic binding: 
See dispatching operation</I>}</SPAN> <A NAME="I2179"></A><SPAN STYLE="font-size: 80%">{<I>generic 
unit: See also dispatching operation</I>}</SPAN> <A NAME="I2180"></A><SPAN STYLE="font-size: 80%">{<I>variant: 
See also tagged type</I>}</SPAN> <A NAME="I2181"></A>Tagged types and 
type extensions support object-oriented programming, based on inheritance 
with extension and run-time polymorphism via <I>dispatching operations</I>. 
<SPAN STYLE="font-size: 80%">{<I>object-oriented programming (OOP): See 
tagged types and type extensions</I>}</SPAN> <A NAME="I2182"></A><SPAN STYLE="font-size: 80%">{<I>OOP 
(object-oriented programming): See tagged types and type extensions</I>}</SPAN> 
<A NAME="I2183"></A><SPAN STYLE="font-size: 80%">{<I>inheritance: See 
also tagged types and type extension</I>}</SPAN> <A NAME="I2184"></A>]</DIV>

<H4 Class="centered">Language Design Principles</H4>
<DIV Class="paranum">1.a/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
The intended implementation model is for <SPAN class="insert2">the static 
portion of&nbsp;</SPAN>a tag to be represented as a pointer to a statically 
allocated and link-time initialized type descriptor. The type descriptor 
contains the address of the code for each primitive operation of the 
type. It probably also contains other information, such as might make 
membership tests convenient and efficient.<SPAN class="insert2">&nbsp;Tags 
for nested type extensions must also have a dynamic part that identifies 
the particular elaboration of the type.</SPAN></DIV>
<DIV Class="paranum">1.b</DIV>
<DIV Class="Annotations">The primitive operations of a tagged type are 
known at its first freezing point; the type descriptor is laid out at 
that point. It contains linker symbols for each primitive operation; 
the linker fills in the actual addresses.</DIV>
<DIV Class="paranum">1.b.1/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
<SPAN class="insert2">Primitive operations of type extensions that are 
declared at a level deeper than the level of the ultimate ancestor from 
which they are derived can be represented by wrappers that use the dynamic 
part of the tag to call the actual primitive operation. The dynamic part 
would generally be some way to represent the static link or display necessary 
for making a nested call. One implementation strategy would be to store 
that information in the extension part of such nested type extensions, 
and use the dynamic part of the tag to point at it. (That way, the &ldquo;dynamic&rdquo; 
part of the tag could be static, at the cost of indirect access.)</SPAN></DIV>
<DIV Class="paranum">1.b.2/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
<SPAN class="insert2">If the tagged type is descended from any interface 
types, it also will need to include &ldquo;subtags&rdquo; (one for each 
interface) that describe the mapping of the primitive operations of the 
interface to the primitives of the type. These subtags could directly 
reference the primitive operations (for faster performance), or simply 
provide the tag &ldquo;slot&rdquo; numbers for the primitive operations 
(for easier derivation). In either case, the subtags would be used for 
calls that dispatch through a class-wide type of the interface.</SPAN></DIV>
<DIV Class="paranum">1.c</DIV>
<DIV Class="Annotations">Other implementation models are possible.</DIV>
<DIV Class="paranum">1.d</DIV>
<DIV Class="Annotations">The rules ensure that &ldquo;dangling dispatching&rdquo; 
is impossible; that is, when a dispatching call is made, there is always 
a body to execute. This is different from some other object-oriented 
languages, such as Smalltalk, where it is possible to get a run-time 
error from a missing method.</DIV>
<DIV Class="paranum">1.e/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
Dispatching calls should be efficient, and should have a bounded worst-case 
execution time. This is important in a language intended for real-time 
applications. In the intended implementation model, a dispatching call 
involves calling indirect through the appropriate slot in the dispatch 
table. No complicated &quot;method lookup&quot; is involved<SPAN class="insert2">&nbsp;although a call which is dispatching on an interface may require a lookup 
of the appropriate interface subtag</SPAN>.</DIV>
<DIV Class="paranum">1.f</DIV>
<DIV Class="Annotations">The programmer should have the choice at each 
call site of a dispatching operation whether to do a dispatching call 
or a statically determined call (i.e. whether the body executed should 
be determined at run time or at compile time).</DIV>
<DIV Class="paranum">1.g</DIV>
<DIV Class="Annotations">The same body should be executed for a call 
where the tag is statically determined to be T'Tag as for a dispatching 
call where the tag is found at run time to be T'Tag. This allows one 
to test a given tagged type with statically determined calls, with some 
confidence that run-time dispatching will produce the same behavior.</DIV>
<DIV Class="paranum">1.h</DIV>
<DIV Class="Annotations">All views of a type should share the same type 
descriptor and the same tag.</DIV>
<DIV Class="paranum">1.i</DIV>
<DIV Class="Annotations">The visibility rules determine what is legal 
at compile time; they have nothing to do with what bodies can be executed 
at run time. Thus, it is possible to dispatch to a subprogram whose declaration 
is not visible at the call site. In fact, this is one of the primary 
facts that gives object-oriented programming its power. The subprogram 
that ends up being dispatched to by a given call might even be designed 
long after the call site has been coded and compiled.</DIV>
<DIV Class="paranum">1.j</DIV>
<DIV Class="Annotations">Given that Ada has overloading, determining 
whether a given subprogram overrides another is based both on the names 
and the type profiles of the operations.</DIV>
<DIV Class="paranum">1.k/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00401.TXT">AI95-00401-01</A></I>} 
When a type extension is declared, if there is any place within its immediate 
scope where a certain subprogram of the parent <SPAN class="insert2">or 
progenitor&nbsp;</SPAN>is visible, then a matching subprogram should override. 
If there is no such place, then a matching subprogram should be totally 
unrelated, and occupy a different slot in the type descriptor. This is 
important to preserve the privacy of private parts; when an operation 
declared in a private part is inherited, the inherited version can be 
overridden only in that private part, in the package body, and in any 
children of the package.</DIV>
<DIV Class="paranum">1.l</DIV>
<DIV Class="Annotations">If an implementation shares code for instances 
of generic bodies, it should be allowed to share type descriptors of 
tagged types declared in the generic body, so long as they are not extensions 
of types declared in the specification of the generic unit.&nbsp;</DIV>

<H4 Class="centered">Static Semantics</H4>
<DIV Class="paranum">2/2</DIV>
<DIV Class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00345.TXT">AI95-00345-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>tagged type</I>}</SPAN> <A NAME="I2185"></A>A 
record type or private type that has the reserved word <B>tagged</B> 
in its declaration is called a <I>tagged</I> type.<SPAN class="insert2">&nbsp;In addition, an interface type is a tagged type, as is a task or protected 
type derived from an interface (see <A HREF="AA-3-9-4.html">3.9.4</A>).</SPAN> 
[When deriving from a tagged type, <SPAN class="insert2">as</SPAN><SPAN class="delete2">&nbsp;additional 
components may be defined. As</SPAN> for any derived type, additional 
primitive subprograms may be defined, and inherited primitive subprograms 
may be overridden.] <SPAN STYLE="font-size: 80%">{<I>type extension</I>}</SPAN> 
<A NAME="I2186"></A><SPAN STYLE="font-size: 80%">{<I>extension (of a 
type)</I>}</SPAN> <A NAME="I2187"></A>The derived type is called an <I>extension</I> 
of <SPAN class="insert2">its</SPAN><SPAN class="delete2">&nbsp;the</SPAN> 
ancestor <SPAN class="insert2">types</SPAN><SPAN class="delete2">&nbsp;type</SPAN>, 
or simply a <I>type extension</I>.<SPAN class="delete2">&nbsp;<SPAN STYLE="font-size: 80%">{<I>extension 
(of a record type)</I>}</SPAN> <A NAME="I2188"></A><SPAN STYLE="font-size: 80%">{<I>private 
extension</I>}</SPAN> <A NAME="I2189"></A><SPAN STYLE="font-size: 80%">{<I>extension 
(of a private type)</I>}</SPAN> <A NAME="I2190"></A>Every type extension 
is also a tagged type, and is either a <I>record extension</I> or a <I>private 
extension</I> of some other tagged type. A record extension is defined 
by a <SPAN Class="swiss"><A HREF="AA-3-4.html#S0035">derived_type_definition</A></SPAN> 
with a <SPAN Class="swiss"><A HREF="AA-3-9-1.html#S0075">record_extension_part</A></SPAN>. 
A private extension, which is a partial view of a record extension, can 
be declared in the visible part of a package (see <A HREF="AA-7-3.html">7.3</A>) 
or in a generic formal part (see <A HREF="AA-12-5-1.html">12.5.1</A>).</SPAN></DIV>
<DIV Class="paranum">2.1/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00345.TXT">AI95-00345-01</A></I>} 
<SPAN class="insert2"><SPAN STYLE="font-size: 80%">{<I>extension (of 
a record type)</I>}</SPAN> <A NAME="I2191"></A><SPAN STYLE="font-size: 80%">{<I>private 
extension</I>}</SPAN> <A NAME="I2192"></A><SPAN STYLE="font-size: 80%">{<I>extension 
(of a private type)</I>}</SPAN> <A NAME="I2193"></A>Every type extension 
is also a tagged type, and is a <I>record extension</I> or a <I>private 
extension</I> of some other tagged type, or a non-interface synchronized 
tagged type (see <A HREF="AA-3-9-4.html">3.9.4</A>). A record extension 
is defined by a <SPAN Class="swiss"><A HREF="AA-3-4.html#S0035">derived_type_definition</A></SPAN> 
with a <SPAN Class="swiss"><A HREF="AA-3-9-1.html#S0075">record_extension_part</A></SPAN> 
(see <A HREF="AA-3-9-1.html">3.9.1</A>)[, which may include the definition 
of additional components]. A private extension, which is a partial view 
of a record extension or of a synchronized tagged type, can be declared 
in the visible part of a package (see <A HREF="AA-7-3.html">7.3</A>) 
or in a generic formal part (see <A HREF="AA-12-5-1.html">12.5.1</A>).</SPAN> 
</DIV>
<DIV Class="paranum">2.a</DIV>
<DIV Class="Annotations"><B>Glossary entry:&nbsp;</B>{<I>Tagged type</I>} 
The objects of a tagged type have a run-time type tag, which indicates 
the specific type with which the object was originally created. An operand 
of a class-wide tagged type can be used in a dispatching call; the tag 
indicates which subprogram body to invoke. Nondispatching calls, in which 
the subprogram body to invoke is determined at compile time, are also 
allowed. Tagged types may be extended with additional components.</DIV>
<DIV Class="paranum">2.b/2</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-20218.TXT">AI95-00218-03</A></I>} 
If a tagged type is declared other than in a <SPAN Class="swiss"><A HREF="AA-7-1.html#S0174">package_specification</A></SPAN>, 
it is impossible to add new primitive subprograms for that type, although 
it can inherit primitive subprograms, and those can be overridden. If 
the user incorrectly thinks a certain subprogram is primitive when it 
is not, and tries to call it with a dispatching call, an error message 
will be given at the call site.<SPAN class="insert2">&nbsp;Similarly, by using 
an <SPAN Class="swiss"><A HREF="AA-8-3-1.html#S0178">overriding_indicator</A></SPAN> 
(see <A HREF="AA-6-1.html">6.1</A>), the user can declare that a subprogram 
is intended to be overriding, and get an error message when they made 
a mistake. The use of <SPAN Class="swiss"><A HREF="AA-8-3-1.html#S0178">overriding_indicator</A></SPAN>s 
is highly recommended in new code that does not need to be compatible 
with Ada 95.</SPAN></DIV>
<DIV Class="paranum">2.c/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00344.TXT">AI95-00344-01</A></I>} 
<SPAN class="delete2">Note that the accessibility rules imply that a 
tagged type declared in a library <SPAN Class="swiss"><A HREF="AA-7-1.html#S0174">package_specification</A></SPAN> 
cannot be extended in a nested subprogram or task body.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">3</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>tag of an object</I>}</SPAN> 
<A NAME="I2194"></A>An object of a tagged type has an associated (run-time) 
<I>tag</I> that identifies the specific tagged type used to create the 
object originally. [ The tag of an operand of a class-wide tagged type 
<I>T</I>'Class controls which subprogram body is to be executed when 
a primitive subprogram of type <I>T</I> is applied to the operand (see 
<A HREF="AA-3-9-2.html">3.9.2</A>); <SPAN STYLE="font-size: 80%">{<I>dispatching</I>}</SPAN> 
<A NAME="I2195"></A>using a tag to control which body to execute is called 
<I>dispatching</I>.] <SPAN STYLE="font-size: 80%">{<I>type tag: See tag</I>}</SPAN> 
<A NAME="I2196"></A><SPAN STYLE="font-size: 80%">{<I>run-time type: See 
tag</I>}</SPAN> <A NAME="I2197"></A><SPAN STYLE="font-size: 80%">{<I>type: 
See also tag</I>}</SPAN> <A NAME="I2198"></A><SPAN STYLE="font-size: 80%">{<I>class: 
See also tag</I>}</SPAN> <A NAME="I2199"></A></DIV>
<DIV Class="paranum">4/2</DIV>
<DIV Class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00344.TXT">AI95-00344-01</A></I>} 
The tag of a specific tagged type identifies the <SPAN Class="swiss"><A HREF="AA-3-2-1.html#S0024">full_type_declaration</A></SPAN> 
of the type<SPAN class="insert2">, and for a type extension, is sufficient 
to uniquely identify the type among all descendants of the same ancestor</SPAN>. 
If a declaration for a tagged type occurs within a <SPAN Class="swiss"><A HREF="AA-12-1.html#S0254">generic_package_declaration</A></SPAN>, 
then the corresponding type declarations in distinct instances of the 
generic package are associated with distinct tags. For a tagged type 
that is local to a generic package body<SPAN class="insert2">&nbsp;and with 
all of its ancestors (if any) also local to the generic body</SPAN>, 
the language does not specify whether repeated instantiations of the 
generic body result in distinct tags.<SPAN STYLE="font-size: 80%">{<I>Unspecified</I> 
[partial]}</SPAN> <A NAME="I2200"></A></DIV>
<DIV Class="paranum">4.a/2</DIV>
<DIV Class="Annotations"><SPAN STYLE="font-size: 80%"><I>This paragraph 
was deleted.</I></SPAN><SPAN class="delete2"><B>Reason:&nbsp;</B></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00344.TXT">AI95-00344-01</A></I>} 
<SPAN class="delete2">This eases generic code sharing.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">4.a.1/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Implementation Note: 
</B></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00344.TXT">AI95-00344-01</A></I>} 
<SPAN class="insert2">In most cases, a tag need only identify a particular 
tagged type declaration, and can therefore be a simple link-time-known 
address. However, for tag checks (see <A HREF="AA-3-9-2.html">3.9.2</A>) 
it is essential that each descendant (that currently exists) of a given 
type have a unique tag. Hence, for types declared in shared generic bodies 
where an ancestor comes from outside the generic, or for types declared 
at a deeper level than an ancestor, the tag needs to be augmented with 
some kind of dynamic descriptor (which may be a static link, global display, 
instance descriptor pointer, or combination). This implies that type 
Tag may need to be two words, the second of which is normally null, but 
in these identified special cases needs to include a static link or equivalent. 
Within an object of one of these types with a two-word tag, the two parts 
of the tag would typically be separated, one part as the first word of 
the object, the second placed in the first extension part that corresponds 
to a type declared more nested than its parent or declared in a shared 
generic body when the parent is declared outside. Alternatively, by using 
an extra level of indirection, the type Tag could remain a single-word.</SPAN></DIV>
<DIV Class="paranum">4.b/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00344.TXT">AI95-00344-01</A></I>} 
<SPAN class="insert2">For types that are not type extensions (even for 
ones declared in nested scopes), we do not require that</SPAN><SPAN class="delete2">&nbsp;The 
language does not specify whether</SPAN> repeated elaborations of the 
same <SPAN Class="swiss"><A HREF="AA-3-2-1.html#S0024">full_type_declaration</A></SPAN> 
correspond to distinct tags. <SPAN class="insert2">This was done so that 
Ada 2005 implementations of tagged types could maintain representation 
compatibility with Ada 95 implementations. Only type extensions that 
were not allowed in Ada 95 require additional information with the tag.</SPAN><SPAN class="delete2">&nbsp;In 
most cases, we expect that all elaborations will correspond to the same 
tag, since the tag will frequently be the address (or index) of a statically 
allocated type descriptor. However, with shared generics, the type descriptor 
might have to be allocated on a per-instance basis, which in some implementation 
models implies per-elaboration of the instantiation.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">4.c/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>To be honest:&nbsp;</B></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00344.TXT">AI95-00344-01</A></I>} 
<SPAN class="insert2">The wording &ldquo;is sufficient to uniquely identify 
the type among all descendants of the same ancestor&rdquo; only applies 
to types that currently exist. It is not necessary to distinguish between 
descendants that currently exist, and descendants of the same type that 
no longer exist. For instance, the address of the stack frame of the 
subprogram that created the tag is sufficient to meet the requirements 
of this rule, even though it is possible, after the subprogram returns, 
that a later call of the subprogram could have the same stack frame and 
thus have an identical tag.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">5</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">The following language-defined 
library package exists:&nbsp;</DIV>
<DIV Class="paranum">6/2</DIV>
<DIV Class="Examples">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00362.TXT">AI95-00362-01</A></I>} 
<A NAME="I2201"></A><B>package</B>&nbsp;Ada.Tags&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="insert2"><B>pragma</B>&nbsp;Preelaborate(Tags);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><B>type</B>&nbsp;<A NAME="I2202"></A>Tag&nbsp;<B>is</B>&nbsp;<B>private</B>;<SPAN class="insert2"><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>pragma</B>&nbsp;Preelaborable_Initialization(Tag);</SPAN></DIV>
<DIV Class="paranum">6.1/2</DIV>
<DIV Class="Examples">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
<SPAN class="insert2">&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="I2203"></A>No_Tag&nbsp;:&nbsp;<B>constant</B>&nbsp;Tag;</SPAN></DIV>
<DIV Class="paranum">7/2</DIV>
<DIV Class="Examples">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00400.TXT">AI95-00400-01</A></I>} 
&nbsp;&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;<A NAME="I2204"></A>Expanded_Name(T&nbsp;:&nbsp;Tag)&nbsp;<B>return</B>&nbsp;String;<SPAN class="insert2"><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;<A NAME="I2205"></A>Wide_Expanded_Name(T&nbsp;:&nbsp;Tag)&nbsp;<B>return</B>&nbsp;Wide_String;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;<A NAME="I2206"></A>Wide_Wide_Expanded_Name(T&nbsp;:&nbsp;Tag)&nbsp;<B>return</B>&nbsp;Wide_Wide_String;</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;<A NAME="I2207"></A>External_Tag(T&nbsp;:&nbsp;Tag)&nbsp;<B>return</B>&nbsp;String;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;<A NAME="I2208"></A>Internal_Tag(External&nbsp;:&nbsp;String)&nbsp;<B>return</B>&nbsp;Tag;</DIV>
<DIV Class="paranum">7.1/2</DIV>
<DIV Class="Examples">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00344.TXT">AI95-00344-01</A></I>} 
<SPAN class="insert2">&nbsp;&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;<A NAME="I2209"></A>Descendant_Tag(External&nbsp;:&nbsp;String;&nbsp;Ancestor&nbsp;:&nbsp;Tag)&nbsp;<B>return</B>&nbsp;Tag;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;<A NAME="I2210"></A>Is_Descendant_At_Same_Level(Descendant,&nbsp;Ancestor&nbsp;:&nbsp;Tag)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>return</B>&nbsp;Boolean;</SPAN></DIV>
<DIV Class="paranum">7.2/2</DIV>
<DIV Class="Examples">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
<SPAN class="insert2">&nbsp;&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;<A NAME="I2211"></A>Parent_Tag&nbsp;(T&nbsp;:&nbsp;Tag)&nbsp;<B>return</B>&nbsp;Tag;</SPAN></DIV>
<DIV Class="paranum">7.3/2</DIV>
<DIV Class="Examples">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00405.TXT">AI95-00405-01</A></I>} 
<SPAN class="insert2">&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;<A NAME="I2212"></A>Tag_Array&nbsp;<B>is&nbsp;array</B>&nbsp;(Positive&nbsp;<B>range</B>&nbsp;&lt;&gt;)&nbsp;<B>of</B>&nbsp;Tag;</SPAN></DIV>
<DIV Class="paranum">7.4/2</DIV>
<DIV Class="Examples">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00405.TXT">AI95-00405-01</A></I>} 
<SPAN class="insert2">&nbsp;&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;<A NAME="I2213"></A>Interface_Ancestor_Tags&nbsp;(T&nbsp;:&nbsp;Tag)&nbsp;<B>return</B>&nbsp;Tag_Array;</SPAN></DIV>
<DIV Class="paranum">8</DIV>
<DIV Class="Examples">&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="I2214"></A>Tag_Error&nbsp;:&nbsp;<B>exception</B>;</DIV>
<DIV Class="paranum">9</DIV>
<DIV Class="Examples"><B>private</B><BR>
&nbsp;&nbsp;&nbsp;...&nbsp;--&nbsp;<SPAN Class="roman"><I>not&nbsp;specified&nbsp;by&nbsp;the&nbsp;language</I></SPAN><BR>
<B>end</B>&nbsp;Ada.Tags;</DIV>
<DIV Class="paranum">9.a</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>Tag is a nonlimited, definite 
subtype, because it needs the equality operators, so that tag checking 
makes sense. Also, equality, assignment, and object declaration are all 
useful capabilities for this subtype.</DIV>
<DIV Class="paranum">9.b</DIV>
<DIV Class="Annotations">For an object X and a type T, &ldquo;X'Tag = 
T'Tag&rdquo; is not needed, because a membership test can be used. However, 
comparing the tags of two objects cannot be done via membership. This 
is one reason to allow equality for type Tag.&nbsp;</DIV>
<DIV Class="paranum">9.1/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
<SPAN class="insert2">No_Tag is the default initial value of type Tag.</SPAN> 
</DIV>
<DIV Class="paranum">9.c/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Reason:&nbsp;</B></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
<SPAN class="insert2">This is similar to the requirement that all access 
values be initialized to <B>null</B>.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">10/2</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00400.TXT">AI95-00400-01</A></I>} 
The function <SPAN class="insert2">Wide_Wide_Expanded_Name</SPAN><SPAN class="delete2">&nbsp;Expanded_Name</SPAN> 
returns the full expanded name of the first subtype of the specific type 
identified by the tag, in upper case, starting with a root library unit. 
The result is implementation defined if the type is declared within an 
unnamed <SPAN Class="swiss"><A HREF="AA-5-6.html#S0145">block_statement</A></SPAN>. 
</DIV>
<DIV Class="paranum">10.a</DIV>
<DIV Class="Annotations"><B>To be honest:&nbsp;</B>This name, as well as each 
<SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN> of 
it, does not denote a <SPAN Class="swiss"><A HREF="AA-8-5.html#S0182">renaming_declaration</A></SPAN>. 
</DIV>
<DIV Class="paranum">10.b/2</DIV>
<DIV Class="Annotations"><B>Implementation defined:&nbsp;</B>The result of 
<SPAN class="insert2">Tags.Wide_Wide_Expanded_Name</SPAN><SPAN class="delete2">&nbsp;Tags.Expanded_Name</SPAN> 
for types declared within an unnamed <SPAN Class="swiss"><A HREF="AA-5-6.html#S0145">block_statement</A></SPAN>.</DIV>
<DIV Class="paranum">10.1/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00400.TXT">AI95-00400-01</A></I>} 
<SPAN class="insert2">The function Expanded_Name (respectively, Wide_Expanded_Name) 
returns the same sequence of graphic characters as that defined for Wide_Wide_Expanded_Name, 
if all the graphic characters are defined in Character (respectively, 
Wide_Character); otherwise, the sequence of characters is implementation 
defined, but no shorter than that returned by Wide_Wide_Expanded_Name 
for the same value of the argument.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">10.c/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Implementation defined: 
</B></SPAN><SPAN class="insert2">The sequence of characters of the value 
returned by Tags.Expanded_Name (respectively, Tags.Wide_Expanded_Name) 
when some of the graphic characters of Tags.Wide_Wide_Expanded_Name are 
not defined in Character (respectively, Wide_Character).</SPAN></DIV>
<DIV Class="paranum">11</DIV>
<DIV Class="Normal">The function External_Tag returns a string to be 
used in an external representation for the given tag. The call External_Tag(S'Tag) 
is equivalent to the <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0100">attribute_reference</A></SPAN> 
S'External_Tag (see <A HREF="AA-13-3.html">13.3</A>).&nbsp;</DIV>
<DIV Class="paranum">11.a</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>It might seem redundant to provide 
both the function External_Tag and the attribute External_Tag. The function 
is needed because the attribute can't be applied to values of type Tag. 
The attribute is needed so that it can be <SPAN class="insert2">specified</SPAN><SPAN class="delete2">&nbsp;specifiable</SPAN> 
via an <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN>. 
</DIV>
<DIV Class="paranum">11.1/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00417.TXT">AI95-00417-01</A></I>} 
<SPAN class="insert2">The string returned by the functions Expanded_Name, 
Wide_Expanded_Name, Wide_Wide_Expanded_Name, and External_Tag has lower 
bound 1.</SPAN></DIV>
<DIV Class="paranum">12/2</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00279.TXT">AI95-00279-01</A></I>} 
The function Internal_Tag returns <SPAN class="insert2">a</SPAN><SPAN class="delete2">&nbsp;the</SPAN> 
tag that corresponds to the given external tag, or raises Tag_Error if 
the given string is not the external tag for any specific type of the 
partition.<SPAN class="insert2">&nbsp;Tag_Error is also raised if the specific 
type identified is a library-level type whose tag has not yet been created 
(see <A HREF="AA-13-14.html">13.14</A>).</SPAN></DIV>
<DIV Class="paranum">12.a/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Reason:&nbsp;</B></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00279.TXT">AI95-00279-01</A></I>} 
<SPAN class="insert2">The check for uncreated library-level types prevents 
a reference to the type before execution reaches the freezing point of 
the type. This is important so that T'Class'Input or an instance of Tags.Generic_Dispatching_Constructor 
do not try to create an object of a type that hasn't been frozen (which 
may not have yet elaborated its constraints). We don't require this behavior 
for non-library-level types as the tag can be created multiple times 
and possibly multiple copies can exist at the same time, making the check 
complex.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">12.1/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00344.TXT">AI95-00344-01</A></I>} 
<SPAN class="insert2">The function Descendant_Tag returns the (internal) 
tag for the type that corresponds to the given external tag and is both 
a descendant of the type identified by the Ancestor tag and has the same 
accessibility level as the identified ancestor. Tag_Error is raised if 
External is not the external tag for such a type. Tag_Error is also raised 
if the specific type identified is a library-level type whose tag has 
not yet been created.</SPAN></DIV>
<DIV Class="paranum">12.b/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Reason:&nbsp;</B>Descendant_Tag 
is used by T'Class'Input to identify the type identified by an external 
tag. Because there can be multiple elaborations of a given type declaration, 
Internal_Tag does not have enough information to choose a unique such 
type. Descendant_Tag does not return the tag for types declared at deeper 
accessibility levels than the ancestor because there could be ambiguity 
in the presence of recursion or multiple tasks. Descendant_Tag can be 
used in constructing a user-defined replacement for T'Class'Input.</SPAN> 
</DIV>
<DIV Class="paranum">12.2/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00344.TXT">AI95-00344-01</A></I>} 
<SPAN class="insert2">The function Is_Descendant_At_Same_Level returns 
True if the Descendant tag identifies a type that is both a descendant 
of the type identified by Ancestor and at the same accessibility level. 
If not, it returns False.</SPAN></DIV>
<DIV Class="paranum">12.c/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Reason:&nbsp;</B>Is_Descendant_At_Same_Level 
(or something similar to it) is used by T'Class'Output to determine whether 
the item being written is at the same accessibility level as T. It may 
be used to determine prior to using T'Class'Output whether Tag_Error 
will be raised, and also can be used in constructing a user-defined replacement 
for T'Class'Output.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">12.3/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
<SPAN class="insert2">The function Parent_Tag returns the tag of the 
parent type of the type whose tag is T. If the type does not have a parent 
type (that is, it was not declared by a derived_type_declaration), then 
No_Tag is returned.</SPAN></DIV>
<DIV Class="paranum">12.d/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Ramification:&nbsp;</B>The 
parent type is always the parent of the full type; a private extension 
appears to define a parent type, but it does not (only the various forms 
of derivation do that). As this is a run-time operation, ignoring privateness 
is OK.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">12.4/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00405.TXT">AI95-00405-01</A></I>} 
<SPAN class="insert2">The function Interface_Ancestor_Tags returns an 
array containing the tag of each interface ancestor type of the type 
whose tag is T, other than T itself. The lower bound of the returned 
array is 1, and the order of the returned tags is unspecified. Each tag 
appears in the result exactly once.[ If the type whose tag is T has no 
interface ancestors, a null array is returned.]</SPAN><SPAN STYLE="font-size: 80%">&nbsp;{<I>Unspecified</I> 
[partial]}</SPAN> <A NAME="I2215"></A></DIV>
<DIV Class="paranum">12.e/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Ramification:&nbsp;</B>The 
result of Interface_Ancestor_Tags includes the tag of the parent type, 
if the parent is an interface.</SPAN></DIV>
<DIV Class="paranum">12.f/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2">Indirect interface ancestors 
are included in the result of Interface_Ancestor_Tags. That's because 
where an interface appears in the derivation tree has no effect on the 
semantics of the type; the only interesting property is whether the type 
has an interface as an ancestor.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">13</DIV>
<DIV Class="Normal">For every subtype S of a tagged type <I>T</I> (specific 
or class-wide), the following attributes are defined:&nbsp;</DIV>
<DIV Class="paranum">14</DIV>
<DIV Class="Hanging-Term">S'Class</DIV><DIV Class="Hanging-Body">
<A NAME="I2216"></A><A NAME="I2217"></A>S'Class denotes a subtype of 
the class-wide type (called <I>T</I>'Class in this International Standard) 
for the class rooted at <I>T</I> (or if S already denotes a class-wide 
subtype, then S'Class is the same as S).</DIV>
<DIV Class="paranum">15</DIV>
<DIV Class="Hanging-Body"><SPAN STYLE="font-size: 80%">{<I>unconstrained 
(subtype)</I>}</SPAN> <A NAME="I2218"></A><SPAN STYLE="font-size: 80%">{<I>constrained 
(subtype)</I>}</SPAN> <A NAME="I2219"></A>S'Class is unconstrained. However, 
if S is constrained, then the values of S'Class are only those that when 
converted to the type <I>T</I> belong to S.&nbsp;</DIV>
<DIV Class="paranum">15.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>This attribute is defined 
for both specific and class-wide subtypes. The definition is such that 
S'Class'Class is the same as S'Class.</DIV>
<DIV Class="paranum">15.b</DIV>
<DIV Class="Annotations">Note that if S is constrained, S'Class is only 
partially constrained, since there might be additional discriminants 
added in descendants of <I>T</I> which are not constrained.&nbsp;</DIV>
<DIV Class="paranum">15.c/2</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00326.TXT">AI95-00326-01</A></I>} 
The Class attribute is not defined for untagged subtypes (except for 
incomplete types and private types whose full view is tagged &mdash; 
see <SPAN class="insert2"><A HREF="AA-J-11.html">J.11</A></SPAN><SPAN class="delete2"><A HREF="AA-3-10-1.html">&nbsp;3.10.1</A></SPAN> 
and <A HREF="AA-7-3-1.html">7.3.1</A>) so as to preclude implicit conversion 
in the absence of run-time type information. If it were defined for untagged 
subtypes, it would correspond to the concept of universal types provided 
for the predefined numeric classes.&nbsp;</DIV>
<DIV Class="paranum">16</DIV>
<DIV Class="Hanging-Term">S'Tag</DIV><DIV Class="Hanging-Body">
<A NAME="I2220"></A><A NAME="I2221"></A>S'Tag denotes the tag of the 
type <I>T</I> (or if <I>T</I> is class-wide, the tag of the root type 
of the corresponding class). The value of this attribute is of type Tag. 
</DIV>
<DIV Class="paranum">16.a</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>S'Class'Tag equals S'Tag, to 
avoid generic contract model problems when S'Class is the actual type 
associated with a generic formal derived type.</DIV>
<DIV Class="paranum">17</DIV>
<DIV Class="Normal">Given a <SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN> 
X that is of a class-wide tagged type [(after any implicit dereference)], 
the following attribute is defined:&nbsp;</DIV>
<DIV Class="paranum">18</DIV>
<DIV Class="Hanging-Term">X'Tag</DIV><DIV Class="Hanging-Body">
<A NAME="I2222"></A><A NAME="I2223"></A>X'Tag denotes the tag of X. The 
value of this attribute is of type Tag.&nbsp;</DIV>
<DIV Class="paranum">18.a</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>X'Tag is not defined if X is 
of a specific type. This is primarily to avoid confusion that might result 
about whether the Tag attribute should reflect the tag of the type of 
X, or the tag of X. No such confusion is possible if X is of a class-wide 
type.&nbsp;</DIV>
<DIV Class="paranum">18.1/2</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00441.TXT">AI95-00441-01</A></I>} 
<SPAN class="insert2">The following language-defined generic function 
exists:</SPAN></DIV>
<DIV Class="paranum">18.2/2</DIV>
<DIV Class="Examples"><SPAN class="insert2"><A NAME="I2224"></A><B>generic</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T&nbsp;(&lt;&gt;)&nbsp;<B>is&nbsp;abstract&nbsp;tagged&nbsp;limited&nbsp;private</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Parameters&nbsp;(&lt;&gt;)&nbsp;<B>is&nbsp;limited&nbsp;private</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>with&nbsp;function</B>&nbsp;Constructor&nbsp;(Params&nbsp;:&nbsp;<B>not&nbsp;null&nbsp;access</B>&nbsp;Parameters)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>return</B>&nbsp;T&nbsp;<B>is&nbsp;abstract</B>;<BR>
<B>function</B>&nbsp;Ada.Tags.Generic_Dispatching_Constructor<BR>
&nbsp;&nbsp;&nbsp;(The_Tag&nbsp;:&nbsp;Tag;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Params&nbsp;&nbsp;:&nbsp;<B>not&nbsp;null&nbsp;access</B>&nbsp;Parameters)&nbsp;<B>return</B>&nbsp;T'Class;<BR>
<B>pragma</B>&nbsp;Preelaborate(Generic_Dispatching_Constructor);<BR>
<B>pragma</B>&nbsp;Convention(Intrinsic,&nbsp;Generic_Dispatching_Constructor);</SPAN></DIV>
<DIV Class="paranum">18.3/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
<SPAN class="insert2">Tags.Generic_Dispatching_Constructor provides a 
mechanism to create an object of an appropriate type from just a tag 
value. The function Constructor is expected to create the object given 
a reference to an object of type Parameters.</SPAN></DIV>
<DIV Class="paranum">18.b/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Discussion:&nbsp;</B>This 
specification is designed to make it easy to create dispatching constructors 
for streams; in particular, this can be used to construct overridings 
for T'Class'Input.</SPAN></DIV>
<DIV Class="paranum">18.c/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2">Note that any tagged type 
will match T (see <A HREF="AA-12-5-1.html">12.5.1</A>).</SPAN>&nbsp;</DIV>

<H4 Class="centered">Dynamic Semantics</H4>
<DIV Class="paranum">19</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">The tag associated 
with an object of a tagged type is determined as follows:&nbsp;</DIV>
<DIV Class="paranum">20</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN STYLE="font-size: 80%">{<I>tag 
of an object (stand-alone object,   component, or aggregate)</I> [partial]}</SPAN> 
<A NAME="I2225"></A>The tag of a stand-alone object, a component, or 
an <SPAN Class="swiss"><A HREF="AA-4-3.html#S0104">aggregate</A></SPAN> 
of a specific tagged type <I>T</I> identifies <I>T</I>.&nbsp;</LI></UL>
<DIV Class="paranum">20.a</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>The tag of a formal parameter 
of type <I>T</I> is not necessarily the tag of <I>T</I>, if, for example, 
the actual was a type conversion.&nbsp;</DIV>
<DIV Class="paranum">21</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN STYLE="font-size: 80%">{<I>tag 
of an object (object created by an allocator)</I> [partial]}</SPAN> <A NAME="I2226"></A>The 
tag of an object created by an allocator for an access type with a specific 
designated tagged type <I>T</I>, identifies <I>T</I>.&nbsp;</LI></UL>
<DIV Class="paranum">21.a</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>The tag of an object designated 
by a value of such an access type might not be <I>T</I>, if, for example, 
the access value is the result of a type conversion.</DIV>
<DIV Class="paranum">22</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN STYLE="font-size: 80%">{<I>tag 
of an object (class-wide object)</I> [partial]}</SPAN> <A NAME="I2227"></A>The 
tag of an object of a class-wide tagged type is that of its initialization 
expression.&nbsp;</LI></UL>
<DIV Class="paranum">22.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>The tag of an object (even 
a class-wide one) cannot be changed after it is initialized, since a 
&ldquo;class-wide&rdquo; <SPAN Class="swiss"><A HREF="AA-5-2.html#S0137">assignment_statement</A></SPAN> 
raises Constraint_Error if the tags don't match, and a &ldquo;specific&rdquo; 
<SPAN Class="swiss"><A HREF="AA-5-2.html#S0137">assignment_statement</A></SPAN> 
does not affect the tag.&nbsp;</DIV>
<DIV Class="paranum">23</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN STYLE="font-size: 80%">{<I>tag 
of an object (returned by a function)</I> [partial]}</SPAN> <A NAME="I2228"></A>The 
tag of the result returned by a function whose result type is a specific 
tagged type <I>T</I> identifies <I>T</I>.&nbsp;</LI></UL>
<DIV Class="paranum">23.a/2</DIV>
<DIV Class="Annotations"><B>Implementation Note:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10318.TXT">AI95-00318-02</A></I>} 
<SPAN class="insert2">For a limited tagged type, the return object is 
&ldquo;built in place&rdquo; in the ultimate result object with the appropriate 
tag.</SPAN><SPAN class="delete2">&nbsp;This requires a run-time check for 
limited tagged types, since they are returned &quot;by-reference.&quot;</SPAN> 
For a nonlimited type, a new anonymous object with the appropriate tag 
is created as part of the function return<SPAN class="delete2">, and 
then assigned the value of the return expression</SPAN>. See <A HREF="AA-6-5.html">6.5</A>, 
&ldquo;<A HREF="AA-6-5.html">Return Statements</A>&rdquo;.&nbsp;</DIV>
<DIV Class="paranum">24/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10318.TXT">AI95-00318-02</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>tag of an object (returned by a function)</I> 
[partial]}</SPAN> <A NAME="I2229"></A>The tag of the result returned 
by a function with a class-wide result type is that of the return <SPAN class="insert2">object</SPAN><SPAN class="delete2">&nbsp;expression</SPAN>. 
</LI></UL>
<DIV Class="paranum">25</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>tag of an object 
(preserved by type conversion and parameter passing)</I> [partial]}</SPAN> 
<A NAME="I2230"></A>The tag is preserved by type conversion and by parameter 
passing. The tag of a value is the tag of the associated object (see 
<A HREF="AA-6-2.html">6.2</A>).</DIV>
<DIV Class="paranum">25.1/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00344.TXT">AI95-00344-01</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00405.TXT">AI95-00405-01</A></I>} 
<SPAN class="insert2">Tag_Error is raised by a call of Descendant_Tag, 
Expanded_Name, External_Tag, Interface_Ancestor_Tag, Is_Descendant_At_Same_Level, 
or Parent_Tag if any tag passed is No_Tag.</SPAN></DIV>
<DIV Class="paranum">25.2/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
<SPAN class="insert2">An instance of Tags.Generic_Dispatching_Constructor 
raises Tag_Error if The_Tag does not represent a concrete descendant 
of T or if the innermost master (see <A HREF="AA-7-6-1.html">7.6.1</A>) 
of this descendant is not also a master of the instance. Otherwise, it 
dispatches to the primitive function denoted by the formal Constructor 
for the type identified by The_Tag, passing Params, and returns the result. 
Any exception raised by the function is propagated.</SPAN></DIV>
<DIV Class="paranum">25.a/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Ramification:&nbsp;</B>The 
tag check checks both that The_Tag is in T'Class, and that it is not 
abstract. These checks are similar to the ones required by streams for 
T'Class'Input (see <A HREF="AA-13-13-2.html">13.13.2</A>). In addition, 
there is a check that the tag identifies a type declared on the current 
dynamic call chain, and not a more nested type or a type declared by 
another task. This check is not necessary for streams, because the stream 
attributes are declared at the same dynamic level as the type used.</SPAN> 
</DIV>

<H4 Class="centered">Erroneous Execution</H4>
<DIV Class="paranum">25.3/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
<SPAN class="insert2"><SPAN STYLE="font-size: 80%">{<I>erroneous execution 
(cause)</I> [partial]}</SPAN> <A NAME="I2231"></A>If an internal tag 
provided to an instance of Tags.Generic_Dispatching_Constructor or to 
any subprogram declared in package Tags identifies either a type that 
is not library-level and whose tag has not been created (see <A HREF="AA-13-14.html">13.14</A>), 
or a type that does not exist in the partition at the time of the call, 
then execution is erroneous.</SPAN></DIV>
<DIV Class="paranum">25.b/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Ramification:&nbsp;</B>One 
reason that a type might not exist in the partition is that the tag refers 
to a type whose declaration was elaborated as part of an execution of 
a <SPAN Class="swiss"><A HREF="AA-6-3.html#S0162">subprogram_body</A></SPAN> 
which has been left (see <A HREF="AA-7-6-1.html">7.6.1</A>).</SPAN></DIV>
<DIV Class="paranum">25.c/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2">We exclude tags of library-level 
types from the current execution of the partition, because misuse of 
such tags should always be detected. T'Tag freezes the type (and thus 
creates the tag), and Internal_Tag and Descendant_Tag cannot return the 
tag of a library-level type that has not been created. All ancestors 
of a tagged type must be frozen no later than the (full) declaration 
of a type that uses them, so Parent_Tag and Interface_Ancestor_Tags cannot 
return a tag that has not been created. Finally, library-level types 
never cease to exist while the partition is executing. Thus, if the tag 
comes from a library-level type, there cannot be erroneous execution 
(the use of Descendant_Tag rather than Internal_Tag can help ensure that 
the tag is of a library-level type). This is also similar to the rules 
for T'Class'Input (see <A HREF="AA-13-13-2.html">13.13.2</A>).</SPAN> 
</DIV>
<DIV Class="paranum">25.d/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Discussion:&nbsp;</B></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00344.TXT">AI95-00344-01</A></I>} 
<SPAN class="insert2">Ada 95 allowed Tag_Error in this case, or expected 
the functions to work. This worked because most implementations used 
tags constructed at link-time, and each elaboration of the same <SPAN Class="swiss"><A HREF="AA-3-2-1.html#S0023">type_declaration</A></SPAN> 
produced the same tag. However, Ada 2005 requires at least part of the 
tags to be dynamically constructed for a type derived from a type at 
a shallower level. For dynamically constructed tags, detecting the error 
can be expensive and unreliable. To see this, consider a program containing 
two tasks. Task A creates a nested tagged type, passes the tag to task 
B (which saves it), and then terminates. The nested tag (if dynamic) 
probably will need to refer in some way to the stack frame for task A. 
If task B later tries to use the tag created by task A, the tag's reference 
to the stack frame of A probably is a dangling pointer. Avoiding this 
would require some sort of protected tag manager, which would be a bottleneck 
in a program's performance. Moreover, we'd still have a race condition; 
if task A terminated after the tag check, but before the tag was used, 
we'd still have a problem. That means that all of these operations would 
have to be serialized. That could be a significant performance drain, 
whether or not nested tagged types are every used. Therefore, we allow 
execution to become erroneous as we do for other dangling pointers. If 
the implementation can detect the error, we recommend that Tag_Error 
be raised.</SPAN>&nbsp;</DIV>

<H4 Class="centered">Implementation Permissions</H4>
<DIV Class="paranum">26/2</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00279.TXT">AI95-00279-01</A></I>} 
The implementation of <SPAN class="insert2">Internal_Tag and Descendant_Tag</SPAN><SPAN class="delete2">&nbsp;the 
functions in Ada.Tags</SPAN> may raise Tag_Error if no specific type 
corresponding to the <SPAN class="insert2">string External</SPAN><SPAN class="delete2">&nbsp;tag</SPAN> 
passed as a parameter exists in the partition at the time the function 
is called<SPAN class="insert2">, or if there is no such type whose innermost 
master is a master of the point of the function call</SPAN>.&nbsp;</DIV>
<DIV Class="paranum">26.a/2</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00279.TXT">AI95-00279-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00344.TXT">AI95-00344-01</A></I>} 
<SPAN class="insert2">Locking would be required to ensure that the mapping 
of strings to tags never returned tags of types which no longer exist, 
because types can cease to exist (because they belong to another task, 
as described above) during the execution of these operations. Moreover, 
even if these functions did use locking, that would not prevent the type 
from ceasing to exist at the instant that the function returned. Thus, 
we do not require the overhead of locking;</SPAN><SPAN class="delete2">&nbsp;In 
most implementations, repeated elaborations of the same <SPAN Class="swiss"><A HREF="AA-3-2-1.html#S0023">type_declaration</A></SPAN> 
will all produce the same tag. In such an implementation, Tag_Error will 
be raised in cases where the internal or external tag was passed from 
a different partition. However, some implementations might create a new 
tag value at run time for each elaboration of a <SPAN Class="swiss"><A HREF="AA-3-2-1.html#S0023">type_declaration</A></SPAN>. 
In that case, Tag_Error could also be raised if the created type no longer 
exists because the subprogram containing it has returned, for example. 
We don't require the latter behavior;</SPAN> hence the word &ldquo;may&rdquo; 
in this rule.&nbsp;</DIV>

<H4 Class="centered">Implementation Advice</H4>
<DIV Class="paranum">26.1/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
<SPAN class="insert2">Internal_Tag should return the tag of a type whose 
innermost master is the master of the point of the function call.</SPAN> 
</DIV>
<DIV Class="paranum">26.b/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Implementation Advice: 
</B></SPAN><SPAN class="insert2">Tags.Internal_Tag should return the 
tag of a type whose innermost master is the master of the point of the 
function call.</SPAN>.</DIV>
<DIV Class="paranum">26.c/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Reason:&nbsp;</B></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00344.TXT">AI95-00344-01</A></I>} 
<SPAN class="insert2">It's not helpful if Internal_Tag returns the tag 
of some type in another task when one is available in the task that made 
the call. We don't require this behavior (because it requires the same 
implementation techniques we decided not to insist on previously), but 
encourage it.</SPAN>&nbsp;</DIV>
<DIV Class="NotesHeader">NOTES</DIV>
<DIV Class="paranum">27</DIV>
<DIV Class="Notes">64&nbsp;&nbsp;A type declared with the reserved word 
<B>tagged</B> should normally be declared in a <SPAN Class="swiss"><A HREF="AA-7-1.html#S0174">package_specification</A></SPAN>, 
so that new primitive subprograms can be declared for it.</DIV>
<DIV Class="paranum">28</DIV>
<DIV Class="Notes">65&nbsp;&nbsp;Once an object has been created, its 
tag never changes.</DIV>
<DIV Class="paranum">29</DIV>
<DIV Class="Notes">66&nbsp;&nbsp;Class-wide types are defined to have 
unknown discriminants (see <A HREF="AA-3-7.html">3.7</A>). This means 
that objects of a class-wide type have to be explicitly initialized (whether 
created by an <SPAN Class="swiss"><A HREF="AA-3-3-1.html#S0032">object_declaration</A></SPAN> 
or an <SPAN Class="swiss"><A HREF="AA-4-8.html#S0129">allocator</A></SPAN>), 
and that <SPAN Class="swiss"><A HREF="AA-4-3.html#S0104">aggregate</A></SPAN>s 
have to be explicitly qualified with a specific type when their expected 
type is class-wide.</DIV>
<DIV Class="paranum">30/2</DIV>
<DIV Class="Notes"><SPAN STYLE="font-size: 80%"><I>This paragraph was 
deleted.</I></SPAN><SPAN class="delete2">67&nbsp;&nbsp;</SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00326.TXT">AI95-00326-01</A></I>} 
<SPAN class="delete2">If S denotes an untagged private type whose full 
type is tagged, then S'Class is also allowed before the full type definition, 
but only in the private part of the package in which the type is declared 
(see <A HREF="AA-7-3-1.html">7.3.1</A>). Similarly, the Class attribute 
is defined for incomplete types whose full type is tagged, but only within 
the library unit in which the incomplete type is declared (see <A HREF="AA-3-10-1.html">3.10.1</A>).</SPAN></DIV>
<DIV Class="paranum">30.1/2</DIV>
<DIV Class="Notes">68&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
<SPAN class="insert2">The capability provided by Tags.Generic_Dispatching_Constructor 
is sometimes known as a <I>factory</I>.<SPAN STYLE="font-size: 80%">{<I>factory</I>}</SPAN> 
<A NAME="I2232"></A><SPAN STYLE="font-size: 80%">{<I>class factory</I>}</SPAN> 
<A NAME="I2233"></A></SPAN></DIV>

<H4 Class="centered">Examples</H4>
<DIV Class="paranum">31</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em"><I>Examples of tagged 
record types:</I>&nbsp;</DIV>
<DIV Class="paranum">32</DIV>
<DIV Class="Examples"><B>type</B>&nbsp;Point&nbsp;<B>is&nbsp;tagged</B><BR>
&nbsp;&nbsp;<B>record</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;X,&nbsp;Y&nbsp;:&nbsp;Real&nbsp;:=&nbsp;0.0;<BR>
&nbsp;&nbsp;<B>end&nbsp;record</B>;</DIV>
<DIV Class="paranum">33</DIV>
<DIV Class="Examples"><B>type</B>&nbsp;Expression&nbsp;<B>is&nbsp;tagged&nbsp;null&nbsp;record</B>;<BR>
&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;Components&nbsp;will&nbsp;be&nbsp;added&nbsp;by&nbsp;each&nbsp;extension</I></SPAN></DIV>

<H4 Class="centered">Extensions to Ada 83</H4>
<DIV Class="paranum">33.a</DIV>
<DIV Class="Annotations">{<I>extensions to Ada 83</I>} <A NAME="I2234"></A>Tagged 
types are a new concept.&nbsp;</DIV>

<H4 Class="centered">Inconsistencies With Ada 95</H4>
<DIV Class="paranum">33.b/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00279.TXT">AI95-00279-01</A></I>} 
<SPAN class="insert2">{<I>inconsistencies with Ada 95</I>} <A NAME="I2235"></A><B>Amendment 
Correction:</B> Added wording specifying that Internal_Tag must raise 
Tag_Error if the tag of a library-level type has not yet been created. 
Ada 95 gave an Implementation Permission to do this; we require it to 
avoid erroneous execution when streaming in an object of a library-level 
type that has not yet been elaborated. This is technically inconsistent; 
a program that used Internal_Tag outside of streaming and used a compiler 
that didn't take advantage of the Implementation Permission would not 
have raised Tag_Error, and may have returned a useful tag. (If the tag 
was used in streaming, the program would have been erroneous.) Since 
such a program would not have been portable to a compiler that did take 
advantage of the Implementation Permission, this is not a significant 
inconsistency.</SPAN></DIV>
<DIV Class="paranum">33.c/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00417.TXT">AI95-00417-01</A></I>} 
<SPAN class="insert2">We now define the lower bound of the string returned 
from [[Wide_]Wide_]Expanded_Name and External_Name. This makes working 
with the returned string easier, and is consistent with many other string-returning 
functions in Ada. This is technically an inconsistency; if a program 
depended on some other lower bound for the string returned from one of 
these functions, it could fail when compiled with Ada 2005. Such code 
is not portable even between Ada 95 implementations, so it should be 
very rare.</SPAN>&nbsp;</DIV>

<H4 Class="centered">Incompatibilities With Ada 95</H4>
<DIV Class="paranum">33.d/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00344.TXT">AI95-00344-01</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00400.TXT">AI95-00400-01</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00405.TXT">AI95-00405-01</A></I>} 
<SPAN class="insert2">{<I>incompatibilities with Ada 95</I>} <A NAME="I2236"></A>Constant 
No_Tag, and functions Parent_Tag, Interface_Ancestor_Tags, Descendant_Tag, 
Is_Descendant_At_Same_Level, Wide_Expanded_Name, and Wide_Wide_Expanded_Name 
are newly added to Ada.Tags. If Ada.Tags is referenced in a <SPAN Class="swiss"><A HREF="AA-8-4.html#S0179">use_clause</A></SPAN>, 
and an entity <I>E</I> with the same <SPAN Class="swiss"><A HREF="AA-3-1.html#S0022">defining_identifier</A></SPAN> 
as a new entity in Ada.Tags is defined in a package that is also referenced 
in a <SPAN Class="swiss"><A HREF="AA-8-4.html#S0179">use_clause</A></SPAN>, 
the entity <I>E</I> may no longer be use-visible, resulting in errors. 
This should be rare and is easily fixed if it does occur.</SPAN>&nbsp;</DIV>

<H4 Class="centered">Extensions to Ada 95</H4>
<DIV Class="paranum">33.e/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00362.TXT">AI95-00362-01</A></I>} 
<SPAN class="insert2">{<I>extensions to Ada 95</I>} <A NAME="I2237"></A>Ada.Tags 
is now defined to be preelaborated.</SPAN></DIV>
<DIV Class="paranum">33.f/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10260.TXT">AI95-00260-02</A></I>} 
<SPAN class="insert2">Generic function Tags.Generic_Dispatching_Constructor 
is new.</SPAN>&nbsp;</DIV>

<H4 Class="centered">Wording Changes from Ada 95</H4>
<DIV Class="paranum">33.g/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10318.TXT">AI95-00318-02</A></I>} 
<SPAN class="insert2">We talk about return objects rather than return 
expressions, as functions can return using an <SPAN Class="swiss"><A HREF="AA-6-5.html#S0170">extended_return_statement</A></SPAN>.</SPAN></DIV>
<DIV Class="paranum">33.h/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00344.TXT">AI95-00344-01</A></I>} 
<SPAN class="insert2">Added wording to define that tags for all descendants 
of a tagged type must be distinct. This is needed to ensure that more 
nested type extensions will work properly. The wording does not require 
implementation changes for types that were allowed in Ada 95.</SPAN> 
</DIV>

<HR>
<DIV Style="margin-top: 0.0em; margin-bottom: 0.6em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-3-8-1.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-3-9-1.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<DIV Style="margin-top:0.0em"><IMG SRC="AE_logo.gif" height=100 width=113 align=right ALT="Ada-Europe">
<SPAN Style="font-size: 125%">Sponsored by <SPAN Style="font-size: 125%"><A HREF="http://www.ada-europe.org/"><B>Ada-Europe</B></A></SPAN></SPAN></DIV>
</BODY>
</HTML>
