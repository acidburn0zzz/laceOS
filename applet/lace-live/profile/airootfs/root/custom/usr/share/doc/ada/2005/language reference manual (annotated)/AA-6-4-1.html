<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Parameter Associations</TITLE>
    <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    H4.centered {text-align: center}
    SPAN.swiss {font-family: Arial, Helvetica, sans-serif; font-size: 92%}
    SPAN.roman {font-family: "Times New Roman", Times, serif}
    DIV.paranum {float: left; font-family: Arial, Helvetica, sans-serif; font-size: 64%; width: 2.8em; margin-left: -0.4em; margin-right: -3.0em; margin-top: 0.2em}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    DIV.Normal {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.2em; margin-bottom: 0.6em}
    DIV.Annotations {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 6.2em; margin-bottom: 0.6em}
    DIV.SmallExamples {font-family: "Courier New", monospace; font-size: 72%; line-height: 122%; margin-left: 9.6em; margin-bottom: 0.6em}
    UL.Bulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.CodeIndentedBulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 7.2em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#000080" VLINK="#330033" ALINK="#0000FF">
<DIV><B><SPAN Style="font-size:200%; color: rgb(0,51,153)">Annotated</SPAN><SPAN Style="font-size:200%; color: rgb(0,0,102)">&nbsp;Ada Reference Manual</SPAN></B> &mdash; <A HREF="AA-TTL.html"><B>Legal Information</B></A></DIV>
<DIV Style="margin-top: 0.6em; margin-bottom: 0.0em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-6-4.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-6-5.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<HR>
<H1>6.4.1 Parameter Associations</H1>
<DIV Class="paranum">1</DIV>
<DIV Class="Normal">[<SPAN STYLE="font-size: 80%">{<I>parameter passing</I>}</SPAN> 
<A NAME="I3466"></A>A parameter association defines the association between 
an actual parameter and a formal parameter.]&nbsp;</DIV>

<H4 Class="centered">Language Design Principles</H4>
<DIV Class="paranum">1.a</DIV>
<DIV Class="Annotations">The parameter passing rules for <B>out</B> parameters 
are designed to ensure that the parts of a type that have implicit initial 
values (see <A HREF="AA-3-3-1.html">3.3.1</A>) don't become &ldquo;de-initialized&rdquo; 
by being passed as an <B>out</B> parameter.&nbsp;</DIV>

<H4 Class="centered">Name Resolution Rules</H4>
<DIV Class="paranum">2</DIV>
<DIV Class="Normal">The <I>formal_parameter_</I><SPAN Class="swiss"><A HREF="AA-4-1-3.html#S0099">selector_name</A></SPAN> 
of a <SPAN Class="swiss"><A HREF="AA-6-4.html#S0166">parameter_association</A></SPAN> 
shall resolve to denote a <SPAN Class="swiss"><A HREF="AA-6-1.html#S0160">parameter_specification</A></SPAN> 
of the view being called.</DIV>
<DIV Class="paranum">3</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>actual parameter 
(for a formal parameter)</I>}</SPAN> <A NAME="I3467"></A>The <I>actual 
parameter</I> is either the <SPAN Class="swiss"><A HREF="AA-6-4.html#S0167">explicit_actual_parameter</A></SPAN> 
given in a <SPAN Class="swiss"><A HREF="AA-6-4.html#S0166">parameter_association</A></SPAN> 
for a given formal parameter, or the corresponding <SPAN Class="swiss"><A HREF="AA-3-7.html#S0063">default_expression</A></SPAN> 
if no <SPAN Class="swiss"><A HREF="AA-6-4.html#S0166">parameter_association</A></SPAN> 
is given for the formal parameter. <SPAN STYLE="font-size: 80%">{<I>expected 
type (actual parameter)</I>}</SPAN> <A NAME="I3468"></A>The expected 
type for an actual parameter is the type of the corresponding formal 
parameter.&nbsp;</DIV>
<DIV Class="paranum">3.a</DIV>
<DIV Class="Annotations"><B>To be honest:&nbsp;</B>The corresponding <SPAN Class="swiss"><A HREF="AA-3-7.html#S0063">default_expression</A></SPAN> 
is the one of the corresponding formal parameter in the profile of the 
view denoted by the <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
or <SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN> 
of the call.&nbsp;</DIV>
<DIV Class="paranum">4</DIV>
<DIV Class="Normal">If the mode is <B>in</B>, the actual is interpreted 
as an <SPAN Class="swiss"><A HREF="AA-4-4.html#S0115">expression</A></SPAN>; 
otherwise, the actual is interpreted only as a <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>, 
if possible.&nbsp;</DIV>
<DIV Class="paranum">4.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>This formally resolves 
the ambiguity present in the syntax rule for <SPAN Class="swiss"><A HREF="AA-6-4.html#S0167">explicit_actual_parameter</A></SPAN>. 
Note that we don't actually require that the actual be a <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
if the mode is not <B>in</B>; we do that below.&nbsp;</DIV>

<H4 Class="centered">Legality Rules</H4>
<DIV Class="paranum">5</DIV>
<DIV Class="Normal">If the mode is <B>in out</B> or <B>out</B>, the actual 
shall be a <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
that denotes a variable.&nbsp;</DIV>
<DIV Class="paranum">5.a</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>We no longer need &ldquo;or 
a <SPAN Class="swiss"><A HREF="AA-4-6.html#S0127">type_conversion</A></SPAN> 
whose argument is the <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
of a variable,&rdquo; because a <SPAN Class="swiss"><A HREF="AA-4-6.html#S0127">type_conversion</A></SPAN> 
is now a <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>, 
and a <SPAN Class="swiss"><A HREF="AA-4-6.html#S0127">type_conversion</A></SPAN> 
of a variable is a variable.&nbsp;</DIV>
<DIV Class="paranum">5.b</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><B>Reason:&nbsp;</B>The 
requirement that the actual be a (variable) <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
is not an overload resolution rule, since we don't want the difference 
between <SPAN Class="swiss"><A HREF="AA-4-4.html#S0115">expression</A></SPAN> 
and <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> to 
be used to resolve overloading. For example:&nbsp;</DIV>
<DIV Class="paranum">5.c</DIV>
<DIV Class="SmallExamples">procedure&nbsp;Print(X&nbsp;:&nbsp;<B>in</B>&nbsp;Integer;&nbsp;Y&nbsp;:&nbsp;<B>in</B>&nbsp;Boolean&nbsp;:=&nbsp;True);<BR>
procedure&nbsp;Print(Z&nbsp;:&nbsp;<B>in&nbsp;out</B>&nbsp;Integer);<BR>
.&nbsp;.&nbsp;.<BR>
Print(3);&nbsp;--<SPAN Class="roman"><I>&nbsp;Ambiguous!</I></SPAN><BR>
&nbsp;&nbsp;</DIV>
<DIV Class="paranum">5.d</DIV>
<DIV Class="Annotations">The above call to Print is ambiguous even though 
the call is not compatible with the second Print which requires an actual 
that is a (variable) <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
(&ldquo;3&rdquo; is an <SPAN Class="swiss"><A HREF="AA-4-4.html#S0115">expression</A></SPAN>, 
not a <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>). 
This requirement is a legality rule, so overload resolution fails before 
it is considered, meaning that the call is ambiguous.&nbsp;</DIV>
<DIV Class="paranum">6</DIV>
<DIV Class="Normal">The type of the actual parameter associated with 
an access parameter shall be convertible (see <A HREF="AA-4-6.html">4.6</A>) 
to its anonymous access type. <SPAN STYLE="font-size: 80%">{<I>convertible 
(required)</I> [partial]}</SPAN> <A NAME="I3469"></A></DIV>

<H4 Class="centered">Dynamic Semantics</H4>
<DIV Class="paranum">7</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em"><SPAN STYLE="font-size: 80%">{<I>evaluation 
(parameter_association)</I> [partial]}</SPAN> <A NAME="I3470"></A>For 
the evaluation of a <SPAN Class="swiss"><A HREF="AA-6-4.html#S0166">parameter_association</A></SPAN>: 
</DIV>
<DIV Class="paranum">8</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>The actual parameter is first evaluated.</LI></UL>
<DIV Class="paranum">9</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>For an access parameter, the <SPAN Class="swiss"><A HREF="AA-3-10.html#S0084">access_definition</A></SPAN> 
is elaborated, which creates the anonymous access type.</LI></UL>
<DIV Class="paranum">10</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>For a parameter [(of any mode)] that 
is passed by reference (see <A HREF="AA-6-2.html">6.2</A>), a view conversion 
of the actual parameter to the nominal subtype of the formal parameter 
is evaluated, and the formal parameter denotes that conversion. <SPAN STYLE="font-size: 80%">{<I>implicit 
subtype conversion (parameter passing)</I> [partial]}</SPAN> <A NAME="I3471"></A></LI></UL>
<DIV Class="paranum">10.a</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>We are always allowing sliding, 
even for [<B>in</B>[ <B>out</B> by-reference parameters.&nbsp;</DIV>
<DIV Class="paranum">11</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN STYLE="font-size: 80%">{<I>assignment 
operation (during evaluation of a parameter_association)</I>}</SPAN> 
<A NAME="I3472"></A>For an <B>in</B> or <B>in out</B> parameter that 
is passed by copy (see <A HREF="AA-6-2.html">6.2</A>), the formal parameter 
object is created, and the value of the actual parameter is converted 
to the nominal subtype of the formal parameter and assigned to the formal. 
<SPAN STYLE="font-size: 80%">{<I>implicit subtype conversion (parameter 
passing)</I> [partial]}</SPAN> <A NAME="I3473"></A></LI></UL>
<DIV Class="paranum">11.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>The conversion mentioned 
here is a value conversion.&nbsp;</DIV>
<DIV Class="paranum">12</DIV>
<UL Class="Bulleted" Style="margin-bottom: 0.3em"><LI TYPE=DISC>For 
an <B>out</B> parameter that is passed by copy, the formal parameter 
object is created, and:&nbsp;</LI></UL>
<DIV Class="paranum">13</DIV>
<UL Class="CodeIndentedBulleted"><LI TYPE=DISC>For an access type, the 
formal parameter is initialized from the value of the actual, without 
a constraint check;&nbsp;</LI></UL>
<DIV Class="paranum">13.a</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>This preserves the Language Design 
Principle that an object of an access type is always initialized with 
a &ldquo;reasonable&rdquo; value.&nbsp;</DIV>
<DIV Class="paranum">14</DIV>
<UL Class="CodeIndentedBulleted"><LI TYPE=DISC>For a composite type with 
discriminants or that has implicit initial values for any subcomponents 
(see <A HREF="AA-3-3-1.html">3.3.1</A>), the behavior is as for an <B>in 
out</B> parameter passed by copy.&nbsp;</LI></UL>
<DIV Class="paranum">14.a</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>This ensures that no part of 
an object of such a type can become &ldquo;de-initialized&rdquo; by being 
part of an <B>out</B> parameter.&nbsp;</DIV>
<DIV Class="paranum">14.b</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>This includes an array 
type whose component type is an access type, and a record type with a 
component that has a <SPAN Class="swiss"><A HREF="AA-3-7.html#S0063">default_expression</A></SPAN>, 
among other things.&nbsp;</DIV>
<DIV Class="paranum">15</DIV>
<UL Class="CodeIndentedBulleted"><LI TYPE=DISC>For any other type, the 
formal parameter is uninitialized. If composite, a view conversion of 
the actual parameter to the nominal subtype of the formal is evaluated 
[(which might raise Constraint_Error)], and the actual subtype of the 
formal is that of the view conversion. If elementary, the actual subtype 
of the formal is given by its nominal subtype.&nbsp;</LI></UL>
<DIV Class="paranum">15.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>This case covers scalar 
types, and composite types whose subcomponent's subtypes do not have 
any implicit initial values. The view conversion for composite types 
ensures that if the lengths don't match between an actual and a formal 
array parameter, the Constraint_Error is raised before the call, rather 
than after.&nbsp;</DIV>
<DIV Class="paranum">16</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>constrained (object)</I> 
[partial]}</SPAN> <A NAME="I3474"></A><SPAN STYLE="font-size: 80%">{<I>unconstrained 
(object)</I> [partial]}</SPAN> <A NAME="I3475"></A>A formal parameter 
of mode <B>in out</B> or <B>out</B> with discriminants is constrained 
if either its nominal subtype or the actual parameter is constrained.</DIV>
<DIV Class="paranum">17</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>parameter copy back</I>}</SPAN> 
<A NAME="I3476"></A><SPAN STYLE="font-size: 80%">{<I>copy back of parameters</I>}</SPAN> 
<A NAME="I3477"></A><SPAN STYLE="font-size: 80%">{<I>parameter assigning 
back</I>}</SPAN> <A NAME="I3478"></A><SPAN STYLE="font-size: 80%">{<I>assigning 
back of parameters</I>}</SPAN> <A NAME="I3479"></A><SPAN STYLE="font-size: 80%">{<I>assignment 
operation (during parameter copy back)</I>}</SPAN> <A NAME="I3480"></A>After 
normal completion and leaving of a subprogram, for each <B>in out</B> 
or <B>out</B> parameter that is passed by copy, the value of the formal 
parameter is converted to the subtype of the variable given as the actual 
parameter and assigned to it. <SPAN STYLE="font-size: 80%">{<I>implicit 
subtype conversion (parameter passing)</I> [partial]}</SPAN> <A NAME="I3481"></A>These 
conversions and assignments occur in an arbitrary order.&nbsp;</DIV>
<DIV Class="paranum">17.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>The conversions mentioned 
above during parameter passing might raise Constraint_Error &mdash; (see 
<A HREF="AA-4-6.html">4.6</A>).&nbsp;</DIV>
<DIV Class="paranum">17.b</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>If any conversion or assignment 
as part of parameter passing propagates an exception, the exception is 
raised at the place of the subprogram call; that is, it cannot be handled 
inside the <SPAN Class="swiss"><A HREF="AA-6-3.html#S0162">subprogram_body</A></SPAN>. 
</DIV>
<DIV Class="paranum">17.c</DIV>
<DIV Class="Annotations"><B>Proof:&nbsp;</B>Since these checks happen before 
or after executing the <SPAN Class="swiss"><A HREF="AA-6-3.html#S0162">subprogram_body</A></SPAN>, 
the execution of the <SPAN Class="swiss"><A HREF="AA-6-3.html#S0162">subprogram_body</A></SPAN> 
does not dynamically enclose them, so it can't handle the exceptions. 
</DIV>
<DIV Class="paranum">17.d</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>The variable we're talking 
about is the one denoted by the <I>variable_</I><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
given as the <SPAN Class="swiss"><A HREF="AA-6-4.html#S0167">explicit_actual_parameter</A></SPAN>. 
If this <I>variable_</I><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
is a <SPAN Class="swiss"><A HREF="AA-4-6.html#S0127">type_conversion</A></SPAN>, 
then the rules in <A HREF="AA-4-6.html">4.6</A> for assigning to a view 
conversion apply. That is, if X is of subtype S1, and the actual is S2(X), 
the above-mentioned conversion will convert to S2, and the one mentioned 
in <A HREF="AA-4-6.html">4.6</A> will convert to S1.&nbsp;</DIV>

<H4 Class="centered">Extensions to Ada 83</H4>
<DIV Class="paranum">17.e</DIV>
<DIV Class="Annotations">{<I>extensions to Ada 83</I>} <A NAME="I3482"></A>In 
Ada 95, a program can rely on the fact that passing an object as an <B>out</B> 
parameter does not &ldquo;de-initialize&rdquo; any parts of the object 
whose subtypes have implicit initial values. (This generalizes the RM83 
rule that required copy-in for parts that were discriminants or of an 
access type.)&nbsp;</DIV>

<H4 Class="centered">Wording Changes from Ada 83</H4>
<DIV Class="paranum">17.f</DIV>
<DIV Class="Annotations">We have eliminated the subclause on Default 
Parameters, as it is subsumed by earlier clauses and subclauses.&nbsp;</DIV>

<HR>
<DIV Style="margin-top: 0.0em; margin-bottom: 0.6em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-6-4.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-6-5.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<DIV Style="margin-top:0.0em"><IMG SRC="AE_logo.gif" height=100 width=113 align=right ALT="Ada-Europe">
<SPAN Style="font-size: 125%">Sponsored by <SPAN Style="font-size: 125%"><A HREF="http://www.ada-europe.org/"><B>Ada-Europe</B></A></SPAN></SPAN></DIV>
</BODY>
</HTML>
