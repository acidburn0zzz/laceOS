<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Stream-Oriented Attributes</TITLE>
    <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    H4.centered {text-align: center}
    SPAN.swiss {font-family: Arial, Helvetica, sans-serif; font-size: 92%}
    SPAN.roman {font-family: "Times New Roman", Times, serif}
    DIV.paranum {float: left; font-family: Arial, Helvetica, sans-serif; font-size: 64%; width: 2.8em; margin-left: -0.4em; margin-right: -3.0em; margin-top: 0.2em}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    SPAN.insert1 {text-decoration: underline; color: rgb(0,51,51) }
    SPAN.delete1 {text-decoration: line-through; color: rgb(0,51,51) }
    SPAN.insert2 {text-decoration: underline; color: rgb(0,102,0) }
    SPAN.delete2 {text-decoration: line-through; color: rgb(0,102,0) }
    DIV.Normal {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.2em; margin-bottom: 0.6em}
    DIV.Annotations {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 6.2em; margin-bottom: 0.6em}
    DIV.Notes {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em; margin-bottom: 0.6em}
    DIV.NotesHeader {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em}
    DIV.Examples {font-family: "Courier New", monospace; font-size: 90%; line-height: 122%; margin-left: 3.4em; margin-bottom: 0.6em}
    DIV.SmallExamples {font-family: "Courier New", monospace; font-size: 72%; line-height: 122%; margin-left: 9.6em; margin-bottom: 0.6em}
    DIV.IndentedExamples {font-family: "Courier New", monospace; font-size: 90%; line-height: 122%; margin-left:  10.0em; margin-bottom: 0.6em}
    UL.Bulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    DIV.Hanging-Body {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 7.2em; margin-top: 0em; margin-bottom: 0.6em}
    DIV.Hanging-Term {float: left; font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.2em; margin-top: 0em; margin-bottom: 0em}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#000080" VLINK="#330033" ALINK="#0000FF">
<DIV><B><SPAN Style="font-size:200%; color: rgb(0,51,153)">Annotated</SPAN><SPAN Style="font-size:200%; color: rgb(0,0,102)">&nbsp;Ada Reference Manual</SPAN></B> &mdash; <A HREF="AA-TTL.html"><B>Legal Information</B></A></DIV>
<DIV Style="margin-top: 0.6em; margin-bottom: 0.0em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-13-13-1.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-13-14.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<HR>
<H1>13.13.2 Stream-Oriented Attributes</H1>
<DIV Class="paranum">1/1</DIV>
<DIV Class="Normal">{<I><A HREF="defect1.html#8652/0009">8652/0009</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00137.TXT">AI95-00137-01</A></I>} 
The <SPAN class="insert1">operational attributes&nbsp;</SPAN>Write, Read, 
Output, and Input <SPAN class="delete1">attributes&nbsp;</SPAN>convert values 
to a stream of elements and reconstruct values from a stream.&nbsp;</DIV>

<H4 Class="centered">Static Semantics</H4>
<DIV Class="paranum">1.1/2</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00270.TXT">AI95-00270-01</A></I>} 
<SPAN class="insert2">For every subtype S of an elementary type <I>T</I>, 
the following representation attribute is defined:</SPAN>&nbsp;</DIV>
<DIV Class="paranum">1.2/2</DIV>
<DIV Class="Hanging-Term" Style="margin-bottom: 0.4em">&nbsp;&nbsp;<SPAN class="insert2">S'Stream_Size</SPAN></DIV><DIV Class="Hanging-Body"><BR clear="left">
<SPAN class="insert2"><A NAME="I5275"></A><A NAME="I5276"></A></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00270.TXT">AI95-00270-01</A></I>} 
<SPAN class="insert2"></SPAN><SPAN class="insert2">Denotes the number 
of bits occupied in a stream by items of subtype S. Hence, the number 
of stream elements required per item of elementary type <I>T</I> is:</SPAN></DIV>
<DIV Class="paranum">1.3/2</DIV>
<DIV Class="IndentedExamples"><SPAN class="insert2"><I>T</I>'Stream_Size&nbsp;/&nbsp;Ada.Streams.Stream_Element'Size</SPAN></DIV>
<DIV Class="paranum">1.4/2</DIV>
<DIV Class="Hanging-Body"><SPAN class="insert2">The value of this attribute 
is of type <I>universal_integer</I> and is a multiple of Stream_Element'Size.</SPAN></DIV>
<DIV Class="paranum">1.5/2</DIV>
<DIV Class="Hanging-Body"><SPAN class="insert2">Stream_Size may be specified 
for first subtypes via an <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN>; 
the <SPAN Class="swiss"><A HREF="AA-4-4.html#S0115">expression</A></SPAN> 
of such a clause shall be static, nonnegative, and a multiple of Stream_Element'Size.</SPAN> 
</DIV>
<DIV Class="paranum">1.a/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Discussion:&nbsp;</B>Stream_Size 
is a type-related attribute (see <A HREF="AA-13-1.html">13.1</A>).</SPAN> 
</DIV>

<H4 Class="centered">Implementation Advice</H4>
<DIV Class="paranum">1.6/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00270.TXT">AI95-00270-01</A></I>} 
<SPAN class="insert2">If not specified, the value of Stream_Size for 
an elementary type should be the number of bits that corresponds to the 
minimum number of stream elements required by the first subtype of the 
type, rounded up to the nearest factor or multiple of the word size that 
is also a multiple of the stream element size.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">1.b/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Implementation Advice: 
</B></SPAN><SPAN class="insert2">If not specified, the value of Stream_Size 
for an elementary type should be the number of bits that corresponds 
to the minimum number of stream elements required by the first subtype 
of the type, rounded up to the nearest factor or multiple of the word 
size that is also a multiple of the stream element size.</SPAN></DIV>
<DIV Class="paranum">1.c/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Reason:&nbsp;</B></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00270.TXT">AI95-00270-01</A></I>} 
<SPAN class="insert2">This is Implementation Advice because we want to 
allow implementations to remain compatible with their Ada 95 implementations, 
which may have a different handling of the number of stream elements. 
Users can always specify Stream_Size if they need a specific number of 
stream elements.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">1.7/2</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00270.TXT">AI95-00270-01</A></I>} 
<SPAN class="insert2"><SPAN STYLE="font-size: 80%">{<I>recommended level 
of support (Stream_Size attribute)</I> [partial]}</SPAN> <A NAME="I5277"></A>The 
recommended level of support for the Stream_Size attribute is:</SPAN> 
</DIV>
<DIV Class="paranum">1.8/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00270.TXT">AI95-00270-01</A></I>} 
<SPAN class="insert2">A Stream_Size clause should be supported for a 
discrete or fixed point type <I>T</I> if the specified Stream_Size is 
a multiple of Stream_Element'Size and is no less than the size of the 
first subtype of <I>T</I>, and no greater than the size of the largest 
type of the same elementary class (signed integer, modular integer, enumeration, 
ordinary fixed point, or decimal fixed point).</SPAN>&nbsp;</LI></UL>
<DIV Class="paranum">1.d/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Implementation Advice: 
</B></SPAN><SPAN class="insert2">The recommended level of support for 
the Stream_Size attribute should be followed.</SPAN></DIV>
<DIV Class="paranum">1.e/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Ramification:&nbsp;</B>There 
are no requirements beyond supporting confirming Stream_Size clauses 
for floating point and access types. Floating point and access types 
usually only have a handful of defined formats, streaming anything else 
makes no sense for them.</SPAN></DIV>
<DIV Class="paranum">1.f/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2">For discrete and fixed 
point types, this may require support for sizes other than the &ldquo;natural&rdquo; 
ones. For instance, on a typical machine with 32-bit integers and a Stream_Element'Size 
of 8, setting Stream_Size to 24 must be supported. This is required as 
such formats can be useful for interoperability with unusual machines, 
and there is no difficulty with the implementation (drop extra bits on 
output, sign extend on input).</SPAN>&nbsp;</DIV>

<H4 Class="centered">Static Semantics</H4>
<DIV Class="paranum">2</DIV>
<DIV Class="Normal">For every subtype S of a specific type <I>T</I>, 
the following attributes are defined.&nbsp;</DIV>
<DIV Class="paranum">3</DIV>
<DIV Class="Hanging-Term" Style="margin-bottom: 0.4em">S'Write</DIV><DIV Class="Hanging-Body">
<A NAME="I5278"></A><A NAME="I5279"></A>S'Write denotes a procedure with 
the following specification:&nbsp;</DIV>
<DIV Class="paranum">4/2</DIV>
<DIV Class="IndentedExamples">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00441.TXT">AI95-00441-01</A></I>} 
<B>procedure</B>&nbsp;S'Write(<BR>
&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><I>Stream</I></SPAN>&nbsp;:&nbsp;<B></B><SPAN class="insert2"><B>not&nbsp;null&nbsp;</B></SPAN><B>access</B>&nbsp;Ada.Streams.Root_Stream_Type'Class;<BR>
&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><I>Item</I></SPAN>&nbsp;:&nbsp;<B>in</B>&nbsp;<SPAN Class="roman"><I>T</I></SPAN>)</DIV>
<DIV Class="paranum">5</DIV>
<DIV Class="Hanging-Body">S'Write writes the value of <I>Item</I> to 
<I>Stream</I>.</DIV>
<DIV Class="paranum">6</DIV>
<DIV Class="Hanging-Term" Style="margin-bottom: 0.4em">S'Read</DIV><DIV Class="Hanging-Body">
<A NAME="I5280"></A><A NAME="I5281"></A>S'Read denotes a procedure with 
the following specification:&nbsp;</DIV>
<DIV Class="paranum">7/2</DIV>
<DIV Class="IndentedExamples">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00441.TXT">AI95-00441-01</A></I>} 
<B>procedure</B>&nbsp;S'Read(<BR>
&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><I>Stream</I></SPAN>&nbsp;:&nbsp;<B></B><SPAN class="insert2"><B>not&nbsp;null&nbsp;</B></SPAN><B>access</B>&nbsp;Ada.Streams.Root_Stream_Type'Class;<BR>
&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><I>Item</I></SPAN>&nbsp;:&nbsp;<B>out</B>&nbsp;<SPAN Class="roman"><I>T</I></SPAN>)</DIV>
<DIV Class="paranum">8</DIV>
<DIV Class="Hanging-Body">S'Read reads the value of <I>Item</I> from 
<I>Stream</I>.&nbsp;</DIV>
<DIV Class="paranum">8.1/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;{<I><A HREF="defect1.html#8652/0040">8652/0040</A></I>} 
<SPAN class="insert1"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00108.TXT">AI95-00108-01</A></I>} 
<SPAN class="insert1"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00444.TXT">AI95-00444-01</A></I>} 
<SPAN class="insert1">For&nbsp;</SPAN><SPAN class="insert2">an&nbsp;</SPAN><SPAN class="insert1">untagged 
derived&nbsp;</SPAN><SPAN class="insert2">type</SPAN><SPAN class="insert1"></SPAN><SPAN class="insert1"><SPAN class="delete2">&nbsp;types</SPAN></SPAN><SPAN class="insert1">, 
the Write&nbsp;</SPAN><SPAN class="insert2">(resp.</SPAN><SPAN class="insert1"></SPAN><SPAN class="insert1"><SPAN class="delete2">&nbsp;and</SPAN></SPAN><SPAN class="insert1">&nbsp;Read</SPAN><SPAN class="insert2">) attribute is</SPAN><SPAN class="insert1"></SPAN><SPAN class="insert1"><SPAN class="delete2">&nbsp;attributes are</SPAN></SPAN><SPAN class="insert1">&nbsp;inherited&nbsp;</SPAN><SPAN class="insert2">according 
to the rules given</SPAN><SPAN class="insert1"></SPAN><SPAN class="insert1"><SPAN class="delete2">&nbsp;as 
specified</SPAN></SPAN><SPAN class="insert1">&nbsp;in <A HREF="AA-13-1.html">13.1</A></SPAN><SPAN class="insert2">&nbsp;if the attribute is available for the parent type at the point where 
<I>T</I> is declared. For a tagged derived type, these attributes are 
not inherited, but rather</SPAN><SPAN class="insert1"></SPAN><SPAN class="insert1"><SPAN class="delete2">; 
otherwise,</SPAN></SPAN><SPAN class="insert1">&nbsp;the default implementations 
</SPAN><SPAN class="insert1"><SPAN class="delete2">of these attributes 
</SPAN></SPAN><SPAN class="insert1">are used.</SPAN><SPAN class="insert1"><SPAN class="delete2">&nbsp;The 
default implementations of Write and Read attributes execute as follows:</SPAN></SPAN><SPAN class="insert1"></SPAN></DIV>
<DIV Class="paranum">8.2/2</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00444.TXT">AI95-00444-01</A></I>} 
<SPAN class="insert2">The default implementations of the Write and Read 
attributes, where available, execute as follows:</SPAN></DIV>
<DIV Class="paranum">9/2</DIV>
<DIV Class="Normal">{<I><A HREF="defect1.html#8652/0040">8652/0040</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00108.TXT">AI95-00108-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00195.TXT">AI95-00195-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00270.TXT">AI95-00270-01</A></I>} 
For elementary types, <SPAN class="insert2">Read reads (and Write writes) 
the number of stream elements implied by the Stream_Size for the type 
<I>T</I>;</SPAN> the representation <SPAN class="delete2">in terms&nbsp;</SPAN>of<SPAN class="insert2">&nbsp;those</SPAN> stream elements is implementation defined. For composite 
types, the Write or Read attribute for each component is called in <SPAN class="delete1">a 
</SPAN>canonical order<SPAN class="insert1">, which</SPAN><SPAN class="delete1">. 
The canonical order of components</SPAN> is last dimension varying fastest 
for an array, and positional aggregate order for a record. Bounds are 
not included in the stream if <I>T</I> is an array type. If <I>T</I> 
is a discriminated type, discriminants are included only if they have 
defaults. If <I>T</I> is a tagged type, the tag is not included. <SPAN class="insert1">For 
type extensions, the Write or Read attribute for the parent type is called, 
followed by the Write or Read attribute of each component of the extension 
part, in canonical order. For a limited type extension, if the attribute 
of&nbsp;</SPAN><SPAN class="insert2">the parent</SPAN><SPAN class="insert1"></SPAN><SPAN class="insert1"><SPAN class="delete2">&nbsp;any 
ancestor</SPAN></SPAN><SPAN class="insert1">&nbsp;type&nbsp;</SPAN><SPAN class="insert2">or 
any progenitor type&nbsp;</SPAN><SPAN class="insert1">of <I>T</I>&nbsp;</SPAN><SPAN class="insert2">is 
available anywhere within the immediate scope of <I>T</I>,</SPAN><SPAN class="insert1"></SPAN><SPAN class="insert1"><SPAN class="delete2">&nbsp;has 
been directly specified</SPAN></SPAN><SPAN class="insert1">&nbsp;and the attribute 
of&nbsp;</SPAN><SPAN class="insert2">the parent type or</SPAN><SPAN class="insert1"></SPAN><SPAN class="insert1"><SPAN class="delete2">&nbsp;any 
ancestor type of</SPAN></SPAN><SPAN class="insert1">&nbsp;the type of any 
of the extension components&nbsp;</SPAN><SPAN class="insert2">is not available 
at the freezing point of <I>T</I>, then</SPAN><SPAN class="insert1"></SPAN><SPAN class="insert1"><SPAN class="delete2">&nbsp;which 
are of a limited type has not been specified,</SPAN></SPAN><SPAN class="insert1">&nbsp;the attribute of <I>T</I> shall be directly specified.</SPAN></DIV>
<DIV Class="paranum">9.a/2</DIV>
<DIV Class="Annotations"><B>Implementation defined:&nbsp;</B>The <SPAN class="insert2">contents 
of the stream elements read and written</SPAN><SPAN class="delete2">&nbsp;representation 
used</SPAN> by the Read and Write attributes of elementary types<SPAN class="delete2">&nbsp;in terms of stream elements</SPAN>.</DIV>
<DIV Class="paranum">9.b</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>A discriminant with a default 
value is treated simply as a component of the object. On the other hand, 
an array bound or a discriminant without a default value, is treated 
as &ldquo;descriptor&rdquo; or &ldquo;dope&rdquo; that must be provided 
in order to create the object and thus is logically separate from the 
regular components. Such &ldquo;descriptor&rdquo; data are written by 
'Output and produced as part of the delivered result by the 'Input function, 
but they are not written by 'Write nor read by 'Read. A tag is like a 
discriminant without a default.</DIV>
<DIV Class="paranum">9.b.1/1</DIV>
<DIV Class="Annotations">{<I><A HREF="defect1.html#8652/0040">8652/0040</A></I>} 
<SPAN class="insert1"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00108.TXT">AI95-00108-01</A></I>} 
<SPAN class="insert1">For limited type extensions, we must have a definition 
of 'Read and 'Write if the parent type has one, as it is possible to 
make a dispatching call through the attributes. The rule is designed 
to automatically do the right thing in as many cases as possible.</SPAN></DIV>
<DIV Class="paranum">9.b.2/1</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
<SPAN class="insert1">Similarly, a type that has a progenitor with an 
available attribute must also have that attribute, for the same reason.</SPAN> 
</DIV>
<DIV Class="paranum">9.c/2</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00195.TXT">AI95-00195-01</A></I>} 
For a composite object, the subprogram denoted by the Write or Read attribute 
of each component is called, whether it is the default or is user-specified.<SPAN class="insert2">&nbsp;Implementations are allowed to optimize these calls (see below), presuming 
the properties of the attributes are preserved.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">9.1/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00270.TXT">AI95-00270-01</A></I>} 
<SPAN class="insert2">Constraint_Error is raised by the predefined Write 
attribute if the value of the elementary item is outside the range of 
values representable using Stream_Size bits. For a signed integer type, 
an enumeration type, or a fixed point type, the range is unsigned only 
if the integer code for the lower bound of the first subtype is nonnegative, 
and a (symmetric) signed range that covers all values of the first subtype 
would require more than Stream_Size bits; otherwise the range is signed.</SPAN></DIV>
<DIV Class="paranum">10</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">For every subtype S'Class 
of a class-wide type <I>T</I>'Class:&nbsp;</DIV>
<DIV Class="paranum">11</DIV>
<DIV Class="Hanging-Term" Style="margin-bottom: 0.4em">S'Class'Write</DIV><DIV Class="Hanging-Body">
<A NAME="I5282"></A><A NAME="I5283"></A>S'Class'Write denotes a procedure 
with the following specification:&nbsp;</DIV>
<DIV Class="paranum">12/2</DIV>
<DIV Class="IndentedExamples">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00441.TXT">AI95-00441-01</A></I>} 
<B>procedure</B>&nbsp;S'Class'Write(<BR>
&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><I>Stream</I></SPAN>&nbsp;:&nbsp;<B></B><SPAN class="insert2"><B>not&nbsp;null&nbsp;</B></SPAN><B>access</B>&nbsp;Ada.Streams.Root_Stream_Type'Class;<BR>
&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><I>Item</I></SPAN>&nbsp;&nbsp;&nbsp;:&nbsp;<B>in</B>&nbsp;<SPAN Class="roman"><I>T</I></SPAN>'Class)</DIV>
<DIV Class="paranum">13</DIV>
<DIV Class="Hanging-Body">Dispatches to the subprogram denoted by the 
Write attribute of the specific type identified by the tag of Item.</DIV>
<DIV Class="paranum">14</DIV>
<DIV Class="Hanging-Term" Style="margin-bottom: 0.4em">S'Class'Read</DIV><DIV Class="Hanging-Body">
<A NAME="I5284"></A><A NAME="I5285"></A>S'Class'Read denotes a procedure 
with the following specification:&nbsp;</DIV>
<DIV Class="paranum">15/2</DIV>
<DIV Class="IndentedExamples">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00441.TXT">AI95-00441-01</A></I>} 
<B>procedure</B>&nbsp;S'Class'Read(<BR>
&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><I>Stream</I></SPAN>&nbsp;:&nbsp;<B></B><SPAN class="insert2"><B>not&nbsp;null&nbsp;</B></SPAN><B>access</B>&nbsp;Ada.Streams.Root_Stream_Type'Class;<BR>
&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><I>Item</I></SPAN>&nbsp;:&nbsp;<B>out</B>&nbsp;<SPAN Class="roman"><I>T</I></SPAN>'Class)</DIV>
<DIV Class="paranum">16</DIV>
<DIV Class="Hanging-Body">Dispatches to the subprogram denoted by the 
Read attribute of the specific type identified by the tag of Item.&nbsp;</DIV>
<DIV Class="paranum">16.a</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>It is necessary to have class-wide 
versions of Read and Write in order to avoid generic contract model violations; 
in a generic, we don't necessarily know at compile time whether a given 
type is specific or class-wide.&nbsp;</DIV>

<H4 Class="centered">Implementation Advice</H4>
<DIV Class="paranum">17/2</DIV>
<DIV Class="Normal">&nbsp;<SPAN STYLE="font-size: 80%"><I>This paragraph was 
deleted.</I></SPAN><SPAN class="delete2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00270.TXT">AI95-00270-01</A></I>} 
<SPAN class="delete2">If a stream element is the same size as a storage 
element, then the normal in-memory representation should be used by Read 
and Write for scalar objects. Otherwise, Read and Write should use the 
smallest number of stream elements needed to represent all values in 
the base range of the scalar type.</SPAN>&nbsp;</DIV>

<H4 Class="centered">Static Semantics</H4>
<DIV Class="paranum">18</DIV>
<DIV Class="Normal">For every subtype S of a specific type <I>T</I>, 
the following attributes are defined.&nbsp;</DIV>
<DIV Class="paranum">19</DIV>
<DIV Class="Hanging-Term" Style="margin-bottom: 0.4em">S'Output</DIV><DIV Class="Hanging-Body">
<A NAME="I5286"></A><A NAME="I5287"></A>S'Output denotes a procedure 
with the following specification:&nbsp;</DIV>
<DIV Class="paranum">20/2</DIV>
<DIV Class="IndentedExamples">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00441.TXT">AI95-00441-01</A></I>} 
<B>procedure</B>&nbsp;S'Output(<BR>
&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><I>Stream</I></SPAN>&nbsp;:&nbsp;<B></B><SPAN class="insert2"><B>not&nbsp;null&nbsp;</B></SPAN><B>access</B>&nbsp;Ada.Streams.Root_Stream_Type'Class;<BR>
&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><I>Item</I></SPAN>&nbsp;:&nbsp;<B>in</B>&nbsp;<SPAN Class="roman"><I>T</I></SPAN>)</DIV>
<DIV Class="paranum">21</DIV>
<DIV Class="Hanging-Body">S'Output writes the value of <I>Item</I> to 
<I>Stream</I>, including any bounds or discriminants.&nbsp;</DIV>
<DIV Class="paranum">21.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>Note that the bounds are 
included even for an array type whose first subtype is constrained.&nbsp;</DIV>
<DIV Class="paranum">22</DIV>
<DIV Class="Hanging-Term" Style="margin-bottom: 0.4em">S'Input</DIV><DIV Class="Hanging-Body">
<A NAME="I5288"></A><A NAME="I5289"></A>S'Input denotes a function with 
the following specification:&nbsp;</DIV>
<DIV Class="paranum">23/2</DIV>
<DIV Class="IndentedExamples">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00441.TXT">AI95-00441-01</A></I>} 
<B>function</B>&nbsp;S'Input(<BR>
&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><I>Stream</I></SPAN>&nbsp;:&nbsp;<B></B><SPAN class="insert2"><B>not&nbsp;null&nbsp;</B></SPAN><B>access</B>&nbsp;Ada.Streams.Root_Stream_Type'Class)<BR>
&nbsp;&nbsp;&nbsp;<B>return</B>&nbsp;<SPAN Class="roman"><I>T</I></SPAN></DIV>
<DIV Class="paranum">24</DIV>
<DIV Class="Hanging-Body">S'Input reads and returns one value from <I>Stream</I>, 
using any bounds or discriminants written by a corresponding S'Output 
to determine how much to read.&nbsp;</DIV>
<DIV Class="paranum">25/2</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="defect1.html#8652/0040">8652/0040</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00108.TXT">AI95-00108-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00444.TXT">AI95-00444-01</A></I>} 
<SPAN class="insert1">For&nbsp;</SPAN><SPAN class="insert2">an&nbsp;</SPAN><SPAN class="insert1">untagged 
derived&nbsp;</SPAN><SPAN class="insert2">type</SPAN><SPAN class="insert1"></SPAN><SPAN class="insert1"><SPAN class="delete2">&nbsp;types</SPAN></SPAN><SPAN class="insert1">, 
the Output&nbsp;</SPAN><SPAN class="insert2">(resp.</SPAN><SPAN class="insert1"></SPAN><SPAN class="insert1"><SPAN class="delete2">&nbsp;and</SPAN></SPAN><SPAN class="insert1">&nbsp;Input</SPAN><SPAN class="insert2">) attribute is</SPAN><SPAN class="insert1"></SPAN><SPAN class="insert1"><SPAN class="delete2">&nbsp;attributes 
of the parent type are</SPAN></SPAN><SPAN class="insert1">&nbsp;inherited 
</SPAN><SPAN class="insert2">according to the rules given</SPAN><SPAN class="insert1"></SPAN><SPAN class="insert1"><SPAN class="delete2">&nbsp;as 
specified</SPAN></SPAN><SPAN class="insert1">&nbsp;in <A HREF="AA-13-1.html">13.1</A></SPAN><SPAN class="insert2">&nbsp;if the attribute is available for the parent type at the point where 
<I>T</I> is declared. For a tagged derived type, these attributes are 
not inherited, but rather</SPAN><SPAN class="insert1"></SPAN><SPAN class="insert1"><SPAN class="delete2">; 
otherwise,</SPAN></SPAN><SPAN class="insert1">&nbsp;the default implementations</SPAN><SPAN class="insert1"><SPAN class="delete2">&nbsp;of these attributes</SPAN></SPAN><SPAN class="insert1">&nbsp;are used.</SPAN><SPAN class="insert1"><SPAN class="delete2">&nbsp;The default implementations of Output and Input attributes execute as 
follows:</SPAN></SPAN><SPAN class="insert1"></SPAN><SPAN class="delete1">&nbsp;Unless 
overridden by an <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN>, 
these subprograms execute as follows:</SPAN></DIV>
<DIV Class="paranum">25.1/2</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00444.TXT">AI95-00444-01</A></I>} 
<SPAN class="insert2">The default implementations of the Output and Input 
attributes, where available, execute as follows:</SPAN>&nbsp;</DIV>
<DIV Class="paranum">26</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>If <I>T</I> is an array type, S'Output 
first writes the bounds, and S'Input first reads the bounds. If <I>T</I> 
has discriminants without defaults, S'Output first writes the discriminants 
(using S'Write for each), and S'Input first reads the discriminants (using 
S'Read for each).</LI></UL>
<DIV Class="paranum">27/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00195.TXT">AI95-00195-01</A></I>} 
S'Output then calls S'Write to write the value of <I>Item</I> to the 
stream. S'Input then creates an object (with the bounds or discriminants, 
if any, taken from the stream), <SPAN class="insert2">passes</SPAN><SPAN class="delete2">&nbsp;initializes</SPAN> 
it <SPAN class="insert2">to</SPAN><SPAN class="delete2">&nbsp;with</SPAN> 
S'Read, and returns the value of the object.<SPAN class="insert2">&nbsp;Normal 
default initialization and finalization take place for this object (see 
<A HREF="AA-3-3-1.html">3.3.1</A>, <A HREF="AA-7-6.html">7.6</A>, and 
<A HREF="AA-7-6-1.html">7.6.1</A>).</SPAN>&nbsp;</LI></UL>
<DIV Class="paranum">27.1/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
<SPAN class="insert2">If <I>T</I> is an abstract type, then S'Input is 
an abstract function.</SPAN></DIV>
<DIV Class="paranum">27.a/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Ramification:&nbsp;</B>For 
an abstract type <I>T</I>, S'Input can be called in a dispatching call, 
or passed to a abstract formal subprogram. But it cannot be used in non-dispatching 
contexts, because we don't allow objects of abstract types to exist. 
The designation of this function as abstract has no impact on descendants 
of <I>T</I>, as <I>T</I>'Input is not inherited for tagged types, but 
rather recreated (and the default implementation of <I>T</I>'Input calls 
<I>T</I>'Read, not the parent type's <I>T</I>'Input). Note that <I>T</I>'Input 
cannot be specified in this case, as any function with the proper profile 
is necessarily abstract, and specifying abstract subprograms in an <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN> 
is illegal.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">28</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">For every subtype S'Class 
of a class-wide type <I>T</I>'Class:&nbsp;</DIV>
<DIV Class="paranum">29</DIV>
<DIV Class="Hanging-Term" Style="margin-bottom: 0.4em">S'Class'Output</DIV><DIV Class="Hanging-Body"><BR clear="left">
<A NAME="I5290"></A><A NAME="I5291"></A>S'Class'Output denotes a procedure 
with the following specification:&nbsp;</DIV>
<DIV Class="paranum">30/2</DIV>
<DIV Class="IndentedExamples">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00441.TXT">AI95-00441-01</A></I>} 
<B>procedure</B>&nbsp;S'Class'Output(<BR>
&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><I>Stream</I></SPAN>&nbsp;:&nbsp;<B></B><SPAN class="insert2"><B>not&nbsp;null&nbsp;</B></SPAN><B>access</B>&nbsp;Ada.Streams.Root_Stream_Type'Class;<BR>
&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><I>Item</I></SPAN>&nbsp;&nbsp;&nbsp;:&nbsp;<B>in</B>&nbsp;<SPAN Class="roman"><I>T</I></SPAN>'Class)</DIV>
<DIV Class="paranum">31/2</DIV>
<DIV Class="Hanging-Body">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00344.TXT">AI95-00344-01</A></I>} 
First writes the external tag of <I>Item</I> to <I>Stream</I> (by calling 
String'Output(<SPAN class="insert2"><I>Stream</I>,&nbsp;</SPAN>Tags.External_Tag(<I>Item</I>'Tag)<SPAN class="insert2">)</SPAN> 
&mdash; see <A HREF="AA-3-9.html">3.9</A>) and then dispatches to the 
subprogram denoted by the Output attribute of the specific type identified 
by the tag.<SPAN class="insert2">&nbsp;Tag_Error is raised if the tag of Item 
identifies a type declared at an accessibility level deeper than that 
of S.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">31.a/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Reason:&nbsp;</B></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00344.TXT">AI95-00344-01</A></I>} 
<SPAN class="insert2">We raise Tag_Error here for nested types as such 
a type cannot be successfully read with S'Class'Input, and it doesn't 
make sense to allow writing a value that cannot be read.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">32</DIV>
<DIV Class="Hanging-Term" Style="margin-bottom: 0.4em">S'Class'Input</DIV><DIV Class="Hanging-Body">
<A NAME="I5292"></A><A NAME="I5293"></A>S'Class'Input denotes a function 
with the following specification:&nbsp;</DIV>
<DIV Class="paranum">33/2</DIV>
<DIV Class="IndentedExamples">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00441.TXT">AI95-00441-01</A></I>} 
<B>function</B>&nbsp;S'Class'Input(<BR>
&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><I>Stream</I></SPAN>&nbsp;:&nbsp;<B></B><SPAN class="insert2"><B>not&nbsp;null&nbsp;</B></SPAN><B>access</B>&nbsp;Ada.Streams.Root_Stream_Type'Class)<BR>
&nbsp;&nbsp;&nbsp;<B>return</B>&nbsp;<SPAN Class="roman"><I>T</I></SPAN>'Class</DIV>
<DIV Class="paranum">34/2</DIV>
<DIV Class="Hanging-Body">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00279.TXT">AI95-00279-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00344.TXT">AI95-00344-01</A></I>} 
First reads the external tag from <I>Stream</I> and determines the corresponding 
internal tag (by calling Tags.<SPAN class="insert2">Descendant_Tag</SPAN><SPAN class="delete2">&nbsp;Internal_Tag</SPAN>(String'Input(<I>Stream</I>)<SPAN class="insert2">, 
S'Tag</SPAN>) <SPAN class="insert2">which might raise Tag_Error&nbsp;</SPAN>&mdash; 
see <A HREF="AA-3-9.html">3.9</A>) and then dispatches to the subprogram 
denoted by the Input attribute of the specific type identified by the 
internal tag; returns that result.<SPAN class="insert2">&nbsp;If the specific 
type identified by the internal tag is not covered by <I>T</I>'Class 
or is abstract, Constraint_Error is raised.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">35/2</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00195.TXT">AI95-00195-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>Range_Check</I> [partial]}</SPAN> <A NAME="I5294"></A><SPAN STYLE="font-size: 80%">{<I>check, 
language-defined (Range_Check)</I>}</SPAN> <A NAME="I5295"></A>In the 
default implementation of Read and Input for a composite type, for each 
scalar component that is a discriminant or whose <SPAN Class="swiss"><A HREF="AA-3-8.html#S0070">component_declaration</A></SPAN> 
includes a <SPAN Class="swiss"><A HREF="AA-3-7.html#S0063">default_expression</A></SPAN>, 
a check is made that the value returned by Read for the component belongs 
to its subtype. <SPAN STYLE="font-size: 80%">{<I>Constraint_Error (raised 
by failure of run-time check)</I>}</SPAN> <A NAME="I5296"></A>Constraint_Error 
is raised if this check fails. For other scalar components, no check 
is made. For each component that is of an access type, if the implementation 
can detect that the value returned by Read for the component is not a 
value of its subtype, Constraint_Error is raised. If the value is not 
a value of its subtype and this error is not detected, the component 
has an abnormal value, and erroneous execution can result (see <A HREF="AA-13-9-1.html">13.9.1</A>).<SPAN class="insert2">&nbsp;In the default implementation of Read for a composite type with defaulted 
discriminants, if the actual parameter of Read is constrained, a check 
is made that the discriminants read from the stream are equal to those 
of the actual parameter. Constraint_Error is raised if this check fails.</SPAN></DIV>
<DIV Class="paranum">36/2</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00195.TXT">AI95-00195-01</A></I>} 
<SPAN class="insert2"><SPAN STYLE="font-size: 80%">{<I>unspecified</I> 
[partial]}</SPAN> <A NAME="I5297"></A>It is unspecified at which point 
and in which order these checks are performed. In particular, if Constraint_Error 
is raised due to the failure of one of these checks, it is unspecified 
how many stream elements have been read from the stream.</SPAN></DIV>
<DIV Class="paranum">37/1</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="defect1.html#8652/0045">8652/0045</A></I>} 
<SPAN class="insert1"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00132.TXT">AI95-00132-01</A></I>} 
<SPAN class="insert1"><SPAN STYLE="font-size: 80%">{<I>End_Error (raised 
by failure of run-time check)</I>}</SPAN> <A NAME="I5298"></A>In the 
default implementation of Read and Input for a type, End_Error is raised 
if the end of the stream is reached before the reading of a value of 
the type is completed.</SPAN></DIV>
<DIV Class="paranum">38/2</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="defect1.html#8652/0040">8652/0040</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00108.TXT">AI95-00108-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00195.TXT">AI95-00195-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>specifiable (of Read for a type)</I> 
[partial]}</SPAN> <A NAME="I5299"></A><SPAN STYLE="font-size: 80%">{<I>specifiable 
(of Write for a type)</I> [partial]}</SPAN> <A NAME="I5300"></A><SPAN STYLE="font-size: 80%">{<I>specifiable 
(of Input for a type)</I> [partial]}</SPAN> <A NAME="I5301"></A><SPAN STYLE="font-size: 80%">{<I>specifiable 
(of Output for a type)</I> [partial]}</SPAN> <A NAME="I5302"></A><SPAN STYLE="font-size: 80%">{<I>Read 
clause</I>}</SPAN> <A NAME="I5303"></A><SPAN STYLE="font-size: 80%">{<I>Write 
clause</I>}</SPAN> <A NAME="I5304"></A><SPAN STYLE="font-size: 80%">{<I>Input 
clause</I>}</SPAN> <A NAME="I5305"></A><SPAN STYLE="font-size: 80%">{<I>Output 
clause</I>}</SPAN> <A NAME="I5306"></A>The stream-oriented attributes 
may be specified for any type via an <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN>. 
<SPAN class="insert2">The subprogram name given in such a clause shall 
not denote an abstract subprogram. Furthermore, if a stream-oriented 
attribute is specified for an interface type by an <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN>, 
the subprogram name given in the clause shall statically denote a null 
procedure.</SPAN><SPAN class="delete2">&nbsp;All nonlimited types have default 
implementations for these operations. An <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0100">attribute_reference</A></SPAN> 
for one of these attributes is illegal if the type is limited, unless 
the attribute has been specified by an <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN></SPAN><SPAN class="insert1"><SPAN class="delete2">&nbsp;or [(for a type extension)] the attribute has been specified for an ancestor 
type</SPAN></SPAN><SPAN class="delete2">. For an <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN> 
specifying one of these attributes, the subtype of the Item parameter 
shall be the base subtype if scalar, and the first subtype otherwise. 
The same rule applies to the result of the Input function.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">38.a/2</DIV>
<DIV Class="Annotations"><SPAN STYLE="font-size: 80%"><I>This paragraph 
was deleted.</I></SPAN><SPAN class="delete2"><B>Reason:&nbsp;</B></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00195.TXT">AI95-00195-01</A></I>} 
<SPAN class="delete2">This is to simplify implementation.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">38.a.1/2</DIV>
<DIV Class="Annotations"><SPAN STYLE="font-size: 80%"><I>This paragraph 
was deleted.</I></SPAN><SPAN class="delete2"><B>Discussion:&nbsp;</B></SPAN>{<I><A HREF="defect1.html#8652/0040">8652/0040</A></I>} 
<SPAN class="delete2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00108.TXT">AI95-00108-01</A></I>} 
<SPAN class="delete2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00195.TXT">AI95-00195-01</A></I>} 
<SPAN class="delete2"></SPAN><SPAN class="insert1"><SPAN class="delete2">&ldquo;Specified&rdquo; 
includes inherited attributes, and default implementations are never 
inherited. So, for untagged limited types, the second part of the <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0100">attribute_reference</A></SPAN> 
rule has the same meaning as the first part. However, tagged types never 
inherit attributes, so the second rule is needed so that the default 
implementations for the attributes can be called when those are constructed 
from a directly specified ancestor.</SPAN></SPAN><SPAN class="delete2"></SPAN> 
</DIV>
<DIV Class="paranum">38.b/2</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><SPAN class="insert2"><B>Discussion: 
</B></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
<SPAN class="insert2">Stream attributes (other than Input) are always 
null procedures for interface types (they have no components). We need 
to allow explicit setting of the Read and Write attributes in order that 
the class-wide attributes like LI'Class'Input can be made available. 
(In that case, any descendant of the interface type would require available 
attributes.) But we don't allow any concrete implementation because these 
don't participate in extensions (unless the interface is the parent type). 
If we didn't ban concrete implementations, the order of declaration of 
a pair of interfaces would become significant. For example, if Int1 and 
Int2 are interfaces with concrete implementations of 'Read, then the 
following declarations would have different implementations for 'Read:</SPAN> 
</DIV>
<DIV Class="paranum">38.c/2</DIV>
<DIV Class="SmallExamples"><SPAN class="insert2"><B>type</B>&nbsp;Con1&nbsp;<B>is&nbsp;new</B>&nbsp;Int1&nbsp;<B>and</B>&nbsp;Int2&nbsp;<B>with&nbsp;null&nbsp;record</B>;<BR>
<B>type</B>&nbsp;Con2&nbsp;<B>is&nbsp;new</B>&nbsp;Int2&nbsp;<B>and</B>&nbsp;Int1&nbsp;<B>with&nbsp;null&nbsp;record</B>;</SPAN></DIV>
<DIV Class="paranum">38.d/2</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.9em"><SPAN class="insert2">This 
would violate our design principle that the order of the specification 
of the interfaces in a <SPAN Class="swiss"><A HREF="AA-3-4.html#S0035">derived_type_definition</A></SPAN> 
doesn't matter.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">38.e/2</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><SPAN class="insert2"><B>Ramification: 
</B>The Input attribute cannot be specified for an interface. As it is 
a function, a null procedure is impossible; a concrete function is not 
possible anyway as any function returning an abstract type must be abstract. 
And we don't allow specifying stream attributes to be abstract subprograms. 
This has no impact, as the availability of Int'Class'Input (where Int 
is a limited interface) depends on whether Int'Read (not Int'Input) is 
specified. There is no reason to allow Int'Output to be specified, either, 
but there is equally no reason to disallow it, so we don't have a special 
rule for that.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">38.f/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Discussion:&nbsp;</B></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00195.TXT">AI95-00195-01</A></I>} 
<SPAN class="insert2">Limited types generally do not have default implementations 
of the stream-oriented attributes. The rules defining when a stream-oriented 
attribute is available (see below) determine when an attribute of a limited 
type is in fact well defined and usable. The rules are designed to maximize 
the number of cases in which the attributes are usable. For instance, 
when the language provides a default implementation of an attribute for 
a limited type based on a specified attribute for the parent type, we 
want to be able to call that attribute.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">39/2</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00195.TXT">AI95-00195-01</A></I>} 
<SPAN class="insert2">A stream-oriented attribute for a subtype of a 
specific type <I>T</I> is <I>available</I> at places where one of the 
following conditions is true: <SPAN STYLE="font-size: 80%">{<I>available 
(stream attribute)</I>}</SPAN> <A NAME="I5307"></A></SPAN></DIV>
<DIV Class="paranum">40/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN class="insert2"><I>T</I> is 
nonlimited.</SPAN></LI></UL>
<DIV Class="paranum">41/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN class="insert2">The <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0101">attribute_designator</A></SPAN> 
is Read (resp. Write) and <I>T</I> is a limited record extension, and 
the attribute Read (resp. Write) is available for the parent type of 
<I>T</I> and for the types of all of the extension components.</SPAN> 
</LI></UL>
<DIV Class="paranum">41.a/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Reason:&nbsp;</B>In this 
case, the language provides a well-defined default implementation, which 
we want to be able to call.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">42/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN class="insert2"><I>T</I> is 
a limited untagged derived type, and the attribute was inherited for 
the type.</SPAN>&nbsp;</LI></UL>
<DIV Class="paranum">42.a/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Reason:&nbsp;</B>Attributes 
are only inherited for untagged derived types, and surely we want to 
be able to call inherited attributes.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">43/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN class="insert2">The <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0101">attribute_designator</A></SPAN> 
is Input (resp. Output), and <I>T</I> is a limited type, and the attribute 
Read (resp. Write) is available for <I>T</I>.</SPAN>&nbsp;</LI></UL>
<DIV Class="paranum">43.a/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Reason:&nbsp;</B>The default 
implementation of Input and Output are based on Read and Write; so if 
the implementation of Read or Write is good, so is the matching implementation 
of Input or Output.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">44/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN class="insert2">The attribute 
has been specified via an <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN>, 
and the <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN> 
is visible.</SPAN>&nbsp;</LI></UL>
<DIV Class="paranum">44.a/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Reason:&nbsp;</B>We always 
want to allow calling a specified attribute. But we don't want availability 
to break privacy. Therefore, only attributes whose specification can 
be seen count. Yes, we defined the visibility of an <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN> 
(see <A HREF="AA-8-3.html">8.3</A>).</SPAN>&nbsp;</DIV>
<DIV Class="paranum">45/2</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00195.TXT">AI95-00195-01</A></I>} 
<SPAN class="insert2">A stream-oriented attribute for a subtype of a 
class-wide type <I>T</I>'Class is available at places where one of the 
following conditions is true:</SPAN></DIV>
<DIV Class="paranum">46/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN class="insert2"><I>T</I> is 
nonlimited;</SPAN></LI></UL>
<DIV Class="paranum">47/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN class="insert2">the attribute 
has been specified via an <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN>, 
and the <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN> 
is visible; or</SPAN></LI></UL>
<DIV Class="paranum">48/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN class="insert2">the corresponding 
attribute of <I>T</I> is available, provided that if <I>T</I> has a partial 
view, the corresponding attribute is available at the end of the visible 
part where <I>T</I> is declared.</SPAN></LI></UL>
<DIV Class="paranum">48.a/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Reason:&nbsp;</B>The rules 
are stricter for class-wide attributes because (for the default implementation) 
we must ensure that any specific attribute that might ever be dispatched 
to is available. Because we require specification of attributes for extensions 
of limited parent types with available attributes, we can in fact know 
this. Otherwise, we would not be able to use default class-wide attributes 
with limited types, a significant limitation.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">49/2</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00195.TXT">AI95-00195-01</A></I>} 
<SPAN class="insert2">An <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0100">attribute_reference</A></SPAN> 
for one of the stream-oriented attributes is illegal unless the attribute 
is available at the place of the <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0100">attribute_reference</A></SPAN>. 
Furthermore, an <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0100">attribute_reference</A></SPAN> 
for <I>T</I>'Input is illegal if <I>T</I> is an abstract type.</SPAN></DIV>
<DIV Class="paranum">49.a/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Discussion:&nbsp;</B>Stream 
attributes always exist. It is illegal to call them in some cases. Having 
the attributes not be defined for some limited types would seem to be 
a cleaner solution, but it would lead to contract model problems for 
limited private types.</SPAN></DIV>
<DIV Class="paranum">49.b/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><I>T</I>'Input is available 
for abstract types so that <I>T</I>'Class'Input is available. But we 
certainly don't want to allow calls that could create an object of an 
abstract type. Remember that <I>T</I>'Class is never abstract, so the 
above legality rule doesn't apply to it. We don't have to discuss whether 
the attribute is specified, as it cannot be: any function returning the 
type would have to be abstract, and we do not allow specifying an attribute 
with an abstract subprogram.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">50/2</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00195.TXT">AI95-00195-01</A></I>} 
<SPAN class="insert2">In the <SPAN Class="swiss"><A HREF="AA-6-1.html#S0158">parameter_and_result_profile</A></SPAN>s 
for the stream-oriented attributes, the subtype of the Item parameter 
is the base subtype of <I>T</I> if <I>T</I> is a scalar type, and the 
first subtype otherwise. The same rule applies to the result of the Input 
attribute.</SPAN></DIV>
<DIV Class="paranum">51/2</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00195.TXT">AI95-00195-01</A></I>} 
<SPAN class="insert2">For an <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN> 
specifying one of these attributes, the subtype of the Item parameter 
shall be the base subtype if scalar, and the first subtype otherwise. 
The same rule applies to the result of the Input function.</SPAN></DIV>
<DIV Class="paranum">51.a/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Reason:&nbsp;</B>This is 
to simplify implementation.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">51.b/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Ramification:&nbsp;</B>The 
view of the type at the point of the <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN> 
determines whether the first subtype or base subtype is required. Thus, 
for a scalar type with a partial view (which is never scalar), whether 
the first subtype or the base subtype is required is determined by whether 
the <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN> 
occurs before or after the full definition of the scalar type.</SPAN> 
</DIV>
<DIV Class="paranum">52/2</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00366.TXT">AI95-00366-01</A></I>} 
<SPAN class="insert2"><SPAN STYLE="font-size: 80%">{<I>support external 
streaming</I>}</SPAN> <A NAME="I5308"></A><SPAN STYLE="font-size: 80%">{<I>external 
streaming (type supports)</I>}</SPAN> <A NAME="I5309"></A>[A type is 
said to <I>support external streaming</I> if Read and Write attributes 
are provided for sending values of such a type between active partitions, 
with Write marshalling the representation, and Read unmarshalling the 
representation.] A limited type supports external streaming only if it 
has available Read and Write attributes. A type with a part that is of 
an access type supports external streaming only if that access type or 
the type of some part that includes the access type component, has Read 
and Write attributes that have been specified via an <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN>, 
and that <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN> 
is visible. [An anonymous access type does not support external streaming. 
]All other types support external streaming.</SPAN></DIV>
<DIV Class="paranum">52.a/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Ramification:&nbsp;</B>A 
limited type with a part that is of an access type needs to satisfy both 
rules.</SPAN>&nbsp;</DIV>

<H4 Class="centered">Erroneous Execution</H4>
<DIV Class="paranum">53/2</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00279.TXT">AI95-00279-01</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00344.TXT">AI95-00344-01</A></I>} 
<SPAN class="insert2"><SPAN STYLE="font-size: 80%">{<I>erroneous execution 
(cause)</I> [partial]}</SPAN> <A NAME="I5310"></A>If the internal tag 
returned by Descendant_Tag to T'Class'Input identifies a type that is 
not library-level and whose tag has not been created, or does not exist 
in the partition at the time of the call, execution is erroneous.</SPAN> 
</DIV>
<DIV Class="paranum">53.a/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Ramification:&nbsp;</B>The 
definition of Descendant_Tag prevents such a tag from being provided 
to T'Class'Input if T is a library-level type. However, this rule is 
needed for nested tagged types.</SPAN>&nbsp;</DIV>

<H4 Class="centered">Implementation Requirements</H4>
<DIV Class="paranum">54/1</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="defect1.html#8652/0040">8652/0040</A></I>} 
<SPAN class="insert1"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00108.TXT">AI95-00108-01</A></I>} 
<SPAN class="insert1">For every subtype <I>S</I> of a language-defined 
nonlimited specific type <I>T</I>, the output generated by S'Output or 
S'Write shall be readable by S'Input or S'Read, respectively. This rule 
applies across partitions if the implementation conforms to the Distributed 
Systems Annex.</SPAN></DIV>
<DIV Class="paranum">55/2</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00195.TXT">AI95-00195-01</A></I>} 
<SPAN class="insert2">If Constraint_Error is raised during a call to 
Read because of failure of one the above checks, the implementation must 
ensure that the discriminants of the actual parameter of Read are not 
modified.</SPAN>&nbsp;</DIV>

<H4 Class="centered">Implementation Permissions</H4>
<DIV Class="paranum">56/2</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00195.TXT">AI95-00195-01</A></I>} 
<SPAN class="insert2">The number of calls performed by the predefined 
implementation of the stream-oriented attributes on the Read and Write 
operations of the stream type is unspecified. An implementation may take 
advantage of this permission to perform internal buffering. However, 
all the calls on the Read and Write operations of the stream type needed 
to implement an explicit invocation of a stream-oriented attribute must 
take place before this invocation returns. An explicit invocation is 
one appearing explicitly in the program text, possibly through a generic 
instantiation (see <A HREF="AA-12-3.html">12.3</A>).</SPAN>&nbsp;</DIV>
<DIV Class="NotesHeader">NOTES</DIV>
<DIV Class="paranum">57</DIV>
<DIV Class="Notes">34&nbsp;&nbsp;For a definite subtype S of a type <I>T</I>, 
only <I>T</I>'Write and <I>T</I>'Read are needed to pass an arbitrary 
value of the subtype through a stream. For an indefinite subtype S of 
a type <I>T</I>, <I>T</I>'Output and <I>T</I>'Input will normally be 
needed, since <I>T</I>'Write and <I>T</I>'Read do not pass bounds, discriminants, 
or tags.</DIV>
<DIV Class="paranum">58</DIV>
<DIV Class="Notes">35&nbsp;&nbsp;User-specified attributes of S'Class 
are not inherited by other class-wide types descended from S.&nbsp;</DIV>

<H4 Class="centered">Examples</H4>
<DIV Class="paranum">59</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em"><I>Example of user-defined 
Write attribute:</I>&nbsp;</DIV>
<DIV Class="paranum">60/2</DIV>
<DIV Class="Examples">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00441.TXT">AI95-00441-01</A></I>} 
<B>procedure</B>&nbsp;My_Write(<BR>
&nbsp;&nbsp;Stream&nbsp;:&nbsp;<B></B><SPAN class="insert2"><B>not&nbsp;null&nbsp;</B></SPAN><B>access</B>&nbsp;Ada.Streams.Root_Stream_Type'Class;<SPAN class="insert2"><BR>
&nbsp;&nbsp;</SPAN>Item<SPAN class="insert2">&nbsp;&nbsp;</SPAN>&nbsp;:&nbsp;My_Integer'Base);<BR>
<B>for</B>&nbsp;My_Integer'Write&nbsp;<B>use</B>&nbsp;My_Write;</DIV>
<DIV Class="paranum">60.a</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><B>Discussion: 
</B><I>Example of network input/output using input output attributes:</I> 
</DIV>
<DIV Class="paranum">60.b</DIV>
<DIV Class="SmallExamples"><B>with</B>&nbsp;Ada.Streams;&nbsp;<B>use</B>&nbsp;Ada.Streams;<BR>
<B>generic</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Msg_Type(&lt;&gt;)&nbsp;<B>is&nbsp;private</B>;<BR>
<B>package</B>&nbsp;Network_IO&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;Connect/Disconnect&nbsp;are&nbsp;used&nbsp;to&nbsp;establish&nbsp;the&nbsp;stream</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Connect(...);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Disconnect(...);</DIV>
<DIV Class="paranum">60.c</DIV>
<DIV Class="SmallExamples">&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;Send/Receive&nbsp;transfer&nbsp;messages&nbsp;across&nbsp;the&nbsp;network</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Send(X&nbsp;:&nbsp;<B>in</B>&nbsp;Msg_Type);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;Receive&nbsp;<B>return</B>&nbsp;Msg_Type;<BR>
<B>private</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Network_Stream&nbsp;<B>is&nbsp;new</B>&nbsp;Root_Stream_Type&nbsp;<B>with</B>&nbsp;...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Read(...);&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;define&nbsp;Read/Write&nbsp;for&nbsp;Network_Stream</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Write(...);<BR>
<B>end</B>&nbsp;Network_IO;</DIV>
<DIV Class="paranum">60.d</DIV>
<DIV Class="SmallExamples"><B>with</B>&nbsp;Ada.Streams;&nbsp;<B>use</B>&nbsp;Ada.Streams;<BR>
<B>package&nbsp;body</B>&nbsp;Network_IO&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;Current_Stream&nbsp;:&nbsp;<B>aliased</B>&nbsp;Network_Stream;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;.&nbsp;.&nbsp;.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Connect(...)&nbsp;<B>is</B>&nbsp;...;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Disconnect(...)&nbsp;<B>is</B>&nbsp;...;</DIV>
<DIV Class="paranum">60.e</DIV>
<DIV Class="SmallExamples">&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Send(X&nbsp;:&nbsp;<B>in</B>&nbsp;Msg_Type)&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Msg_Type'Output(Current_Stream'Access,&nbsp;X);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;Send;</DIV>
<DIV Class="paranum">60.f</DIV>
<DIV Class="SmallExamples">&nbsp;&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;Receive&nbsp;<B>return</B>&nbsp;Msg_Type&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>return</B>&nbsp;Msg_Type'Input(Current_Stream'Access);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;Receive;<BR>
<B>end</B>&nbsp;Network_IO;</DIV>

<H4 Class="centered">Inconsistencies With Ada 95</H4>
<DIV Class="paranum">60.g/2</DIV>
<DIV Class="Annotations">{<I><A HREF="defect1.html#8652/0040">8652/0040</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00108.TXT">AI95-00108-01</A></I>} 
<SPAN class="insert2">{<I>inconsistencies with Ada 95</I>} <A NAME="I5311"></A><B>Corrigendum:</B> 
Clarified how the default implementation for stream attributes is determined 
(eliminating conflicting language). The new wording provides that attributes 
for type extensions are created by composing the parent's attribute with 
those for the extension components if any. If a program was written assuming 
that the extension components were not included in the stream (as in 
original Ada 95), it would fail to work in the language as corrected 
by the Corrigendum.</SPAN></DIV>
<DIV Class="paranum">60.h/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00195.TXT">AI95-00195-01</A></I>} 
<SPAN class="insert2"><B>Amendment Correction:</B> Explicitly provided 
a permission that the number of calls to the underlying stream Read and 
Write operations may differ from the number determined by the canonical 
operations. If Ada 95 code somehow depended on the number of calls to 
Read or Write, it could fail with an Ada 2005 implementation. Such code 
is likely to be very rare; moreover, such code is really wrong, as the 
permission applies to Ada 95 as well.</SPAN>&nbsp;</DIV>

<H4 Class="centered">Extensions to Ada 95</H4>
<DIV Class="paranum">60.i/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00270.TXT">AI95-00270-01</A></I>} 
<SPAN class="insert2">{<I>extensions to Ada 95</I>} <A NAME="I5312"></A>The 
Stream_Size attribute is new. It allows specifying the number of bits 
that will be streamed for a type. The Implementation Advice involving 
this also was changed; this is not incompatible because Implementation 
Advice does not have to be followed.</SPAN></DIV>
<DIV Class="paranum">60.j/2</DIV>
<DIV Class="Annotations">{<I><A HREF="defect1.html#8652/0040">8652/0040</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00108.TXT">AI95-00108-01</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00195.TXT">AI95-00195-01</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00444.TXT">AI95-00444-01</A></I>} 
<SPAN class="insert2"><B>Corrigendum:</B> Limited types may have default 
constructed attributes if all of the parent and (for extensions) extension 
components have available attributes. Ada 2005 adds the notion of availability 
to patch up some holes in the Corrigendum model.</SPAN>&nbsp;</DIV>

<H4 Class="centered">Wording Changes from Ada 95</H4>
<DIV Class="paranum">60.k/2</DIV>
<DIV Class="Annotations">{<I><A HREF="defect1.html#8652/0009">8652/0009</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00137.TXT">AI95-00137-01</A></I>} 
<SPAN class="insert2"><B>Corrigendum:</B> Added wording to specify that 
these are operational attributes.</SPAN></DIV>
<DIV Class="paranum">60.l/2</DIV>
<DIV Class="Annotations">{<I><A HREF="defect1.html#8652/0045">8652/0045</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00132.TXT">AI95-00132-01</A></I>} 
<SPAN class="insert2"><B>Corrigendum:</B> Clarified that End_Error is 
raised by the default implementation of Read and Input if the end of 
the stream is reached. (The result could have been abnormal without this 
clarification, thus this is not an inconsistency, as the programmer could 
not have depended on the previous behavior.)</SPAN></DIV>
<DIV Class="paranum">60.m/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00195.TXT">AI95-00195-01</A></I>} 
<SPAN class="insert2">Clarified that the default implementation of S'Input 
does normal initialization on the object that it passes to S'Read.</SPAN></DIV>
<DIV Class="paranum">60.n/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00195.TXT">AI95-00195-01</A></I>} 
<SPAN class="insert2">Explicitly stated that what is read from a stream 
when a required check fails is unspecified.</SPAN></DIV>
<DIV Class="paranum">60.o/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
<SPAN class="insert2">Defined availability and default implementations 
for types with progenitors.</SPAN></DIV>
<DIV Class="paranum">60.p/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00279.TXT">AI95-00279-01</A></I>} 
<SPAN class="insert2">Specified that Constraint_Error is raised if the 
internal tag retrieved for S'Class'Input is for some type not covered 
by S'Class or is abstract. We also explicitly state that the program 
is erroneous if the tag has not been created or does not currently exist 
in the partition. (Ada 95 did not specify what happened in these cases; 
it's very unlikely to have provided some useful result, so this is not 
considered an inconsistency.)</SPAN></DIV>
<DIV Class="paranum">60.q/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00344.TXT">AI95-00344-01</A></I>} 
<SPAN class="insert2">Added wording to support nested type extensions. 
S'Input and S'Output always raise Tag_Error for such extensions, and 
such extensions were not permitted in Ada 95, so this is neither an extension 
nor an incompatibility.</SPAN></DIV>
<DIV Class="paranum">60.r/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00366.TXT">AI95-00366-01</A></I>} 
<SPAN class="insert2">Defined <I>supports external streaming</I> to put 
all of the rules about &ldquo;good&rdquo; stream attributes in one place. 
This is used for distribution and for defining pragma Pure.</SPAN></DIV>
<DIV Class="paranum">60.s/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00441.TXT">AI95-00441-01</A></I>} 
<SPAN class="insert2">Added the <B>not null</B> qualifier to the first 
parameter of all of the stream attributes, so that the semantics doesn't 
change between Ada 95 and Ada 2005. This change is compatible, because 
mode conformance is required for subprograms specified as stream attributes, 
and <SPAN Class="swiss"><A HREF="AA-3-10.html#S0083">null_exclusion</A></SPAN>s 
are not considered for mode conformance.</SPAN></DIV>
<DIV Class="paranum">60.t/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00444.TXT">AI95-00444-01</A></I>} 
<SPAN class="insert2">Improved the wording to make it clear that we don't 
define the default implementations of attributes that cannot be called 
(that is, aren't &ldquo;available&rdquo;). Also clarified when inheritance 
takes place.</SPAN>&nbsp;</DIV>

<HR>
<DIV Style="margin-top: 0.0em; margin-bottom: 0.6em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-13-13-1.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-13-14.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<DIV Style="margin-top:0.0em"><IMG SRC="AE_logo.gif" height=100 width=113 align=right ALT="Ada-Europe">
<SPAN Style="font-size: 125%">Sponsored by <SPAN Style="font-size: 125%"><A HREF="http://www.ada-europe.org/"><B>Ada-Europe</B></A></SPAN></SPAN></DIV>
</BODY>
</HTML>
