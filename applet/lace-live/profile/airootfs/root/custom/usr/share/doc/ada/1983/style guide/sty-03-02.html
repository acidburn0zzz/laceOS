<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML><HEAD>
<TITLE>Ada '83 Quality and Style, Sec 3.2: Naming Conventions
</TITLE>
</HEAD><BODY bgcolor=#ffffff>
<a href="/AdaIC/"><IMG SRC="small_adaic_logo.gif" ALT="[Ada Information Clearinghouse]"></a>
<hr>
<H1>Ada '83 Quality and Style:</h1>
<h2>Guidelines for Professional Programmers</H2>
<h6><a href="sty-00.html">Copyright</a> 1989, 1991,1992
Software Productivity Consortium, Inc., Herndon, Virginia.</h6>
<hr>
<H2>CHAPTER 3: Readability</H2>
<H3><a name="3.2">3.2     Naming Conventions</a></H3>

Choose names that clarify the object's or entity's intended use. Ada allows 
identifiers to be any length as long as the identifier fits on a line with all 
characters being significant (including underscores). Identifiers are the 
names used for variables, constants, program units, and other entities within 
a program.<P>
<b>Language Ref Manual references:</b> 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-02-03.html#2.3">2.3&nbsp;Identifiers</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-04-01.html#4.1">4.1&nbsp;Universal Expressions</A>

<center><TABLE BORDER CELLPADDING=6>
   <TR>
      <TD>
<b><font size=+1>In this section...</font><BR>
<a href="#3.2.1">3.2.1   Names</a><BR>
<a href="#3.2.2">3.2.2   Type Names</a><BR>
<a href="#3.2.3">3.2.3   Object Names</a><BR>
<a href="#3.2.4">3.2.4   Program Unit Names</a><BR>
<a href="#3.2.5">3.2.5   Constants and Named Numbers</a></b>
     </TD>
   </TR>
   <TR>
      <TD>
<b><a href="sty-03-05.html#3.5.2"> Summary of Guidelines from this section</a></b>
     </TD>
   </TR>
</TABLE></center>

<H3><BR><a name="3.2.1">3.2.1   Names</a></H3>

<H4>guideline</H4>
<UL>
<li>Choose names that are as self-documenting as possible. 
<li>Use a short synonym instead of an abbreviation (see <a href="sty-03-01.html#3.1.4">Guideline 3.1.4</a>). 
<li>Use names given by the application but not obscure jargon. 
</UL>

<H4>example</H4>
In a tree-walker, using the name <CODE>Left</CODE> instead of <CODE>Left_Branch </CODE> is sufficient to 
convey the full meaning given the context.  However, use <CODE>Time_Of_Day</CODE> instead 
of <CODE>TOD</CODE>.<P>
Mathematical formulas are often given using single-letter names for variables.  
Continue this convention for mathematical equations where it would recall the  
formula; for example:<BR>
<IMG SRC="indent.gif"><CODE>A*(X**2) + B*C.</CODE>

<H4>rationale</H4>
A program that follows these guidelines can be more easily comprehended.   
Self-documenting names require fewer explanatory comments. Empirical studies  
have shown that you can further improve comprehension if your variable names  
are not excessively long (Schneiderman 1986, 7). The context and application  
can help greatly. The unit of measure for numeric entities can be a source of  
type names.

<H4>note</H4>
See <a href="sty-08-01.html#8.1.2">Guideline 8.1.2</a> for a discussion on how to use the application domain as a  
guideline for selecting abbreviations.<P>
<b>Language Ref Manual references:</b> 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-03-01.html#3.1">3.1&nbsp;Declarations</A>

<H3><BR><a name="3.2.2">3.2.2   Type Names</a></H3>

<H4>guideline</H4>
<UL>
<li>Use singular, general nouns as (sub)type identifiers. 
<li>Choose identifiers that describe one of the (sub)type's values. 
<li> Do not use identifier constructions (e.g., suffixes) that are unique 
to (sub)type identifiers. 
<li>Do not use the type names from predefined packages. 
</UL>

<H4>example</H4>
<table border cellpadding=6><tr><td><PRE>type Day is 
   (Monday,    Tuesday,   Wednesday, Thursday,  Friday, 
    Saturday,  Sunday);
    
type Day_Of_Month    is range      0 ..    31; 
type Month_Number    is range      1 ..    12; 
type Historical_Year is range -6_000 .. 2_500;

type Date is 
   record 
      Day   : Day_Of_Month; 
      Month : Month_Number; 
      Year  : Historical_Year; 
   end record;</PRE></td></tr></table>
<P>
In particular, <CODE>Day</CODE> should be used in preference to <CODE>Days</CODE> or <CODE>Day_Type</CODE>;<P>
The identifier <CODE>Historical_Year</CODE> might appear to be specific, but it is actually  
general, with the adjective, historical, describing the range constraint.

<H4>rationale</H4>
When this style and the suggested style for object identifiers are used,  
program code more closely resembles English (see <a href="#3.2.3">Guideline 3.2.3</a>).   
Furthermore, this style is consistent with the names of the language's  
predefined identifiers.  They are not named <CODE>Integers</CODE>, <CODE>Booleans</CODE>, <CODE>Integer_Type</CODE>,  
or <CODE>Boolean_Type</CODE>.<P>
However, using the name of a type from the predefined packages is sure to  
confuse a programmer when that type appears somewhere without a package  
qualification.
<p>
<b>Language Ref Manual references:</b> 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-03-03.html#3.3">3.3&nbsp;Types and Subtypes</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-08-06.html#8.6">8.6&nbsp;The Package Standard</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-14-03.html#14.3.10">14.3.10&nbsp;Specification of the Package Text_IO</A>


<H3><BR><a name="3.2.3">3.2.3   Object Names</a></H3>

<H4>guideline</H4>
<UL>
<li>Use predicate clauses or adjectives for boolean objects. 
<li>Use singular, specific nouns as object identifiers. 
<li>Choose identifiers that describe the object's value during execution. 
<li>Use singular, general nouns as identifiers for record components. 
</UL>

<H4>example</H4>
Nonboolean objects:
<table border cellpadding=6><tr><td><pre>Today           : Day; 
Yesterday       : Day; 
Retirement_Date : Date;</pre></td></tr></table>
<P>
Boolean objects:
<table border cellpadding=6><tr><td><pre>User_Is_Available : Boolean;        -- predicate clause 
List_Is_Empty     : Boolean;        -- predicate clause 
Empty             : Boolean;        -- adjective 
Bright            : Boolean;        -- adjective</pre></td></tr></table>


<H4>rationale</H4>
Using specific nouns for objects establishes a context for understanding the 
object's value, which is one of the general values described by the 
(sub)type's name (<a href="#3.2.2">Guideline 3.2.2</a>).  Object declarations become very 
English-like with this style.  For example, the first declaration above is 
read as &quot;Today is a Day.&quot;<P>
General nouns, rather that specific, are used for record components because a  
record object's name will supply the context for understanding the component.   
Thus, the following component is understood as &quot;the year of retirement.&quot;:<BR>
<IMG SRC="indent.gif"><CODE>Retirement_Date.Year</CODE><P>
Following conventions which relate object types and parts of speech makes code  
read more like text. For example, because of the names chosen, the following  
code segment needs no comments:
<table border cellpadding=6><tr><td><pre>if List_Is_Empty then 
   Number_Of_Elements := 0; 
else 
   Number_Of_Elements := Length_Of_List; 
end if;</pre></td></tr></table>


<H4>note</H4>
If it is difficult to find a specific noun that describes an object's value  
during the entire execution of a program, the object is probably serving  
multiple purposes.  Multiple objects should be used in such a case.<P>
<b>Language Ref Manual references:</b> 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-03-02.html#3.2">3.2&nbsp;Objects and Named Numbers</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-03-05.html#3.5.3">3.5.3&nbsp;Boolean Types</A>

<H3><BR><a name="3.2.4">3.2.4   Program Unit Names</a></H3>

<H4>guideline</H4>
<UL>
<li>Use action verbs for procedures and entries. 
<li>Use predicate-clauses for boolean functions. 
<li>Use nouns for nonboolean functions. 
<li>Give packages names that imply higher levels of organization than  
subprograms. Generally, these are noun phrases that describe the abstraction  
provided.  
<li>Give tasks names that imply an active entity.   
<li>Name generic subprograms as if they were nongeneric subprograms. 
<li>Name generic packages as if they were nongeneric packages. 
<li>Make the generic names more general than the instantiated names. 
</UL>

<H4>example</H4>
The following are sample names for elements that comprise an Ada program.<P>
Sample procedure names:
<table border cellpadding=6><tr><td><PRE>procedure Get_Next_Token          -- get is a transitive verb 
procedure Create                  -- create is a transitverb</PRE></td></tr></table>
<P>
Sample function names for boolean-valued functions:
<table border cellpadding=6><tr><td><PRE>function Is_Last_Item             -- predicate clause 
function Is_Empty                 -- predicate clause</PRE></td></tr></table>
<P>
Sample function names for nonboolean-valued functions:
<table border cellpadding=6><tr><td><pre>function Successor                -- common noun 
function Length                   -- attribute 
function Top                      -- component</pre></td></tr></table>
<P>
Sample package names:
<table border cellpadding=6><tr><td><pre>package Terminal is               -- common noun 
package Text_Utilities is         -- common noun</pre></td></tr></table>
<P>
Sample task names:
<table border cellpadding=6><tr><td><pre>task Terminal_Resource_Manager is -- common noun that shows action</pre></td></tr></table>
<P>
Below is a sample piece of code to show the clarity that results from using  
these conventions the parts-of-speech naming conventions.
<table border cellpadding=6><tr><td><pre>Get_Next_Token(Current_Token);

case Current_Token is 
   when Identifier =&gt;         Process_Identifier; 
   when Numeric    =&gt;         Process_Numeric; 
end case;  -- Current_Token

if Is_Empty(Current_List) then 
   Number_Of_Elements := 0; 
else 
   Number_Of_Elements := Length(Current_List); 
end if;</pre></td></tr></table>
<P>
When packages and their subprograms are named together, the resulting code is  
very descriptive.
<table border cellpadding=6><tr><td><pre>if Stack.Is_Empty(Current_List) then 
   Current_Token := Stack.Top(Current_List); 
end if;</pre></td></tr></table>


<H4>rationale</H4>
Using these naming conventions creates understandable code that reads much 
like natural language. When verbs are used for actions, such as subprograms, 
and nouns are used for objects, such as the data that the subprogram 
manipulates, code is easier to read and understand. This models a medium of 
communication already familiar to a reader. Where the pieces of a program 
model a real-life situation, using these conventions reduces the number of 
translation steps involved in reading and understanding the program. In a 
sense, your choice of names reflects the level of abstraction from computer 
hardware toward application requirements.

<H4>note</H4>
There are some conflicting conventions in current use for task entries. Some  
programmers and designers advocate naming task entries with the same  
conventions used for subprograms to blur the fact that a task is involved.  
Their reasoning is that if the task is reimplemented as a package, or vice  
versa, the names need not change. Others prefer to make the fact of a task  
entry as explicit as possible to ensure that the existence of a task with its  
presumed overhead is recognizable. Project-specific priorities may be useful in 
choosing between these conventions.<P>
<b>Language Ref Manual references:</b> 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-06-01.html#6.1">6.1&nbsp;Subprogram Declarations</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-06-05.html#6.5">6.5&nbsp;Function Subprograms</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-07-02.html#7.2">7.2&nbsp;Package Specifications and Declarations</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-09-01.html#9.1">9.1&nbsp;Abort Statements</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-09-05.html#9.5">9.5&nbsp;Entries, Entry Calls, and Accept Statements</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-12-01.html#12.1">12.1&nbsp;Generic Declarations</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-12-03.html#12.3">12.3&nbsp;Generic Instantiation</A>


<H3><BR><a name="3.2.5">3.2.5   Constants and Named Numbers</a></H3>

<H4>guideline</H4>
<UL>
<li>Use symbolic values instead of literals wherever possible. 
<li>Use constants instead of variables for constant values. 
<li>Use named numbers instead of constants when possible. 
<li>Use named numbers to replace numeric literals whose type or context is truly universal. 
<li>Use constants for objects whose values cannot change after elaboration  
(United Technologies 1987). 
<li> Show relationships between symbolic values by defining them with 
static expressions. 
<li>Use linearly independent sets of literals. 
<li>Use attributes like 'First and 'Last instead of literals wherever  
possible. 
</UL>

<H4>example</H4>
<table border cellpadding=6><tr><td><pre>3.141_592_653_589_793                 -- literal 
Max : constant Integer := 65_535;     -- constant 
Pi  : constant         := 3.141_592;  -- named number 
PI / 2                                -- static expression 
PI                                    -- symbolic value</pre></td></tr></table>
<P>
Declaring <CODE>Pi</CODE> as a named number allows it to be referenced symbolically in the  
assignment statement below:
<table border cellpadding=6><tr><td><pre>Area :=       Pi * Radius**2;       -- if radius is known.</pre></td></tr></table>
<P>
instead of
<table border cellpadding=6><tr><td><pre>Area := 3.141_59 * Radius**2;       -- Needs explanatory comment.</pre></td></tr></table>
<P>
Also, <CODE>ASCII.Bel</CODE> is more expressive than <CODE>Character'Val(8#007#)</CODE>.<P>
Clarity of constant and named number declarations can be improved by using <BR>
other constant and named numbers. For example:
<table border cellpadding=6><tr><td><pre>Bytes_Per_Page   : constant := 512; 
Pages_Per_Buffer : constant := 10; 
Buffer_Size      : constant := Pages_Per_Buffer * Bytes_Per_Page;</pre></td></tr></table>
<P>
is more self-explanatory and easier to maintain than
<table border cellpadding=6><tr><td><pre>Buffer_Size : constant := 5_120;   -- ten pages</pre></td></tr></table>
<P>
The following literals should be constants:
<table border cellpadding=6><tr><td><pre>if New_Character  = '$' then  -- &quot;constant&quot; that may change 
... 
if Current_Column = 7 then    -- &quot;constant&quot; that may change</pre></td></tr></table>

<H4>rationale</H4>
Using identifiers instead of literals makes the purpose of expressions clear 
reducing the need for comments. Constant declarations consisting of 
expressions of numeric literals are safer since they do not need to be 
computed by hand.  They are also more enlightening than a single numeric 
literal since there is more opportunity for embedding explanatory names. 
Clarity of constant declarations can be improved further by using other 
related constants in static expressions defining new constants. This is not 
less efficient because static expressions of named numbers are computed at 
compile time.<P>
A constant has a type. A named number can only be a universal type: universal 
integer or universal real. Strong typing is enforced for identifiers but not 
literals. Named numbers allow compilers to generate more efficient code than 
for constants and to perform more complete error checking at compile time. If 
the literal contains a large number of digits (as Pi in the example above), 
the use of an identifier reduces keystroke errors. If keystroke errors occur, 
they are easier to locate either by inspection or at compile time.<P>
Linear independence of literals means that the few literals that are used do  
not depend on one another and that any relationship between constant or named  
values is shown in the static expressions. Linear independence of literal  
values gives the property that if one literal value changes, all of the named  
numbers of values dependent on that literal are automatically changed.

<H4>note</H4>
There are some gray areas where the literal is actually more self-documenting 
than a name. These are application-specific and generally occur with 
universally familiar, unchangeable values such as the following relationship: <BR>
<IMG SRC="indent.gif"><CODE>Fahrenheit := 32.0 + (9.0 * Celsius) / 5.0;</CODE><P>
<b>Language Ref Manual references:</b> 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-02-04.html#2.4">2.4&nbsp;Numeric Literals</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-02-05.html#2.5">2.5&nbsp;Character Literals</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-02-06.html#2.6">2.6&nbsp;String Literals</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-03-02.html#3.2">3.2&nbsp;Objects and Named Numbers</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-04-09.html#4.9">4.9&nbsp;Static Expressions and Static Subtypes</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-A.html#A.">A.&nbsp;Predefined Language Attributes</A>


<hr>
<A HREF="index.html">Back to document index</A><P>

</BODY></HTML>

