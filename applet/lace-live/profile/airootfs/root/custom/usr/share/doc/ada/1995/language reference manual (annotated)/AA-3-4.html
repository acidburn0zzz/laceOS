<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Derived Types and Classes</TITLE>
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    DIV.paranum {position: absolute; font-family: Arial, Helvetica, sans-serif; left: 0.5em; top: auto}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    DIV.Normal {font-family: "Times New Roman", Times, serif; margin-bottom: 0.6em}
    DIV.Wide {font-family: "Times New Roman", Times, serif; margin-top: 0.6em; margin-bottom: 0.6em}
    DIV.Annotations {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-bottom: 0.6em}
    DIV.WideAnnotations {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-top: 0.6em; margin-bottom: 0.6em}
    DIV.Index {font-family: "Times New Roman", Times, serif}
    DIV.SyntaxSummary {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-bottom: 0.4em}
    DIV.Notes {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-bottom: 0.6em}
    DIV.NotesHeader {font-family: "Times New Roman", Times, serif; margin-left: 2.0em}
    DIV.SyntaxIndented {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-bottom: 0.4em}
    DIV.Indented {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-bottom: 0.6em}
    DIV.CodeIndented {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-bottom: 0.6em}
    DIV.SmallIndented {font-family: "Times New Roman", Times, serif; margin-left:  10.0em; margin-bottom: 0.6em}
    DIV.SmallCodeIndented {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-bottom: 0.6em}
    DIV.Examples {font-family: "Courier New", monospace; margin-left: 2.0em; margin-bottom: 0.6em}
    DIV.SmallExamples {font-family: "Courier New", monospace; font-size: 80%; margin-left: 7.5em; margin-bottom: 0.6em}
    DIV.IndentedExamples {font-family: "Courier New", monospace; margin-left: 8.0em; margin-bottom: 0.6em}
    DIV.SmallIndentedExamples {font-family: "Courier New", monospace; font-size: 80%; margin-left:  15.0em; margin-bottom: 0.6em}
    UL.Bulleted {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.SmallBulleted {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.NestedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-right: 4.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.SmallNestedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-right: 8.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.IndentedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-right: 8.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.CodeIndentedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.CodeIndentedNestedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-right: 8.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.SyntaxIndentedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-right: 4.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.NotesBulleted {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-right: 4.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.NotesNestedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    DL.Hanging {font-family: "Times New Roman", Times, serif; margin-top: 0em; margin-bottom: 0.6em}
    DD.Hanging {margin-left: 6.0em}
    DL.IndentedHanging {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-top: 0em; margin-bottom: 0.6em}
    DD.IndentedHanging {margin-left: 2.0em}
    DL.HangingInBulleted {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    DD.HangingInBulleted {margin-left: 4.0em}
    DL.SmallHanging {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-top: 0em; margin-bottom: 0.6em}
    DD.SmallHanging {margin-left: 7.5em}
    DL.SmallIndentedHanging {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-top: 0em; margin-bottom: 0.6em}
    DD.SmallIndentedHanging {margin-left: 2.0em}
    DL.SmallHangingInBulleted {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    DD.SmallHangingInBulleted {margin-left: 5.0em}
    DL.Enumerated {font-family: "Times New Roman", Times, serif; margin-right: 0.0em; margin-top: 0em; margin-bottom: 0.5em}
    DD.Enumerated {margin-left: 2.0em}
    DL.SmallEnumerated {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-right: 4.0em; margin-top: 0em; margin-bottom: 0.5em}
    DD.SmallEnumerated {margin-left: 2.5em}
    DL.NestedEnumerated {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    DL.SmallNestedEnumerated {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">
<P><A HREF="AA-TOC.html">Contents</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-0-29.html">Index</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-SRCH.html">Search</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-3-3-2.html">Previous</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-3-4-1.html">Next</A></P>
<HR>
<H1> 3.4 Derived Types and Classes</H1>
<DIV Class="Paranum"><FONT SIZE=-2>1</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>derived type</I>}</FONT> <A NAME="I1496"></A>A
<FONT FACE="Arial, Helvetica">derived_type_definition</FONT> defines
a new type (and its first subtype) whose characteristics are <I>derived</I>
from those of a <I>parent type</I>. <FONT SIZE="-1">{<I>inheritance:
See derived types and classes</I>}</FONT> <A NAME="I1497"></A></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>1.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Glossary entry: </B>{<I>Derived
type</I>} A derived type is a type defined in terms of another type,
which is the parent type of the derived type. Each class containing the
parent type also contains the derived type. The derived type inherits
properties such as components and primitive operations from the parent.
A type together with the types derived from it (directly or indirectly)
form a derivation class.</FONT></DIV>

<H4 ALIGN=CENTER>Syntax</H4>
<DIV Class="Paranum"><FONT SIZE=-2>2</FONT></DIV>
<DIV Class="SyntaxIndented"><FONT FACE="Arial, Helvetica">derived_type_definition</FONT><FONT FACE="Arial, Helvetica"><A NAME="I1498"></A>
::= </FONT>[<B>abstract</B>]&nbsp;<B>new</B>&nbsp;<I>parent_</I><A NAME="I1499"></A><FONT FACE="Arial, Helvetica">subtype_indication</FONT>&nbsp;[<A NAME="I1500"></A><FONT FACE="Arial, Helvetica">record_extension_part</FONT>]</DIV>

<H4 ALIGN=CENTER>Legality Rules</H4>
<DIV Class="Paranum"><FONT SIZE=-2>3</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>parent subtype</I>}</FONT>
<A NAME="I1501"></A><FONT SIZE="-1">{<I>parent type</I>}</FONT> <A NAME="I1502"></A>The
<I>parent_</I><FONT FACE="Arial, Helvetica">subtype_indication</FONT>
defines the <I>parent subtype</I>; its type is the parent type.</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>4</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;A type shall be completely defined (see <A HREF="AA-3-11-1.html">3.11.1</A>)
prior to being specified as the parent type in a <FONT FACE="Arial, Helvetica">derived_type_definition</FONT>
-- [the <FONT FACE="Arial, Helvetica">full_type_declaration</FONT>s for
the parent type and any of its subcomponents have to precede the <FONT FACE="Arial, Helvetica">derived_type_definition</FONT>.]
</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>4.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Discussion: </B>This restriction
does not apply to the ancestor type of a private extension -- see <A HREF="AA-7-3.html">7.3</A>;
such a type need not be completely defined prior to the <FONT FACE="Arial, Helvetica">private_extension_declaration</FONT>.
However, the restriction does apply to record extensions, so the ancestor
type will have to be completely defined prior to the <FONT FACE="Arial, Helvetica">full_type_declaration</FONT>
corresponding to the <FONT FACE="Arial, Helvetica">private_extension_declaration</FONT>.
</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>4.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Reason: </B>We originally
hoped we could relax this restriction. However, we found it too complex
to specify the rules for a type derived from an incompletely defined
limited type that subsequently became nonlimited. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>5</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>record extension</I>}</FONT>
<A NAME="I1503"></A>If there is a <FONT FACE="Arial, Helvetica">record_extension_part</FONT>,
the derived type is called a <I>record extension</I> of the parent type.
A <FONT FACE="Arial, Helvetica">record_extension_part</FONT> shall be
provided if and only if the parent type is a tagged type. </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>5.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Implementation Note: </B>We
allow a record extension to inherit discriminants; an early version of
Ada 9X did not. If the parent subtype is unconstrained, it can be implemented
as though its discriminants were repeated in a new <FONT FACE="Arial, Helvetica">known_discriminant_part</FONT>
and then used to constrain the old ones one-for-one. However, in an extension
aggregate, the discriminants in this case do not appear in the component
association list. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>5.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>This rule
needs to be rechecked in the visible part of an instance of a generic
unit. </FONT></DIV>

<H4 ALIGN=CENTER>Static Semantics</H4>
<DIV Class="Paranum"><FONT SIZE=-2>6</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>constrained (subtype)</I>}</FONT>
<A NAME="I1504"></A><FONT SIZE="-1">{<I>unconstrained (subtype)</I>}</FONT>
<A NAME="I1505"></A>The first subtype of the derived type is unconstrained
if a <FONT FACE="Arial, Helvetica">known_discriminant_part</FONT> is
provided in the declaration of the derived type, or if the parent subtype
is unconstrained. <FONT SIZE="-1">{<I>corresponding constraint</I>}</FONT>
<A NAME="I1506"></A>Otherwise, the constraint of the first subtype <I>corresponds</I>
to that of the parent subtype in the following sense: it is the same
as that of the parent subtype except that for a range constraint (implicit
or explicit), the value of each bound of its range is replaced by the
corresponding value of the derived type. </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>6.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Discussion: </B>A <FONT FACE="Arial, Helvetica">digits_constraint</FONT>
in a <FONT FACE="Arial, Helvetica">subtype_indication</FONT> for a decimal
fixed point subtype always imposes a range constraint, implicitly if
there is no explicit one given. See <A HREF="AA-3-5-9.html">3.5.9</A>,
``<A HREF="AA-3-5-9.html">Fixed Point Types</A>''. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>7</FONT></DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;&nbsp;&nbsp;The characteristics
of the derived type are defined as follows: </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>8</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC>Each class of types that includes
the parent type also includes the derived type. </LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>8.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Discussion: </B>This is inherent
in our notion of a ``class'' of types. It is not mentioned in the initial
definition of ``class'' since at that point type derivation has not been
defined. In any case, this rule ensures that every class of types is
closed under derivation.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>9</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC>If the parent type is an elementary
type or an array type, then the set of possible values of the derived
type is a copy of the set of possible values of the parent type. For
a scalar type, the base range of the derived type is the same as that
of the parent type. </LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>9.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Discussion: </B>The base
range of a type defined by an <FONT FACE="Arial, Helvetica">integer_type_definition</FONT>
or a <FONT FACE="Arial, Helvetica">real_type_definition</FONT> is determined
by the <FONT FACE="Arial, Helvetica">_definition</FONT>, and is not necessarily
the same as that of the corresponding root numeric type from which the
newly defined type is implicitly derived. Treating numerics types as
implicitly derived from one of the two root numeric types is simply to
link them into a type hierarchy; such an implicit derivation does not
follow all the rules given here for an explicit <FONT FACE="Arial, Helvetica">derived_type_definition</FONT>.
</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>10</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC>If the parent type is a composite
type other than an array type, then the components, protected subprograms,
and entries that are declared for the derived type are as follows: </LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>11</FONT></DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>The discriminants specified
by a new <FONT FACE="Arial, Helvetica">known_discriminant_part</FONT>,
if there is one; otherwise, each discriminant of the parent type (implicitly
declared in the same order with the same specifications) -- <FONT SIZE="-1">{<I>inherited
discriminant</I>}</FONT> <A NAME="I1507"></A><FONT SIZE="-1">{<I>inherited
component</I>}</FONT> <A NAME="I1508"></A>in the latter case, the discriminants
are said to be <I>inherited</I>, or if unknown in the parent, are also
unknown in the derived type;</LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>12</FONT></DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>Each nondiscriminant component,
entry, and protected subprogram of the parent type, implicitly declared
in the same order with the same declarations; <FONT SIZE="-1">{<I>inherited
component</I>}</FONT> <A NAME="I1509"></A><FONT SIZE="-1">{<I>inherited
protected subprogram</I>}</FONT> <A NAME="I1510"></A><FONT SIZE="-1">{<I>inherited
entry</I>}</FONT> <A NAME="I1511"></A>these components, entries, and
protected subprograms are said to be <I>inherited</I>; </LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>12.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>The profiles
of entries and protected subprograms do not change upon type derivation,
although the type of the ``implicit'' parameter identified by the <FONT FACE="Arial, Helvetica">prefix</FONT>
of the <FONT FACE="Arial, Helvetica">name</FONT> in a call does.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>12.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>To be honest: </B>Any name
in the parent <FONT FACE="Arial, Helvetica">type_declaration</FONT> that
denotes the current instance of the type is replaced with a name denoting
the current instance of the derived type, converted to the parent type.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>13</FONT></DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>Each component declared in a
<FONT FACE="Arial, Helvetica">record_extension_part</FONT>, if any. </LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>14</FONT></DIV>
<UL Class="Bulleted">Declarations of components, protected subprograms,
and entries, whether implicit or explicit, occur immediately within the
declarative region of the type, in the order indicated above, following
the parent <FONT FACE="Arial, Helvetica">subtype_indication</FONT>. </UL>
<DIV Class="Paranum"><FONT SIZE=-2>14.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Discussion: </B>The order
of declarations within the region matters for <FONT FACE="Arial, Helvetica">record_aggregate</FONT>s
and <FONT FACE="Arial, Helvetica">extension_aggregate</FONT>s. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>14.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>In most
cases, these things are implicitly declared <I>immediately</I> following
the parent <FONT FACE="Arial, Helvetica">subtype_indication</FONT>. However,
<A HREF="AA-7-3-1.html">7.3.1</A>, ``<A HREF="AA-7-3-1.html">Private
Operations</A>'' defines some cases in which they are implicitly declared
later, and some cases in which the are not declared at all. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>14.c</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Discussion: </B>The place
of the implicit declarations of inherited components matters for visibility
-- they are not visible in the <FONT FACE="Arial, Helvetica">known_discriminant_part</FONT>
nor in the parent <FONT FACE="Arial, Helvetica">subtype_indication</FONT>,
but are usually visible within the <FONT FACE="Arial, Helvetica">record_extension_part</FONT>,
if any (although there are restrictions on their use). Note that a discriminant
specified in a new <FONT FACE="Arial, Helvetica">known_discriminant_part</FONT>
is not considered ``inherited'' even if it has the same name and subtype
as a discriminant of the parent type. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>15</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC>The derived type is limited if and
only if the parent type is limited. </LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>15.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>To be honest: </B>The derived
type can become nonlimited if the derivation takes place in the visible
part of a child package, and the parent type is nonlimited as viewed
from the private part of the child package -- see <A HREF="AA-7-5.html">7.5</A>.
</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>16</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC>[For each predefined operator of the
parent type, there is a corresponding predefined operator of the derived
type.] </LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>16.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Proof: </B>This is a ramification
of the fact that each class that includes the parent type also includes
the derived type, and the fact that the set of predefined operators that
is defined for a type, as described in <A HREF="AA-4-5.html">4.5</A>,
is determined by the classes to which it belongs. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>16.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Reason: </B>Predefined operators
are handled separately because they follow a slightly different rule
than user-defined primitive subprograms. In particular the systematic
replacement described below does not apply fully to the relational operators
for Boolean and the exponentiation operator for Integer. The relational
operators for a type derived from Boolean still return Standard.Boolean.
The exponentiation operator for a type derived from Integer still expects
Standard.Integer for the right operand. In addition, predefined operators
&quot;reemerge&quot; when a type is the actual type corresponding to
a generic formal type, so they need to be well defined even if hidden
by user-defined primitive subprograms. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>17</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC><FONT SIZE="-1">{<I>inherited subprogram</I>}</FONT>
<A NAME="I1512"></A>For each user-defined primitive subprogram (other
than a user-defined equality operator -- see below) of the parent type
that already exists at the place of the <FONT FACE="Arial, Helvetica">derived_type_definition</FONT>,
there exists a corresponding <I>inherited</I> primitive subprogram of
the derived type with the same defining name. <FONT SIZE="-1">{<I>equality
operator (special inheritance rule for tagged types)</I>}</FONT> <A NAME="I1513"></A>Primitive
user-defined equality operators of the parent type are also inherited
by the derived type, except when the derived type is a nonlimited record
extension, and the inherited operator would have a profile that is type
conformant with the profile of the corresponding predefined equality
operator; in this case, the user-defined equality operator is not inherited,
but is rather incorporated into the implementation of the predefined
equality operator of the record extension (see <A HREF="AA-4-5-2.html">4.5.2</A>).
<FONT SIZE="-1">{<I>type conformance</I> [partial]}</FONT> <A NAME="I1514"></A></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>17.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>We say
``...already exists...'' rather than ``is visible'' or ``has been declared''
because there are certain operations that are declared later, but still
exist at the place of the <FONT FACE="Arial, Helvetica">derived_type_definition</FONT>,
and there are operations that are never declared, but still exist. These
cases are explained in <A HREF="AA-7-3-1.html">7.3.1</A>.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>17.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">Note that nonprivate extensions
can appear only after the last primitive subprogram of the parent --
the freezing rules ensure this. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>17.c</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Reason: </B>A special case
is made for the equality operators on nonlimited record extensions because
their predefined equality operators are already defined in terms of the
primitive equality operator of their parent type (and of the tagged components
of the extension part). Inheriting the parent's equality operator as
is would be undesirable, because it would ignore any components of the
extension part. On the other hand, if the parent type is limited, then
any user-defined equality operator is inherited as is, since there is
no predefined equality operator to take its place. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>17.d</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>Because
user-defined equality operators are not inherited by record extensions,
the formal parameter names of = and /= revert to Left and Right, even
if different formal parameter names were used in the user-defined equality
operators of the parent type. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>18</FONT></DIV>
<UL Class="Bulleted">The profile of an inherited subprogram (including
an inherited enumeration literal) is obtained from the profile of the
corresponding (user-defined) primitive subprogram of the parent type,
after systematic replacement of each subtype of its profile (see <A HREF="AA-6-1.html">6.1</A>)
that is of the parent type with a <I>corresponding subtype</I> of the
derived type. <FONT SIZE="-1">{<I>corresponding subtype</I>}</FONT> <A NAME="I1515"></A>For
a given subtype of the parent type, the corresponding subtype of the
derived type is defined as follows: </UL>
<DIV Class="Paranum"><FONT SIZE=-2>19</FONT></DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>If the declaration of the derived
type has neither a <FONT FACE="Arial, Helvetica">known_discriminant_part</FONT>
nor a <FONT FACE="Arial, Helvetica">record_extension_part</FONT>, then
the corresponding subtype has a constraint that corresponds (as defined
above for the first subtype of the derived type) to that of the given
subtype.</LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>20</FONT></DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>If the derived type is a record
extension, then the corresponding subtype is the first subtype of the
derived type.</LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>21</FONT></DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>If the derived type has a new
<FONT FACE="Arial, Helvetica">known_discriminant_part</FONT> but is not
a record extension, then the corresponding subtype is constrained to
those values that when converted to the parent type belong to the given
subtype (see <A HREF="AA-4-6.html">4.6</A>). <FONT SIZE="-1">{<I>implicit
subtype conversion (derived type discriminants)</I> [partial]}</FONT>
<A NAME="I1516"></A></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>21.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Reason: </B>An inherited
subprogram of an untagged type has an Intrinsic calling convention, which
precludes the use of the Access attribute. We preclude 'Access because
correctly performing all required constraint checks on an indirect call
to such an inherited subprogram was felt to impose an undesirable implementation
burden. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>22</FONT></DIV>
<UL Class="Bulleted">The same formal parameters have <FONT FACE="Arial, Helvetica">default_expression</FONT>s
in the profile of the inherited subprogram. [Any type mismatch due to
the systematic replacement of the parent type by the derived type is
handled as part of the normal type conversion associated with parameter
passing -- see <A HREF="AA-6-4-1.html">6.4.1</A>.] </UL>
<DIV Class="Paranum"><FONT SIZE=-2>22.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Reason: </B>We don't introduce
the type conversion explicitly here since conversions to record extensions
or on access parameters are not generally legal. Furthermore, any type
conversion would just be &quot;undone&quot; since the parent's subprogram
is ultimately being called anyway. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>23</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;If a primitive subprogram of the parent type
is visible at the place of the <FONT FACE="Arial, Helvetica">derived_type_definition</FONT>,
then the corresponding inherited subprogram is implicitly declared immediately
after the <FONT FACE="Arial, Helvetica">derived_type_definition</FONT>.
Otherwise, the inherited subprogram is implicitly declared later or not
at all, as explained in <A HREF="AA-7-3-1.html">7.3.1</A>.</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>24</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>derived type</I> [partial]}</FONT>
<A NAME="I1517"></A>A derived type can also be defined by a <FONT FACE="Arial, Helvetica">private_extension_declaration</FONT>
(see <A HREF="AA-7-3.html">7.3</A>) or a <FONT FACE="Arial, Helvetica">formal_derived_type_definition</FONT>
(see <A HREF="AA-12-5-1.html">12.5.1</A>). Such a derived type is a partial
view of the corresponding full or actual type.</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>25</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;All numeric types are derived types, in that
they are implicitly derived from a corresponding root numeric type (see
<A HREF="AA-3-5-4.html">3.5.4</A> and <A HREF="AA-3-5-6.html">3.5.6</A>).</DIV>

<H4 ALIGN=CENTER>Dynamic Semantics</H4>
<DIV Class="Paranum"><FONT SIZE=-2>26</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>elaboration (derived_type_definition)</I>
[partial]}</FONT> <A NAME="I1518"></A>The elaboration of a <FONT FACE="Arial, Helvetica">derived_type_definition</FONT>
creates the derived type and its first subtype, and consists of the elaboration
of the <FONT FACE="Arial, Helvetica">subtype_indication</FONT> and the
<FONT FACE="Arial, Helvetica">record_extension_part</FONT>, if any. If
the <FONT FACE="Arial, Helvetica">subtype_indication</FONT> depends on
a discriminant, then only those expressions that do not depend on a discriminant
are evaluated.</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>27</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>execution (call on an inherited
subprogram)</I> [partial]}</FONT> <A NAME="I1519"></A>For the execution
of a call on an inherited subprogram, a call on the corresponding primitive
subprogram of the parent type is performed; the normal conversion of
each actual parameter to the subtype of the corresponding formal parameter
(see <A HREF="AA-6-4-1.html">6.4.1</A>) performs any necessary type conversion
as well. If the result type of the inherited subprogram is the derived
type, the result of calling the parent's subprogram is converted to the
derived type. <FONT SIZE="-1">{<I>implicit subtype conversion (result
of inherited function)</I> [partial]}</FONT> <A NAME="I1520"></A></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>27.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Discussion: </B>If an inherited
function returns the derived type, and the type is a record extension,
then the inherited function is abstract, and (unless overridden) cannot
be called except via a dispatching call. See <A HREF="AA-3-9-3.html">3.9.3</A>.
</FONT></DIV>
<DIV Class="NotesHeader"><FONT SIZE="-1">NOTES</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>28</FONT></DIV>
<DIV Class="Notes"><FONT SIZE="-1">10&nbsp;&nbsp;<FONT SIZE="-1">{<I>closed
under derivation</I>}</FONT> <A NAME="I1521"></A>Classes are closed under
derivation -- any class that contains a type also contains its derivatives.
Operations available for a given class of types are available for the
derived types in that class.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>29</FONT></DIV>
<DIV Class="Notes"><FONT SIZE="-1">11&nbsp;&nbsp;Evaluating an inherited
enumeration literal is equivalent to evaluating the corresponding enumeration
literal of the parent type, and then converting the result to the derived
type. This follows from their equivalence to parameterless functions.
<FONT SIZE="-1">{<I>implicit subtype conversion (inherited enumeration
literal)</I> [partial]}</FONT> <A NAME="I1522"></A></FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>30</FONT></DIV>
<DIV Class="Notes"><FONT SIZE="-1">12&nbsp;&nbsp;A generic subprogram
is not a subprogram, and hence cannot be a primitive subprogram and cannot
be inherited by a derived type. On the other hand, an instance of a generic
subprogram can be a primitive subprogram, and hence can be inherited.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>31</FONT></DIV>
<DIV Class="Notes"><FONT SIZE="-1">13&nbsp;&nbsp;If the parent type is
an access type, then the parent and the derived type share the same storage
pool; there is a <B>null</B> access value for the derived type and it
is the implicit initial value for the type. See <A HREF="AA-3-10.html">3.10</A>.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>32</FONT></DIV>
<DIV Class="Notes"><FONT SIZE="-1">14&nbsp;&nbsp;If the parent type is
a boolean type, the predefined relational operators of the derived type
deliver a result of the predefined type Boolean (see <A HREF="AA-4-5-2.html">4.5.2</A>).
If the parent type is an integer type, the right operand of the predefined
exponentiation operator is of the predefined type Integer (see <A HREF="AA-4-5-6.html">4.5.6</A>).</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>33</FONT></DIV>
<DIV Class="Notes"><FONT SIZE="-1">15&nbsp;&nbsp;Any discriminants of
the parent type are either all inherited, or completely replaced with
a new set of discriminants.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>34</FONT></DIV>
<DIV Class="Notes"><FONT SIZE="-1">16&nbsp;&nbsp;For an inherited subprogram,
the subtype of a formal parameter of the derived type need not have any
value in common with the first subtype of the derived type. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>34.a</FONT></DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><FONT SIZE="-1"><B>Proof:
</B>This happens when the parent subtype is constrained to a range that
does not overlap with the range of a subtype of the parent type that
appears in the profile of some primitive subprogram of the parent type.
For example: </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>34.b</FONT></DIV>
<DIV Class="SmallExamples"><TT><B>type</B>&nbsp;T1&nbsp;<B>is&nbsp;range</B>&nbsp;1..100;<BR>
<B>subtype</B>&nbsp;S1&nbsp;<B>is</B>&nbsp;T1&nbsp;<B>range</B>&nbsp;1..10;<BR>
<B>procedure</B>&nbsp;P(X&nbsp;:&nbsp;<B>in</B>&nbsp;S1);&nbsp;&nbsp;<I>--&nbsp;P&nbsp;is&nbsp;a&nbsp;primitive&nbsp;subprogram</I><BR>
<B>type</B>&nbsp;T2&nbsp;<B>is&nbsp;new</B>&nbsp;T1&nbsp;<B>range</B>&nbsp;11..20;<BR>
<I>--&nbsp;implicitly&nbsp;declared:</I><BR>
<I>--&nbsp;<B>procedure</B>&nbsp;P(X&nbsp;:&nbsp;<B>in</B>&nbsp;T2'Base&nbsp;<B>range</B>&nbsp;1..10);</I><BR>
<I>--&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;cannot&nbsp;be&nbsp;in&nbsp;T2'First&nbsp;..&nbsp;T2'Last</I></TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>35</FONT></DIV>
<DIV Class="Notes"><FONT SIZE="-1">17&nbsp;&nbsp;If the reserved word
<B>abstract</B> is given in the declaration of a type, the type is abstract
(see <A HREF="AA-3-9-3.html">3.9.3</A>). </FONT></DIV>

<H4 ALIGN=CENTER>Examples</H4>
<DIV Class="Paranum"><FONT SIZE=-2>36</FONT></DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;&nbsp;&nbsp;&nbsp;<I>Examples of
derived type declarations:</I> </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>37</FONT></DIV>
<DIV Class="Examples"><TT><B>type</B>&nbsp;Local_Coordinate&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Coordinate;&nbsp;&nbsp;&nbsp;<I>--&nbsp;&nbsp;two&nbsp;different&nbsp;types</I><BR>
<B>type</B>&nbsp;Midweek&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Day&nbsp;<B>range</B>&nbsp;Tue&nbsp;..&nbsp;Thu;&nbsp;&nbsp;<I>--&nbsp;&nbsp;see&nbsp;<A HREF="AA-3-5-1.html">3.5.1</A></I><BR>
<B>type</B>&nbsp;Counter&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Positive;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>--&nbsp;&nbsp;same&nbsp;range&nbsp;as&nbsp;Positive&nbsp;</I></TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>38</FONT></DIV>
<DIV Class="Examples"><TT><B>type</B>&nbsp;Special_Key&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Key_Manager.Key;&nbsp;&nbsp;&nbsp;<I>--&nbsp;&nbsp;see&nbsp;<A HREF="AA-7-3-1.html">7.3.1</A></I><BR>
&nbsp;&nbsp;<I>--&nbsp;the&nbsp;inherited&nbsp;subprograms&nbsp;have&nbsp;the&nbsp;following&nbsp;specifications:&nbsp;</I><BR>
&nbsp;&nbsp;<I>--&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;Get_Key(K&nbsp;:&nbsp;out&nbsp;Special_Key);</I><BR>
&nbsp;&nbsp;<I>--&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;&quot;&lt;&quot;(X,Y&nbsp;:&nbsp;Special_Key)&nbsp;return&nbsp;Boolean;</I></TT></DIV>

<H4 ALIGN=CENTER>Inconsistencies With Ada 83</H4>
<DIV Class="Paranum"><FONT SIZE=-2>38.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">{<I>inconsistencies with Ada
83</I>} <A NAME="I1523"></A>When deriving from a (nonprivate, nonderived)
type in the same visible part in which it is defined, if a predefined
operator had been overridden prior to the derivation, the derived type
will inherit the user-defined operator rather than the predefined operator.
The work-around (if the new behavior is not the desired behavior) is
to move the definition of the derived type prior to the overriding of
any predefined operators.</FONT></DIV>

<H4 ALIGN=CENTER>Incompatibilities With Ada 83</H4>
<DIV Class="Paranum"><FONT SIZE=-2>38.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">{<I>incompatibilities with Ada
83</I>} <A NAME="I1524"></A>When deriving from a (nonprivate, nonderived)
type in the same visible part in which it is defined, a primitive subprogram
of the parent type declared before the derived type will be inherited
by the derived type. This can cause upward incompatibilities in cases
like this: </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>38.c</FONT></DIV>
<DIV Class="SmallExamples" Style="margin-bottom: 0.4em"><TT>&nbsp;&nbsp;&nbsp;<B>package</B>&nbsp;P&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T&nbsp;<B>is</B>&nbsp;(A,&nbsp;B,&nbsp;C,&nbsp;D);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;F(&nbsp;X&nbsp;:&nbsp;T&nbsp;:=&nbsp;A&nbsp;)&nbsp;<B>return</B>&nbsp;Integer;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;NT&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;T;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<I>&nbsp;inherits&nbsp;F&nbsp;as</I><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<I>&nbsp;function&nbsp;F(&nbsp;X&nbsp;:&nbsp;NT&nbsp;:=&nbsp;A&nbsp;)&nbsp;return&nbsp;Integer;</I><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<I>&nbsp;in&nbsp;Ada&nbsp;95&nbsp;only</I><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<BR>
&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;P;<BR>
&nbsp;&nbsp;&nbsp;...<BR>
&nbsp;&nbsp;&nbsp;<B>use</B>&nbsp;P;&nbsp;&nbsp;--<I>&nbsp;Only&nbsp;one&nbsp;declaration&nbsp;of&nbsp;F&nbsp;from&nbsp;P&nbsp;is&nbsp;use-visible&nbsp;in</I><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<I>&nbsp;Ada&nbsp;83;&nbsp;&nbsp;two&nbsp;declarations&nbsp;of&nbsp;F&nbsp;are&nbsp;use-visible&nbsp;in</I><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<I>&nbsp;Ada&nbsp;95.</I><BR>
<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;...<BR>
&nbsp;&nbsp;&nbsp;<B>if</B>&nbsp;F&nbsp;&gt;&nbsp;1&nbsp;<B>then</B>&nbsp;...&nbsp;--<I>&nbsp;legal&nbsp;in&nbsp;Ada&nbsp;83,&nbsp;ambiguous&nbsp;in&nbsp;Ada&nbsp;95</I></TT></DIV>

<H4 ALIGN=CENTER>Extensions to Ada 83</H4>
<DIV Class="Paranum"><FONT SIZE=-2>38.d</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">{<I>extensions to Ada 83</I>}
<A NAME="I1525"></A>The syntax for a <FONT FACE="Arial, Helvetica">derived_type_definition</FONT>
is amended to include an optional <FONT FACE="Arial, Helvetica">record_extension_part</FONT>
(see <A HREF="AA-3-9-1.html">3.9.1</A>).</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>38.e</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">A derived type may override
the discriminants of the parent by giving a new <FONT FACE="Arial, Helvetica">discriminant_part</FONT>.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>38.f</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">The parent type in a <FONT FACE="Arial, Helvetica">derived_type_definition</FONT>
may be a derived type defined in the same visible part.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>38.g</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">When deriving from a type in
the same visible part in which it is defined, the primitive subprograms
declared prior to the derivation are inherited as primitive subprograms
of the derived type. See <A HREF="AA-3-2-3.html">3.2.3</A>. </FONT></DIV>

<H4 ALIGN=CENTER>Wording Changes from Ada 83</H4>
<DIV Class="Paranum"><FONT SIZE=-2>38.h</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">We now talk about the classes
to which a type belongs, rather than a single class.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>38.i</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">As explained in Section 13,
the concept of &quot;storage pool&quot; replaces the Ada 83 concept of
&quot;collection.&quot; These concepts are similar, but not the same.
</FONT></DIV>

<HR>
<P><A HREF="AA-TOC.html">Contents</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-0-29.html">Index</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-SRCH.html">Search</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-3-3-2.html">Previous</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-3-4-1.html">Next</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-TTL.html">Legal</A></P>
</BODY>
</HTML>
