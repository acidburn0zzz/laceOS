<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Remote Subprogram Calls</TITLE>
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    DIV.paranum {position: absolute; font-family: Arial, Helvetica, sans-serif; left: 0.5em; top: auto}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    DIV.Normal {font-family: "Times New Roman", Times, serif; margin-bottom: 0.6em}
    DIV.Wide {font-family: "Times New Roman", Times, serif; margin-top: 0.6em; margin-bottom: 0.6em}
    DIV.Annotations {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-bottom: 0.6em}
    DIV.WideAnnotations {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-top: 0.6em; margin-bottom: 0.6em}
    DIV.Index {font-family: "Times New Roman", Times, serif}
    DIV.SyntaxSummary {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-bottom: 0.4em}
    DIV.Notes {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-bottom: 0.6em}
    DIV.NotesHeader {font-family: "Times New Roman", Times, serif; margin-left: 2.0em}
    DIV.SyntaxIndented {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-bottom: 0.4em}
    DIV.Indented {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-bottom: 0.6em}
    DIV.CodeIndented {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-bottom: 0.6em}
    DIV.SmallIndented {font-family: "Times New Roman", Times, serif; margin-left:  10.0em; margin-bottom: 0.6em}
    DIV.SmallCodeIndented {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-bottom: 0.6em}
    DIV.Examples {font-family: "Courier New", monospace; margin-left: 2.0em; margin-bottom: 0.6em}
    DIV.SmallExamples {font-family: "Courier New", monospace; font-size: 80%; margin-left: 7.5em; margin-bottom: 0.6em}
    DIV.IndentedExamples {font-family: "Courier New", monospace; margin-left: 8.0em; margin-bottom: 0.6em}
    DIV.SmallIndentedExamples {font-family: "Courier New", monospace; font-size: 80%; margin-left:  15.0em; margin-bottom: 0.6em}
    UL.Bulleted {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.SmallBulleted {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.NestedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-right: 4.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.SmallNestedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-right: 8.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.IndentedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-right: 8.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.CodeIndentedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.CodeIndentedNestedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-right: 8.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.SyntaxIndentedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-right: 4.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.NotesBulleted {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-right: 4.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.NotesNestedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    DL.Hanging {font-family: "Times New Roman", Times, serif; margin-top: 0em; margin-bottom: 0.6em}
    DD.Hanging {margin-left: 6.0em}
    DL.IndentedHanging {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-top: 0em; margin-bottom: 0.6em}
    DD.IndentedHanging {margin-left: 2.0em}
    DL.HangingInBulleted {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    DD.HangingInBulleted {margin-left: 4.0em}
    DL.SmallHanging {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-top: 0em; margin-bottom: 0.6em}
    DD.SmallHanging {margin-left: 7.5em}
    DL.SmallIndentedHanging {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-top: 0em; margin-bottom: 0.6em}
    DD.SmallIndentedHanging {margin-left: 2.0em}
    DL.SmallHangingInBulleted {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    DD.SmallHangingInBulleted {margin-left: 5.0em}
    DL.Enumerated {font-family: "Times New Roman", Times, serif; margin-right: 0.0em; margin-top: 0em; margin-bottom: 0.5em}
    DD.Enumerated {margin-left: 2.0em}
    DL.SmallEnumerated {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-right: 4.0em; margin-top: 0em; margin-bottom: 0.5em}
    DD.SmallEnumerated {margin-left: 2.5em}
    DL.NestedEnumerated {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    DL.SmallNestedEnumerated {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">
<P><A HREF="AA-TOC.html">Contents</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-0-29.html">Index</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-SRCH.html">Search</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-E-3.html">Previous</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-E-4-1.html">Next</A></P>
<HR>
<H1> E.4 Remote Subprogram Calls</H1>
<DIV Class="Paranum"><FONT SIZE=-2>1</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>remote subprogram call</I>}</FONT>
<A NAME="I7047"></A><FONT SIZE="-1">{<I>asynchronous remote procedure
call</I> [distributed]}</FONT> <A NAME="I7048"></A><FONT SIZE="-1">{<I>calling
partition</I>}</FONT> <A NAME="I7049"></A><FONT SIZE="-1">{<I>called
partition</I>}</FONT> <A NAME="I7050"></A><FONT SIZE="-1">{<I>remote
subprogram binding</I>}</FONT> <A NAME="I7051"></A>A <I>remote subprogram
call</I> is a subprogram call that invokes the execution of a subprogram
in another partition. The partition that originates the remote subprogram
call is the <I>calling partition</I>, and the partition that executes
the corresponding subprogram body is the <I>called partition</I>. Some
remote procedure calls are allowed to return prior to the completion
of subprogram execution. These are called <I>asynchronous remote procedure
calls</I>.</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>2</FONT></DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;&nbsp;&nbsp;There are three
different ways of performing a remote subprogram call: </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>3</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC>As a direct call on a (remote) subprogram
explicitly declared in a remote call interface;</LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>4</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC>As an indirect call through a value
of a remote access-to-subprogram type;</LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>5</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC>As a dispatching call with a controlling
operand designated by a value of a remote access-to-class-wide type.
</LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>6</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;The first way of calling corresponds to a <I>static</I>
binding between the calling and the called partition. The latter two
ways correspond to a <I>dynamic</I> binding between the calling and the
called partition.</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>7</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;A remote call interface library unit (see <A HREF="AA-E-2-3.html">E.2.3</A>)
defines the remote subprograms or remote access types used for remote
subprogram calls. </DIV>

<H4 ALIGN=CENTER>Language Design Principles</H4>
<DIV Class="Paranum"><FONT SIZE=-2>7.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">Remote subprogram calls are
standardized since the RPC paradigm is widely-used, and establishing
an interface to it in the annex will increase the portability and reusability
of distributed programs.</FONT></DIV>

<H4 ALIGN=CENTER>Legality Rules</H4>
<DIV Class="Paranum"><FONT SIZE=-2>8</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;In a dispatching call with two or more controlling
operands, if one controlling operand is designated by a value of a remote
access-to-class-wide type, then all shall be. </DIV>

<H4 ALIGN=CENTER>Dynamic Semantics</H4>
<DIV Class="Paranum"><FONT SIZE=-2>9</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>marshalling</I>}</FONT> <A NAME="I7052"></A><FONT SIZE="-1">{<I>unmarshalling</I>}</FONT>
<A NAME="I7053"></A><FONT SIZE="-1">{<I>execution (remote subprogram
call)</I> [partial]}</FONT> <A NAME="I7054"></A>For the execution of
a remote subprogram call, subprogram parameters (and later the results,
if any) are passed using a stream-oriented representation (see <A HREF="AA-13-13-1.html">13.13.1</A>)
[which is suitable for transmission between partitions]. This action
is called <I>marshalling</I>. <I>Unmarshalling</I> is the reverse action
of reconstructing the parameters or results from the stream-oriented
representation. [Marshalling is performed initially as part of the remote
subprogram call in the calling partition; unmarshalling is done in the
called partition. After the remote subprogram completes, marshalling
is performed in the called partition, and finally unmarshalling is done
in the calling partition.]</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>10</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>calling stub</I>}</FONT>
<A NAME="I7055"></A><FONT SIZE="-1">{<I>receiving stub</I>}</FONT> <A NAME="I7056"></A>A
<I>calling stub</I> is the sequence of code that replaces the subprogram
body of a remotely called subprogram in the calling partition. A <I>receiving
stub</I> is the sequence of code (the ``wrapper'') that receives a remote
subprogram call on the called partition and invokes the appropriate subprogram
body. </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>10.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Discussion: </B>The use of
the term <I>stub</I> in this annex should not be confused with <FONT FACE="Arial, Helvetica">body_stub</FONT>
as defined in <A HREF="AA-10-1-3.html">10.1.3</A>. The term <I>stub</I>
is used here because it is a commonly understood term when talking about
the RPC paradigm. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>11</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>at-most-once execution</I>}</FONT>
<A NAME="I7057"></A>Remote subprogram calls are executed at most once,
that is, if the subprogram call returns normally, then the called subprogram's
body was executed exactly once.</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>12</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;The task executing a remote subprogram call blocks
until the subprogram in the called partition returns, unless the call
is asynchronous. For an asynchronous remote procedure call, the calling
task can become ready before the procedure in the called partition returns.</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>13</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>cancellation of a remote
subprogram call</I>}</FONT> <A NAME="I7058"></A>If a construct containing
a remote call is aborted, the remote subprogram call is <I>cancelled</I>.
Whether the execution of the remote subprogram is immediately aborted
as a result of the cancellation is implementation defined. </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>13.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Implementation defined: </B>Whether
the execution of the remote subprogram is immediately aborted as a result
of cancellation.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>14</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;If a remote subprogram call is received by a
called partition before the partition has completed its elaboration,
the call is kept pending until the called partition completes its elaboration
(unless the call is cancelled by the calling partition prior to that).</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>15</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;If an exception is propagated by a remotely called
subprogram, and the call is not an asynchronous call, the corresponding
exception is reraised at the point of the remote subprogram call. For
an asynchronous call, if the remote procedure call returns prior to the
completion of the remotely called subprogram, any exception is lost.</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>16</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;The exception Communication_Error (see <A HREF="AA-E-5.html">E.5</A>)
is raised if a remote call cannot be completed due to difficulties in
communicating with the called partition.</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>17</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>potentially blocking operation
(remote subprogram call)</I> [partial]}</FONT> <A NAME="I7059"></A><FONT SIZE="-1">{<I>blocking,
potentially (remote subprogram call)</I> [partial]}</FONT> <A NAME="I7060"></A>All
forms of remote subprogram calls are potentially blocking operations
(see <A HREF="AA-9-5-1.html">9.5.1</A>). </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>17.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Reason: </B>Asynchronous
remote procedure calls are potentially blocking since the implementation
may require waiting for the availability of shared resources to initiate
the remote call. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>18/1</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I><A HREF="defect1.html#8652/0085">8652/0085</A></I>}
<FONT SIZE="-1">{<I>Accessibility_Check</I> [partial]}</FONT> <A NAME="I7061"></A><FONT SIZE="-1">{<I>check,
language-defined (Accessibility_Check)</I>}</FONT> <A NAME="I7062"></A>In
a remote subprogram call with a formal parameter of a class-wide type,
a check is made that the tag of the actual parameter identifies a tagged
type declared in a declared-pure or shared passive library unit, or in
the visible part of a remote types or remote call interface library unit.
<FONT SIZE="-1">{<I>Program_Error (raised by failure of run-time check)</I>}</FONT>
<A NAME="I7063"></A>Program_Error is raised if this check fails. <U>In
a remote function call which returns a class-wide type, the same check
is made on the function result.</U>  </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>18.a/1</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Discussion: </B>{<I><A HREF="defect1.html#8652/0085">8652/0085</A></I>}
This check makes certain that the specific type passed<U> or returned</U> 
in an RPC satisfies the rules for a &quot;communicable&quot; type. Normally
this is guaranteed by the compile-time restrictions on remote call interfaces.
However, with class-wide types, it is possible to pass an object whose
tag identifies a type declared outside the &quot;safe&quot; packages.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>18.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">This is considered an accessibility_check
since only the types declared in &quot;safe&quot; packages are considered
truly &quot;global&quot; (cross-partition). Other types are local to
a single partition. This is analogous to the &quot;accessibility&quot;
of global vs. local declarations in a single-partition program.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>18.c</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">This rule replaces a rule from
an early version of Ada 9X which was given in the subclause on Remote
Types Library Units (now <A HREF="AA-E-2-2.html">E.2.2</A>, ``<A HREF="AA-E-2-2.html">Remote
Types Library Units</A>''). That rule tried to prevent &quot;bad&quot;
types from being sent by arranging for their tags to mismatch between
partitions. However, that interfered with other uses of tags. The new
rule allows tags to agree in all partitions, even for those types which
are not &quot;safe&quot; to pass in an RPC. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>19</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>Partition_Check</I> [partial]}</FONT>
<A NAME="I7064"></A><FONT SIZE="-1">{<I>check, language-defined (Partition_Check)</I>}</FONT>
<A NAME="I7065"></A>In a dispatching call with two or more controlling
operands that are designated by values of a remote access-to-class-wide
type, a check is made [(in addition to the normal Tag_Check -- see <A HREF="AA-11-5.html">11.5</A>)]
that all the remote access-to-class-wide values originated from Access
<FONT FACE="Arial, Helvetica">attribute_reference</FONT>s that were evaluated
by tasks of the same active partition. <FONT SIZE="-1">{<I>Constraint_Error
(raised by failure of run-time check)</I>}</FONT> <A NAME="I7066"></A>Constraint_Error
is raised if this check fails. </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>19.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Implementation Note: </B>When
a remote access-to-class-wide value is created by an Access <FONT FACE="Arial, Helvetica">attribute_reference</FONT>,
the identity of the active partition that evaluated the <FONT FACE="Arial, Helvetica">attribute_reference</FONT>
should be recorded in the representation of the remote access value.
</FONT></DIV>

<H4 ALIGN=CENTER>Implementation Requirements</H4>
<DIV Class="Paranum"><FONT SIZE=-2>20</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;The implementation of remote subprogram calls
shall conform to the PCS interface as defined by the specification of
the language-defined package System.RPC (see <A HREF="AA-E-5.html">E.5</A>).
The calling stub shall use the Do_RPC procedure unless the remote procedure
call is asynchronous in which case Do_APC shall be used. On the receiving
side, the corresponding receiving stub shall be invoked by the RPC-receiver.
</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>20.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Implementation Note: </B>One
possible implementation model is as follows:</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>20.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">The code for calls to subprograms
declared in an RCI package is generated normally, that is, the call-site
is the same as for a local subprogram call. The code for the remotely
callable subprogram bodies is also generated normally. Subprogram's prologue
and epilogue are the same as for a local call.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>20.c</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">When compiling the specification
of an RCI package, the compiler generates calling stubs for each visible
subprogram. Similarly, when compiling the body of an RCI package, the
compiler generates receiving stubs for each visible subprogram together
with the appropriate tables to allow the RPC-receiver to locate the correct
receiving stub.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>20.d</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">For the statically bound remote
calls, the identity of the remote partition is statically determined
(it is resolved at configuration/link time).</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>20.e</FONT></DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><FONT SIZE="-1">The
calling stub operates as follows: </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>20.f</FONT></DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC><FONT SIZE="-1">It allocates
(or reuses) a stream of Params_Stream_Type of Initial_Size, and initializes
it by repeatedly calling Write operations, first to identify which remote
subprogram in the receiving partition is being called, and then to pass
the incoming value of each of the <B>in</B> and <B>in out</B> parameters
of the call.</FONT></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>20.g</FONT></DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC><FONT SIZE="-1">It allocates
(or reuses) a stream for the Result, unless a pragma Asynchronous is
applied to the procedure.</FONT></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>20.h</FONT></DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC><FONT SIZE="-1">It calls Do_RPC
unless a pragma Asynchronous is applied to the procedure in which case
it calls Do_APC. An access value designating the message stream allocated
and initialized above is passed as the Params parameter. An access value
designating the Result stream is passed as the Result parameter.</FONT></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>20.i</FONT></DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC><FONT SIZE="-1">If the pragma
Asynchronous is not specified for the procedure, Do_RPC blocks until
a reply message arrives, and then returns to the calling stub. The stub
returns after extracting from the Result stream, using Read operations,
the <B>in out</B> and <B>out</B> parameters or the function result. If
the reply message indicates that the execution of the remote subprogram
propagated an exception, the exception is propagated from Do_RPC to the
calling stub, and thence to the point of the original remote subprogram
call. If Do_RPC detects that communication with the remote partition
has failed, it propagates Communication_Error.</FONT></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>20.j</FONT></DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><FONT SIZE="-1">On
the receiving side, the RPC-receiver procedure operates as follows: </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>20.k</FONT></DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC><FONT SIZE="-1">It is called
from the PCS when a remote-subprogram-call message is received. The call
originates in some remote call receiver task executed and managed in
the context of the PCS.</FONT></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>20.l</FONT></DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC><FONT SIZE="-1">It extracts information
from the stream to identify the appropriate receiving stub.</FONT></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>20.m</FONT></DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC><FONT SIZE="-1">The receiving
stub extracts the <B>in</B> and <B>in out</B> parameters using Read from
the stream designated by the Params parameter.</FONT></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>20.n</FONT></DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC><FONT SIZE="-1">The receiving
stub calls the actual subprogram body and, upon completion of the subprogram,
uses Write to insert the results into the stream pointed to by the Result
parameter. The receiving stub returns to the RPC-receiver procedure which
in turn returns to the PCS. If the actual subprogram body propagates
an exception, it is propagated by the RPC-receiver to the PCS, which
handles the exception, and indicates in the reply message that the execution
of the subprogram body propagated an exception. The exception occurrence
can be represented in the reply message using the Write attribute of
Ada.Exceptions.Exception_Occurrence. </FONT></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>20.o</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">For remote access-to-subprogram
types:</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>20.p</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">A value of a remote access-to-subprogram
type can be represented by the following components: a reference to the
remote partition, an index to the package containing the remote subprogram,
and an index to the subprogram within the package. The values of these
components are determined at run time when the remote access value is
created. These three components serve the same purpose when calling Do_APC/RPC,
as in the statically bound remote calls; the only difference is that
they are evaluated dynamically.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>20.q</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">For remote access-to-class-wide
types:</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>20.r</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">For each remote access-to-class-wide
type, a calling stub is generated for each dispatching operation of the
designated type. In addition, receiving stubs are generated to perform
the remote dispatching operations in the called partition. The appropriate
<FONT FACE="Arial, Helvetica">subprogram_body</FONT> is determined as
for a local dispatching call once the receiving stub has been reached.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>20.s</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">A value of a remote access-to-class-wide
type can be represented with the following components: a reference to
the remote partition, an index to a table (created one per each such
access type) containing addresses of all the dispatching operations of
the designated type, and an access value designating the actual remote
object.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>20.t</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">Alternatively, a remote access-to-class-wide
value can be represented as a normal access value, pointing to a &quot;stub&quot;
object which in turn contains the information mentioned above. A call
on any dispatching operation of such a stub object does the remote call,
if necessary, using the information in the stub object to locate the
target partition, etc. This approach has the advantage that less special-casing
is required in the compiler. All access values can remain just a simple
address.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>20.u</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">{<I>Constraint_Error (raised
by failure of run-time check)</I>} <A NAME="I7067"></A>For a call to
Do_RPC or Do_APC: The partition ID of all controlling operands are checked
for equality (a Constraint_Error is raised if this check fails). The
partition ID value is used for the Partition parameter. An index into
the <I>tagged-type-descriptor</I> is created. This index points to the
receiving stub of the class-wide operation. This index and the index
to the table (described above) are written to the stream. Then, the actual
parameters are marshalled into the message stream. For a controlling
operand, only the access value designating the remote object is required
(the other two components are already present in the other parameters).</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>20.v</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">On the called partition (after
the RPC-receiver has transferred control to the appropriate receiving
stub) the parameters are first unmarshalled. Then, the tags of the controlling
operands (obtained by dereferencing the pointer to the object) are checked
for equality. {<I>Constraint_Error (raised by failure of run-time check)</I>}
<A NAME="I7068"></A>If the check fails Constraint_Error is raised and
propagated back to the calling partition, unless it is a result of an
asynchronous call. Finally, a dispatching call to the specific subprogram
(based on the controlling object's tag) is made. Note that since this
subprogram is not in an RCI package, no specific stub is generated for
it, it is called normally from the <I>dispatching stub</I>.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>20.1/1</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I><A HREF="defect1.html#8652/0086">8652/0086</A></I>}
<U>With respect to shared variables in shared passive library units,
the execution of the corresponding subprogram body of a synchronous remote
procedure call is considered to be part of the execution of the calling
task. The execution of the corresponding subprogram body of an asynchronous
remote procedure call proceeds in parallel with the calling task and
does not signal the next action of the calling task (see <A HREF="AA-9-10.html">9.10</A>).</U> 
</DIV>
<DIV Class="NotesHeader"><FONT SIZE="-1">NOTES</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>21</FONT></DIV>
<DIV Class="Notes"><FONT SIZE="-1">6&nbsp;&nbsp;A given active partition
can both make and receive remote subprogram calls. Thus, an active partition
can act as both a client and a server.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>22</FONT></DIV>
<DIV Class="Notes"><FONT SIZE="-1">7&nbsp;&nbsp;If a given exception
is propagated by a remote subprogram call, but the exception does not
exist in the calling partition, the exception can be handled by an <B>others</B>
choice or be propagated to and handled by a third partition. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>22.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Discussion: </B>This situation
can happen in a case of dynamically nested remote subprogram calls, where
an intermediate call executes in a partition that does not include the
library unit that defines the exception. </FONT></DIV>

<HR>
<P><A HREF="AA-TOC.html">Contents</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-0-29.html">Index</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-SRCH.html">Search</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-E-3.html">Previous</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-E-4-1.html">Next</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-TTL.html">Legal</A></P>
</BODY>
</HTML>
