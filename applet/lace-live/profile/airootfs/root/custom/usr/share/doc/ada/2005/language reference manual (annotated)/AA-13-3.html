<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Operational and Representation Attributes</TITLE>
    <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    H4.centered {text-align: center}
    SPAN.swiss {font-family: Arial, Helvetica, sans-serif; font-size: 92%}
    SPAN.roman {font-family: "Times New Roman", Times, serif}
    DIV.paranum {float: left; font-family: Arial, Helvetica, sans-serif; font-size: 64%; width: 2.8em; margin-left: -0.4em; margin-right: -3.0em; margin-top: 0.2em}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    SPAN.insert1 {text-decoration: underline; color: rgb(0,51,51) }
    SPAN.delete1 {text-decoration: line-through; color: rgb(0,51,51) }
    SPAN.insert2 {text-decoration: underline; color: rgb(0,102,0) }
    SPAN.delete2 {text-decoration: line-through; color: rgb(0,102,0) }
    DIV.Normal {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.2em; margin-bottom: 0.6em}
    DIV.Annotations {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 6.2em; margin-bottom: 0.6em}
    DIV.Notes {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em; margin-bottom: 0.6em}
    DIV.NotesHeader {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em}
    DIV.SyntaxIndented {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-bottom: 0.4em}
    DIV.Examples {font-family: "Courier New", monospace; font-size: 90%; line-height: 122%; margin-left: 3.4em; margin-bottom: 0.6em}
    DIV.SmallExamples {font-family: "Courier New", monospace; font-size: 72%; line-height: 122%; margin-left: 9.6em; margin-bottom: 0.6em}
    UL.Bulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.SmallBulleted {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 8.7em; margin-right: 2.5em; margin-top: 0em; margin-bottom: 0.5em}
    UL.NestedBulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 5.2em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.IndentedBulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 9.2em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    DIV.Hanging-Body {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 7.2em; margin-top: 0em; margin-bottom: 0.6em}
    DIV.Hanging-Term {float: left; font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.2em; margin-top: 0em; margin-bottom: 0em}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#000080" VLINK="#330033" ALINK="#0000FF">
<DIV><B><SPAN Style="font-size:200%; color: rgb(0,51,153)">Annotated</SPAN><SPAN Style="font-size:200%; color: rgb(0,0,102)">&nbsp;Ada Reference Manual</SPAN></B> &mdash; <A HREF="AA-TTL.html"><B>Legal Information</B></A></DIV>
<DIV Style="margin-top: 0.6em; margin-bottom: 0.0em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-13-2.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-13-4.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<HR>
<H1>&nbsp;13.3 <SPAN class="insert1">Operational and Representation Attributes</SPAN> <SPAN class="delete1">Representation Attributes</SPAN></H1>
<DIV Class="paranum">1/1</DIV>
<DIV Class="Normal">{<I><A HREF="defect1.html#8652/0009">8652/0009</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00137.TXT">AI95-00137-01</A></I>} 
[<SPAN STYLE="font-size: 80%">{<I>representation attribute</I>}</SPAN> 
<A NAME="I4936"></A><SPAN STYLE="font-size: 80%">{<I>attribute (representation)</I>}</SPAN> 
<A NAME="I4937"></A>The values of certain implementation-dependent characteristics 
can be obtained by interrogating appropriate <SPAN class="insert1">operational 
or&nbsp;</SPAN>representation attributes. <SPAN STYLE="font-size: 80%">{<I>attribute 
(specifying)</I> [distributed]}</SPAN> <A NAME="I4938"></A>Some of these 
attributes are specifiable via an <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN>.] 
</DIV>

<H4 Class="centered">Language Design Principles</H4>
<DIV Class="paranum">1.a</DIV>
<DIV Class="Annotations">In general, the meaning of a given attribute 
should not depend on whether the attribute was specified via an <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN>, 
or chosen by default by the implementation.&nbsp;</DIV>

<H4 Class="centered">Syntax</H4>
<DIV Class="paranum">2</DIV>
<DIV Class="SyntaxIndented"><SPAN Class="swiss">attribute_definition_clause</SPAN><A NAME="I4939"></A><A NAME="S0286"></A><SPAN Class="swiss">&nbsp;::=&nbsp;</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>for</B>&nbsp;<A NAME="I4940"></A><SPAN Class="swiss"><A HREF="AA-13-1.html#S0285">local_name</A></SPAN>'<A NAME="I4941"></A><SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0101">attribute_designator</A></SPAN>&nbsp;<B>use</B>&nbsp;<A NAME="I4942"></A><SPAN Class="swiss"><A HREF="AA-4-4.html#S0115">expression</A></SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<B>for</B>&nbsp;<A NAME="I4943"></A><SPAN Class="swiss"><A HREF="AA-13-1.html#S0285">local_name</A></SPAN>'<A NAME="I4944"></A><SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0101">attribute_designator</A></SPAN>&nbsp;<B>use</B>&nbsp;<A NAME="I4945"></A><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>;</DIV>

<H4 Class="centered">Name Resolution Rules</H4>
<DIV Class="paranum">3</DIV>
<DIV Class="Normal">For an <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN> 
that specifies an attribute that denotes a value, the form with an <SPAN Class="swiss"><A HREF="AA-4-4.html#S0115">expression</A></SPAN> 
shall be used. Otherwise, the form with a <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
shall be used.</DIV>
<DIV Class="paranum">4</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>expected type (attribute_definition_clause 
expression or name)</I> [partial]}</SPAN> <A NAME="I4946"></A>For an 
<SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN> 
that specifies an attribute that denotes a value or an object, the expected 
type for the expression or <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
is that of the attribute. <SPAN STYLE="font-size: 80%">{<I>expected profile 
(attribute_definition_clause name)</I> [partial]}</SPAN> <A NAME="I4947"></A>For 
an <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN> 
that specifies an attribute that denotes a subprogram, the expected profile 
for the <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
is the profile required for the attribute. For an <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN> 
that specifies an attribute that denotes some other kind of entity, the 
<SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> shall 
resolve to denote an entity of the appropriate kind.&nbsp;</DIV>
<DIV Class="paranum">4.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>For example, the Size attribute 
is of type <I>universal_integer</I>. Therefore, the expected type for 
Y in &ldquo;<B>for</B> X'Size <B>use</B> Y;&rdquo; is <I>universal_integer</I>, 
which means that Y can be of any integer type.&nbsp;</DIV>
<DIV Class="paranum">4.b</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>For attributes that denote 
subprograms, the required profile is indicated separately for the individual 
attributes.&nbsp;</DIV>
<DIV Class="paranum">4.c</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><B>Ramification: 
</B>For an <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN> 
with a <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>, 
the <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> need 
not statically denote the entity it denotes. For example, the following 
kinds of things are allowed:&nbsp;</DIV>
<DIV Class="paranum">4.d</DIV>
<DIV Class="SmallExamples"><B>for</B>&nbsp;Some_Access_Type'Storage_Pool&nbsp;<B>use</B>&nbsp;Storage_Pool_Array(I);<BR>
<B>for</B>&nbsp;Some_Type'Read&nbsp;<B>use</B>&nbsp;Subprogram_Pointer.<B>all</B>;</DIV>

<H4 Class="centered">Legality Rules</H4>
<DIV Class="paranum">5/1</DIV>
<DIV Class="Normal">{<I><A HREF="defect1.html#8652/0009">8652/0009</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00137.TXT">AI95-00137-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>specifiable (of an attribute and for 
an entity)</I> [distributed]}</SPAN> <A NAME="I4948"></A><SPAN STYLE="font-size: 80%">{<I>attribute 
(specifiable)</I> [distributed]}</SPAN> <A NAME="I4949"></A>An <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0101">attribute_designator</A></SPAN> 
is allowed in an <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN> 
only if this International Standard explicitly allows it, or for an implementation-defined 
attribute if the implementation allows it. <SPAN STYLE="font-size: 80%">{<I>aspect 
of representation (specifiable attributes)</I> [partial]}</SPAN> <A NAME="I4950"></A>Each 
specifiable attribute constitutes an <SPAN class="insert1"><SPAN STYLE="font-size: 80%">{<I>operational 
aspect (specifiable attributes)</I> [partial]}</SPAN> <A NAME="I4951"></A>operational 
aspect or&nbsp;</SPAN>aspect of representation.&nbsp;</DIV>
<DIV Class="paranum">5.a</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>For each specifiable attribute, 
we generally say something like, &ldquo;The ... attribute may be specified 
for ... via an <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN>.&rdquo;</DIV>
<DIV Class="paranum">5.b</DIV>
<DIV Class="Annotations">The above wording allows for T'Class'Alignment, 
T'Class'Size, T'Class'Input, and T'Class'Output to be specifiable.</DIV>
<DIV Class="paranum">5.c</DIV>
<DIV Class="Annotations">A specifiable attribute is not necessarily specifiable 
for all entities for which it is defined. For example, one is allowed 
to ask T'Component_Size for an array subtype T, but &ldquo;<B>for</B> 
T'Component_Size <B>use</B> ...&rdquo; is only allowed if T is a first 
subtype, because Component_Size is a type-related aspect.&nbsp;</DIV>
<DIV Class="paranum">6</DIV>
<DIV Class="Normal">For an <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN> 
that specifies an attribute that denotes a subprogram, the profile shall 
be mode conformant with the one required for the attribute, and the convention 
shall be Ada. Additional requirements are defined for particular attributes. 
<SPAN STYLE="font-size: 80%">{<I>mode conformance (required)</I>}</SPAN> 
<A NAME="I4952"></A></DIV>
<DIV Class="paranum">6.a</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><B>Ramification: 
</B>This implies, for example, that if one writes:&nbsp;</DIV>
<DIV Class="paranum">6.b</DIV>
<DIV Class="SmallExamples"><B>for</B>&nbsp;T'Read&nbsp;<B>use</B>&nbsp;R;</DIV>
<DIV Class="paranum">6.c</DIV>
<DIV Class="Annotations">R has to be a procedure with two parameters 
with the appropriate subtypes and modes as shown in <A HREF="AA-13-13-2.html">13.13.2</A>. 
</DIV>

<H4 Class="centered">Static Semantics</H4>
<DIV Class="paranum">7/2</DIV>
<DIV Class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00270.TXT">AI95-00270-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>Address clause</I>}</SPAN> <A NAME="I4953"></A><SPAN STYLE="font-size: 80%">{<I>Alignment 
clause</I>}</SPAN> <A NAME="I4954"></A><SPAN STYLE="font-size: 80%">{<I>Size 
clause</I>}</SPAN> <A NAME="I4955"></A><SPAN STYLE="font-size: 80%">{<I>Component_Size 
clause</I>}</SPAN> <A NAME="I4956"></A><SPAN STYLE="font-size: 80%">{<I>External_Tag 
clause</I>}</SPAN> <A NAME="I4957"></A><SPAN STYLE="font-size: 80%">{<I>Small 
clause</I>}</SPAN> <A NAME="I4958"></A><SPAN STYLE="font-size: 80%">{<I>Bit_Order 
clause</I>}</SPAN> <A NAME="I4959"></A><SPAN STYLE="font-size: 80%">{<I>Storage_Pool 
clause</I>}</SPAN> <A NAME="I4960"></A><SPAN STYLE="font-size: 80%">{<I>Storage_Size 
clause</I>}</SPAN> <A NAME="I4961"></A><SPAN class="insert2"><SPAN STYLE="font-size: 80%">{<I>Stream_Size 
clause</I>}</SPAN> <A NAME="I4962"></A></SPAN><SPAN STYLE="font-size: 80%">{<I>Read 
clause</I>}</SPAN> <A NAME="I4963"></A><SPAN STYLE="font-size: 80%">{<I>Write 
clause</I>}</SPAN> <A NAME="I4964"></A><SPAN STYLE="font-size: 80%">{<I>Input 
clause</I>}</SPAN> <A NAME="I4965"></A><SPAN STYLE="font-size: 80%">{<I>Output 
clause</I>}</SPAN> <A NAME="I4966"></A><SPAN STYLE="font-size: 80%">{<I>Machine_Radix 
clause</I>}</SPAN> <A NAME="I4967"></A>A <I>Size clause</I> is an <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN> 
whose <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0101">attribute_designator</A></SPAN> 
is Size. Similar definitions apply to the other specifiable attributes. 
</DIV>
<DIV Class="paranum">7.a</DIV>
<DIV Class="Annotations"><B>To be honest:&nbsp;</B>{<I>type-related (attribute_definition_clause)</I> 
[partial]} <A NAME="I4968"></A>{<I>subtype-specific (attribute_definition_clause)</I> 
[partial]} <A NAME="I4969"></A>An <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN> 
is type-related or subtype-specific if the <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0101">attribute_designator</A></SPAN> 
denotes a type-related or subtype-specific attribute, respectively.&nbsp;</DIV>
<DIV Class="paranum">8</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>storage element</I>}</SPAN> 
<A NAME="I4970"></A><SPAN STYLE="font-size: 80%">{<I>byte: See storage 
element</I>}</SPAN> <A NAME="I4971"></A>A <I>storage element</I> is an 
addressable element of storage in the machine. <SPAN STYLE="font-size: 80%">{<I>word</I>}</SPAN> 
<A NAME="I4972"></A>A <I>word</I> is the largest amount of storage that 
can be conveniently and efficiently manipulated by the hardware, given 
the implementation's run-time model. A word consists of an integral number 
of storage elements.&nbsp;</DIV>
<DIV Class="paranum">8.a</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>A storage element is not 
intended to be a single bit, unless the machine can efficiently address 
individual bits.&nbsp;</DIV>
<DIV Class="paranum">8.b</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>For example, on a machine 
with 8-bit storage elements, if there exist 32-bit integer registers, 
with a full set of arithmetic and logical instructions to manipulate 
those registers, a word ought to be 4 storage elements &mdash; that is, 
32 bits.&nbsp;</DIV>
<DIV Class="paranum">8.c</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>The &ldquo;given the implementation's 
run-time model&rdquo; part is intended to imply that, for example, on 
an 80386 running MS-DOS, the word might be 16 bits, even though the hardware 
can support 32 bits.</DIV>
<DIV Class="paranum">8.d</DIV>
<DIV Class="Annotations">A word is what ACID refers to as a &ldquo;natural 
hardware boundary&rdquo;.</DIV>
<DIV Class="paranum">8.e</DIV>
<DIV Class="Annotations">Storage elements may, but need not be, independently 
addressable (see <A HREF="AA-9-10.html">9.10</A>, &ldquo;<A HREF="AA-9-10.html">Shared 
Variables</A>&rdquo;). Words are expected to be independently addressable. 
</DIV>
<DIV Class="paranum">8.1/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00133.TXT">AI95-00133-01</A></I>} 
<SPAN class="insert2"><SPAN STYLE="font-size: 80%">{<I>machine scalar</I>}</SPAN> 
<A NAME="I4973"></A>A <I>machine scalar</I> is an amount of storage that 
can be conveniently and efficiently loaded, stored, or operated upon 
by the hardware. Machine scalars consist of an integral number of storage 
elements. The set of machine scalars is implementation defined, but must 
include at least the storage element and the word. Machine scalars are 
used to interpret <SPAN Class="swiss"><A HREF="AA-13-5-1.html#S0290">component_clause</A></SPAN>s 
when the nondefault bit ordering applies.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">8.e.1/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Implementation defined: 
</B></SPAN><SPAN class="insert2">The set of machine scalars.</SPAN></DIV>
<DIV Class="paranum">9/1</DIV>
<DIV Class="Normal">{<I><A HREF="defect1.html#8652/0009">8652/0009</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00137.TXT">AI95-00137-01</A></I>} 
<SPAN class="insert1">The following representation attributes are defined: 
Address, Alignment, Size, Storage_Size, and Component_Size.</SPAN><SPAN class="delete1">&nbsp;The 
following attributes are defined:</SPAN></DIV>
<DIV Class="paranum">10/1</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;For a <SPAN class="insert1"><SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN></SPAN><SPAN class="delete1">&nbsp;prefix</SPAN> 
X that denotes an object, program unit, or label:&nbsp;</DIV>
<DIV Class="paranum">11</DIV>
<DIV Class="Hanging-Term">X'Address</DIV><DIV Class="Hanging-Body">
<A NAME="I4974"></A><A NAME="I4975"></A>Denotes the address of the first 
of the storage elements allocated to X. For a program unit or label, 
this value refers to the machine code associated with the corresponding 
body or <SPAN Class="swiss"><A HREF="AA-5-1.html#S0131">statement</A></SPAN>. 
The value of this attribute is of type System.Address.&nbsp;</DIV>
<DIV Class="paranum">11.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>Here, the &ldquo;first 
of the storage elements&rdquo; is intended to mean the one with the lowest 
address; the endianness of the machine doesn't matter.</DIV>
<DIV Class="paranum">12</DIV>
<DIV Class="Hanging-Body"><SPAN STYLE="font-size: 80%">{<I>specifiable 
(of Address for stand-alone objects and for program units)</I> [partial]}</SPAN> 
<A NAME="I4976"></A><SPAN STYLE="font-size: 80%">{<I>Address clause</I>}</SPAN> 
<A NAME="I4977"></A>Address may be specified for stand-alone objects 
and for program units via an <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN>. 
</DIV>
<DIV Class="paranum">12.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>Address is not allowed 
for enumeration literals, predefined operators, derived task types, or 
derived protected types, since they are not program units.</DIV>
<DIV Class="paranum">12.b</DIV>
<DIV Class="Annotations">The validity of a given address depends on the 
run-time model; thus, in order to use Address clauses correctly, one 
needs intimate knowledge of the run-time model.</DIV>
<DIV Class="paranum">12.c</DIV>
<DIV Class="Annotations">If the Address of an object is specified, any 
explicit or implicit initialization takes place as usual, unless a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Import is also specified for the object (in which case any necessary 
initialization is presumably done in the foreign language).</DIV>
<DIV Class="paranum">12.d</DIV>
<DIV Class="Annotations">Any compilation unit containing an <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0100">attribute_reference</A></SPAN> 
of a given type depends semantically on the declaration of the package 
in which the type is declared, even if not mentioned in an applicable 
<SPAN Class="swiss"><A HREF="AA-10-1-2.html#S0237">with_clause</A></SPAN> 
&mdash; see <A HREF="AA-10-1-1.html">10.1.1</A>. In this case, it means 
that if a compilation unit contains X'Address, then it depends on the 
declaration of System. Otherwise, the fact that the value of Address 
is of a type in System wouldn't make sense; it would violate the &ldquo;legality 
determinable via semantic dependences&rdquo; Language Design Principle.</DIV>
<DIV Class="paranum">12.e</DIV>
<DIV Class="Annotations">AI83-00305 &mdash; If X is a task type, then 
within the body of X, X denotes the current task object; thus, X'Address 
denotes the object's address.</DIV>
<DIV Class="paranum">12.f</DIV>
<DIV Class="Annotations">Interrupt entries and their addresses are described 
in <A HREF="AA-J-7-1.html">J.7.1</A>, &ldquo;<A HREF="AA-J-7-1.html">Interrupt 
Entries</A>&rdquo;.</DIV>
<DIV Class="paranum">12.g</DIV>
<DIV Class="Annotations">If X is not allocated on a storage element boundary, 
X'Address points at the first of the storage elements that contains any 
part of X. This is important for the definition of the Position attribute 
to be sensible.&nbsp;</DIV>

<H4 Class="centered">Erroneous Execution</H4>
<DIV Class="paranum">13</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>erroneous execution 
(cause)</I> [partial]}</SPAN> <A NAME="I4978"></A>If an Address is specified, 
it is the programmer's responsibility to ensure that the address is valid; 
otherwise, program execution is erroneous.&nbsp;</DIV>

<H4 Class="centered">Implementation Advice</H4>
<DIV Class="paranum">14</DIV>
<DIV Class="Normal">For an array X, X'Address should point at the first 
component of the array, and not at the array bounds.&nbsp;</DIV>
<DIV Class="paranum">14.a.1/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Implementation Advice: 
</B></SPAN><SPAN class="insert2">For an array X, X'Address should point 
at the first component of the array rather than the array bounds.</SPAN></DIV>
<DIV Class="paranum">14.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>On the other hand, we have 
no advice to offer about discriminants and tag fields; whether or not 
the address points at them is not specified by the language. If discriminants 
are stored separately, then the Position of a discriminant might be negative, 
or might raise an exception.&nbsp;</DIV>
<DIV Class="paranum">15</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>recommended level 
of support (Address attribute)</I> [partial]}</SPAN> <A NAME="I4979"></A>The 
recommended level of support for the Address attribute is:&nbsp;</DIV>
<DIV Class="paranum">16</DIV>
<UL Class="Bulleted" Style="margin-bottom: 0.3em"><LI TYPE=DISC>X'Address 
should produce a useful result if X is an object that is aliased or of 
a by-reference type, or is an entity whose Address has been specified. 
</LI></UL>
<DIV Class="paranum">16.a</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>Aliased objects are the ones 
for which the Unchecked_Access attribute is allowed; hence, these have 
to be allocated on an addressable boundary anyway. Similar considerations 
apply to objects of a by-reference type.</DIV>
<DIV Class="paranum">16.b</DIV>
<DIV Class="Annotations">An implementation need not go to any trouble 
to make Address work in other cases. For example, if an object X is not 
aliased and not of a by-reference type, and the implementation chooses 
to store it in a register, X'Address might return System.Null_Address 
(assuming registers are not addressable). For a subprogram whose calling 
convention is Intrinsic, or for a package, the implementation need not 
generate an out-of-line piece of code for it.&nbsp;</DIV>
<DIV Class="paranum">17</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>An implementation should support Address 
clauses for imported subprograms.</LI></UL>
<DIV Class="paranum">18/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN STYLE="font-size: 80%"><I>This 
paragraph was deleted.</I></SPAN><SPAN class="delete2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10291.TXT">AI95-00291-02</A></I>} 
<SPAN class="delete2">Objects (including subcomponents) that are aliased 
or of a by-reference type should be allocated on storage element boundaries.</SPAN> 
</LI></UL>
<DIV Class="paranum">18.a/2</DIV>
<DIV Class="Annotations"><SPAN STYLE="font-size: 80%"><I>This paragraph 
was deleted.</I></SPAN><SPAN class="delete2"><B>Reason:&nbsp;</B>This is necessary 
for the Address attribute to be useful (since First_Bit and Last_Bit 
apply only to components). Implementations generally need to do this 
anyway, for tasking to work properly.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">19</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>If the Address of an object is specified, 
or it is imported or exported, then the implementation should not perform 
optimizations based on assumptions of no aliases.&nbsp;</LI></UL>
<DIV Class="paranum">19.a/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Implementation Advice: 
</B></SPAN><SPAN class="insert2">The recommended level of support for 
the Address attribute should be followed.</SPAN></DIV>
<DIV Class="NotesHeader">NOTES</DIV>
<DIV Class="paranum">20</DIV>
<DIV Class="Notes">1&nbsp;&nbsp;The specification of a link name in a 
<SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> Export 
(see <A HREF="AA-B-1.html">B.1</A>) for a subprogram or object is an 
alternative to explicit specification of its link-time address, allowing 
a link-time directive to place the subprogram or object within memory.</DIV>
<DIV Class="paranum">21</DIV>
<DIV Class="Notes">2&nbsp;&nbsp;The rules for the Size attribute imply, 
for an aliased object X, that if X'Size = Storage_Unit, then X'Address 
points at a storage element containing all of the bits of X, and only 
the bits of X.&nbsp;</DIV>

<H4 Class="centered">Wording Changes from Ada 83</H4>
<DIV Class="paranum">21.a</DIV>
<DIV Class="Annotations">The intended meaning of the various attributes, 
and their <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN>s, 
is more explicit.</DIV>
<DIV Class="paranum">21.b</DIV>
<DIV Class="Annotations">The <SPAN Class="swiss">address_clause</SPAN> 
has been renamed to <SPAN Class="swiss"><A HREF="AA-J-7.html#S0298">at_clause</A></SPAN> 
and moved to <A HREF="AA-J.html">Annex J</A>, &ldquo;<A HREF="AA-J.html">Obsolescent 
Features</A>&rdquo;. One can use an Address clause (&ldquo;for T'Address 
<B>use</B> ...;&rdquo;) instead.</DIV>
<DIV Class="paranum">21.c</DIV>
<DIV Class="Annotations">The attributes defined in RM83-13.7.3 are moved 
to <A HREF="AA-G.html">Annex G</A>, <A HREF="AA-A-5-3.html">A.5.3</A>, 
and <A HREF="AA-A-5-4.html">A.5.4</A>.&nbsp;</DIV>

<H4 Class="centered">Language Design Principles</H4>
<DIV Class="paranum">21.d</DIV>
<DIV Class="Annotations">By default, the Alignment of a subtype should 
reflect the &ldquo;natural&rdquo; alignment for objects of the subtype 
on the machine. The Alignment, whether specified or default, should be 
known at compile time, even though Addresses are generally not known 
at compile time. (The generated code should never need to check at run 
time the number of zero bits at the end of an address to determine an 
alignment).</DIV>
<DIV Class="paranum">21.e</DIV>
<DIV Class="Annotations">There are two symmetric purposes of Alignment 
clauses, depending on whether or not the implementation has control over 
object allocation. If the implementation allocates an object, the implementation 
should ensure that the Address and Alignment are consistent with each 
other. If something outside the implementation allocates an object, the 
implementation should be allowed to assume that the Address and Alignment 
are consistent, but should not assume stricter alignments than that. 
</DIV>

<H4 Class="centered">Static Semantics</H4>
<DIV Class="paranum">22/2</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10291.TXT">AI95-00291-02</A></I>} 
For a <SPAN class="insert1"><SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN></SPAN><SPAN class="delete1">&nbsp;prefix</SPAN> 
X that denotes <SPAN class="insert2">an</SPAN><SPAN class="delete2">&nbsp;a 
subtype or</SPAN> object:&nbsp;</DIV>
<DIV Class="paranum">23/2</DIV>
<DIV Class="Hanging-Term">&nbsp;X'Alignment</DIV><DIV Class="Hanging-Body">
<A NAME="I4980"></A><A NAME="I4981"></A>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10291.TXT">AI95-00291-02</A></I>} 
<SPAN class="insert2">The value of this attribute is of type <I>universal_integer</I>, 
and nonnegative; zero means that the object is not necessarily aligned 
on a storage element boundary. If X'Alignment is not zero, then X is 
aligned on a storage unit boundary and X'Address</SPAN><SPAN class="delete2">&nbsp;The 
Address of an object that is allocated under control of the implementation</SPAN> 
is an integral multiple of <SPAN class="insert2">X'Alignment</SPAN><SPAN class="delete2">&nbsp;the 
Alignment of the object</SPAN> (that is, the Address modulo the Alignment 
is zero).<SPAN class="delete2">The offset of a record component is a 
multiple of the Alignment of the component. For an object that is not 
allocated under control of the implementation (that is, one that is imported, 
that is allocated by a user-defined allocator, whose Address has been 
specified, or is designated by an access value returned by an instance 
of Unchecked_Conversion), the implementation may assume that the Address 
is an integral multiple of its Alignment. The implementation shall not 
assume a stricter alignment.</SPAN></DIV>
<DIV Class="paranum">24/2</DIV>
<DIV Class="Hanging-Body"><SPAN STYLE="font-size: 80%"><I>This paragraph 
was deleted.</I></SPAN><SPAN class="delete2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10291.TXT">AI95-00291-02</A></I>} 
<SPAN class="delete2">The value of this attribute is of type <I>universal_integer</I>, 
and nonnegative; zero means that the object is not necessarily aligned 
on a storage element boundary.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">24.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>The Alignment is passed 
by an <SPAN Class="swiss"><A HREF="AA-4-8.html#S0129">allocator</A></SPAN> 
to the Allocate operation; the implementation has to choose a value such 
that if the address returned by Allocate is aligned as requested, the 
generated code can correctly access the object.</DIV>
<DIV Class="paranum">24.b</DIV>
<DIV Class="Annotations">The above mention of &ldquo;modulo&rdquo; is 
referring to the &quot;<B>mod</B>&quot; operator declared in System.Storage_Elements; 
if X <B>mod</B> N = 0, then X is by definition aligned on an N-storage-element 
boundary.&nbsp;</DIV>
<DIV Class="paranum">25/2</DIV>
<DIV Class="Hanging-Body">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10291.TXT">AI95-00291-02</A></I>} 
<SPAN class="insert2"><SPAN STYLE="font-size: 80%">{<I>specifiable (of 
Alignment for objects)</I> [partial]}</SPAN> <A NAME="I4982"></A></SPAN><SPAN class="delete2"><SPAN STYLE="font-size: 80%">{<I>specifiable 
(of Alignment for first subtypes and objects)</I> [partial]}</SPAN> <A NAME="I4983"></A></SPAN><SPAN STYLE="font-size: 80%">{<I>Alignment 
clause</I>}</SPAN> <A NAME="I4984"></A>Alignment may be specified for<SPAN class="delete2">&nbsp;first subtypes and</SPAN> [stand-alone] objects via an <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN>; 
the expression of such a clause shall be static, and its value nonnegative.<SPAN class="delete2">If 
the Alignment of a subtype is specified, then the Alignment of an object 
of the subtype is at least as strict, unless the object's Alignment is 
also specified. The Alignment of an object created by an allocator is 
that of the designated subtype.</SPAN></DIV>
<DIV Class="paranum">26/2</DIV>
<DIV Class="Hanging-Body"><SPAN STYLE="font-size: 80%"><I>This paragraph 
was deleted.</I></SPAN><SPAN class="delete2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00247.TXT">AI95-00247-01</A></I>} 
<SPAN class="delete2">If an Alignment is specified for a composite subtype 
or object, this Alignment shall be equal to the least common multiple 
of any specified Alignments of the subcomponent subtypes, or an integer 
multiple thereof.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">26.1/2</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10291.TXT">AI95-00291-02</A></I>} 
<SPAN class="insert2">For every subtype S:</SPAN>&nbsp;</DIV>
<DIV Class="paranum">26.2/2</DIV>
<DIV Class="Hanging-Term">&nbsp;&nbsp;&nbsp;<SPAN class="insert2">S'Alignment</SPAN></DIV><DIV Class="Hanging-Body"><BR clear="left">
<SPAN class="insert2"><A NAME="I4985"></A><A NAME="I4986"></A></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10291.TXT">AI95-00291-02</A></I>} 
<SPAN class="insert2"></SPAN><SPAN class="insert2">The value of this 
attribute is of type <I>universal_integer</I>, and nonnegative.</SPAN></DIV>
<DIV Class="paranum">26.3/2</DIV>
<DIV Class="Hanging-Body">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10051.TXT">AI95-00051-02</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10291.TXT">AI95-00291-02</A></I>} 
<SPAN class="insert2">For an object X of subtype S, if S'Alignment is 
not zero, then X'Alignment is a nonzero integral multiple of S'Alignment 
unless specified otherwise by a representation item.</SPAN></DIV>
<DIV Class="paranum">26.4/2</DIV>
<DIV Class="Hanging-Body">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10291.TXT">AI95-00291-02</A></I>} 
<SPAN class="insert2"><SPAN STYLE="font-size: 80%">{<I>specifiable (of 
Alignment for first subtypes)</I> [partial]}</SPAN> <A NAME="I4987"></A><SPAN STYLE="font-size: 80%">{<I>Alignment 
clause</I>}</SPAN> <A NAME="I4988"></A>Alignment may be specified for 
first subtypes via an <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN>; 
the expression of such a clause shall be static, and its value nonnegative.</SPAN></DIV>

<H4 Class="centered">Erroneous Execution</H4>
<DIV Class="paranum">27</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>erroneous execution 
(cause)</I> [partial]}</SPAN> <A NAME="I4989"></A>Program execution is 
erroneous if an Address clause is given that conflicts with the Alignment. 
</DIV>
<DIV Class="paranum">27.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>The user has to either 
give an Alignment clause also, or else know what Alignment the implementation 
will choose by default.&nbsp;</DIV>
<DIV Class="paranum">28/2</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10051.TXT">AI95-00051-02</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10291.TXT">AI95-00291-02</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>erroneous execution (cause)</I> [partial]}</SPAN> 
<A NAME="I4990"></A><SPAN class="insert2">For</SPAN><SPAN class="delete2">&nbsp;If 
the Alignment is specified for</SPAN> an object that is not allocated 
under control of the implementation, execution is erroneous if the object 
is not aligned according to <SPAN class="insert2">its</SPAN><SPAN class="delete2">&nbsp;the</SPAN> 
Alignment.</DIV>

<H4 Class="centered">Implementation Advice</H4>
<DIV Class="paranum">29</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>recommended level 
of support (Alignment attribute for subtypes)</I> [partial]}</SPAN> <A NAME="I4991"></A>The 
recommended level of support for the Alignment attribute for subtypes 
is:&nbsp;</DIV>
<DIV Class="paranum">30/2</DIV>
<UL Class="Bulleted" Style="margin-bottom: 0.3em"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10051.TXT">AI95-00051-02</A></I>} 
An implementation should support <SPAN class="insert2">an Alignment clause 
for a discrete type, fixed point type, record type, or array type, specifying 
an Alignment value that is zero or a power of two</SPAN><SPAN class="delete2">&nbsp;specified 
Alignments that are factors and multiples of the number of storage elements 
per word</SPAN>, subject to the following:</LI></UL>
<DIV Class="paranum">31/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10051.TXT">AI95-00051-02</A></I>} 
An implementation need not support <SPAN class="insert2">an Alignment 
clause for a signed integer type specifying an Alignment greater than 
the largest Alignment value that is ever chosen by default by the implementation 
for any signed integer type. A corresponding limitation may be imposed 
for modular integer types, fixed point types, enumeration types, record 
types, and array types</SPAN><SPAN class="delete2">&nbsp;specified Alignments 
for combinations of Sizes and Alignments that cannot be easily loaded 
and stored by available machine instructions</SPAN>.</LI></UL>
<DIV Class="paranum">32/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10051.TXT">AI95-00051-02</A></I>} 
An implementation need not support <SPAN class="insert2">a nonconfirming 
Alignment clause which could enable the creation of an object of an elementary 
type which cannot be easily loaded and stored by available machine instructions.</SPAN><SPAN class="delete2">&nbsp;specified 
Alignments that are greater than the maximum Alignment the implementation 
ever returns by default.</SPAN></LI></UL>
<DIV Class="paranum">32.1/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10291.TXT">AI95-00291-02</A></I>} 
<SPAN class="insert2">An implementation need not support an Alignment 
specified for a derived tagged type which is not a multiple of the Alignment 
of the parent type. An implementation need not support a nonconfirming 
Alignment specified for a derived untagged by-reference type.</SPAN> 
</LI></UL>
<DIV Class="paranum">32.a/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Ramification:&nbsp;</B></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10291.TXT">AI95-00291-02</A></I>} 
<SPAN class="insert2">There is no recommendation to support any nonconfirming 
Alignment clauses for types not mentioned above. Remember that <A HREF="AA-13-1.html">13.1</A> 
requires support for confirming Alignment clauses for all types.</SPAN> 
</DIV>
<DIV Class="paranum">33</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em"><SPAN STYLE="font-size: 80%">{<I>recommended 
level of support (Alignment attribute for objects)</I> [partial]}</SPAN> 
<A NAME="I4992"></A>The recommended level of support for the Alignment 
attribute for objects is:&nbsp;</DIV>
<DIV Class="paranum">34/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN STYLE="font-size: 80%"><I>This 
paragraph was deleted.</I></SPAN><SPAN class="delete2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10291.TXT">AI95-00291-02</A></I>} 
<SPAN class="delete2">Same as above, for subtypes, but in addition:</SPAN></LI></UL>
<DIV Class="paranum">35</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>For stand-alone library-level objects 
of statically constrained subtypes, the implementation should support 
all Alignments supported by the target linker. For example, page alignment 
is likely to be supported for such objects, but not for subtypes.</LI></UL>
<DIV Class="paranum">35.1/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10291.TXT">AI95-00291-02</A></I>} 
<SPAN class="insert2">For other objects, an implementation should at 
least support the alignments supported for their subtype, subject to 
the following:</SPAN></LI></UL>
<DIV Class="paranum">35.2/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10291.TXT">AI95-00291-02</A></I>} 
<SPAN class="insert2">An implementation need not support Alignments specified 
for objects of a by-reference type or for objects of types containing 
aliased subcomponents if the specified Alignment is not a multiple of 
the Alignment of the subtype of the object.</SPAN>&nbsp;</LI></UL>
<DIV Class="paranum">35.a/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Implementation Advice: 
</B></SPAN><SPAN class="insert2">The recommended level of support for 
the Alignment attribute should be followed.</SPAN></DIV>
<DIV Class="NotesHeader">NOTES</DIV>
<DIV Class="paranum">36</DIV>
<DIV Class="Notes">3&nbsp;&nbsp;Alignment is a subtype-specific attribute.</DIV>
<DIV Class="paranum">37/2</DIV>
<DIV Class="Notes"><SPAN STYLE="font-size: 80%"><I>This paragraph was 
deleted.</I></SPAN><SPAN class="delete2">4&nbsp;&nbsp;</SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00247.TXT">AI95-00247-01</A></I>} 
<SPAN class="delete2">The Alignment of a composite object is always equal 
to the least common multiple of the Alignments of its components, or 
a multiple thereof.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">37.a/2</DIV>
<DIV Class="Annotations"><SPAN STYLE="font-size: 80%"><I>This paragraph 
was deleted.</I></SPAN><SPAN class="delete2"><B>Discussion:&nbsp;</B>For default 
Alignments, this follows from the semantics of Alignment. For specified 
Alignments, it follows from a Legality Rule stated above.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">38</DIV>
<DIV Class="Notes">5&nbsp;&nbsp;A <SPAN Class="swiss"><A HREF="AA-13-5-1.html#S0290">component_clause</A></SPAN>, 
Component_Size clause, or a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Pack can override a specified Alignment.&nbsp;</DIV>
<DIV Class="paranum">38.a</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>Most objects are allocated 
by the implementation; for these, the implementation obeys the Alignment. 
The implementation is of course allowed to make an object <I>more</I> 
aligned than its Alignment requires &mdash; an object whose Alignment 
is 4 might just happen to land at an address that's a multiple of 4096. 
For formal parameters, the implementation might want to force an Alignment 
stricter than the parameter's subtype. For example, on some systems, 
it is customary to always align parameters to 4 storage elements.</DIV>
<DIV Class="paranum">38.b</DIV>
<DIV Class="Annotations">Hence, one might initially assume that the implementation 
could evilly make all Alignments 1 by default, even though integers, 
say, are normally aligned on a 4-storage-element boundary. However, the 
implementation cannot get away with that &mdash; if the Alignment is 
1, the generated code cannot assume an Alignment of 4, at least not for 
objects allocated outside the control of the implementation.</DIV>
<DIV Class="paranum">38.c</DIV>
<DIV Class="Annotations">Of course implementations can assume anything 
they can prove, but typically an implementation will be unable to prove 
much about the alignment of, say, an imported object. Furthermore, the 
information about where an address &ldquo;came from&rdquo; can be lost 
to the compiler due to separate compilation.</DIV>
<DIV Class="paranum">38.d/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00114.TXT">AI95-00114-01</A></I>} 
The Alignment of an object that is a component of a packed composite 
object will usually be 0, to indicate that the component is not necessarily 
aligned on a storage element boundary. For a subtype, an Alignment of 
0 means that objects of the subtype are not normally aligned on a storage 
element boundary at all. For example, an implementation might choose 
to make Component_Size be <SPAN class="insert2">1</SPAN><SPAN class="delete2">&nbsp;0</SPAN> 
for an array of Booleans, even when <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Pack has not been specified for the array. In this case, Boolean'Alignment 
would be 0. (In the presence of tasking, this would in general be feasible 
only on a machine that had atomic test-bit and set-bit instructions.)</DIV>
<DIV Class="paranum">38.e</DIV>
<DIV Class="Annotations">If the machine has no particular natural alignments, 
then all subtype Alignments will probably be 1 by default.</DIV>
<DIV Class="paranum">38.f</DIV>
<DIV Class="Annotations">Specifying an Alignment of 0 in an <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN> 
does not require the implementation to do anything (except return 0 when 
the Alignment is queried). However, it might be taken as advice on some 
implementations.</DIV>
<DIV Class="paranum">38.g</DIV>
<DIV Class="Annotations">It is an error for an Address clause to disobey 
the object's Alignment. The error cannot be detected at compile time, 
in general, because the Address is not necessarily known at compile time 
(and is almost certainly not static). We do not require a run-time check, 
since efficiency seems paramount here, and Address clauses are treading 
on thin ice anyway. Hence, this misuse of Address clauses is just like 
any other misuse of Address clauses &mdash; it's erroneous.</DIV>
<DIV Class="paranum">38.h</DIV>
<DIV Class="Annotations">A type extension can have a stricter Alignment 
than its parent. This can happen, for example, if the Alignment of the 
parent is 4, but the extension contains a component with Alignment 8. 
The Alignment of a class-wide type or object will have to be the maximum 
possible Alignment of any extension.</DIV>
<DIV Class="paranum">38.i</DIV>
<DIV Class="Annotations">The recommended level of support for the Alignment 
attribute is intended to reflect a minimum useful set of capabilities. 
An implementation can assume that all Alignments are multiples of each 
other &mdash; 1, 2, 4, and 8 might be the only supported Alignments for 
subtypes. An Alignment of 3 or 6 is unlikely to be useful. For objects 
that can be allocated statically, we recommend that the implementation 
support larger alignments, such as 4096. We do not recommend such large 
alignments for subtypes, because the maximum subtype alignment will also 
have to be used as the alignment of stack frames, heap objects, and class-wide 
objects. Similarly, we do not recommend such large alignments for stack-allocated 
objects.</DIV>
<DIV Class="paranum">38.j</DIV>
<DIV Class="Annotations">If the maximum default Alignment is 8 (say, 
Long_Float'Alignment = 8), then the implementation can refuse to accept 
stricter alignments for subtypes. This simplifies the generated code, 
since the compiler can align the stack and class-wide types to this maximum 
without a substantial waste of space (or time).</DIV>
<DIV Class="paranum">38.k</DIV>
<DIV Class="Annotations">Note that the recommended level of support takes 
into account interactions between Size and Alignment. For example, on 
a 32-bit machine with 8-bit storage elements, where load and store instructions 
have to be aligned according to the size of the thing being loaded or 
stored, the implementation might accept an Alignment of 1 if the Size 
is 8, but might reject an Alignment of 1 if the Size is 32. On a machine 
where unaligned loads and stores are merely inefficient (as opposed to 
causing hardware traps), we would expect an Alignment of 1 to be supported 
for any Size.&nbsp;</DIV>

<H4 Class="centered">Wording Changes from Ada 83</H4>
<DIV Class="paranum">38.l</DIV>
<DIV Class="Annotations">The nonnegative part is missing from RM83 (for 
<SPAN Class="swiss"><A HREF="AA-J-8.html#S0299">mod_clause</A></SPAN>s, 
nee <SPAN Class="swiss">alignment_clause</SPAN>s, which are an obsolete 
version of Alignment clauses).&nbsp;</DIV>

<H4 Class="centered">Static Semantics</H4>
<DIV Class="paranum">39/1</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;For a <SPAN class="insert1"><SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN></SPAN><SPAN class="delete1">&nbsp;prefix</SPAN> 
X that denotes an object:&nbsp;</DIV>
<DIV Class="paranum">40</DIV>
<DIV Class="Hanging-Term">X'Size</DIV><DIV Class="Hanging-Body">
<A NAME="I4993"></A><A NAME="I4994"></A>Denotes the size in bits of the 
representation of the object. The value of this attribute is of the type 
<I>universal_integer</I>.&nbsp;</DIV>
<DIV Class="paranum">40.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>Note that Size is in bits 
even if Machine_Radix is 10. Each decimal digit (and the sign) is presumably 
represented as some number of bits.&nbsp;</DIV>
<DIV Class="paranum">41</DIV>
<DIV Class="Hanging-Body"><SPAN STYLE="font-size: 80%">{<I>specifiable 
(of Size for stand-alone objects)</I> [partial]}</SPAN> <A NAME="I4995"></A><SPAN STYLE="font-size: 80%">{<I>Size 
clause</I>}</SPAN> <A NAME="I4996"></A>Size may be specified for [stand-alone] 
objects via an <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN>; 
the expression of such a clause shall be static and its value nonnegative. 
</DIV>

<H4 Class="centered">Implementation Advice</H4>
<DIV Class="paranum">41.1/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10051.TXT">AI95-00051-02</A></I>} 
<SPAN class="insert2">The size of an array object should not include 
its bounds.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">41.a.1/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Implementation Advice: 
</B></SPAN><SPAN class="insert2">The Size of an array object should not 
include its bounds.</SPAN></DIV>
<DIV Class="paranum">42/2</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10051.TXT">AI95-00051-02</A></I>} 
<SPAN class="delete2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10291.TXT">AI95-00291-02</A></I>} 
<SPAN class="delete2"></SPAN><SPAN STYLE="font-size: 80%">{<I>recommended 
level of support (Size attribute)</I> [partial]}</SPAN> <A NAME="I4997"></A>The 
recommended level of support for the Size attribute of objects is<SPAN class="insert2">&nbsp;the same as for subtypes (see below), except that only a confirming Size 
clause need be supported for an aliased elementary object.</SPAN><SPAN class="delete2">:</SPAN> 
</DIV>
<DIV Class="paranum">43/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN STYLE="font-size: 80%"><I>This 
paragraph was deleted.</I></SPAN><SPAN class="delete2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10051.TXT">AI95-00051-02</A></I>} 
<SPAN class="delete2">A Size clause should be supported for an object 
if the specified Size is at least as large as its subtype's Size, and 
corresponds to a size in storage elements that is a multiple of the object's 
Alignment (if the Alignment is nonzero).</SPAN>&nbsp;</LI></UL>

<H4 Class="centered">Static Semantics</H4>
<DIV Class="paranum">44</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">For every subtype S: 
</DIV>
<DIV Class="paranum">45</DIV>
<DIV Class="Hanging-Term" Style="margin-bottom: 0.4em">S'Size</DIV><DIV Class="Hanging-Body">
<A NAME="I4998"></A><A NAME="I4999"></A>If S is definite, denotes the 
size [(in bits)] that the implementation would choose for the following 
objects of subtype S:&nbsp;</DIV>
<DIV Class="paranum">46</DIV>
<UL Class="IndentedBulleted"><LI TYPE=DISC>A record component of subtype 
S when the record type is packed.</LI></UL>
<DIV Class="paranum">47</DIV>
<UL Class="IndentedBulleted"><LI TYPE=DISC>The formal parameter of an 
instance of Unchecked_Conversion that converts from subtype S to some 
other subtype.&nbsp;</LI></UL>
<DIV Class="paranum">48</DIV>
<DIV Class="Hanging-Body">If S is indefinite, the meaning is implementation 
defined. The value of this attribute is of the type <I>universal_integer</I>. 
<SPAN STYLE="font-size: 80%">{<I>specifiable (of Size for first subtypes)</I> 
[partial]}</SPAN> <A NAME="I5000"></A><SPAN STYLE="font-size: 80%">{<I>Size 
clause</I>}</SPAN> <A NAME="I5001"></A>The Size of an object is at least 
as large as that of its subtype, unless the object's Size is determined 
by a Size clause, a component_clause, or a Component_Size clause. Size 
may be specified for first subtypes via an <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN>; 
the expression of such a clause shall be static and its value nonnegative. 
</DIV>
<DIV Class="paranum">48.a</DIV>
<DIV Class="Annotations"><B>Implementation defined:&nbsp;</B>The meaning of 
Size for indefinite subtypes.</DIV>
<DIV Class="paranum">48.b</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><B>Reason:&nbsp;</B>The 
effects of specifying the Size of a subtype are:&nbsp;</DIV>
<DIV Class="paranum">48.c</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>Unchecked_Conversion works in 
a predictable manner.</LI></UL>
<DIV Class="paranum">48.d</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>A composite type cannot be packed 
so tightly as to override the specified Size of a component's subtype.</LI></UL>
<DIV Class="paranum">48.e</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>Assuming the Implementation Advice 
is obeyed, if the specified Size allows independent addressability, then 
the Size of certain objects of the subtype should be equal to the subtype's 
Size. This applies to stand-alone objects and to components (unless a 
<SPAN Class="swiss"><A HREF="AA-13-5-1.html#S0290">component_clause</A></SPAN> 
or a Component_Size clause applies).&nbsp;</LI></UL>
<DIV Class="paranum">48.f</DIV>
<DIV Class="Annotations">A <SPAN Class="swiss"><A HREF="AA-13-5-1.html#S0290">component_clause</A></SPAN> 
or a Component_Size clause can cause an object to be smaller than its 
subtype's specified size. A <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Pack cannot; if a component subtype's size is specified, this limits 
how tightly the composite object can be packed.</DIV>
<DIV Class="paranum">48.g</DIV>
<DIV Class="Annotations">The Size of a class-wide (tagged) subtype is 
unspecified, because it's not clear what it should mean; it should certainly 
not depend on all of the descendants that happen to exist in a given 
program. Note that this cannot be detected at compile time, because in 
a generic unit, it is not necessarily known whether a given subtype is 
class-wide. It might raise an exception on some implementations.&nbsp;</DIV>
<DIV Class="paranum">48.h</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><B>Ramification: 
</B>A Size clause for a numeric subtype need not affect the underlying 
numeric type. For example, if I say:&nbsp;</DIV>
<DIV Class="paranum">48.i</DIV>
<DIV Class="SmallExamples"><B>type</B>&nbsp;S&nbsp;<B>is</B>&nbsp;<B>range</B>&nbsp;1..2;<BR>
<B>for</B>&nbsp;S'Size&nbsp;<B>use</B>&nbsp;64;<BR>
&nbsp;&nbsp;</DIV>
<DIV Class="paranum">48.j</DIV>
<DIV Class="Annotations">I am not guaranteed that S'Base'Last &gt;= 2**63&ndash;1, 
nor that intermediate results will be represented in 64 bits.&nbsp;</DIV>
<DIV Class="paranum">48.k</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>There is no need to complicate 
implementations for this sort of thing, because the right way to affect 
the base range of a type is to use the normal way of declaring the base 
range:&nbsp;</DIV>
<DIV Class="paranum">48.l</DIV>
<DIV Class="SmallExamples"><B>type</B>&nbsp;Big&nbsp;<B>is</B>&nbsp;<B>range</B>&nbsp;-2**63&nbsp;..&nbsp;2**63&nbsp;-&nbsp;1;<BR>
<B>subtype</B>&nbsp;Small&nbsp;<B>is</B>&nbsp;Big&nbsp;<B>range</B>&nbsp;1..1000;<BR>
&nbsp;&nbsp;</DIV>
<DIV Class="paranum">48.m</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>The Size of a large unconstrained 
subtype (e.g. String'Size) is likely to raise Constraint_Error, since 
it is a nonstatic expression of type <I>universal_integer</I> that might 
overflow the largest signed integer type. There is no requirement that 
the largest integer type be able to represent the size in bits of the 
largest possible object.&nbsp;</DIV>

<H4 Class="centered">Implementation Requirements</H4>
<DIV Class="paranum">49</DIV>
<DIV Class="Normal">In an implementation, Boolean'Size shall be 1.&nbsp;</DIV>

<H4 Class="centered">Implementation Advice</H4>
<DIV Class="paranum">50/2</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10051.TXT">AI95-00051-02</A></I>} 
If the Size of a subtype <SPAN class="delete2">is specified, and&nbsp;</SPAN>allows 
for efficient independent addressability (see <A HREF="AA-9-10.html">9.10</A>) 
on the target architecture, then the Size of the following objects of 
the subtype should equal the Size of the subtype:&nbsp;</DIV>
<DIV Class="paranum">51</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>Aliased objects (including components).</LI></UL>
<DIV Class="paranum">52</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>Unaliased components, unless the Size 
of the component is determined by a <SPAN Class="swiss"><A HREF="AA-13-5-1.html#S0290">component_clause</A></SPAN> 
or Component_Size clause.&nbsp;</LI></UL>
<DIV Class="paranum">52.a.1/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Implementation Advice: 
</B></SPAN><SPAN class="insert2">If the Size of a subtype allows for 
efficient independent addressability, then the Size of most objects of 
the subtype should equal the Size of the subtype.</SPAN></DIV>
<DIV Class="paranum">52.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>Thus, on a typical 32-bit 
machine, &ldquo;<B>for</B> S'Size <B>use</B> 32;&rdquo; will guarantee 
that aliased objects of subtype S, and components whose subtype is S, 
will have Size = 32 (assuming the implementation chooses to obey this 
Implementation Advice). On the other hand, if one writes, &ldquo;<B>for</B> 
S2'Size <B>use</B> 5;&rdquo; then stand-alone objects of subtype S2 will 
typically have their Size rounded up to ensure independent addressability.</DIV>
<DIV Class="paranum">52.b</DIV>
<DIV Class="Annotations">Note that &ldquo;<B>for</B> S'Size <B>use</B> 
32;&rdquo; does not cause things like formal parameters to have Size 
= 32 &mdash; the implementation is allowed to make all parameters be 
at least 64 bits, for example.</DIV>
<DIV Class="paranum">52.c</DIV>
<DIV Class="Annotations">Note that &ldquo;<B>for</B> S2'Size <B>use</B> 
5;&rdquo; requires record components whose subtype is S2 to be exactly 
5 bits if the record type is packed. The same is not true of array components; 
their Size may be rounded up to the nearest factor of the word size. 
</DIV>
<DIV Class="paranum">52.d/2</DIV>
<DIV Class="Annotations"><B>Implementation Note:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10291.TXT">AI95-00291-02</A></I>} 
{<I>gaps</I>} <A NAME="I5002"></A>On most machines, arrays don't contain 
gaps between <SPAN class="insert2">elementary&nbsp;</SPAN>components; if the 
Component_Size is greater than the Size of the component subtype, the 
extra bits are generally considered part of each component, rather than 
gaps between components. On the other hand, a record might contain gaps 
between <SPAN class="insert2">elementary&nbsp;</SPAN>components, depending 
on what sorts of loads, stores, and masking operations are generally 
done by the generated code.</DIV>
<DIV Class="paranum">52.e/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10291.TXT">AI95-00291-02</A></I>} 
For an array, any extra bits stored for each <SPAN class="insert2">elementary 
</SPAN>component will generally be part of the component &mdash; the 
whole point of storing extra bits is to make loads and stores more efficient 
by avoiding the need to mask out extra bits. The PDP-10 is one counter-example; 
since the hardware supports byte strings with a gap at the end of each 
word, one would want to pack in that manner.&nbsp;</DIV>
<DIV Class="paranum">53</DIV>
<DIV Class="Normal">A Size clause on a composite subtype should not affect 
the internal layout of components.&nbsp;</DIV>
<DIV Class="paranum">53.a.1/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Implementation Advice: 
</B></SPAN><SPAN class="insert2">A Size clause on a composite subtype 
should not affect the internal layout of components.</SPAN></DIV>
<DIV Class="paranum">53.a</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>That's what Pack <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN>s, 
<SPAN Class="swiss"><A HREF="AA-13-5-1.html#S0289">record_representation_clause</A></SPAN>s, 
and Component_Size clauses are for.&nbsp;</DIV>
<DIV Class="paranum">54</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em"><SPAN STYLE="font-size: 80%">{<I>recommended 
level of support (Size attribute)</I> [partial]}</SPAN> <A NAME="I5003"></A>The 
recommended level of support for the Size attribute of subtypes is:&nbsp;</DIV>
<DIV Class="paranum">55</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>The Size (if not specified) of a static 
discrete or fixed point subtype should be the number of bits needed to 
represent each value belonging to the subtype using an unbiased representation, 
leaving space for a sign bit only if the subtype contains negative values. 
If such a subtype is a first subtype, then an implementation should support 
a specified Size for it that reflects this representation.</LI></UL>
<DIV Class="paranum">55.a</DIV>
<DIV Class="Annotations"><B>Implementation Note:&nbsp;</B>This applies to 
static enumeration subtypes, using the internal codes used to represent 
the values.</DIV>
<DIV Class="paranum">55.b</DIV>
<DIV Class="Annotations">For a two's-complement machine, this implies 
that for a static signed integer subtype S, if all values of S are in 
the range 0 .. 2<SUP><SPAN STYLE="font-size: 140%"><SPAN STYLE="font-size: 64%"><I>n</I></SPAN></SPAN></SUP>&ndash;1, 
or all values of S are in the range &ndash;2<SUP><SPAN STYLE="font-size: 140%"><SPAN STYLE="font-size: 64%"><I>n&ndash;1</I></SPAN></SPAN></SUP> 
.. 2<SUP><SPAN STYLE="font-size: 140%"><SPAN STYLE="font-size: 64%"><I>n&ndash;1</I></SPAN></SPAN></SUP>&ndash;1, 
for some <I>n</I> less than or equal to the word size, then S'Size should 
be &lt;= the smallest such <I>n</I>. For a one's-complement machine, 
it is the same except that in the second range, the lower bound &ldquo;&ndash;2<SUP><SPAN STYLE="font-size: 140%"><SPAN STYLE="font-size: 64%"><I>n&ndash;1</I></SPAN></SPAN></SUP>&rdquo; 
is replaced by &ldquo;&ndash;2<SUP><SPAN STYLE="font-size: 140%"><SPAN STYLE="font-size: 64%"><I>n&ndash;1</I></SPAN></SPAN></SUP>+1&rdquo;.</DIV>
<DIV Class="paranum">55.c</DIV>
<DIV Class="Annotations">If an integer subtype (whether signed or unsigned) 
contains no negative values, the Size should not include space for a 
sign bit.</DIV>
<DIV Class="paranum">55.d</DIV>
<DIV Class="Annotations">Typically, the implementation will choose to 
make the Size of a subtype be exactly the smallest such <I>n</I>. However, 
it might, for example, choose a biased representation, in which case 
it could choose a smaller value.</DIV>
<DIV Class="paranum">55.e</DIV>
<DIV Class="Annotations">On most machines, it is in general not a good 
idea to pack (parts of) multiple stand-alone objects into the same storage 
element, because (1) it usually doesn't save much space, and (2) it requires 
locking to prevent tasks from interfering with each other, since separate 
stand-alone objects are independently addressable. Therefore, if S'Size 
= 2 on a machine with 8-bit storage elements, the size of a stand-alone 
object of subtype S will probably not be 2. It might, for example, be 
8, 16 or 32, depending on the availability and efficiency of various 
machine instructions. The same applies to components of composite types, 
unless packing, Component_Size, or record layout is specified.</DIV>
<DIV Class="paranum">55.f</DIV>
<DIV Class="Annotations">For an unconstrained discriminated object, if 
the implementation allocates the maximum possible size, then the Size 
attribute should return that maximum possible size.&nbsp;</DIV>
<DIV Class="paranum">55.g</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>The Size of an object X 
is not usually the same as that of its subtype S. If X is a stand-alone 
object or a parameter, for example, most implementations will round X'Size 
up to a storage element boundary, or more, so X'Size might be greater 
than S'Size. On the other hand, X'Size cannot be less than S'Size, even 
if the implementation can prove, for example, that the range of values 
actually taken on by X during execution is smaller than the range of 
S.</DIV>
<DIV Class="paranum">55.h</DIV>
<DIV Class="Annotations">For example, if S is a first integer subtype 
whose range is 0..3, S'Size will be probably be 2 bits, and components 
of packed composite types of this subtype will be 2 bits (assuming Storage_Unit 
is a multiple of 2), but stand-alone objects and parameters will probably 
not have a size of 2 bits; they might be rounded up to 32 bits, for example. 
On the other hand, Unchecked_Conversion will use the 2-bit size, even 
when converting a stand-alone object, as one would expect.</DIV>
<DIV Class="paranum">55.i</DIV>
<DIV Class="Annotations">Another reason for making the Size of an object 
bigger than its subtype's Size is to support the run-time detection of 
uninitialized variables. {<I>uninitialized variables</I> [partial]} <A NAME="I5004"></A>The 
implementation might add an extra value to a discrete subtype that represents 
the uninitialized state, and check for this value on use. In some cases, 
the extra value will require an extra bit in the representation of the 
object. Such detection is not required by the language. If it is provided, 
the implementation has to be able to turn it off. For example, if the 
programmer gives a <SPAN Class="swiss"><A HREF="AA-13-5-1.html#S0289">record_representation_clause</A></SPAN> 
or Component_Size clause that makes a component too small to allow the 
extra bit, then the implementation will not be able to perform the checking 
(not using this method, anyway).</DIV>
<DIV Class="paranum">55.j</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em">The fact that 
the size of an object is not necessarily the same as its subtype can 
be confusing:&nbsp;</DIV>
<DIV Class="paranum">55.k</DIV>
<DIV Class="SmallExamples"><B>type</B>&nbsp;Device_Register&nbsp;<B>is</B>&nbsp;<B>range</B>&nbsp;0..2**8&nbsp;-&nbsp;1;<BR>
<B>for</B>&nbsp;Device_Register'Size&nbsp;<B>use</B>&nbsp;8;&nbsp;--<SPAN Class="roman"><I>&nbsp;Confusing!</I></SPAN><BR>
My_Device&nbsp;:&nbsp;Device_Register;<BR>
<B>for</B>&nbsp;My_Device'Address&nbsp;<B>use</B>&nbsp;To_Address(16#FF00#);<BR>
&nbsp;&nbsp;</DIV>
<DIV Class="paranum">55.l</DIV>
<DIV Class="Annotations">The programmer might think that My_Device'Size 
is 8, and that My_Device'Address points at an 8-bit location. However, 
this is not true. In Ada 83 (and in Ada 95), My_Device'Size might well 
be 32, and My_Device'Address might well point at the high-order 8 bits 
of the 32-bit object, which are always all zero bits. If My_Device'Address 
is passed to an assembly language subprogram, based on the programmer's 
assumption, the program will not work properly.&nbsp;</DIV>
<DIV Class="paranum">55.m</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>It is not reasonable to require 
that an implementation allocate exactly 8 bits to all objects of subtype 
Device_Register. For example, in many run-time models, stand-alone objects 
and parameters are always aligned to a word boundary. Such run-time models 
are generally based on hardware considerations that are beyond the control 
of the implementer. (It is reasonable to require that an implementation 
allocate exactly 8 bits to all components of subtype Device_Register, 
if packed.)&nbsp;</DIV>
<DIV Class="paranum">55.n</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><B>Ramification: 
</B>The correct way to write the above code is like this:&nbsp;</DIV>
<DIV Class="paranum">55.o</DIV>
<DIV Class="SmallExamples"><B>type</B>&nbsp;Device_Register&nbsp;<B>is</B>&nbsp;<B>range</B>&nbsp;0..2**8&nbsp;-&nbsp;1;<BR>
My_Device&nbsp;:&nbsp;Device_Register;<BR>
<B>for</B>&nbsp;My_Device'Size&nbsp;<B>use</B>&nbsp;8;<BR>
<B>for</B>&nbsp;My_Device'Address&nbsp;<B>use</B>&nbsp;To_Address(16#FF00#);<BR>
&nbsp;&nbsp;</DIV>
<DIV Class="paranum">55.p</DIV>
<DIV Class="Annotations">If the implementation cannot accept 8-bit stand-alone 
objects, then this will be illegal. However, on a machine where an 8-bit 
device register exists, the implementation will probably be able to accept 
8-bit stand-alone objects. Therefore, My_Device'Size will be 8, and My_Device'Address 
will point at those 8 bits, as desired.</DIV>
<DIV Class="paranum">55.q</DIV>
<DIV Class="Annotations">If an object of subtype Device_Register is passed 
to a foreign language subprogram, it will be passed according to that 
subprogram's conventions. Most foreign language implementations have 
similar run-time model restrictions. For example, when passing to a C 
function, where the argument is of the C type char* (that is, pointer 
to char), the C compiler will generally expect a full word value, either 
on the stack, or in a register. It will <I>not</I> expect a single byte. 
Thus, Size clauses for subtypes really have nothing to do with passing 
parameters to foreign language subprograms.&nbsp;</DIV>
<DIV Class="paranum">56</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>For a subtype implemented with levels 
of indirection, the Size should include the size of the pointers, but 
not the size of what they point at.&nbsp;</LI></UL>
<DIV Class="paranum">56.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>For example, if a task 
object is represented as a pointer to some information (including a task 
stack), then the size of the object should be the size of the pointer. 
The Storage_Size, on the other hand, should include the size of the stack. 
</DIV>
<DIV Class="paranum">56.1/2</DIV>
<UL Class="Bulleted" Style="margin-bottom: 0.3em"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10051.TXT">AI95-00051-02</A></I>} 
<SPAN class="insert2">An implementation should support a Size clause 
for a discrete type, fixed point type, record type, or array type, subject 
to the following:</SPAN>&nbsp;</LI></UL>
<DIV Class="paranum">56.2/2</DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10051.TXT">AI95-00051-02</A></I>} 
<SPAN class="insert2">An implementation need not support a Size clause 
for a signed integer type specifying a Size greater than that of the 
largest signed integer type supported by the implementation in the absence 
of a size clause (that is, when the size is chosen by default). A corresponding 
limitation may be imposed for modular integer types, fixed point types, 
enumeration types, record types, and array types.</SPAN></LI></UL>
<DIV Class="paranum">56.b/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Discussion:&nbsp;</B></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10051.TXT">AI95-00051-02</A></I>} 
<SPAN class="insert2">Note that the &ldquo;corresponding limitation&rdquo; 
for a record or array type implies that an implementation may impose 
some reasonable maximum size for records and arrays (e.g. 2**32 bits), 
which is an upper bound (&ldquo;capacity&rdquo; limit) on the size, whether 
chosen by default or by being specified by the user. The largest size 
supported for records need not be the same as the largest size supported 
for arrays.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">56.3/2</DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10291.TXT">AI95-00291-02</A></I>} 
<SPAN class="insert2">A nonconfirming size clause for the first subtype 
of a derived untagged by-reference type need not be supported.</SPAN> 
</LI></UL>
<DIV Class="paranum">56.c/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Implementation Advice: 
</B></SPAN><SPAN class="insert2">The recommended level of support for 
the Size attribute should be followed.</SPAN></DIV>
<DIV Class="paranum">56.d/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Ramification:&nbsp;</B></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10291.TXT">AI95-00291-02</A></I>} 
<SPAN class="insert2">There is no recommendation to support any nonconfirming 
Size clauses for types not mentioned above. Remember that <A HREF="AA-13-1.html">13.1</A> 
requires support for confirming Size clauses for all types.</SPAN>&nbsp;</DIV>
<DIV Class="NotesHeader">NOTES</DIV>
<DIV Class="paranum">57</DIV>
<DIV Class="Notes">6&nbsp;&nbsp;Size is a subtype-specific attribute.</DIV>
<DIV Class="paranum">58</DIV>
<DIV Class="Notes">7&nbsp;&nbsp;A <SPAN Class="swiss"><A HREF="AA-13-5-1.html#S0290">component_clause</A></SPAN> 
or Component_Size clause can override a specified Size. A <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Pack cannot.&nbsp;</DIV>

<H4 Class="centered">Inconsistencies With Ada 83</H4>
<DIV Class="paranum">58.a.1/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00114.TXT">AI95-00114-01</A></I>} 
<SPAN class="insert2">We specify the meaning of Size in much more detail 
than Ada 83. This is not technically an inconsistency, but it is in practice, 
as most Ada 83 compilers use a different definition for Size than is 
required here. This should have been documented more explicitly during 
the Ada 9X process.</SPAN>&nbsp;</DIV>

<H4 Class="centered">Wording Changes from Ada 83</H4>
<DIV Class="paranum">58.a</DIV>
<DIV Class="Annotations">The requirement for a nonnegative value in a 
Size clause was not in RM83, but it's hard to see how it would make sense. 
For uniformity, we forbid negative sizes, rather than letting implementations 
define their meaning.&nbsp;</DIV>

<H4 Class="centered">Static Semantics</H4>
<DIV Class="paranum">59/1</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;For a <SPAN class="insert1"><SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN></SPAN><SPAN class="delete1">&nbsp;prefix</SPAN> 
T that denotes a task object [(after any implicit dereference)]:&nbsp;</DIV>
<DIV Class="paranum">60</DIV>
<DIV Class="Hanging-Term">T'Storage_Size</DIV><DIV Class="Hanging-Body"><BR clear="left">
<A NAME="I5005"></A><A NAME="I5006"></A>Denotes the number of storage 
elements reserved for the task. The value of this attribute is of the 
type <I>universal_integer</I>. The Storage_Size includes the size of 
the task's stack, if any. The language does not specify whether or not 
it includes other storage associated with the task (such as the &ldquo;task 
control block&rdquo; used by some implementations.) If a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Storage_Size is given, the value of the Storage_Size attribute is at 
least the value specified in the <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN>. 
</DIV>
<DIV Class="paranum">60.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>The value of this attribute 
is never negative, since it is impossible to &ldquo;reserve&rdquo; a 
negative number of storage elements.</DIV>
<DIV Class="paranum">60.b</DIV>
<DIV Class="Annotations">If the implementation chooses to allocate an 
initial amount of storage, and then increase this as needed, the Storage_Size 
cannot include the additional amounts (assuming the allocation of the 
additional amounts can raise Storage_Error); this is inherent in the 
meaning of &ldquo;reserved.&rdquo;</DIV>
<DIV Class="paranum">60.c</DIV>
<DIV Class="Annotations">The implementation is allowed to allocate different 
amounts of storage for different tasks of the same subtype.</DIV>
<DIV Class="paranum">60.d</DIV>
<DIV Class="Annotations">Storage_Size is also defined for access subtypes 
&mdash; see <A HREF="AA-13-11.html">13.11</A>.&nbsp;</DIV>
<DIV Class="paranum">61</DIV>
<DIV Class="Normal">[<SPAN STYLE="font-size: 80%">{<I>Storage_Size clause: 
See also pragma Storage_Size</I>}</SPAN> <A NAME="I5007"></A>A <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Storage_Size specifies the amount of storage to be reserved for the execution 
of a task.]&nbsp;</DIV>

<H4 Class="centered">Syntax</H4>
<DIV Class="paranum">62</DIV>
<DIV Class="SyntaxIndented" Style="margin-bottom: 0.2em">The form of 
a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> Storage_Size 
is as follows:&nbsp;</DIV>
<DIV Class="paranum">63</DIV>
<DIV Class="SyntaxIndented">&nbsp;&nbsp;<B>pragma</B> <A NAME="I5008"></A><A NAME="I5009"></A>Storage_Size(<A NAME="I5010"></A><SPAN Class="swiss"><A HREF="AA-4-4.html#S0115">expression</A></SPAN>);</DIV>
<DIV Class="paranum">64</DIV>
<DIV Class="SyntaxIndented">A <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Storage_Size is allowed only immediately within a <SPAN Class="swiss"><A HREF="AA-9-1.html#S0190">task_definition</A></SPAN>. 
</DIV>

<H4 Class="centered">Name Resolution Rules</H4>
<DIV Class="paranum">65</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>expected type (Storage_Size 
pragma argument)</I> [partial]}</SPAN> <A NAME="I5011"></A>The <SPAN Class="swiss"><A HREF="AA-4-4.html#S0115">expression</A></SPAN> 
of a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Storage_Size is expected to be of any integer type.&nbsp;</DIV>

<H4 Class="centered">Dynamic Semantics</H4>
<DIV Class="paranum">66</DIV>
<DIV Class="Normal">A <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Storage_Size is elaborated when an object of the type defined by the 
immediately enclosing <SPAN Class="swiss"><A HREF="AA-9-1.html#S0190">task_definition</A></SPAN> 
is created. <SPAN STYLE="font-size: 80%">{<I>elaboration (Storage_Size 
pragma)</I> [partial]}</SPAN> <A NAME="I5012"></A>For the elaboration 
of a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Storage_Size, the <SPAN Class="swiss"><A HREF="AA-4-4.html#S0115">expression</A></SPAN> 
is evaluated; the Storage_Size attribute of the newly created task object 
is at least the value of the <SPAN Class="swiss"><A HREF="AA-4-4.html#S0115">expression</A></SPAN>. 
</DIV>
<DIV Class="paranum">66.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>The implementation is allowed 
to round up a specified Storage_Size amount. For example, if the implementation 
always allocates in chunks of 4096 bytes, the number 200 might be rounded 
up to 4096. Also, if the user specifies a negative number, the implementation 
has to normalize this to 0, or perhaps to a positive number.&nbsp;</DIV>
<DIV Class="paranum">67</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>Storage_Check</I> 
[partial]}</SPAN> <A NAME="I5013"></A><SPAN STYLE="font-size: 80%">{<I>check, 
language-defined (Storage_Check)</I>}</SPAN> <A NAME="I5014"></A><SPAN STYLE="font-size: 80%">{<I>Storage_Error 
(raised by failure of run-time check)</I>}</SPAN> <A NAME="I5015"></A>At 
the point of task object creation, or upon task activation, Storage_Error 
is raised if there is insufficient free storage to accommodate the requested 
Storage_Size.&nbsp;</DIV>

<H4 Class="centered">Static Semantics</H4>
<DIV Class="paranum">68/1</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;For a <SPAN class="insert1"><SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN></SPAN><SPAN class="delete1">&nbsp;prefix</SPAN> 
X that denotes an array subtype or array object [(after any implicit 
dereference)]:&nbsp;</DIV>
<DIV Class="paranum">69</DIV>
<DIV Class="Hanging-Term">X'Component_Size</DIV><DIV Class="Hanging-Body"><BR clear="left">
<A NAME="I5016"></A><A NAME="I5017"></A>Denotes the size in bits of components 
of the type of X. The value of this attribute is of type <I>universal_integer</I>. 
</DIV>
<DIV Class="paranum">70</DIV>
<DIV Class="Hanging-Body"><SPAN STYLE="font-size: 80%">{<I>specifiable 
(of Component_Size for array types)</I> [partial]}</SPAN> <A NAME="I5018"></A><SPAN STYLE="font-size: 80%">{<I>Component_Size 
clause</I>}</SPAN> <A NAME="I5019"></A>Component_Size may be specified 
for array types via an <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN>; 
the expression of such a clause shall be static, and its value nonnegative. 
</DIV>
<DIV Class="paranum">70.a</DIV>
<DIV Class="Annotations"><B>Implementation Note:&nbsp;</B>The intent is that 
the value of X'Component_Size is always nonnegative. If the array is 
stored &ldquo;backwards&rdquo; in memory (which might be caused by an 
implementation-defined pragma), X'Component_Size is still positive.&nbsp;</DIV>
<DIV Class="paranum">70.b</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>For an array object A, 
A'Component_Size = A(I)'Size for any index I.&nbsp;</DIV>

<H4 Class="centered">Implementation Advice</H4>
<DIV Class="paranum">71</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em"><SPAN STYLE="font-size: 80%">{<I>recommended 
level of support (Component_Size attribute)</I> [partial]}</SPAN> <A NAME="I5020"></A>The 
recommended level of support for the Component_Size attribute is:&nbsp;</DIV>
<DIV Class="paranum">72</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>An implementation need not support 
specified Component_Sizes that are less than the Size of the component 
subtype.</LI></UL>
<DIV Class="paranum">73</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>An implementation should support specified 
Component_Sizes that are factors and multiples of the word size. For 
such Component_Sizes, the array should contain no gaps between components. 
For other Component_Sizes (if supported), the array should contain no 
gaps between components when packing is also specified; the implementation 
should forbid this combination in cases where it cannot support a no-gaps 
representation.&nbsp;</LI></UL>
<DIV Class="paranum">73.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>For example, if Storage_Unit 
= 8, and Word_Size = 32, then the user is allowed to specify a Component_Size 
of 1, 2, 4, 8, 16, and 32, with no gaps. In addition, <I>n</I>*32 is 
allowed for positive integers <I>n</I>, again with no gaps. If the implementation 
accepts Component_Size = 3, then it might allocate 10 components per 
word, with a 2-bit gap at the end of each word (unless packing is also 
specified), or it might not have any internal gaps at all. (There can 
be gaps at either end of the array.)&nbsp;</DIV>
<DIV Class="paranum">73.b/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Implementation Advice: 
</B></SPAN><SPAN class="insert2">The recommended level of support for 
the Component_Size attribute should be followed.</SPAN></DIV>

<H4 Class="centered">Static Semantics</H4>
<DIV Class="paranum">73.1/1</DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="defect1.html#8652/0009">8652/0009</A></I>} 
<SPAN class="insert1"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00137.TXT">AI95-00137-01</A></I>} 
<SPAN class="insert1">The following operational attribute is defined: 
External_Tag.</SPAN></DIV>
<DIV Class="paranum">74/1</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;{<I><A HREF="defect1.html#8652/0009">8652/0009</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00137.TXT">AI95-00137-01</A></I>} 
For every subtype S of a tagged type <I>T</I> (specific or class-wide)<SPAN class="delete1">, 
the following attribute is defined</SPAN>:</DIV>
<DIV Class="paranum">75/1</DIV>
<DIV Class="Hanging-Term">&nbsp;S'External_Tag</DIV><DIV Class="Hanging-Body"><BR clear="left">
<A NAME="I5021"></A><A NAME="I5022"></A>{<I><A HREF="defect1.html#8652/0040">8652/0040</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00108.TXT">AI95-00108-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>External_Tag clause</I>}</SPAN> <A NAME="I5023"></A><SPAN STYLE="font-size: 80%">{<I>specifiable 
(of External_Tag for a tagged type)</I> [partial]}</SPAN> <A NAME="I5024"></A>S'External_Tag 
denotes an external string representation for S'Tag; it is of the predefined 
type String. External_Tag may be specified for a specific tagged type 
via an <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN>; 
the expression of such a clause shall be static. The default external 
tag representation is implementation defined. See <A HREF="AA-3-9-2.html">3.9.2</A> 
and <A HREF="AA-13-13-2.html">13.13.2</A>. <SPAN class="insert1">The 
value of External_Tag is never inherited[; the default value is always 
used unless a new value is directly specified for a type].</SPAN>&nbsp;</DIV>
<DIV Class="paranum">75.a</DIV>
<DIV Class="Annotations"><B>Implementation defined:&nbsp;</B>The default external 
representation for a type tag.</DIV>

<H4 Class="centered">Implementation Requirements</H4>
<DIV Class="paranum">76</DIV>
<DIV Class="Normal">In an implementation, the default external tag for 
each specific tagged type declared in a partition shall be distinct, 
so long as the type is declared outside an instance of a generic body. 
If the compilation unit in which a given tagged type is declared, and 
all compilation units on which it semantically depends, are the same 
in two different partitions, then the external tag for the type shall 
be the same in the two partitions. What it means for a compilation unit 
to be the same in two different partitions is implementation defined. 
At a minimum, if the compilation unit is not recompiled between building 
the two different partitions that include it, the compilation unit is 
considered the same in the two partitions.&nbsp;</DIV>
<DIV Class="paranum">76.a</DIV>
<DIV Class="Annotations"><B>Implementation defined:&nbsp;</B>What determines 
whether a compilation unit is the same in two different partitions.</DIV>
<DIV Class="paranum">76.b</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>These requirements are important 
because external tags are used for input/output of class-wide types. 
These requirements ensure that what is written by one program can be 
read back by some other program so long as they share the same declaration 
for the type (and everything it depends on).</DIV>
<DIV Class="paranum">76.c</DIV>
<DIV Class="Annotations">The user may specify the external tag if (s)he 
wishes its value to be stable even across changes to the compilation 
unit in which the type is declared (or changes in some unit on which 
it depends).</DIV>
<DIV Class="paranum">76.d/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00114.TXT">AI95-00114-01</A></I>} 
We use a String rather than a <SPAN class="insert2">Stream_Element_Array</SPAN><SPAN class="delete2">&nbsp;Storage_Array</SPAN> 
to represent an external tag for portability.&nbsp;</DIV>
<DIV Class="paranum">76.e</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>Note that the characters 
of an external tag need not all be graphic characters. In other words, 
the external tag can be a sequence of arbitrary 8-bit bytes.&nbsp;</DIV>
<DIV Class="NotesHeader">NOTES</DIV>
<DIV Class="paranum">77/2</DIV>
<DIV Class="Notes">8&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00270.TXT">AI95-00270-01</A></I>} 
The following language-defined attributes are specifiable, at least for 
some of the kinds of entities to which they apply: Address, <SPAN class="delete2">Size, 
Component_Size,&nbsp;</SPAN>Alignment, <SPAN class="insert2">Bit_Order, Component_Size, 
</SPAN>External_Tag, <SPAN class="insert2">Input, Machine_Radix, Output, 
Read, Size,&nbsp;</SPAN>Small, <SPAN class="delete2">Bit_Order,&nbsp;</SPAN>Storage_Pool, 
Storage_Size, <SPAN class="insert2">Stream_Size, and&nbsp;</SPAN>Write<SPAN class="delete2">, 
Output, Read, Input, and Machine_Radix</SPAN>.</DIV>
<DIV Class="paranum">78</DIV>
<DIV Class="Notes">9&nbsp;&nbsp;It follows from the general rules in 
<A HREF="AA-13-1.html">13.1</A> that if one writes &ldquo;<B>for</B> 
X'Size <B>use</B> Y;&rdquo; then the X'Size <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0100">attribute_reference</A></SPAN> 
will return Y (assuming the implementation allows the Size clause). The 
same is true for all of the specifiable attributes except Storage_Size. 
</DIV>
<DIV Class="paranum">78.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>An implementation may specify 
that an implementation-defined attribute is specifiable for certain entities. 
This follows from the fact that the semantics of implementation-defined 
attributes is implementation defined. An implementation is not allowed 
to make a language-defined attribute specifiable if it isn't.&nbsp;</DIV>

<H4 Class="centered">Examples</H4>
<DIV Class="paranum">79</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em"><I>Examples of attribute 
definition clauses:</I>&nbsp;</DIV>
<DIV Class="paranum">80</DIV>
<DIV Class="Examples">Byte&nbsp;:&nbsp;<B>constant</B>&nbsp;:=&nbsp;8;<BR>
Page&nbsp;:&nbsp;<B>constant</B>&nbsp;:=&nbsp;2**12;</DIV>
<DIV Class="paranum">81</DIV>
<DIV Class="Examples"><B>type</B>&nbsp;Medium&nbsp;<B>is</B>&nbsp;<B>range</B>&nbsp;0&nbsp;..&nbsp;65_000;<BR>
<B>for</B>&nbsp;Medium'Size&nbsp;<B>use</B>&nbsp;2*Byte;<BR>
<B>for</B>&nbsp;Medium'Alignment&nbsp;<B>use</B>&nbsp;2;<BR>
Device_Register&nbsp;:&nbsp;Medium;<BR>
<B>for</B>&nbsp;Device_Register'Size&nbsp;<B>use</B>&nbsp;Medium'Size;<BR>
<B>for</B>&nbsp;Device_Register'Address&nbsp;<B>use</B>&nbsp;System.Storage_Elements.To_Address(16#FFFF_0020#);</DIV>
<DIV Class="paranum">82</DIV>
<DIV Class="Examples"><B>type</B>&nbsp;Short&nbsp;<B>is</B>&nbsp;<B>delta</B>&nbsp;0.01&nbsp;<B>range</B>&nbsp;-100.0&nbsp;..&nbsp;100.0;<BR>
<B>for</B>&nbsp;Short'Size&nbsp;<B>use</B>&nbsp;15;</DIV>
<DIV Class="paranum">83</DIV>
<DIV Class="Examples"><B>for</B>&nbsp;Car_Name'Storage_Size&nbsp;<B>use</B>&nbsp;--<SPAN Class="roman"><I>&nbsp;specify&nbsp;access&nbsp;type's&nbsp;storage&nbsp;pool&nbsp;size</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2000*((Car'Size/System.Storage_Unit)&nbsp;+1);&nbsp;--<SPAN Class="roman"><I>&nbsp;approximately&nbsp;2000&nbsp;cars</I></SPAN></DIV>
<DIV Class="paranum">84/2</DIV>
<DIV Class="Examples">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00441.TXT">AI95-00441-01</A></I>} 
<B>function</B>&nbsp;<SPAN class="insert2">My_Input</SPAN><SPAN class="delete2">&nbsp;My_Read</SPAN>(Stream&nbsp;:&nbsp;<B></B><SPAN class="insert2"><B>not&nbsp;null&nbsp;</B></SPAN><B>access</B>&nbsp;Ada.Streams.Root_Stream_Type'Class)<BR>
&nbsp;&nbsp;<B>return</B>&nbsp;T;<BR>
<B>for</B>&nbsp;T'<SPAN class="insert2">Input</SPAN><SPAN class="delete2">&nbsp;Read</SPAN>&nbsp;<B>use</B>&nbsp;<SPAN class="insert2">My_Input</SPAN><SPAN class="delete2">&nbsp;My_Read</SPAN>;&nbsp;--<SPAN Class="roman"><I>&nbsp;see&nbsp;<A HREF="AA-13-13-2.html">13.13.2</A></I></SPAN></DIV>
<DIV Class="NotesHeader">NOTES</DIV>
<DIV Class="paranum">85</DIV>
<DIV Class="Notes">10&nbsp;&nbsp;<I>Notes on the examples:</I> In the 
Size clause for Short, fifteen bits is the minimum necessary, since the 
type definition requires Short'Small &lt;= 2**(&ndash;7).&nbsp;</DIV>

<H4 Class="centered">Extensions to Ada 83</H4>
<DIV Class="paranum">85.a</DIV>
<DIV Class="Annotations">{<I>extensions to Ada 83</I>} <A NAME="I5025"></A>The 
syntax rule for <SPAN Class="swiss">length_clause</SPAN> is replaced 
with the new syntax rule for <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN>, 
and it is modified to allow a <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
(as well as an expression).&nbsp;</DIV>

<H4 Class="centered">Wording Changes from Ada 83</H4>
<DIV Class="paranum">85.b</DIV>
<DIV Class="Annotations">The syntax rule for <SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN> 
now requires that the prefix of the attribute be a <SPAN Class="swiss"><A HREF="AA-13-1.html#S0285">local_name</A></SPAN>; 
in Ada 83 this rule was stated in the text.</DIV>
<DIV Class="paranum">85.c/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00114.TXT">AI95-00114-01</A></I>} 
In Ada 83, the relationship between a <SPAN class="insert2"><SPAN Class="swiss"><A HREF="AA-13-1.html#S0283">aspect_clause</A></SPAN></SPAN><SPAN class="delete2"><SPAN Class="swiss"><A HREF="AA-13-1.html#S0284">&nbsp;representation_clause</A></SPAN></SPAN> 
specifying a certain aspect and an attribute that queried that aspect 
was unclear. In Ada 95, they are the same, except for certain explicit 
exceptions.&nbsp;</DIV>

<H4 Class="centered">Wording Changes from Ada 95</H4>
<DIV Class="paranum">85.d/2</DIV>
<DIV Class="Annotations">{<I><A HREF="defect1.html#8652/0009">8652/0009</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00137.TXT">AI95-00137-01</A></I>} 
<SPAN class="insert2"><B>Corrigendum:</B> Added wording to specify for 
each attribute whether it is an operational or representation attribute.</SPAN></DIV>
<DIV Class="paranum">85.e/2</DIV>
<DIV Class="Annotations">{<I><A HREF="defect1.html#8652/0040">8652/0040</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00108.TXT">AI95-00108-01</A></I>} 
<SPAN class="insert2"><B>Corrigendum:</B> Added wording to specify that 
External_Tag is never inherited.</SPAN></DIV>
<DIV Class="paranum">85.f/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00051.TXT">AI95-00051-01</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00291.TXT">AI95-00291-01</A></I>} 
<SPAN class="insert2">Adjusted the Recommended Level of Support for Alignment 
to eliminate nonsense requirements and to ensure that useful capabilities 
are required.</SPAN></DIV>
<DIV Class="paranum">85.g/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00051.TXT">AI95-00051-01</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00291.TXT">AI95-00291-01</A></I>} 
<SPAN class="insert2">Adjusted the Recommended Level of Support for Size 
to eliminate nonsense requirements and to ensure that useful capabilities 
are required. Also eliminated any dependence on whether an aspect was 
specified (a confirming representation item should not affect the semantics).</SPAN></DIV>
<DIV Class="paranum">85.h/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00133.TXT">AI95-00133-01</A></I>} 
<SPAN class="insert2">Added the definition of machine scalar.</SPAN></DIV>
<DIV Class="paranum">85.i/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00247.TXT">AI95-00247-01</A></I>} 
<SPAN class="insert2">Removed the requirement that specified alignments 
for a composite type cannot override those for their components, because 
it was never intended to apply to components whose location was specified 
with a representation item. Moreover, it causes a difference in legality 
when a confirming alignment is specified for one of the composite types.</SPAN></DIV>
<DIV Class="paranum">85.j/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10291.TXT">AI95-00291-02</A></I>} 
<SPAN class="insert2">Removed recommended level of support rules about 
types with by-reference and aliased parts, because there are now blanket 
rules covering all recommended level of support rules.</SPAN></DIV>
<DIV Class="paranum">85.k/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10291.TXT">AI95-00291-02</A></I>} 
<SPAN class="insert2">Split the definition of Alignment for subtypes 
and for objects. This simplified the wording and eliminated confusion 
about which rules applied to objects, which applied to subtypes, and 
which applied to both.</SPAN>&nbsp;</DIV>

<HR>
<DIV Style="margin-top: 0.0em; margin-bottom: 0.6em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-13-2.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-13-4.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<DIV Style="margin-top:0.0em"><IMG SRC="AE_logo.gif" height=100 width=113 align=right ALT="Ada-Europe">
<SPAN Style="font-size: 125%">Sponsored by <SPAN Style="font-size: 125%"><A HREF="http://www.ada-europe.org/"><B>Ada-Europe</B></A></SPAN></SPAN></DIV>
</BODY>
</HTML>
