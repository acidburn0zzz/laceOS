<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Elaboration Control</TITLE>
    <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    H4.centered {text-align: center}
    SPAN.swiss {font-family: Arial, Helvetica, sans-serif; font-size: 92%}
    SPAN.roman {font-family: "Times New Roman", Times, serif}
    DIV.paranum {float: left; font-family: Arial, Helvetica, sans-serif; font-size: 64%; width: 2.8em; margin-left: -0.4em; margin-right: -3.0em; margin-top: 0.2em}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    SPAN.insert1 {text-decoration: underline; color: rgb(0,51,51) }
    SPAN.delete1 {text-decoration: line-through; color: rgb(0,51,51) }
    SPAN.insert2 {text-decoration: underline; color: rgb(0,102,0) }
    SPAN.delete2 {text-decoration: line-through; color: rgb(0,102,0) }
    DIV.Normal {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.2em; margin-bottom: 0.6em}
    DIV.Annotations {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 6.2em; margin-bottom: 0.6em}
    DIV.Notes {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em; margin-bottom: 0.6em}
    DIV.NotesHeader {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em}
    DIV.SyntaxIndented {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-bottom: 0.4em}
    UL.Bulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#000080" VLINK="#330033" ALINK="#0000FF">
<DIV><B><SPAN Style="font-size:200%; color: rgb(0,51,153)">Annotated</SPAN><SPAN Style="font-size:200%; color: rgb(0,0,102)">&nbsp;Ada Reference Manual</SPAN></B> &mdash; <A HREF="AA-TTL.html"><B>Legal Information</B></A></DIV>
<DIV Style="margin-top: 0.6em; margin-bottom: 0.0em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-10-2.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-11.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<HR>
<H1>10.2.1 Elaboration Control</H1>
<DIV Class="paranum">1</DIV>
<DIV Class="Normal">[<SPAN STYLE="font-size: 80%">{<I>elaboration control</I>}</SPAN> 
<A NAME="I4464"></A>This subclause defines pragmas that help control 
the elaboration order of <SPAN Class="swiss"><A HREF="AA-10-1-1.html#S0230">library_item</A></SPAN>s.] 
</DIV>

<H4 Class="centered">Language Design Principles</H4>
<DIV Class="paranum">1.a</DIV>
<DIV Class="Annotations">The rules governing preelaboration are designed 
to allow it to be done largely by bulk initialization of statically allocated 
storage from information in a &ldquo;load module&rdquo; created by a 
linker. Some implementations may require run-time code to be executed 
in some cases, but we consider these cases rare enough that we need not 
further complicate the rules.</DIV>
<DIV Class="paranum">1.b</DIV>
<DIV Class="Annotations">It is important that programs be able to declare 
data structures that are link-time initialized with <SPAN Class="swiss"><A HREF="AA-4-3.html#S0104">aggregate</A></SPAN>s, 
<SPAN Class="swiss"><A HREF="AA-2-6.html#S0016">string_literal</A></SPAN>s, 
and concatenations thereof. It is important to be able to write link-time 
evaluated expressions involving the First, Last, and Length attributes 
of such data structures (including variables), because they might be 
initialized with positional <SPAN Class="swiss"><A HREF="AA-4-3.html#S0104">aggregate</A></SPAN>s 
or <SPAN Class="swiss"><A HREF="AA-2-6.html#S0016">string_literal</A></SPAN>s, 
and we don't want the user to have to count the elements. There is no 
corresponding need for accessing discriminants, since they can be initialized 
with a static constant, and then the constant can be referred to elsewhere. 
It is important to allow link-time initialized data structures involving 
discriminant-dependent components. It is important to be able to write 
link-time evaluated expressions involving pointers (both access values 
and addresses) to the above-mentioned data structures.</DIV>
<DIV Class="paranum">1.c</DIV>
<DIV Class="Annotations">The rules also ensure that no Elaboration_Check 
need be performed for calls on library-level subprograms declared within 
a preelaborated package. This is true also of the Elaboration_Check on 
task activation for library level task types declared in a preelaborated 
package. However, it is not true of the Elaboration_Check on instantiations.</DIV>
<DIV Class="paranum">1.d</DIV>
<DIV Class="Annotations">A static expression should never prevent a library 
unit from being preelaborable.</DIV>

<H4 Class="centered">Syntax</H4>
<DIV Class="paranum">2</DIV>
<DIV Class="SyntaxIndented" Style="margin-bottom: 0.2em">The form of 
a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> Preelaborate 
is as follows:&nbsp;</DIV>
<DIV Class="paranum">3</DIV>
<DIV Class="SyntaxIndented">&nbsp;&nbsp;<B>pragma</B> <A NAME="I4465"></A><A NAME="I4466"></A>Preelaborate[(<I>library_unit_</I><A NAME="I4467"></A><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>)];</DIV>
<DIV Class="paranum">4</DIV>
<DIV Class="SyntaxIndented"><SPAN STYLE="font-size: 80%">{<I>library 
unit pragma (Preelaborate)</I> [partial]}</SPAN> <A NAME="I4468"></A><SPAN STYLE="font-size: 80%">{<I>pragma, 
library unit (Preelaborate)</I> [partial]}</SPAN> <A NAME="I4469"></A>A 
<SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> Preelaborate 
is a library unit pragma.&nbsp;</DIV>
<DIV Class="paranum">4.1/2</DIV>
<DIV Class="SyntaxIndented" Style="margin-bottom: 0.2em">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00161.TXT">AI95-00161-01</A></I>} 
<SPAN class="insert2">The form of a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Preelaborable_Initialization is as follows:</SPAN>&nbsp;</DIV>
<DIV Class="paranum">4.2/2</DIV>
<DIV Class="SyntaxIndented"><SPAN class="insert2">&nbsp;&nbsp;<B>pragma</B> 
<A NAME="I4470"></A><A NAME="I4471"></A>Preelaborable_Initialization(<A NAME="I4472"></A><SPAN Class="swiss"><A HREF="AA-4-1.html#S0092">direct_name</A></SPAN>);</SPAN> 
</DIV>

<H4 Class="centered">Legality Rules</H4>
<DIV Class="paranum">5</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em"><SPAN STYLE="font-size: 80%">{<I>preelaborable 
(of an elaborable construct)</I> [distributed]}</SPAN> <A NAME="I4473"></A>An 
elaborable construct is preelaborable unless its elaboration performs 
any of the following actions:&nbsp;</DIV>
<DIV Class="paranum">5.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>A <I>preelaborable</I> 
construct can be elaborated without using any information that is available 
only at run time. Note that we don't try to prevent exceptions in preelaborable 
constructs; if the implementation wishes to generate code to raise an 
exception, that's OK.</DIV>
<DIV Class="paranum">5.b</DIV>
<DIV Class="Annotations">Because there is no flow of control and there 
are no calls (other than to predefined subprograms), these run-time properties 
can actually be detected at compile time. This is necessary in order 
to require compile-time enforcement of the rules.&nbsp;</DIV>
<DIV Class="paranum">6</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>The execution of a <SPAN Class="swiss"><A HREF="AA-5-1.html#S0131">statement</A></SPAN> 
other than a <SPAN Class="swiss"><A HREF="AA-5-1.html#S0134">null_statement</A></SPAN>. 
</LI></UL>
<DIV Class="paranum">6.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>A preelaborable construct 
can contain <SPAN Class="swiss"><A HREF="AA-5-1.html#S0135">label</A></SPAN>s 
and <SPAN Class="swiss"><A HREF="AA-5-1.html#S0134">null_statement</A></SPAN>s. 
</DIV>
<DIV Class="paranum">7</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>A call to a subprogram other than 
a static function.</LI></UL>
<DIV Class="paranum">8</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>The evaluation of a <SPAN Class="swiss"><A HREF="AA-4-4.html#S0120">primary</A></SPAN> 
that is a <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
of an object, unless the <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
is a static expression, or statically denotes a discriminant of an enclosing 
type.&nbsp;</LI></UL>
<DIV Class="paranum">8.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>One can evaluate such a 
<SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>, but 
not as a <SPAN Class="swiss"><A HREF="AA-4-4.html#S0120">primary</A></SPAN>. 
For example, one can evaluate an attribute of the object. One can evaluate 
an <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0100">attribute_reference</A></SPAN>, 
so long as it does not denote an object, and its <SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN> 
does not disobey any of these rules. For example, Obj'Access, Obj'Unchecked_Access, 
and Obj'Address are generally legal in preelaborated library units.&nbsp;</DIV>
<DIV Class="paranum">9/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00161.TXT">AI95-00161-01</A></I>} 
The creation of a<SPAN class="insert2">n object [(including a component)] 
of a type that does not have preelaborable initialization. Similarly,</SPAN><SPAN class="delete2">&nbsp;default-initialized object [(including a component)] of a descendant 
of a private type, private extension, controlled type, task type, or 
protected type with <SPAN Class="swiss"><A HREF="AA-9-5-2.html#S0200">entry_declaration</A></SPAN>s; 
similarly</SPAN> the evaluation of an <SPAN Class="swiss"><A HREF="AA-4-3-2.html#S0109">extension_aggregate</A></SPAN> 
with an ancestor <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0028">subtype_mark</A></SPAN> 
denoting a subtype of such a type.</LI></UL>
<DIV Class="paranum">9.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>One can declare these kinds 
of types, but one cannot create objects of those types.</DIV>
<DIV Class="paranum">9.b</DIV>
<DIV Class="Annotations">It is also non-preelaborable to create an object 
if that will cause the evaluation of a default expression that will call 
a user-defined function. This follows from the rule above forbidding 
non-null statements.&nbsp;</DIV>
<DIV Class="paranum">9.c/2</DIV>
<DIV Class="Annotations"><SPAN STYLE="font-size: 80%"><I>This paragraph 
was deleted.</I></SPAN><SPAN class="delete2"><B>Reason:&nbsp;</B></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00161.TXT">AI95-00161-01</A></I>} 
<SPAN class="delete2">Controlled objects are disallowed because most 
implementations will have to take some run-time action during initialization, 
even if the Initialize procedure is null.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">10/2</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00403.TXT">AI95-00403-01</A></I>} 
<SPAN class="insert2"></SPAN>A generic body is preelaborable only if 
elaboration of a corresponding instance body would not perform any such 
actions, presuming that<SPAN class="insert2">:</SPAN><SPAN class="delete2">&nbsp;the actual for each formal private type (or extension) is a private type 
(or extension), and the actual for each formal subprogram is a user-defined 
subprogram.</SPAN> <SPAN STYLE="font-size: 80%">{<I>generic contract 
issue</I>}</SPAN> <A NAME="I4474"></A></DIV>
<DIV Class="paranum">10.1/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00403.TXT">AI95-00403-01</A></I>} 
<SPAN class="insert2">the actual for each formal private type (or extension) 
declared within the formal part of the generic unit is a private type 
(or extension) that does not have preelaborable initialization;</SPAN></LI></UL>
<DIV Class="paranum">10.2/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00403.TXT">AI95-00403-01</A></I>} 
<SPAN class="insert2">the actual for each formal type is nonstatic;</SPAN></LI></UL>
<DIV Class="paranum">10.3/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00403.TXT">AI95-00403-01</A></I>} 
<SPAN class="insert2">the actual for each formal object is nonstatic; 
and</SPAN></LI></UL>
<DIV Class="paranum">10.4/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00403.TXT">AI95-00403-01</A></I>} 
<SPAN class="insert2">the actual for each formal subprogram is a user-defined 
subprogram.</SPAN>&nbsp;</LI></UL>
<DIV Class="paranum">10.a.1/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Discussion:&nbsp;</B></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00403.TXT">AI95-00403-01</A></I>} 
<SPAN class="insert2">This is an &ldquo;assume-the-worst&rdquo; rule. 
The elaboration of a generic unit doesn't perform any of the actions 
listed above, because its sole effect is to establish that the generic 
can from now on be instantiated. So the elaboration of the generic itself 
is not the interesting part when it comes to preelaboration rules. The 
interesting part is what happens when you elaborate &ldquo;any instantiation&rdquo; 
of the generic. For instance, declaring an object of a limited formal 
private type might well start tasks, call functions, and do all sorts 
of non-preelaborable things. We prevent these situations by assuming 
that the actual parameters are as badly behaved as possible.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">10.a</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>Without this rule about generics, 
we would have to forbid instantiations in preelaborated library units, 
which would significantly reduce their usefulness.&nbsp;</DIV>
<DIV Class="paranum">11/1</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="defect1.html#8652/0035">8652/0035</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00002.TXT">AI95-00002-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>preelaborated</I> [partial]}</SPAN> 
<A NAME="I4475"></A>If a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Preelaborate (or <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Pure &mdash; see below) applies to a library unit, then it is <I>preelaborated</I>. 
[ <SPAN STYLE="font-size: 80%">{<I>preelaborated</I> [distributed]}</SPAN> 
<A NAME="I4476"></A>If a library unit is preelaborated, then its declaration, 
if any, and body, if any, are elaborated prior to all non-preelaborated 
<SPAN Class="swiss"><A HREF="AA-10-1-1.html#S0230">library_item</A></SPAN>s 
of the partition.] <SPAN class="insert1">The declaration and body of 
a preelaborated library unit, and all subunits that are elaborated as 
part of elaborating the library unit,</SPAN><SPAN class="delete1">&nbsp;All 
compilation units of a preelaborated library unit</SPAN> shall be preelaborable. 
<SPAN STYLE="font-size: 80%">{<I>generic contract issue</I> [partial]}</SPAN> 
<A NAME="I4477"></A>In addition to the places where Legality Rules normally 
apply (see <A HREF="AA-12-3.html">12.3</A>), this rule applies also in 
the private part of an instance of a generic unit. In addition, all compilation 
units of a preelaborated library unit shall depend semantically only 
on compilation units of other preelaborated library units.&nbsp;</DIV>
<DIV Class="paranum">11.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>In a generic body, we assume 
the worst about formal private types and extensions.</DIV>
<DIV Class="paranum">11.a.1/1</DIV>
<DIV Class="Annotations">{<I><A HREF="defect1.html#8652/0035">8652/0035</A></I>} 
<SPAN class="insert1"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00002.TXT">AI95-00002-01</A></I>} 
<SPAN class="insert1">Subunits of a preelaborated subprogram unit do 
not need to be preelaborable. This is needed in order to be consistent 
with units nested in a subprogram body, which do not need to be preelaborable 
even if the subprogram is preelaborated. However, such subunits cannot 
depend semantically on non-preelaborated units, which is also consistent 
with nested units.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">11.1/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00161.TXT">AI95-00161-01</A></I>} 
<SPAN class="insert2"><SPAN STYLE="font-size: 80%">{<I>preelaborable 
initialization</I>}</SPAN> <A NAME="I4478"></A>The following rules specify 
which entities have <I>preelaborable initialization</I>:</SPAN></DIV>
<DIV Class="paranum">11.2/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN class="insert2">The partial 
view of a private type or private extension, a protected type without 
<SPAN Class="swiss"><A HREF="AA-9-5-2.html#S0200">entry_declaration</A></SPAN>s, 
a generic formal private type, or a generic formal derived type, have 
preelaborable initialization if and only if the <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Preelaborable_Initialization has been applied to them. [A protected type 
with <SPAN Class="swiss"><A HREF="AA-9-5-2.html#S0200">entry_declaration</A></SPAN>s 
or a task type never has preelaborable initialization.]</SPAN></LI></UL>
<DIV Class="paranum">11.3/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN class="insert2">A component 
(including a discriminant) of a record or protected type has preelaborable 
initialization if its declaration includes a <SPAN Class="swiss"><A HREF="AA-3-7.html#S0063">default_expression</A></SPAN> 
whose execution does not perform any actions prohibited in preelaborable 
constructs as described above, or if its declaration does not include 
a default expression and its type has preelaborable initialization.</SPAN></LI></UL>
<DIV Class="paranum">11.4/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN class="insert2">A derived type 
has preelaborable initialization if its parent type has preelaborable 
initialization and (in the case of a derived record extension) if the 
non-inherited components all have preelaborable initialization. However, 
a user-defined controlled type with an overriding Initialize procedure 
does not have preelaborable initialization.</SPAN></LI></UL>
<DIV Class="paranum">11.5/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00161.TXT">AI95-00161-01</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00345.TXT">AI95-00345-01</A></I>} 
<SPAN class="insert2">A view of a type has preelaborable initialization 
if it is an elementary type, an array type whose component type has preelaborable 
initialization, a record type whose components all have preelaborable 
initialization, or an interface type.</SPAN>&nbsp;</LI></UL>
<DIV Class="paranum">11.6/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00161.TXT">AI95-00161-01</A></I>} 
<SPAN class="insert2">A <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Preelaborable_Initialization specifies that a type has preelaborable 
initialization. This pragma shall appear in the visible part of a package 
or generic package.</SPAN></DIV>
<DIV Class="paranum">11.7/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00161.TXT">AI95-00161-01</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00345.TXT">AI95-00345-01</A></I>} 
<SPAN class="insert2">If the pragma appears in the first list of <SPAN Class="swiss"><A HREF="AA-3-11.html#S0088">basic_declarative_item</A></SPAN>s 
of a <SPAN Class="swiss"><A HREF="AA-7-1.html#S0174">package_specification</A></SPAN>, 
then the <SPAN Class="swiss"><A HREF="AA-4-1.html#S0092">direct_name</A></SPAN> 
shall denote the first subtype of a private type, private extension, 
or protected type that is not an interface type and is without <SPAN Class="swiss"><A HREF="AA-9-5-2.html#S0200">entry_declaration</A></SPAN>s, 
and the type shall be declared immediately within the same package as 
the <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN>. 
If the <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
is applied to a private type or a private extension, the full view of 
the type shall have preelaborable initialization. If the <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
is applied to a protected type, each component of the protected type 
shall have preelaborable initialization. In addition to the places where 
Legality Rules normally apply, these rules apply also in the private 
part of an instance of a generic unit.</SPAN></DIV>
<DIV Class="paranum">11.8/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00161.TXT">AI95-00161-01</A></I>} 
<SPAN class="insert2">If the <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
appears in a <SPAN Class="swiss"><A HREF="AA-12-1.html#S0255">generic_formal_part</A></SPAN>, 
then the <SPAN Class="swiss"><A HREF="AA-4-1.html#S0092">direct_name</A></SPAN> 
shall denote a generic formal private type or a generic formal derived 
type declared in the same <SPAN Class="swiss"><A HREF="AA-12-1.html#S0255">generic_formal_part</A></SPAN> 
as the <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN>. 
In a <SPAN Class="swiss"><A HREF="AA-12-3.html#S0257">generic_instantiation</A></SPAN> 
the corresponding actual type shall have preelaborable initialization.</SPAN></DIV>
<DIV Class="paranum">11.b/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Ramification:&nbsp;</B>Not 
only do protected types with <SPAN Class="swiss"><A HREF="AA-9-5-2.html#S0200">entry_declaration</A></SPAN>s 
and task types not have preelaborable initialization, but they cannot 
have pragma Preelaborable_Initialization applied to them.</SPAN>&nbsp;</DIV>

<H4 Class="centered">Implementation Advice</H4>
<DIV Class="paranum">12</DIV>
<DIV Class="Normal">In an implementation, a type declared in a preelaborated 
package should have the same representation in every elaboration of a 
given version of the package, whether the elaborations occur in distinct 
executions of the same program, or in executions of distinct programs 
or partitions that include the given version.&nbsp;</DIV>
<DIV Class="paranum">12.a/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Implementation Advice: 
</B></SPAN><SPAN class="insert2">A type declared in a preelaborated package 
should have the same representation in every elaboration of a given version 
of the package.</SPAN></DIV>

<H4 Class="centered">Syntax</H4>
<DIV Class="paranum">13</DIV>
<DIV Class="SyntaxIndented" Style="margin-bottom: 0.2em">The form of 
a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> Pure 
is as follows:&nbsp;</DIV>
<DIV Class="paranum">14</DIV>
<DIV Class="SyntaxIndented">&nbsp;&nbsp;<B>pragma</B> <A NAME="I4479"></A><A NAME="I4480"></A>Pure[(<I>library_unit_</I><A NAME="I4481"></A><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>)];</DIV>
<DIV Class="paranum">15</DIV>
<DIV Class="SyntaxIndented"><SPAN STYLE="font-size: 80%">{<I>library 
unit pragma (Pure)</I> [partial]}</SPAN> <A NAME="I4482"></A><SPAN STYLE="font-size: 80%">{<I>pragma, 
library unit (Pure)</I> [partial]}</SPAN> <A NAME="I4483"></A>A <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Pure is a library unit pragma.&nbsp;</DIV>

<H4 Class="centered">Static Semantics</H4>
<DIV Class="paranum">15.1/2</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00366.TXT">AI95-00366-01</A></I>} 
<SPAN class="insert2"><SPAN STYLE="font-size: 80%">{<I>pure</I>}</SPAN> 
<A NAME="I4484"></A>A <I>pure</I> <SPAN Class="swiss"><A HREF="AA-10-1-1.html#S0230">library_item</A></SPAN> 
is a preelaborable <SPAN Class="swiss"><A HREF="AA-10-1-1.html#S0230">library_item</A></SPAN> 
whose elaboration does not perform any of the following actions:</SPAN></DIV>
<DIV Class="paranum">15.2/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN class="insert2">the elaboration 
of a variable declaration;</SPAN></LI></UL>
<DIV Class="paranum">15.3/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN class="insert2">the evaluation 
of an <SPAN Class="swiss"><A HREF="AA-4-8.html#S0129">allocator</A></SPAN> 
of an access-to-variable type; for the purposes of this rule, the partial 
view of a type is presumed to have non-visible components whose default 
initialization evaluates such an <SPAN Class="swiss"><A HREF="AA-4-8.html#S0129">allocator</A></SPAN>;</SPAN></LI></UL>
<DIV Class="paranum">15.a/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Reason:&nbsp;</B>This rule 
is needed because aggregates can specify the default initialization of 
a private type or extension using &lt;&gt; or the ancestor subtype of 
an extension aggregate. The subtype of a component could use an <SPAN Class="swiss"><A HREF="AA-4-8.html#S0129">allocator</A></SPAN> 
to initialize an access discriminant. Ada 95 did not allow such private 
types to have preelaborable initialization, so they could not have occurred. 
Thus this rule is not incompatible with Ada 95.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">15.4/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN class="insert2">the elaboration 
of the declaration of a named access-to-variable type unless the Storage_Size 
of the type has been specified by a static expression with value zero 
or is defined by the language to be zero;</SPAN></LI></UL>
<DIV Class="paranum">15.b/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Discussion:&nbsp;</B>A remote 
access-to-class-wide type (see <A HREF="AA-E-2-2.html">E.2.2</A>) has 
its Storage_Size defined to be zero.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">15.c/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Reason:&nbsp;</B></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00366.TXT">AI95-00366-01</A></I>} 
<SPAN class="insert2">We disallow most named access-to-object types because 
an <SPAN Class="swiss"><A HREF="AA-4-8.html#S0129">allocator</A></SPAN> 
has a side effect; the pool constitutes variable data. We allow access-to-subprogram 
types because they don't have <SPAN Class="swiss"><A HREF="AA-4-8.html#S0129">allocator</A></SPAN>s. 
We even allow named access-to-object types if they have an empty predefined 
pool (they can't have a user-defined pool as System.Storage_Pools is 
not pure). In this case, most attempts to use an <SPAN Class="swiss"><A HREF="AA-4-8.html#S0129">allocator</A></SPAN> 
are illegal, and any others (in a generic body) will raise Storage_Error.</SPAN> 
</DIV>
<DIV Class="paranum">15.5/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN class="insert2">the elaboration 
of the declaration of a named access-to-constant type for which the Storage_Size 
has been specified by an expression other than a static expression with 
value zero.</SPAN></LI></UL>
<DIV Class="paranum">15.d/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Discussion:&nbsp;</B>We 
allow access-to-constant types so long as there is no user-specified 
non-zero Storage_Size; if there were a user-specified non-zero Storage_Size 
restricting the size of the storage pool, allocators would be problematic 
since the package is supposedly &lsquo;stateless&rsquo;, and the allocated 
size count for the storage pool would represent state.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">15.6/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00366.TXT">AI95-00366-01</A></I>} 
<SPAN class="insert2">The Storage_Size for an anonymous access-to-variable 
type declared at library level in a library unit that is declared pure 
is defined to be zero.</SPAN></DIV>
<DIV Class="paranum">15.e/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Ramification:&nbsp;</B>This 
makes <SPAN Class="swiss"><A HREF="AA-4-8.html#S0129">allocator</A></SPAN>s 
illegal for such types (see <A HREF="AA-4-8.html">4.8</A>), making a 
storage pool unnecessary for these types. A storage pool would represent 
state.</SPAN></DIV>
<DIV Class="paranum">15.f/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2">Note that access discriminants 
and access parameters are never library-level, even when they are declared 
in a type or subprogram declared at library-level. That's because they 
have their own special accessibility rules (see <A HREF="AA-3-10-2.html">3.10.2</A>).</SPAN> 
</DIV>

<H4 Class="centered">Legality Rules</H4>
<DIV Class="paranum">16/2</DIV>
<DIV Class="Normal">&nbsp;<SPAN STYLE="font-size: 80%"><I>This paragraph was 
deleted.</I></SPAN><SPAN class="delete2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00366.TXT">AI95-00366-01</A></I>} 
<SPAN class="delete2"><SPAN STYLE="font-size: 80%">{<I>pure</I>}</SPAN> 
<A NAME="I4485"></A>A <I>pure</I> <SPAN Class="swiss"><A HREF="AA-10-1-1.html#S0230">library_item</A></SPAN> 
is a preelaborable <SPAN Class="swiss"><A HREF="AA-10-1-1.html#S0230">library_item</A></SPAN> 
that does not contain the declaration of any variable or named access 
within a subprogram, generic subprogram, task unit, or protected unit.</SPAN></DIV>
<DIV Class="paranum">17/2</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00366.TXT">AI95-00366-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>declared pure</I>}</SPAN> <A NAME="I4486"></A>A 
<SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> Pure 
is used to declare that a library unit is pure. If a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Pure applies to a library unit, then its compilation units shall be pure, 
and they shall depend semantically only on compilation units of other 
library units that are declared pure.<SPAN class="insert2">&nbsp;Furthermore, 
the full view of any partial view declared in the visible part of the 
library unit that has any available stream attributes shall support external 
streaming (see <A HREF="AA-13-13-2.html">13.13.2</A>).</SPAN>&nbsp;</DIV>
<DIV Class="paranum">17.a</DIV>
<DIV Class="Annotations"><B>To be honest:&nbsp;</B>A <I>declared-pure</I> 
library unit is one to which a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Pure applies. Its declaration and body are also said to be declared pure. 
</DIV>
<DIV Class="paranum">17.b</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>A declared-pure package is 
useful for defining types to be shared between partitions with no common 
address space.&nbsp;</DIV>
<DIV Class="paranum">17.c</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>Note that generic packages are 
not mentioned in the list of things that can contain variable declarations. 
Note that the Ada 95 rules for deferred constants make them allowable 
in library units that are declared pure; that isn't true of Ada 83's 
deferred constants.&nbsp;</DIV>
<DIV Class="paranum">17.d/2</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00366.TXT">AI95-00366-01</A></I>} 
Anonymous access types <SPAN class="delete2">(that is, access discriminants 
and access parameters)&nbsp;</SPAN>are allowed.&nbsp;</DIV>
<DIV Class="paranum">17.e/2</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00366.TXT">AI95-00366-01</A></I>} 
<SPAN class="insert2">Ada 95 didn't allow any access types as</SPAN><SPAN class="delete2">&nbsp;The 
primary reason for disallowing named access types is that an <SPAN Class="swiss"><A HREF="AA-4-8.html#S0129">allocator</A></SPAN> 
has a side effect; the pool constitutes variable data. We considered 
somehow allowing <SPAN Class="swiss"><A HREF="AA-4-8.html#S0129">allocator</A></SPAN>-less 
access types. However,</SPAN> these (including access-to-subprogram types) 
<SPAN class="delete2">would&nbsp;</SPAN>cause trouble for <A HREF="AA-E.html">Annex 
E</A>, &ldquo;<A HREF="AA-E.html">Distributed Systems</A>&rdquo;, because 
such types <SPAN class="delete2">would&nbsp;</SPAN> allow access values in 
a shared passive partition to designate objects in an active partition, 
thus allowing inter-address space references.<SPAN class="insert2">&nbsp;We 
decided to disallow such uses in the relatively rare cases where they 
cause problems, rather than making life harder for the majority of users. 
Types declared in a pure package can be used in remote operations only 
if they are externally streamable. That simply means that there is a 
means to transport values of the type; that's automatically true for 
nonlimited types that don't have an access part. The only tricky part 
about this is to avoid privacy leakage; that was handled by ensuring 
that any private types (and private extensions) declared in a pure package 
that have available stream attributes (which include all nonlimited types 
by definition) have to be externally streamable.</SPAN><SPAN class="delete2">&nbsp;Furthermore, 
a named access-to-object type without a pool would be a new concept, 
adding complexity from the user's point of view. Finally, the prevention 
of <SPAN Class="swiss"><A HREF="AA-4-8.html#S0129">allocator</A></SPAN>s 
would have to be a run-time check, in order to avoid violations of the 
generic contract model.</SPAN>&nbsp;</DIV>

<H4 Class="centered">Implementation Permissions</H4>
<DIV Class="paranum">18/2</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00366.TXT">AI95-00366-01</A></I>} 
If a library unit is declared pure, then the implementation is permitted 
to omit a call on a library-level subprogram of the library unit if the 
results are not needed after the call. <SPAN class="insert2">In addition, 
the implementation</SPAN><SPAN class="delete2">&nbsp;Similarly, it</SPAN> 
may omit <SPAN class="delete2">such&nbsp;</SPAN>a call<SPAN class="insert2">&nbsp;on such a subprogram</SPAN> and simply reuse the results produced by 
an earlier call on the same subprogram, provided that none of the parameters 
<SPAN class="insert2">nor any object accessible via access values from 
the parameters&nbsp;</SPAN>are of a limited type, and the addresses and values 
of all by-reference actual parameters, <SPAN class="delete2">and&nbsp;</SPAN>the 
values of all by-copy-in actual parameters, <SPAN class="insert2">and 
the values of all objects accessible via access values from the parameters, 
</SPAN>are the same as they were at the earlier call. [This permission 
applies even if the subprogram produces other side effects when called.] 
</DIV>
<DIV Class="paranum">18.a/2</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00366.TXT">AI95-00366-01</A></I>} 
A declared-pure <SPAN Class="swiss"><A HREF="AA-10-1-1.html#S0230">library_item</A></SPAN> 
has no variable state. Hence, a call on one of its (nonnested) subprograms 
cannot <SPAN class="insert2">normally</SPAN><SPAN class="delete2">&nbsp;&ldquo;normally&rdquo;</SPAN> 
have side effects. The only possible side effects from such a call would 
be through machine code insertions,<SPAN class="insert2">&nbsp;imported subprograms,</SPAN> unchecked 
conversion to an access type declared within the subprogram, and similar 
features. The compiler may omit a call to such a subprogram even if such 
side effects exist, so the writer of such a subprogram has to keep this 
in mind.&nbsp;</DIV>

<H4 Class="centered">Syntax</H4>
<DIV Class="paranum">19</DIV>
<DIV Class="SyntaxIndented" Style="margin-bottom: 0.2em">The form of 
a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> Elaborate, 
Elaborate_All, or Elaborate_Body is as follows:&nbsp;</DIV>
<DIV Class="paranum">20</DIV>
<DIV Class="SyntaxIndented">&nbsp;&nbsp;<B>pragma</B> <A NAME="I4487"></A><A NAME="I4488"></A>Elaborate(<I>library_unit_</I><A NAME="I4489"></A><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>{, 
<I>library_unit_</I><A NAME="I4490"></A><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>});</DIV>
<DIV Class="paranum">21</DIV>
<DIV Class="SyntaxIndented">&nbsp;&nbsp;<B>pragma</B> <A NAME="I4491"></A><A NAME="I4492"></A>Elaborate_All(<I>library_unit_</I><A NAME="I4493"></A><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>{, 
<I>library_unit_</I><A NAME="I4494"></A><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>});</DIV>
<DIV Class="paranum">22</DIV>
<DIV Class="SyntaxIndented">&nbsp;&nbsp;<B>pragma</B> <A NAME="I4495"></A><A NAME="I4496"></A>Elaborate_Body[(<I>library_unit_</I><A NAME="I4497"></A><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>)];</DIV>
<DIV Class="paranum">23</DIV>
<DIV Class="SyntaxIndented">A <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Elaborate or Elaborate_All is only allowed within a <SPAN Class="swiss"><A HREF="AA-10-1-2.html#S0235">context_clause</A></SPAN>. 
</DIV>
<DIV Class="paranum">23.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>&ldquo;Within a <SPAN Class="swiss"><A HREF="AA-10-1-2.html#S0235">context_clause</A></SPAN>&rdquo; 
allows it to be the last item in the <SPAN Class="swiss"><A HREF="AA-10-1-2.html#S0235">context_clause</A></SPAN>. 
It can't be first, because the <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
has to denote something mentioned earlier.&nbsp;</DIV>
<DIV Class="paranum">24</DIV>
<DIV Class="SyntaxIndented"><SPAN STYLE="font-size: 80%">{<I>library 
unit pragma (Elaborate_Body)</I> [partial]}</SPAN> <A NAME="I4498"></A><SPAN STYLE="font-size: 80%">{<I>pragma, 
library unit (Elaborate_Body)</I> [partial]}</SPAN> <A NAME="I4499"></A>A 
<SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> Elaborate_Body 
is a library unit pragma.&nbsp;</DIV>
<DIV Class="paranum">24.a</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>Hence, a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Elaborate or Elaborate_All is not elaborated, not that it makes any practical 
difference.</DIV>
<DIV Class="paranum">24.b</DIV>
<DIV Class="Annotations">Note that a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Elaborate or Elaborate_All is neither a program unit pragma, nor a library 
unit pragma.</DIV>

<H4 Class="centered">Legality Rules</H4>
<DIV Class="paranum">25</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>requires a completion 
(declaration to which a pragma Elaborate_Body applies)</I> [partial]}</SPAN> 
<A NAME="I4500"></A>If a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Elaborate_Body applies to a declaration, then the declaration requires 
a completion [(a body)].</DIV>
<DIV Class="paranum">25.1/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-50217.TXT">AI95-00217-06</A></I>} 
<SPAN class="insert2">The <I>library_unit_</I><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
of a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Elaborate or Elaborate_All shall denote a nonlimited view of a library 
unit.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">25.a/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Reason:&nbsp;</B>These <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN>s 
are intended to prevent elaboration check failures. But a limited view 
does not make anything visible that has an elaboration check, so the 
<SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN>s cannot 
do anything useful. Moreover, the <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN>s 
would probably reintroduce the circularity that the <SPAN Class="swiss"><A HREF="AA-10-1-2.html#S0238">limited_with_clause</A></SPAN> 
was intended to break. So we make such uses illegal.</SPAN>&nbsp;</DIV>

<H4 Class="centered">Static Semantics</H4>
<DIV Class="paranum">26</DIV>
<DIV Class="Normal">[A <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Elaborate specifies that the body of the named library unit is elaborated 
before the current <SPAN Class="swiss"><A HREF="AA-10-1-1.html#S0230">library_item</A></SPAN>. 
A <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> Elaborate_All 
specifies that each <SPAN Class="swiss"><A HREF="AA-10-1-1.html#S0230">library_item</A></SPAN> 
that is needed by the named library unit declaration is elaborated before 
the current <SPAN Class="swiss"><A HREF="AA-10-1-1.html#S0230">library_item</A></SPAN>. 
A <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> Elaborate_Body 
specifies that the body of the library unit is elaborated immediately 
after its declaration.]&nbsp;</DIV>
<DIV Class="paranum">26.a</DIV>
<DIV Class="Annotations"><B>Proof:&nbsp;</B>The official statement of the 
semantics of these <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN>s 
is given in <A HREF="AA-10-2.html">10.2</A>.&nbsp;</DIV>
<DIV Class="paranum">26.b</DIV>
<DIV Class="Annotations"><B>Implementation Note:&nbsp;</B>The presence of 
a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> Elaborate_Body 
simplifies the removal of unnecessary Elaboration_Checks. For a subprogram 
declared immediately within a library unit to which a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Elaborate_Body applies, the only calls that can fail the Elaboration_Check 
are those that occur in the library unit itself, between the declaration 
and body of the called subprogram; if there are no such calls (which 
can easily be detected at compile time if there are no <SPAN Class="swiss">stub</SPAN>s), 
then no Elaboration_Checks are needed for that subprogram. The same is 
true for Elaboration_Checks on task activations and instantiations, and 
for library subprograms and generic units.&nbsp;</DIV>
<DIV Class="paranum">26.c</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>The fact that the unit 
of elaboration is the <SPAN Class="swiss"><A HREF="AA-10-1-1.html#S0230">library_item</A></SPAN> 
means that if a <SPAN Class="swiss"><A HREF="AA-6-3.html#S0162">subprogram_body</A></SPAN> 
is not a completion, it is impossible for any <SPAN Class="swiss"><A HREF="AA-10-1-1.html#S0230">library_item</A></SPAN> 
to be elaborated between the declaration and the body of such a subprogram. 
Therefore, it is impossible for a call to such a subprogram to fail its 
Elaboration_Check.&nbsp;</DIV>
<DIV Class="paranum">26.d</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>The visibility rules imply 
that each <I>library_unit_</I><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
of a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Elaborate or Elaborate_All has to denote a library unit mentioned by 
a previous <SPAN Class="swiss"><A HREF="AA-10-1-2.html#S0237">with_clause</A></SPAN> 
of the same <SPAN Class="swiss"><A HREF="AA-10-1-2.html#S0235">context_clause</A></SPAN>. 
</DIV>
<DIV Class="NotesHeader">NOTES</DIV>
<DIV Class="paranum">27</DIV>
<DIV Class="Notes">12&nbsp;&nbsp;A preelaborated library unit is allowed 
to have non-preelaborable children.&nbsp;</DIV>
<DIV Class="paranum">27.a/1</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>{<I><A HREF="defect1.html#8652/0035">8652/0035</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00002.TXT">AI95-00002-01</A></I>} 
But <SPAN class="insert1">generally&nbsp;</SPAN>not non-preelaborated subunits. 
<SPAN class="insert1">(Non-preelaborated subunits of subprograms are 
allowed as discussed above.)</SPAN>&nbsp;</DIV>
<DIV Class="paranum">28</DIV>
<DIV Class="Notes">13&nbsp;&nbsp;A library unit that is declared pure 
is allowed to have impure children.&nbsp;</DIV>
<DIV Class="paranum">28.a/1</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>{<I><A HREF="defect1.html#8652/0035">8652/0035</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00002.TXT">AI95-00002-01</A></I>} 
But <SPAN class="insert1">generally&nbsp;</SPAN>not impure subunits. <SPAN class="insert1">(Impure 
subunits of subprograms are allowed as discussed above.)</SPAN>&nbsp;</DIV>
<DIV Class="paranum">28.b</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>Pragma Elaborate is mainly 
for closely related library units, such as when two package bodies 'with' 
each other's declarations. In such cases, Elaborate_All sometimes won't 
work.&nbsp;</DIV>

<H4 Class="centered">Extensions to Ada 83</H4>
<DIV Class="paranum">28.c</DIV>
<DIV Class="Annotations">{<I>extensions to Ada 83</I>} <A NAME="I4501"></A>The 
concepts of preelaborability and purity are new to Ada 95. The Elaborate_All, 
Elaborate_Body, Preelaborate, and Pure <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN>s 
are new to Ada 95.</DIV>
<DIV Class="paranum">28.d</DIV>
<DIV Class="Annotations">Pragmas Elaborate are allowed to be mixed in 
with the other things in the <SPAN Class="swiss"><A HREF="AA-10-1-2.html#S0235">context_clause</A></SPAN> 
&mdash; in Ada 83, they were required to appear last.&nbsp;</DIV>

<H4 Class="centered">Incompatibilities With Ada 95</H4>
<DIV Class="paranum">28.e/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00366.TXT">AI95-00366-01</A></I>} 
<SPAN class="insert2">{<I>incompatibilities with Ada 95</I>} <A NAME="I4502"></A>The 
requirement that a partial view with available stream attributes be externally 
streamable can cause an incompatibility in rare cases. If there is a 
limited tagged type declared in a pure package with available attributes, 
and that type is used to declare a private extension in another pure 
package, and the full type for the private extension has a component 
of an explicitly limited record type, a protected type, or a type with 
access discriminants, then the stream attributes will have to be user-specified 
in the visible part of the package. That is not a requirement for Ada 
95, but this combination seems very unlikely in pure packages. Note that 
this cannot be an incompatibility for a nonlimited type, as all of the 
types that are allowed in Ada 95 that would require explicitly defined 
stream attributes are limited (and thus cannot be used as components 
in a nonlimited type).</SPAN></DIV>
<DIV Class="paranum">28.f/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00403.TXT">AI95-00403-01</A></I>} 
<SPAN class="insert2"><B>Amendment Correction:</B> Added wording to cover 
missing cases for preelaborated generic units. This is incompatible as 
a preelaborated unit could have used a formal object to initialize a 
library-level object; that isn't allowed in Ada 2005. But such a unit 
wouldn't really be preelaborable, and Ada 95 compilers can reject such 
units (as this is a Binding Interpretation), so such units should be 
very rare.</SPAN>&nbsp;</DIV>

<H4 Class="centered">Extensions to Ada 95</H4>
<DIV Class="paranum">28.g/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00161.TXT">AI95-00161-01</A></I>} 
<SPAN class="insert2">{<I>extensions to Ada 95</I>} <A NAME="I4503"></A><B>Amendment 
Correction:</B> The concept of preelaborable initialization and <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Preelaborable_Initialization are new. These allow more types of objects 
to be created in preelaborable units, and fix holes in the old rules.</SPAN></DIV>
<DIV Class="paranum">28.h/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00366.TXT">AI95-00366-01</A></I>} 
<SPAN class="insert2">Access-to-subprogram types and access-to-object 
types with a Storage_Size of 0 are allowed in pure units. The permission 
to omit calls was adjusted accordingly (which also fixes a hole in Ada 
95, as access parameters are allowed, and changes in the values accessed 
by them must be taken into account).</SPAN>&nbsp;</DIV>

<H4 Class="centered">Wording Changes from Ada 95</H4>
<DIV Class="paranum">28.i/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00002.TXT">AI95-00002-01</A></I>} 
<SPAN class="insert2"><B>Corrigendum:</B> The wording was changed so 
that subunits of a preelaborated subprogram are also preelaborated.</SPAN></DIV>
<DIV Class="paranum">28.j/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-50217.TXT">AI95-00217-06</A></I>} 
<SPAN class="insert2">Disallowed pragma Elaborate and Elaborate_All for 
packages that are mentioned in a <SPAN Class="swiss"><A HREF="AA-10-1-2.html#S0238">limited_with_clause</A></SPAN>.</SPAN> 
</DIV>

<HR>
<DIV Style="margin-top: 0.0em; margin-bottom: 0.6em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-10-2.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-11.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<DIV Style="margin-top:0.0em"><IMG SRC="AE_logo.gif" height=100 width=113 align=right ALT="Ada-Europe">
<SPAN Style="font-size: 125%">Sponsored by <SPAN Style="font-size: 125%"><A HREF="http://www.ada-europe.org/"><B>Ada-Europe</B></A></SPAN></SPAN></DIV>
</BODY>
</HTML>
