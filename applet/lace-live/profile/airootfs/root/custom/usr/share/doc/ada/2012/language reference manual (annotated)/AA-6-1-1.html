<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Preconditions and Postconditions</TITLE>
    <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    H4.centered {text-align: center}
    SPAN.swiss {font-family: Arial, Helvetica, sans-serif; font-size: 92%}
    SPAN.roman {font-family: "Times New Roman", Times, serif}
    DIV.paranum {float: left; font-family: Arial, Helvetica, sans-serif; font-size: 64%; width: 2.8em; margin-left: -0.4em; margin-right: -3.0em; margin-top: 0.2em}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    SPAN.insert4 {text-decoration: underline; color: rgb(153,0,0) }
    SPAN.delete4 {text-decoration: line-through; color: rgb(153,0,0) }
    A.Bar:link {font-family: Arial, Helvetica, sans-serif; font-style: normal; text-decoration: none; color: rgb(204,204,51)}
    A.Bar:visited {font-family: Arial, Helvetica, sans-serif; font-style: normal; text-decoration: none; color: rgb(204,204,51)}
    DIV.Normal {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.2em; margin-bottom: 0.6em}
    DIV.Notes {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em; margin-bottom: 0.6em}
    DIV.Annotations {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 6.2em; margin-bottom: 0.6em}
    DIV.NotesHeader {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em}
    DIV.Indented5Examples {font-family: "Courier New", monospace; font-size: 90%; line-height: 122%; margin-left:  12.2em; margin-bottom: 0.6em}
    DIV.SmallExamples {font-family: "Courier New", monospace; font-size: 72%; line-height: 122%; margin-left: 9.6em; margin-bottom: 0.6em}
    DIV.Bulleted-NoPrefix {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    DIV.Bulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em; display: list-item; list-style-type: disc}
    DIV.Indented4Bulleted-NoPrefix {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 9.2em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    DIV.Indented4Bulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 9.2em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em; display: list-item; list-style-type: disc}
    DIV.WideHanging-Body {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 7.2em; margin-top: 0em; margin-bottom: 0.6em}
    DIV.WideHanging-Term {float: left; font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.2em; margin-top: 0em; margin-bottom: 0em}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#000080" VLINK="#330033" ALINK="#0000FF">
<DIV><B><SPAN Style="font-size:200%; color: rgb(0,51,153)">Annotated</SPAN><SPAN Style="font-size:200%; color: rgb(0,0,102)">&nbsp;Ada Reference Manual</SPAN></B> &mdash; <A HREF="AA-TTL.html"><B>Legal Information</B></A></DIV>
<div style="margin-top: 0.6em; margin-bottom: 0.0em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-6-1.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-6-2.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</div>
<HR>
<H1>6.1.1 Preconditions and Postconditions</H1>
<div class="paranum"><a name="p1">1/4</a></div>
<div class="Normal" style="margin-bottom: 0.4em">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0145-2.TXT">AI05-0145-2</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0247-1.TXT">AI05-0247-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0045-1.TXT">AI12-0045-1</A></I>} 
For a <span class="insert4">noninstance&nbsp;</span>subprogram<span class="insert4">, 
a generic subprogram,</span> or <span class="insert4">an&nbsp;</span>entry, 
the following language-defined aspects may be specified with an <SPAN Class="swiss"><A HREF="AA-13-1-1.html#S0307">aspect_specification</A></SPAN> 
(see <A HREF="AA-13-1-1.html">13.1.1</A>):</div>
<div class="paranum"><a name="p1.a">1.a/4</a></div>
<div class="Annotations"><span class="insert4"><B>Ramification:&nbsp;</B></span>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0045-1.TXT">AI12-0045-1</A></I>} 
<span class="insert4">&ldquo;Noninstance subprogram&rdquo; excludes a 
subprogram that is an instance of a generic subprogram. In that case, 
the aspects should be specified on the generic subprogram. If preconditions 
or postconditions need to be added to an instance of a generic subprogram, 
it can be accomplished by creating a separate subprogram specification 
and then completing that specification with a renames-as-body of the 
instance.</span>&nbsp;</div>
<div class="paranum"><a name="p2">2/3</a></div>
<div class="WideHanging-Term">Pre</div><div class="WideHanging-Body">
This aspect specifies a specific precondition for a callable entity; 
it shall be specified by an <SPAN Class="swiss"><A HREF="AA-4-4.html#S0117">expression</A></SPAN>, 
called a <I>specific precondition expression</I>.<A NAME="I3617"></A><A NAME="I3618"></A> 
If not specified for an entity, the specific precondition expression 
for the entity is the enumeration literal True.<A NAME="I3619"></A><A NAME="I3620"></A></div>
<div class="paranum"><a name="p2.a">2.a/3</a></div>
<div class="Annotations"><B>To be honest:&nbsp;</B>In this and the following 
rules, we are talking about the enumeration literal True declared in 
package Standard (see <A HREF="AA-A-1.html">A.1</A>), and not some other 
value or identifier True. That matters as some rules depend on full conformance 
of these expressions, which depends on the specific declarations involved. 
</div>
<div class="paranum"><a name="p2.b">2.b/3</a></div>
<div class="Annotations"><B>Aspect Description for&nbsp;</B><B>Pre:&nbsp;</B>Precondition; 
a condition that must hold true before a call.</div>
<div class="paranum"><a name="p3">3/3</a></div>
<div class="WideHanging-Term">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0254-1.TXT">AI05-0254-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0262-1.TXT">AI05-0262-1</A></I>} 
Pre'Class</div><div class="WideHanging-Body"><br clear="left">
This aspect specifies a class-wide precondition for an operation of a 
tagged type and its descendants; it shall be specified by an <SPAN Class="swiss"><A HREF="AA-4-4.html#S0117">expression</A></SPAN>, 
called a <I>class-wide precondition expression</I>.<A NAME="I3621"></A><A NAME="I3622"></A> 
If not specified for an entity, then if no other class-wide precondition 
applies to the entity, the class-wide precondition expression for the 
entity is the enumeration literal True.<A NAME="I3623"></A><A NAME="I3624"></A></div>
<div class="paranum"><a name="p3.a">3.a/3</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0254-1.TXT">AI05-0254-1</A></I>} 
If other class-wide preconditions apply to the entity and no class-wide 
precondition is specified, no class-wide precondition is defined for 
the entity; of course, the class-wide preconditions (of ancestors) that 
apply are still going to be checked. We need subprograms that don't have 
ancestors and don't specify a class-wide precondition to have a class-wide 
precondition of True, so that adding such a precondition to a descendant 
has no effect (necessary as a dispatching call through the root routine 
would not check any precondition).&nbsp;</div>
<div class="paranum"><a name="p3.b">3.b/3</a></div>
<div class="Annotations"><B>Aspect Description for&nbsp;</B><B>Pre'Class: 
</B>Precondition inherited on type derivation.</div>
<div class="paranum"><a name="p4">4/3</a></div>
<div class="WideHanging-Term">Post</div><div class="WideHanging-Body">
This aspect specifies a specific postcondition for a callable entity; 
it shall be specified by an <SPAN Class="swiss"><A HREF="AA-4-4.html#S0117">expression</A></SPAN>, 
called a <I>specific postcondition expression</I>.<A NAME="I3625"></A><A NAME="I3626"></A> 
If not specified for an entity, the specific postcondition expression 
for the entity is the enumeration literal True.<A NAME="I3627"></A><A NAME="I3628"></A></div>
<div class="paranum"><a name="p4.a">4.a/3</a></div>
<div class="Annotations"><B>Aspect Description for&nbsp;</B><B>Post:&nbsp;</B>Postcondition; 
a condition that must hold true after a call.</div>
<div class="paranum"><a name="p5">5/3</a></div>
<div class="WideHanging-Term">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0262-1.TXT">AI05-0262-1</A></I>} 
Post'Class</div><div class="WideHanging-Body"><br clear="left">
This aspect specifies a class-wide postcondition for an operation of 
a tagged type and its descendants; it shall be specified by an <SPAN Class="swiss"><A HREF="AA-4-4.html#S0117">expression</A></SPAN>, 
called a <I>class-wide postcondition expression</I>.<A NAME="I3629"></A><A NAME="I3630"></A> 
If not specified for an entity, the class-wide postcondition expression 
for the entity is the enumeration literal True.<A NAME="I3631"></A><A NAME="I3632"></A> 
</div>
<div class="paranum"><a name="p5.a">5.a/3</a></div>
<div class="Annotations"><B>Aspect Description for&nbsp;</B><B>Post'Class: 
</B>Postcondition inherited on type derivation.</div>

<H4 Class="centered">Name Resolution Rules</H4>
<div class="paranum"><a name="p6">6/3</a></div>
<div class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0145-2.TXT">AI05-0145-2</A></I>} 
The expected type for a precondition or postcondition expression is any 
boolean type.<A NAME="I3633"></A><A NAME="I3634"></A></div>
<div class="paranum"><a name="p7">7/4</a></div>
<div class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0145-2.TXT">AI05-0145-2</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0262-1.TXT">AI05-0262-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0113-1.TXT">AI12-0113-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0159-1.TXT">AI12-0159-1</A></I>} 
Within the expression for a Pre'Class or Post'Class aspect for a primitive 
subprogram <span class="insert4"><I>S</I>&nbsp;</span>of a tagged type <I>T</I>, 
a <span class="insert4"><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN></span><span class="delete4">&nbsp;name</span> 
that denotes a formal parameter <span class="insert4">(or <I>S</I>'Result) 
</span>of type <I>T</I> is interpreted as <span class="insert4">though 
it had a (notional) type <I>NT</I> that is a formal derived type whose 
ancestor type is <I>T</I>, with directly visible primitive operations</span><span class="delete4">&nbsp;having 
type <I>T</I>'Class</span>. Similarly, a <span class="insert4"><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN></span><span class="delete4">&nbsp;name</span> 
that denotes a formal access parameter <span class="insert4">(or <I>S</I>'Result) 
</span>of type access-to-<I>T</I> is interpreted as having type <span class="insert4">access-to-<I>NT</I></span><span class="delete4">&nbsp;access-to-<I>T</I>'Class</span>. 
[<span class="insert4">The result of this interpretation is that the 
only operations that can be applied to such <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>s 
are those defined for such a formal derived type.</span><span class="delete4">&nbsp;This 
ensures that the expression is well-defined for a primitive subprogram 
of a type descended from <I>T</I>.</span>]</div>
<div class="paranum"><a name="p7.a">7.a/4</a></div>
<div class="Annotations"><span class="insert4"><B>Reason:&nbsp;</B></span>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0159-1.TXT">AI12-0159-1</A></I>} 
<span class="insert4">This ensures that the expression is well-defined 
for any primitive subprogram of a type descended from <I>T</I>.</span> 
</div>
<div class="paranum"><a name="p8">8/3</a></div>
<div class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0145-2.TXT">AI05-0145-2</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0264-1.TXT">AI05-0264-1</A></I>} 
For an attribute_reference with attribute_designator Old, if the attribute 
reference has an expected type or shall resolve to a given type, the 
same applies to the <SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN>; 
otherwise, the <SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN> 
shall be resolved independently of context.</div>

<H4 Class="centered">Legality Rules</H4>
<div class="paranum"><a name="p9">9/3</a></div>
<div class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0145-2.TXT">AI05-0145-2</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0230-1.TXT">AI05-0230-1</A></I>} 
The Pre or Post aspect shall not be specified for an abstract subprogram 
or a null procedure. [Only the Pre'Class and Post'Class aspects may be 
specified for such a subprogram.]</div>
<div class="paranum"><a name="p9.a">9.a/3</a></div>
<div class="Annotations"><B>Discussion:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0183-1.TXT">AI05-0183-1</A></I>} 
Pre'Class and Post'Class can only be specified on primitive routines 
of tagged types, by a blanket rule found in <A HREF="AA-13-1-1.html">13.1.1</A>. 
</div>
<div class="paranum"><a name="p10">10/3</a></div>
<div class="Normal" style="margin-bottom: 0.4em">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0247-1.TXT">AI05-0247-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0254-1.TXT">AI05-0254-1</A></I>} 
If a type <I>T</I> has an implicitly declared subprogram <I>P</I> inherited 
from a parent type <I>T1</I> and a homograph (see <A HREF="AA-8-3.html">8.3</A>) 
of <I>P</I> from a progenitor type <I>T2</I>, and</div>
<div class="paranum"><a name="p11">11/3</a></div>
<div class="Bulleted">the corresponding primitive subprogram <I>P1</I> 
of type <I>T1</I> is neither null nor abstract; and</div>
<div class="paranum"><a name="p12">12/3</a></div>
<div class="Bulleted">the class-wide precondition expression True does 
not apply to <I>P1</I> (implicitly or explicitly); and</div>
<div class="paranum"><a name="p13">13/3</a></div>
<div class="Bulleted">there is a class-wide precondition expression that 
applies to the corresponding primitive subprogram <I>P2</I> of <I>T2</I> 
that does not fully conform to any class-wide precondition expression 
that applies to <I>P1</I>,&nbsp;</div>
<div class="paranum"><a name="p14">14/3</a></div>
<div class="Normal" style="margin-bottom: 0.4em">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0247-1.TXT">AI05-0247-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0254-1.TXT">AI05-0254-1</A></I>} 
then:</div>
<div class="paranum"><a name="p15">15/3</a></div>
<div class="Bulleted">If the type <I>T</I> is abstract, the implicitly 
declared subprogram <I>P</I> is <I>abstract</I>.</div>
<div class="paranum"><a name="p16">16/3</a></div>
<div class="Bulleted">Otherwise, the subprogram <I>P</I> <I>requires 
overriding</I> and shall be overridden with a nonabstract subprogram.<A NAME="I3635"></A></div>
<div class="paranum"><a name="p16.a">16.a/3</a></div>
<div class="Annotations"><B>Discussion:&nbsp;</B>We use the term &quot;requires 
overriding&quot; here so that this rule is taken into account when calculating 
visibility in <A HREF="AA-8-3.html">8.3</A>; otherwise we would have 
a mess when this routine is overridden.&nbsp;</div>
<div class="paranum"><a name="p16.b">16.b/3</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>Such an inherited subprogram 
would necessarily violate the Liskov Substitutability Principle (LSP) 
if called via a dispatching call from an ancestor other than the one 
that provides the called body. In such a case, the class-wide precondition 
of the actual body is stronger than the class-wide precondition of the 
ancestor. If we did not enforce that precondition for the body, the body 
could be called when the precondition it knows about is False &mdash; 
such &quot;counterfeiting&quot; of preconditions has to be avoided. But 
enforcing the precondition violates LSP. We do not want the language 
to be implicitly creating bodies that violate LSP; the programmer can 
still write an explicit body that calls the appropriate parent subprogram. 
In that case, the violation of LSP is explicitly in the code and obvious 
to code reviewers (both human and automated).</div>
<div class="paranum"><a name="p16.c">16.c/3</a></div>
<div class="Annotations">We have to say that the subprogram is abstract 
for an abstract type in this case, so that the next concrete type has 
to override it for the reasons above. Otherwise, inserting an extra level 
of abstract types would eliminate the requirement to override (as there 
is only one declared operation for the concrete type), and that would 
be bad for the reasons given above.&nbsp;</div>
<div class="paranum"><a name="p16.d">16.d/3</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>This requires the set of 
class-wide preconditions that apply to the interface routine to be strictly 
stronger than those that apply to the concrete routine. Since full conformance 
requires each name to denote the same declaration, it is unlikely that 
independently declared preconditions would conform. This rule does allow 
&quot;diamond inheritance&quot; of preconditions, and of course no preconditions 
at all match.</div>
<div class="paranum"><a name="p16.e">16.e/3</a></div>
<div class="Annotations">We considered adopting a rule that would allow 
examples where the expressions would conform after all inheritance has 
been applied, but this is complex and is not likely to be common in practice. 
Since the penalty here is just that an explicit overriding is required, 
the complexity is too much.&nbsp;</div>
<div class="paranum"><a name="p17">17/3</a></div>
<div class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0247-1.TXT">AI05-0247-1</A></I>} 
If a renaming of a subprogram or entry <I>S1</I> overrides an inherited 
subprogram <I>S2</I>, then the overriding is illegal unless each class-wide 
precondition expression that applies to <I>S1</I> fully conforms to some 
class-wide precondition expression that applies to <I>S2</I> and each 
class-wide precondition expression that applies to <I>S2</I> fully conforms 
to some class-wide precondition expression that applies to <I>S1</I>.</div>
<div class="paranum"><a name="p17.a">17.a/3</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>Such an overriding subprogram 
would violate LSP, as the precondition of <I>S1</I> would usually be 
different (and thus stronger) than the one known to a dispatching call 
through an ancestor routine of <I>S2</I>. This is always OK if the preconditions 
match, so we always allow that.&nbsp;</div>
<div class="paranum"><a name="p17.b">17.b/3</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>This only applies to primitives 
of tagged types; other routines cannot have class-wide preconditions. 
</div>
<div class="paranum"><a name="p17.1">17.1/4</a></div>
<div class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0131-1.TXT">AI12-0131-1</A></I>} 
<span class="insert4">Pre'Class shall not be specified for an overriding 
primitive subprogram of a tagged type <I>T</I> unless the Pre'Class aspect 
is specified for the corresponding primitive subprogram of some ancestor 
of <I>T</I>.</span></div>
<div class="paranum"><a name="p17.c">17.c/4</a></div>
<div class="Annotations"><span class="insert4"><B>Reason:&nbsp;</B>Any such 
Pre'Class will have no effect, as it will be <B>or</B>ed with True. As 
such, it is highly misleading for readers, especially for those who are 
determining the assumptions that can be made in the body of the primitive 
subprogram. Note that in this case there is nothing explicit that might 
indicate that the class-wide precondition is ineffective. This rule does 
not prevent explicitly writing an ineffective class-wide precondition 
(for instance, if the parent subprogram has explicitly specified a precondition 
of True).</span>&nbsp;</div>
<div class="paranum"><a name="p17.2">17.2/4</a></div>
<div class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0131-1.TXT">AI12-0131-1</A></I>} 
<span class="insert4"><A NAME="I3636"></A>In addition to the places where 
Legality Rules normally apply (see <A HREF="AA-12-3.html">12.3</A>), 
these rules also apply in the private part of an instance of a generic 
unit.</span>&nbsp;</div>

<H4 Class="centered">Static Semantics</H4>
<div class="paranum"><a name="p18">18/4</a></div>
<div class="Normal" style="margin-bottom: 0.4em">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0145-2.TXT">AI05-0145-2</A></I>} 
<span class="insert4"></span>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0113-1.TXT">AI12-0113-1</A></I>} 
<span class="insert4"></span>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0131-1.TXT">AI12-0131-1</A></I>} 
<span class="insert4"></span>If a Pre'Class or Post'Class aspect is specified 
for a primitive subprogram <span class="insert4"><I>S</I>&nbsp;</span>of a 
tagged type <I>T</I>, <span class="insert4">or such an aspect defaults 
to True,&nbsp;</span>then <span class="insert4">a corresponding</span><span class="delete4">&nbsp;the 
associated</span> expression also applies to the corresponding primitive 
subprogram <span class="insert4"><I>S</I>&nbsp;</span>of each descendant of 
<I>T</I>.<span class="insert4">&nbsp;The <I>corresponding expression</I> is 
constructed from the associated expression as follows:<A NAME="I3637"></A> 
<A NAME="I3638"></A></span></div>
<div class="paranum"><a name="p18.a">18.a/4</a></div>
<div class="Annotations"><span class="insert4"><B>Ramification:&nbsp;</B>A 
Pre'Class defaults to True only if no class-wide preconditions are inherited 
for the subprogram. The same is true for Post'Class.</span>&nbsp;</div>
<div class="paranum"><a name="p18.b">18.b/4</a></div>
<div class="Annotations"><span class="insert4"><B>Reason:&nbsp;</B>We have 
to inherit precondition expressions that default to True, so that later 
overridings don't strengthen the precondition (a violation of LSP). We 
do the same for postconditions for consistency.</span>&nbsp;</div>
<div class="paranum"><a name="p18.1">18.1/4</a></div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0113-1.TXT">AI12-0113-1</A></I>} 
<span class="insert4">References to formal parameters of <I>S</I> (or 
to <I>S</I> itself) are replaced with references to the corresponding 
formal parameters of the corresponding inherited or overriding subprogram 
<I>S</I> (or to the corresponding subprogram <I>S</I> itself).</span></div>
<div class="paranum"><a name="p18.c">18.c/4</a></div>
<div class="Annotations"><span class="insert4"><B>Reason:&nbsp;</B>We have 
to define the corresponding expression this way as overriding routines 
are only required to be subtype conformant; in particular, the parameter 
names can be different. So we have to talk about corresponding parameters 
without mentioning any names.</span>&nbsp;</div>
<div class="paranum"><a name="p18.2">18.2/4</a></div>
<div class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0113-1.TXT">AI12-0113-1</A></I>} 
<span class="insert4">The primitive subprogram <I>S</I> is illegal if 
it is not abstract and the corresponding expression for a Pre'Class or 
Post'Class aspect would be illegal.</span></div>
<div class="paranum"><a name="p18.d">18.d/4</a></div>
<div class="Annotations"><span class="insert4"><B>Ramification:&nbsp;</B>This 
can happen, for instance, if one of the subprograms called in the corresponding 
expression is abstract. We made the rule general so that we don't have 
to worry about exactly which cases can cause this to happen, both now 
and in the future.</span>&nbsp;</div>
<div class="paranum"><a name="p18.e">18.e/4</a></div>
<div class="Annotations"><span class="insert4"><B>Reason:&nbsp;</B>We allow 
illegal corresponding expressions on abstract subprograms as they could 
never be evaluated, and we need to allow such expressions to contain 
calls to abstract subprograms.</span>&nbsp;</div>
<div class="paranum"><a name="p19">19/3</a></div>
<div class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0145-2.TXT">AI05-0145-2</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0262-1.TXT">AI05-0262-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0290-1.TXT">AI05-0290-1</A></I>} 
If performing checks is required by the Pre, Pre'Class, Post, or Post'Class 
assertion policies (see <A HREF="AA-11-4-2.html">11.4.2</A>) in effect 
at the point of a corresponding aspect specification applicable to a 
given subprogram or entry, then the respective precondition or postcondition 
expressions are considered <I>enabled</I>.<A NAME="I3639"></A><A NAME="I3640"></A></div>
<div class="paranum"><a name="p19.a">19.a/3</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0290-1.TXT">AI05-0290-1</A></I>} 
If a class-wide precondition or postcondition expression is enabled, 
it remains enabled when inherited by an overriding subprogram, even if 
the policy in effect is Ignore for the inheriting subprogram.&nbsp;</div>
<div class="paranum"><a name="p20">20/3</a></div>
<div class="Normal" style="margin-bottom: 0.4em">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0273-1.TXT">AI05-0273-1</A></I>} 
An <SPAN Class="swiss"><A HREF="AA-4-4.html#S0117">expression</A></SPAN> 
is <I>potentially unevaluated</I> if it occurs within:<A NAME="I3641"></A></div>
<div class="paranum"><a name="p21">21/3</a></div>
<div class="Bulleted">any part of an <SPAN Class="swiss"><A HREF="AA-4-5-7.html#S0134">if_expression</A></SPAN> 
other than the first <SPAN Class="swiss"><A HREF="AA-4-5-7.html#S0135">condition</A></SPAN>;</div>
<div class="paranum"><a name="p22">22/3</a></div>
<div class="Bulleted">a <I>dependent_</I><SPAN Class="swiss"><A HREF="AA-4-4.html#S0117">expression</A></SPAN> 
of a <SPAN Class="swiss"><A HREF="AA-4-5-7.html#S0136">case_expression</A></SPAN>;</div>
<div class="paranum"><a name="p22.1">22.1/4</a></div>
<div class="Bulleted">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0032-1.TXT">AI12-0032-1</A></I>} 
<span class="insert4">a <SPAN Class="swiss"><A HREF="AA-4-5-8.html#S0140">predicate</A></SPAN> 
of a <SPAN Class="swiss"><A HREF="AA-4-5-8.html#S0138">quantified_expression</A></SPAN>;</span></div>
<div class="paranum"><a name="p23">23/3</a></div>
<div class="Bulleted">the right operand of a short-circuit control form; 
or</div>
<div class="paranum"><a name="p24">24/3</a></div>
<div class="Bulleted">a <SPAN Class="swiss"><A HREF="AA-4-4.html#S0122">membership_choice</A></SPAN> 
other than the first of a membership operation.&nbsp;</div>
<div class="paranum"><a name="p25">25/3</a></div>
<div class="Normal" style="margin-bottom: 0.4em">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0145-2.TXT">AI05-0145-2</A></I>} 
For a <SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN> 
X that denotes an object of a nonlimited type, the following attribute 
is defined:&nbsp;</div>
<div class="paranum"><a name="p26">26/4</a></div>
<div class="WideHanging-Term">&nbsp;X'Old</div><div class="WideHanging-Body">
<A NAME="I3642"></A><A NAME="I3643"></A>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0145-2.TXT">AI05-0145-2</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0262-1.TXT">AI05-0262-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0273-1.TXT">AI05-0273-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0032-1.TXT">AI12-0032-1</A></I>} 
<span class="insert4">Each</span><span class="delete4">&nbsp;For each</span> 
X'Old in a postcondition expression that is enabled<span class="insert4">&nbsp;denotes</span><span class="delete4">,</span> a constant <span class="insert4">that 
</span>is implicitly declared at the beginning of the subprogram <span class="insert4">body,</span><span class="delete4">&nbsp;or</span> 
entry<span class="insert4">&nbsp;body, or accept statement</span>.<span class="delete4">&nbsp;The constant is of the type of X and is initialized to the result of 
evaluating X (as an expression) at the point of the constant declaration. 
The value of X'Old in the postcondition expression is the value of this 
constant; the type of X'Old is the type of X. These implicit constant 
declarations occur in an arbitrary order.<A NAME="I3644"></A></span></div>
<div class="paranum"><a name="p26.1">26.1/4</a></div>
<div class="WideHanging-Body" style="margin-bottom: 0.4em">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0032-1.TXT">AI12-0032-1</A></I>} 
<span class="insert4"></span>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0159-1.TXT">AI12-0159-1</A></I>} 
<span class="insert4">The implicitly declared entity denoted by each 
occurrence of X'Old is declared as follows:</span></div>
<div class="paranum"><a name="p26.2">26.2/4</a></div>
<div class="Indented4Bulleted" style="margin-bottom: 0.3em"><span class="insert4">If 
X is of an anonymous access type defined by an <SPAN Class="swiss"><A HREF="AA-3-10.html#S0084">access_definition</A></SPAN> 
<I>A</I> then</span>&nbsp;</div>
<div class="paranum"><a name="p26.3">26.3/4</a></div>
<div class="Indented5Examples"><span class="insert4"><I>X'Old</I>&nbsp;:&nbsp;<B>constant</B>&nbsp;<I>A</I>&nbsp;:=&nbsp;X;</span></div>
<div class="paranum"><a name="p26.4">26.4/4</a></div>
<div class="Indented4Bulleted" style="margin-bottom: 0.3em"><span class="insert4">If 
X is of a specific tagged type <I>T</I> then</span>&nbsp;</div>
<div class="paranum"><a name="p26.5">26.5/4</a></div>
<div class="Indented5Examples"><span class="insert4"><SPAN Class="roman"><I>anonymous</I></SPAN>&nbsp;:&nbsp;<B>constant</B>&nbsp;<I>T</I>'Class&nbsp;:=&nbsp;<I>T</I>'Class(X);<BR>
<I>X'Old</I>&nbsp;:&nbsp;<I>T</I>&nbsp;<B>renames</B>&nbsp;<I>T</I>(<SPAN Class="roman"><I>anonymous</I></SPAN>);</span></div>
<div class="paranum"><a name="p26.6">26.6/4</a></div>
<div class="Indented4Bulleted-NoPrefix"><span class="insert4">where the 
name X'Old denotes the object renaming.</span>&nbsp;</div>
<div class="paranum"><a name="p26.a">26.a/4</a></div>
<div class="Annotations"><span class="insert4"><B>Ramification:&nbsp;</B>This 
means that the underlying tag associated with X'Old is that of X and 
not that of the nominal type of X.</span>&nbsp;</div>
<div class="paranum"><a name="p26.7">26.7/4</a></div>
<div class="Indented4Bulleted" style="margin-bottom: 0.3em"><span class="insert4">Otherwise</span> 
</div>
<div class="paranum"><a name="p26.8">26.8/4</a></div>
<div class="Indented5Examples"><span class="insert4"><I>X'Old</I>&nbsp;:&nbsp;<B>constant</B>&nbsp;<I>S</I>&nbsp;:=&nbsp;X;</span></div>
<div class="paranum"><a name="p26.9">26.9/4</a></div>
<div class="Indented4Bulleted-NoPrefix"><span class="insert4">where <I>S</I> 
is the nominal subtype of X. This includes the case where the type of 
<I>S</I> is an anonymous array type or a universal type.</span>&nbsp;</div>
<div class="paranum"><a name="p26.10">26.10/4</a></div>
<div class="WideHanging-Body">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0032-1.TXT">AI12-0032-1</A></I>} 
<span class="insert4">The nominal subtype of X'Old is as implied by the 
above definitions. The expected type of the prefix of an Old attribute 
is that of the attribute. Similarly, if an Old attribute shall resolve 
to be of some type, then the prefix of the attribute shall resolve to 
be of that type.</span></div>
<div class="paranum"><a name="p27">27/3</a></div>
<div class="WideHanging-Body">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0145-2.TXT">AI05-0145-2</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0262-1.TXT">AI05-0262-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0273-1.TXT">AI05-0273-1</A></I>} 
Reference to this attribute is only allowed within a postcondition expression. 
The <SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN> 
of an Old <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0100">attribute_reference</A></SPAN> 
shall not contain a Result <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0100">attribute_reference</A></SPAN>, 
nor an Old <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0100">attribute_reference</A></SPAN>, 
nor a use of an entity declared within the postcondition expression but 
not within <SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN> 
itself (for example, the loop parameter of an enclosing <SPAN Class="swiss"><A HREF="AA-4-5-8.html#S0138">quantified_expression</A></SPAN>). 
The <SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN> 
of an Old <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0100">attribute_reference</A></SPAN> 
that is potentially unevaluated shall statically denote an entity.</div>
<div class="paranum"><a name="p27.a">27.a/3</a></div>
<div class="Annotations"><B>Discussion:&nbsp;</B>The <SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN> 
X can be any nonlimited object that obeys the syntax for prefix other 
than the few exceptions given above (discussed below). Useful cases are: 
the <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> of 
a formal parameter of mode [<B>in</B>] <B>out</B>, the <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
of a global variable updated by the subprogram, a function call passing 
those as parameters, a subcomponent of those things, etc.</div>
<div class="paranum"><a name="p27.b">27.b/3</a></div>
<div class="Annotations">A qualified expression can be used to make an 
arbitrary expression into a valid prefix, so T'(X + Y)'Old is legal, 
even though (X + Y)'Old is not. The value being saved here is the sum 
of X and Y (a function result is an object). Of course, in this case 
&quot;+&quot;(X, Y)'Old is also legal, but the qualified expression is 
arguably more readable.</div>
<div class="paranum"><a name="p27.c">27.c/3</a></div>
<div class="Annotations">Note that F(X)'Old and F(X'Old) are not necessarily 
equal. The former calls F(X) and saves that value for later use during 
the postcondition. The latter saves the value of X, and during the postcondition, 
passes that saved value to F. In most cases, the former is what one wants 
(but it is not always legal, see below).</div>
<div class="paranum"><a name="p27.d">27.d/4</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0032-1.TXT">AI12-0032-1</A></I>} 
If X has controlled parts, adjustment and finalization are implied by 
the implicit constant declaration.<span class="insert4">&nbsp;Similarly, the 
implicit constant declaration defines the accessibility level of X'Old.</span></div>
<div class="paranum"><a name="p27.e">27.e/3</a></div>
<div class="Annotations">If postconditions are disabled, we want the 
compiler to avoid any overhead associated with saving 'Old values.</div>
<div class="paranum"><a name="p27.f">27.f/3</a></div>
<div class="Annotations">'Old makes no sense for limited types, because 
its implementation involves copying. It might make semantic sense to 
allow build-in-place, but it's not worth the trouble.&nbsp;</div>
<div class="paranum"><a name="p27.g">27.g/3</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0273-1.TXT">AI05-0273-1</A></I>} 
Since the <SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN> 
is evaluated unconditionally when the subprogram is called, we cannot 
allow it to include values that do not exist at that time (like 'Result 
and loop parameters of <SPAN Class="swiss"><A HREF="AA-4-5-8.html#S0138">quantified_expression</A></SPAN>s). 
We also do not allow it to include 'Old references, as those would be 
redundant (the entire <SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN> 
is evaluated when the subprogram is called), and allowing them would 
require some sort of order to the implicit constant declarations (because 
in A(I'Old)'Old, we surely would want the value of I'Old evaluated before 
the A(I'Old) is evaluated).</div>
<div class="paranum"><a name="p27.h">27.h/3</a></div>
<div class="Annotations" style="margin-bottom: 0.4em">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0273-1.TXT">AI05-0273-1</A></I>} 
In addition, we only allow simple names as the <SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN> 
of the Old attribute if the <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0100">attribute_reference</A></SPAN> 
might not be evaluated when the postcondition expression is evaluated. 
This is necessary because the Old <SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN>es 
have to be unconditionally evaluated when the subprogram is called; the 
compiler cannot in general know whether they will be needed in the postcondition 
expression. To see the problem, consider:</div>
<div class="paranum"><a name="p27.i">27.i/3</a></div>
<div class="SmallExamples">Table&nbsp;:&nbsp;<B>array</B>&nbsp;(1..10)&nbsp;<B>of</B>&nbsp;Integer&nbsp;:=&nbsp;...<BR>
<B>procedure</B>&nbsp;Bar&nbsp;(I&nbsp;:&nbsp;<B>in&nbsp;out</B>&nbsp;Natural)<BR>
&nbsp;&nbsp;&nbsp;<B>with</B>&nbsp;Post&nbsp;=&gt;&nbsp;I&nbsp;&gt;&nbsp;0&nbsp;<B>and&nbsp;then</B>&nbsp;Table(I)'Old&nbsp;=&nbsp;1;&nbsp;--&nbsp;<SPAN Class="roman"><I>Illegal</I></SPAN></div>
<div class="paranum"><a name="p27.j">27.j/3</a></div>
<div class="Annotations" style="margin-bottom: 0.9em">In this example, 
the compiler cannot know the value of I when the subprogram returns (since 
the subprogram execution can change it), and thus it does not know whether 
Table(I)'Old will be needed then. Thus it has to always create an implicit 
constant and evaluate Table(I) when Bar is called (because not having 
the value when it is needed is not acceptable). But if I = 0 when the 
subprogram is called, that evaluation will raise Constraint_Error, and 
that will happen even if I is unchanged by the subprogram and the value 
of Table(I)'Old is not ultimately needed. It's easy to see how a similar 
problem could occur for a dereference of an access type. This would be 
mystifying (since the point of the short circuit is to eliminate this 
possibility, but it cannot do so). Therefore, we require the <SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN> 
of any Old attribute in such a context to statically denote an object, 
which eliminates anything that could change at during execution.</div>
<div class="paranum"><a name="p27.k">27.k/3</a></div>
<div class="Annotations">It is easy to work around most errors that occur 
because of this rule. Just move the 'Old to the outer object, before 
any indexing, dereferences, or components. (That does not work for function 
calls, however, nor does it work for array indexing if the index can 
change during the execution of the subprogram.)&nbsp;</div>
<div class="paranum"><a name="p27.l">27.l/4</a></div>
<div class="Annotations" style="margin-bottom: 0.4em"><span class="insert4"><B>Ramification: 
</B></span>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0032-1.TXT">AI12-0032-1</A></I>} 
<span class="insert4">An accept statement for a task entry with enabled 
postconditions such as</span>&nbsp;</div>
<div class="paranum"><a name="p27.m">27.m/4</a></div>
<div class="SmallExamples"><span class="insert4"><B>accept</B>&nbsp;E&nbsp;<B>do</B><BR>
&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><I>statements</I></SPAN><BR>
<B>exception</B><BR>
&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><I>handlers</I></SPAN><BR>
<B>end</B>;</span></div>
<div class="paranum"><a name="p27.n">27.n/4</a></div>
<div class="Annotations" style="margin-bottom: 0.4em"><span class="insert4">behaves 
(at runtime) as follows:</span>&nbsp;</div>
<div class="paranum"><a name="p27.o">27.o/4</a></div>
<div class="SmallExamples"><span class="insert4"><B>accept</B>&nbsp;E&nbsp;<B>do</B><BR>
&nbsp;&nbsp;&nbsp;<B>declare</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><I>declarations,&nbsp;if&nbsp;any,&nbsp;of&nbsp;'Old&nbsp;constants</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><I>statements</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>exception</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><I>handlers</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>end</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><I>postcondition&nbsp;checks</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;<B>end</B>;<BR>
<B>end</B>;</span></div>
<div class="paranum"><a name="p27.p">27.p/4</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0032-1.TXT">AI12-0032-1</A></I>} 
<span class="insert4">Preconditions are checked by the caller before 
the rendezvous begins. Postcondition expressions might, of course, reference 
'Old constants.</span></div>
<div class="paranum"><a name="p27.q">27.q/4</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0032-1.TXT">AI12-0032-1</A></I>} 
<span class="insert4">In the case of a protected operation with enabled 
postconditions, 'Old constant declarations (if any) are elaborated after 
the start of the protected action. Postcondition checks (which might 
reference these constants) are performed before the end of the protected 
action as described below.</span>&nbsp;</div>
<div class="paranum"><a name="p28">28/3</a></div>
<div class="Normal" style="margin-bottom: 0.4em">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0145-2.TXT">AI05-0145-2</A></I>} 
For a <SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN> 
F that denotes a function declaration, the following attribute is defined: 
</div>
<div class="paranum"><a name="p29">29/3</a></div>
<div class="WideHanging-Term">&nbsp;F'Result</div><div class="WideHanging-Body">
<A NAME="I3645"></A><A NAME="I3646"></A>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0145-2.TXT">AI05-0145-2</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0262-1.TXT">AI05-0262-1</A></I>} 
Within a postcondition expression for function F, denotes the result 
object of the function. The type of this attribute is that of the function 
result except within a Post'Class postcondition expression for a function 
with a controlling result or with a controlling access result. For a 
controlling result, the type of the attribute is <I>T</I>'Class, where 
<I>T</I> is the function result type. For a controlling access result, 
the type of the attribute is an anonymous access type whose designated 
type is <I>T</I>'Class, where <I>T</I> is the designated type of the 
function result type.</div>
<div class="paranum"><a name="p30">30/3</a></div>
<div class="WideHanging-Body">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0262-1.TXT">AI05-0262-1</A></I>} 
Use of this attribute is allowed only within a postcondition expression 
for F.&nbsp;</div>

<H4 Class="centered">Dynamic Semantics</H4>
<div class="paranum"><a name="p31">31/3</a></div>
<div class="Normal" style="margin-bottom: 0.4em">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0145-2.TXT">AI05-0145-2</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0247-1.TXT">AI05-0247-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0290-1.TXT">AI05-0290-1</A></I>} 
Upon a call of the subprogram or entry, after evaluating any actual parameters, 
precondition checks are performed as follows:</div>
<div class="paranum"><a name="p32">32/3</a></div>
<div class="Bulleted">The specific precondition check begins with the 
evaluation of the specific precondition expression that applies to the 
subprogram or entry, if it is enabled; if the expression evaluates to 
False, Assertions.Assertion_Error is raised; if the expression is not 
enabled, the check succeeds.<A NAME="I3647"></A><A NAME="I3648"></A><A NAME="I3649"></A></div>
<div class="paranum"><a name="p33">33/3</a></div>
<div class="Bulleted">The class-wide precondition check begins with the 
evaluation of any enabled class-wide precondition expressions that apply 
to the subprogram or entry. If and only if all the class-wide precondition 
expressions evaluate to False, Assertions.Assertion_Error is raised.<A NAME="I3650"></A><A NAME="I3651"></A><A NAME="I3652"></A></div>
<div class="paranum"><a name="p33.a">33.a/3</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>The class-wide precondition 
expressions of the entity itself as well as those of any parent or progenitor 
operations are evaluated, as these expressions apply to the corresponding 
operations of all descendants.</div>
<div class="paranum"><a name="p33.b">33.b/3</a></div>
<div class="Annotations">Class-wide precondition checks are performed 
for all appropriate calls, but only enabled precondition expressions 
are evaluated. Thus, the check would be trivial if no precondition expressions 
are enabled.&nbsp;</div>
<div class="paranum"><a name="p34">34/3</a></div>
<div class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0145-2.TXT">AI05-0145-2</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0247-1.TXT">AI05-0247-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0254-1.TXT">AI05-0254-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0269-1.TXT">AI05-0269-1</A></I>} 
The precondition checks are performed in an arbitrary order, and if any 
of the class-wide precondition expressions evaluate to True, it is not 
specified whether the other class-wide precondition expressions are evaluated. 
The precondition checks and any check for elaboration of the subprogram 
body are performed in an arbitrary order. It is not specified whether 
in a call on a protected operation, the checks are performed before or 
after starting the protected action. For an entry call, the checks are 
performed prior to checking whether the entry is open.<A NAME="I3653"></A><A NAME="I3654"></A></div>
<div class="paranum"><a name="p34.a">34.a/3</a></div>
<div class="Annotations"><B>Reason:&nbsp;</B>We need to explicitly allow short-circuiting 
of the evaluation of the class-wide precondition check if any expression 
fails, as it consists of multiple expressions; we don't need a similar 
permission for the specific precondition check as it consists only of 
a single expression. Nothing is evaluated for the call after a check 
fails, as the failed check propagates an exception.&nbsp;</div>
<div class="paranum"><a name="p35">35/3</a></div>
<div class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0145-2.TXT">AI05-0145-2</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0247-1.TXT">AI05-0247-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0254-1.TXT">AI05-0254-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0262-1.TXT">AI05-0262-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0290-1.TXT">AI05-0290-1</A></I>} 
Upon successful return from a call of the subprogram or entry, prior 
to copying back any by-copy <B>in out</B> or <B>out</B> parameters, the 
postcondition check is performed. This consists of the evaluation of 
any enabled specific and class-wide postcondition expressions that apply 
to the subprogram or entry. If any of the postcondition expressions evaluate 
to False, then Assertions.Assertion_Error is raised. The postcondition 
expressions are evaluated in an arbitrary order, and if any postcondition 
expression evaluates to False, it is not specified whether any other 
postcondition expressions are evaluated. The postcondition check, and 
any constraint or predicate checks associated with <B>in out</B> or <B>out</B> 
parameters are performed in an arbitrary order.<A NAME="I3655"></A><A NAME="I3656"></A><A NAME="I3657"></A><A NAME="I3658"></A><A NAME="I3659"></A></div>
<div class="paranum"><a name="p35.a">35.a/3</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>The class-wide postcondition 
expressions of the entity itself as well as those of any parent or progenitor 
operations are evaluated, as these apply to all descendants; in contrast, 
only the specific postcondition of the entity applies. Postconditions 
can always be evaluated inside the invoked body.&nbsp;</div>
<div class="paranum"><a name="p35.1">35.1/4</a></div>
<div class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0032-1.TXT">AI12-0032-1</A></I>} 
<span class="insert4">For a call to a task entry, the postcondition check 
is performed before the end of the rendezvous; for a call to a protected 
operation, the postcondition check is performed before the end of the 
protected action of the call. The postcondition check for any call is 
performed before the finalization of any implicitly-declared constants 
associated (as described above) with Old <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0100">attribute_reference</A></SPAN>s 
but after the finalization of any other entities whose accessibility 
level is that of the execution of the callable construct.</span>&nbsp;</div>
<div class="paranum"><a name="p35.a.1">35.a.1/4</a></div>
<div class="Annotations"><span class="insert4"><B>Reason:&nbsp;</B></span>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0032-1.TXT">AI12-0032-1</A></I>} 
<span class="insert4">If a postcondition references the implicitly-declared 
constant associated with an Old attribute, the postcondition must be 
evaluated before the constant is finalized. One way to think of this 
is to imagine declaring a controlled object between any implicit &quot;'Old&quot; 
constant declarations and any explicit declarations, then performing 
postcondition checks during the finalization of this object.</span>&nbsp;</div>
<div class="paranum"><a name="p36">36/3</a></div>
<div class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0145-2.TXT">AI05-0145-2</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0262-1.TXT">AI05-0262-1</A></I>} 
If a precondition or postcondition check fails, the exception is raised 
at the point of the call[; the exception cannot be handled inside the 
called subprogram or entry]. Similarly, any exception raised by the evaluation 
of a precondition or postcondition expression is raised at the point 
of call.</div>
<div class="paranum"><a name="p37">37/4</a></div>
<div class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0145-2.TXT">AI05-0145-2</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0247-1.TXT">AI05-0247-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0254-1.TXT">AI05-0254-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0262-1.TXT">AI05-0262-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0113-1.TXT">AI12-0113-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0159-1.TXT">AI12-0159-1</A></I>} 
For any<span class="insert4">&nbsp;call to a</span> subprogram or entry <span class="insert4"><I>S</I></span><span class="delete4">&nbsp;call</span> 
(including dispatching calls), the checks that are performed to verify 
specific precondition expressions and specific and class-wide postcondition 
expressions are determined by those for the subprogram or entry actually 
invoked. Note that the class-wide postcondition expressions verified 
by the postcondition check that is part of a call on a primitive subprogram 
of type <I>T</I> includes all class-wide postcondition expressions originating 
in any progenitor of <I>T</I>[, even if the primitive subprogram called 
is inherited from a type <I>T1</I> and some of the postcondition expressions 
do not apply to the corresponding primitive subprogram of <I>T1</I>].<span class="insert4">&nbsp;Any operations within a class-wide postcondition expression that were 
resolved as primitive operations of the (notional) formal derived type 
<I>NT</I>, are in the evaluation of the postcondition bound to the corresponding 
operations of the type identified by the controlling tag of the call 
on <I>S</I>.[ This applies to both dispatching and non-dispatching calls 
on <I>S</I>.]</span></div>
<div class="paranum"><a name="p37.a">37.a/3</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>This applies to access-to-subprogram 
calls, dispatching calls, and to statically bound calls. We need this 
rule to cover statically bound calls as well, as specific pre- and postconditions 
are not inherited, but the subprogram might be.</div>
<div class="paranum"><a name="p37.b">37.b/3</a></div>
<div class="Annotations">For concrete subprograms, we require the original 
specific postcondition to be evaluated as well as the inherited class-wide 
postconditions in order that the semantics of an explicitly defined wrapper 
that does nothing but call the original subprogram is the same as that 
of an inherited subprogram.</div>
<div class="paranum"><a name="p37.c">37.c/3</a></div>
<div class="Annotations">Note that this rule does not apply to class-wide 
preconditions; they have their own rules mentioned below.&nbsp;</div>
<div class="paranum"><a name="p38">38/4</a></div>
<div class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0145-2.TXT">AI05-0145-2</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0247-1.TXT">AI05-0247-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0254-1.TXT">AI05-0254-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0113-1.TXT">AI12-0113-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0159-1.TXT">AI12-0159-1</A></I>} 
The class-wide precondition check for a call to a subprogram or entry 
<span class="insert4"><I>S</I>&nbsp;</span>consists solely of checking the 
class-wide precondition expressions that apply to the denoted callable 
entity (not necessarily <span class="insert4">to&nbsp;</span>the one that 
is invoked).<span class="insert4">&nbsp;Any operations within such an expression 
that were resolved as primitive operations of the (notional) formal derived 
type <I>NT</I> are in the evaluation of the precondition bound to the 
corresponding operations of the type identified by the controlling tag 
of the call on <I>S</I>.[ This applies to both dispatching and non-dispatching 
calls on <I>S</I>.]</span></div>
<div class="paranum"><a name="p38.a">38.a/3</a></div>
<div class="Annotations"><B>Ramification:&nbsp;</B>For a dispatching call, 
we are talking about the Pre'Class(es) that apply to the subprogram that 
the dispatching call is resolving to, not the Pre'Class(es) for the subprogram 
that is ultimately dispatched to. The class-wide precondition of the 
resolved call is necessarily the same or stronger than that of the invoked 
call. For a statically bound call, these are the same; for an access-to-subprogram, 
(which has no class-wide preconditions of its own), we check the class-wide 
preconditions of the invoked routine.&nbsp;</div>
<div class="paranum"><a name="p38.b">38.b/3</a></div>
<div class="Annotations"><B>Implementation Note:&nbsp;</B>These rules imply 
that logically, class-wide preconditions of routines must be checked 
at the point of call (other than for access-to-subprogram calls, which 
must be checked in the body, probably using a wrapper). Specific preconditions 
that might be called with a dispatching call or via an access-to-subprogram 
value must be checked inside of the subprogram body. In contrast, the 
postcondition checks always need to be checked inside the body of the 
routine. Of course, an implementation can evaluate all of these at the 
point of call for statically bound calls if the implementation uses wrappers 
for dispatching bodies and for 'Access values.</div>
<div class="paranum"><a name="p38.c">38.c/3</a></div>
<div class="Annotations">There is no requirement for an implementation 
to generate special code for routines that are imported from outside 
of the Ada program. That's because there is a requirement on the programmer 
that the use of interfacing aspects do not violate Ada semantics (see 
<A HREF="AA-B-1.html">B.1</A>). That includes making pre- and postcondition 
checks. For instance, if the implementation expects routines to make 
their own postcondition checks in the body before returning, C code can 
be assumed to do this (even though that is highly unlikely). That's even 
though the formal definition of those checks is that they are evaluated 
at the call site. Note that pre- and postconditions can be very useful 
for verification tools (even if they aren't checked), because they tell 
the tool about the expectations on the foreign code that it most likely 
cannot analyze.&nbsp;</div>
<div class="paranum"><a name="p39">39/3</a></div>
<div class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0145-2.TXT">AI05-0145-2</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0247-1.TXT">AI05-0247-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0254-1.TXT">AI05-0254-1</A></I>} 
For a call via an access-to-subprogram value, all precondition and postcondition 
checks performed are determined by the subprogram or entry denoted by 
the prefix of the Access attribute reference that produced the value. 
</div>
<div class="NotesHeader">NOTES</div>
<div class="paranum"><a name="p40">40/3</a></div>
<div class="Notes">5&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0145-2.TXT">AI05-0145-2</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0262-1.TXT">AI05-0262-1</A></I>} 
A precondition is checked just before the call. If another task can change 
any value that the precondition expression depends on, the precondition 
need not hold within the subprogram or entry body.&nbsp;</div>

<H4 Class="centered">Extensions to Ada 2005</H4>
<div class="paranum"><a name="p40.a">40.a/3</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0145-2.TXT">AI05-0145-2</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0230-1.TXT">AI05-0230-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0247-1.TXT">AI05-0247-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0254-1.TXT">AI05-0254-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0262-1.TXT">AI05-0262-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0273-1.TXT">AI05-0273-1</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI05s/AI05-0274-1.TXT">AI05-0274-1</A></I>} 
<A NAME="I3660"></A>Pre and Post aspects are new.&nbsp;</div>

<H4 Class="centered">Inconsistencies With Ada 2012</H4>
<div class="paranum"><a name="p40.b">40.b/4</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0032-1.TXT">AI12-0032-1</A></I>} 
<span class="insert4"><A NAME="I3661"></A><B>Corrigendum:</B> The Old 
attribute is defined more carefully. This changes the nominal subtype 
and place of declaration of the attribute compared to the published Ada 
2012 Standard. In extreme cases, this could change the runtime behavior 
of the attribute (for instance, the tag might be different). The changes 
are most likely going to prevent bugs by being more intuitive, but it 
is possible that a program that previously worked might fail.</span></div>
<div class="paranum"><a name="p40.c">40.c/4</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0113-1.TXT">AI12-0113-1</A></I>} 
<span class="insert4"></span>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0159-1.TXT">AI12-0159-1</A></I>} 
<span class="insert4"><B>Corrigendum:</B> Eliminated unintentional redispatching 
from class-wide preconditions and postconditions. This means that a different 
body might be evaluated for a statically bound call to a routine that 
has a class-wide precondition or postcondition. The change means that 
the behavior of Pre and Pre'Class will be the same for a particular subprogram, 
and that the known behavior of the operations can be assumed within the 
body of that subprogram for Pre'Class. We expect that this change will 
primarily fix bugs, as it will make Pre'Class and Post'Class work more 
like expected. In the case where redispatching is desired, an explicit 
conversion to a class-wide type can be used.</span></div>

<H4 Class="centered">Incompatibilities With Ada 2012</H4>
<div class="paranum"><a name="p40.d">40.d/4</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0045-1.TXT">AI12-0045-1</A></I>} 
<span class="insert4"><A NAME="I3662"></A><B>Corrigendum:</B> Precondition 
and postcondition aspects cannot be specified on instances of generic 
subprograms (they should be specified on the generic subprogram instead). 
This was (unintentionally) allowed by the Ada 2012 standard. These are 
not be allowed on instances as there is no corresponding way to add preconditions 
and postconditions to subprograms declared within the instance of a generic 
package. Therefore, allowing specification on a subprogram instance could 
present a maintenance problem in the future if the entity needs to be 
converted to a generic package (a common conversion).</span></div>
<div class="paranum"><a name="p40.e">40.e/4</a></div>
<div class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AI12s/AI12-0131-1.TXT">AI12-0131-1</A></I>} 
<span class="insert4"><B>Corrigendum:</B> Pre'Class is no longer allowed 
to be specified for an overriding primitive subprogram unless there are 
also inherited class-wide precondittions. This incompatibility prevents 
cases where the explicit Pre'Class is counterfeited by an implicit class-wide 
precondition of True. This rule should catch more bugs than it creates; 
the programmer should have written Pre rather than Pre'Class in this 
case (or written Pre'Class on the original subprogram, not an overriding). 
Note that this incompatibility eliminates what otherwise would be an 
inconsistency with original Ada 2012, where precondition checks that 
would have previously been made for a statically bound call would no 
longer be made. That dynamic change was necessary to eliminate cases 
where the evaluated class-wide precondition on a dispatching call would 
have been weaker than the class-wide precondition of a statically bound 
call. (The original Ada 2012 violated the LSP semantics that class-wide 
preconditions were intended to model.</span>&nbsp;</div>

<HR>
<div style="margin-top: 0.0em; margin-bottom: 0.6em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-6-1.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-6-2.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</div>
<DIV Style="margin-top:0.0em"><IMG SRC="AE_logo.gif" height=100 width=113 align=right ALT="Ada-Europe">
<SPAN Style="vertical-align: middle; font-size:120%">Ada 2005 and 2012 Editions sponsored in part by <SPAN Style="font-size: 125%"><A HREF="http://www.ada-europe.org/"><B>Ada-Europe</B></A></SPAN></SPAN></DIV>
</BODY>
</HTML>
