<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Formal Parameter Modes</TITLE>
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    DIV.paranum {position: absolute; font-family: Arial, Helvetica, sans-serif; left: 0.5em; top: auto}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    DIV.Normal {font-family: "Times New Roman", Times, serif; margin-bottom: 0.6em}
    DIV.Wide {font-family: "Times New Roman", Times, serif; margin-top: 0.6em; margin-bottom: 0.6em}
    DIV.Annotations {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-bottom: 0.6em}
    DIV.WideAnnotations {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-top: 0.6em; margin-bottom: 0.6em}
    DIV.Index {font-family: "Times New Roman", Times, serif}
    DIV.SyntaxSummary {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-bottom: 0.4em}
    DIV.Notes {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-bottom: 0.6em}
    DIV.NotesHeader {font-family: "Times New Roman", Times, serif; margin-left: 2.0em}
    DIV.SyntaxIndented {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-bottom: 0.4em}
    DIV.Indented {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-bottom: 0.6em}
    DIV.CodeIndented {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-bottom: 0.6em}
    DIV.SmallIndented {font-family: "Times New Roman", Times, serif; margin-left:  10.0em; margin-bottom: 0.6em}
    DIV.SmallCodeIndented {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-bottom: 0.6em}
    DIV.Examples {font-family: "Courier New", monospace; margin-left: 2.0em; margin-bottom: 0.6em}
    DIV.SmallExamples {font-family: "Courier New", monospace; font-size: 80%; margin-left: 7.5em; margin-bottom: 0.6em}
    DIV.IndentedExamples {font-family: "Courier New", monospace; margin-left: 8.0em; margin-bottom: 0.6em}
    DIV.SmallIndentedExamples {font-family: "Courier New", monospace; font-size: 80%; margin-left:  15.0em; margin-bottom: 0.6em}
    UL.Bulleted {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.SmallBulleted {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.NestedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-right: 4.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.SmallNestedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-right: 8.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.IndentedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-right: 8.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.CodeIndentedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.CodeIndentedNestedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-right: 8.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.SyntaxIndentedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-right: 4.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.NotesBulleted {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-right: 4.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.NotesNestedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    DL.Hanging {font-family: "Times New Roman", Times, serif; margin-top: 0em; margin-bottom: 0.6em}
    DD.Hanging {margin-left: 6.0em}
    DL.IndentedHanging {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-top: 0em; margin-bottom: 0.6em}
    DD.IndentedHanging {margin-left: 2.0em}
    DL.HangingInBulleted {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    DD.HangingInBulleted {margin-left: 4.0em}
    DL.SmallHanging {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-top: 0em; margin-bottom: 0.6em}
    DD.SmallHanging {margin-left: 7.5em}
    DL.SmallIndentedHanging {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-top: 0em; margin-bottom: 0.6em}
    DD.SmallIndentedHanging {margin-left: 2.0em}
    DL.SmallHangingInBulleted {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    DD.SmallHangingInBulleted {margin-left: 5.0em}
    DL.Enumerated {font-family: "Times New Roman", Times, serif; margin-right: 0.0em; margin-top: 0em; margin-bottom: 0.5em}
    DD.Enumerated {margin-left: 2.0em}
    DL.SmallEnumerated {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-right: 4.0em; margin-top: 0em; margin-bottom: 0.5em}
    DD.SmallEnumerated {margin-left: 2.5em}
    DL.NestedEnumerated {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    DL.SmallNestedEnumerated {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">
<P><A HREF="AA-TOC.html">Contents</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-0-29.html">Index</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-SRCH.html">Search</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-6-1.html">Previous</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-6-3.html">Next</A></P>
<HR>
<H1> 6.2 Formal Parameter Modes</H1>
<DIV Class="Paranum"><FONT SIZE=-2>1</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;[A <FONT FACE="Arial, Helvetica">parameter_specification</FONT>
declares a formal parameter of mode <B>in</B>, <B>in out</B>, or <B>out</B>.]
</DIV>

<H4 ALIGN=CENTER>Static Semantics</H4>
<DIV Class="Paranum"><FONT SIZE=-2>2</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>pass by copy</I>}</FONT> <A NAME="I3061"></A><FONT SIZE="-1">{<I>by
copy parameter passing</I>}</FONT> <A NAME="I3062"></A><FONT SIZE="-1">{<I>copy
parameter passing</I>}</FONT> <A NAME="I3063"></A><FONT SIZE="-1">{<I>pass
by reference</I>}</FONT> <A NAME="I3064"></A><FONT SIZE="-1">{<I>by reference
parameter passing</I>}</FONT> <A NAME="I3065"></A><FONT SIZE="-1">{<I>reference
parameter passing</I>}</FONT> <A NAME="I3066"></A>A parameter is passed
either <I>by copy</I> or <I>by reference</I>. [When a parameter is passed
by copy, the formal parameter denotes a separate object from the actual
parameter, and any information transfer between the two occurs only before
and after executing the subprogram. When a parameter is passed by reference,
the formal parameter denotes (a view of) the object denoted by the actual
parameter; reads and updates of the formal parameter directly reference
the actual parameter object.]</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>3</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>by-copy type</I>}</FONT> <A NAME="I3067"></A>A
type is a <I>by-copy type</I> if it is an elementary type, or if it is
a descendant of a private type whose full type is a by-copy type. A parameter
of a by-copy type is passed by copy.</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>4</FONT></DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>by-reference
type</I>}</FONT> <A NAME="I3068"></A>A type is a <I>by-reference type</I>
if it is a descendant of one of the following: </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>5</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC>a tagged type;</LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>6</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC>a task or protected type;</LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>7</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC>a nonprivate type with the reserved
word <B>limited</B> in its declaration; </LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>7.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>A limited
private type is by-reference only if it falls under one of the other
categories. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>8</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC>a composite type with a subcomponent
of a by-reference type;</LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>9</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC>a private type whose full type is
a by-reference type. </LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>10</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;A parameter of a by-reference type is passed
by reference. <FONT SIZE="-1">{<I>associated object (of a value of a
by-reference type)</I>}</FONT> <A NAME="I3069"></A>Each value of a by-reference
type has an associated object. For a parenthesized expression, <FONT FACE="Arial, Helvetica">qualified_expression</FONT>,
or <FONT FACE="Arial, Helvetica">type_conversion</FONT>, this object
is the one associated with the operand.</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>10.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>By-reference
parameter passing makes sense only if there is an object to reference;
hence, we define such an object for each case.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>10.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">Since tagged types are by-reference
types, this implies that every value of a tagged type has an associated
object. This simplifies things, because we can define the tag to be a
property of the object, and not of the value of the object, which makes
it clearer that object tags never change.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>10.c</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">We considered simplifying things
even more by making every value (and therefore every expression) have
an associated object. After all, there is little semantic difference
between a constant object and a value. However, this would cause problems
for untagged types. In particular, we would have to do a constraint check
on every read of a type conversion (or a renaming thereof) in certain
cases.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>10.d</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">We do not want this definition
to depend on the view of the type; privateness is essentially ignored
for this definition. Otherwise, things would be confusing (does the rule
apply at the call site, at the site of the declaration of the subprogram,
at the site of the <FONT FACE="Arial, Helvetica">return_statement</FONT>?),
and requiring different calls to use different mechanisms would be an
implementation burden.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>10.e</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><A HREF="AA-C-6.html">C.6</A>,
``<A HREF="AA-C-6.html">Shared Variable Control</A>'' says that a composite
type with an atomic or volatile subcomponent is a by-reference type,
among other things.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>10.f</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">{<I>associated object (of a
value of a limited type)</I>} <A NAME="I3070"></A>Every value of a limited
by-reference type is the value of one and only one limited object. The
<I>associated object</I> of a value of a limited by-reference type is
the object whose value it represents. {<I>same value (for a limited type)</I>}
<A NAME="I3071"></A>Two values of a limited by-reference type are the
<I>same</I> if and only if they represent the value of the same object.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>10.g</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">We say ``by-reference'' above
because these statements are not always true for limited private types
whose underlying type is nonlimited (unfortunately). </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>11</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>unspecified</I> [partial]}</FONT>
<A NAME="I3072"></A>For parameters of other types, it is unspecified
whether the parameter is passed by copy or by reference. </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>11.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Discussion: </B>There is
no need to incorporate the discussion of AI83-00178, which requires pass-by-copy
for certain kinds of actual parameters, while allowing pass-by-reference
for others. This is because we explicitly indicate that a function creates
an anonymous constant object for its result, unless the type is a return-by-reference
type (see <A HREF="AA-6-5.html">6.5</A>). We also provide a special dispensation
for instances of Unchecked_Conversion to return by reference, even if
the result type is not a return-by-reference type (see <A HREF="AA-13-9.html">13.9</A>).
</FONT></DIV>

<H4 ALIGN=CENTER>Bounded (Run-Time) Errors</H4>
<DIV Class="Paranum"><FONT SIZE=-2>12</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>distinct access paths</I>}</FONT>
<A NAME="I3073"></A><FONT SIZE="-1">{<I>access paths (distinct)</I>}</FONT>
<A NAME="I3074"></A><FONT SIZE="-1">{<I>aliasing: See distinct access
paths</I>}</FONT> <A NAME="I3075"></A><FONT SIZE="-1">{<I>bounded error
(cause)</I> [partial]}</FONT> <A NAME="I3076"></A>If one <FONT FACE="Arial, Helvetica">name</FONT>
denotes a part of a formal parameter, and a second <FONT FACE="Arial, Helvetica">name</FONT>
denotes a part of a distinct formal parameter or an object that is not
part of a formal parameter, then the two <FONT FACE="Arial, Helvetica">name</FONT>s
are considered <I>distinct access paths</I>. If an object is of a type
for which the parameter passing mechanism is not specified, then it is
a bounded error to assign to the object via one access path, and then
read the value of the object via a distinct access path, unless the first
access path denotes a part of a formal parameter that no longer exists
at the point of the second access [(due to leaving the corresponding
callable construct).] <FONT SIZE="-1">{<I>Program_Error (raised by failure
of run-time check)</I>}</FONT> <A NAME="I3077"></A>The possible consequences
are that Program_Error is raised, or the newly assigned value is read,
or some old value of the object is read. </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>12.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Discussion: </B>For example,
if we call ``P(X =&gt; Global_Variable, Y =&gt; Global_Variable)'', then
within P, the names ``X'', ``Y'', and ``Global_Variable'' are all distinct
access paths. If Global_Variable's type is neither pass-by-copy nor pass-by-reference,
then it is a bounded error to assign to Global_Variable and then read
X or Y, since the language does not specify whether the old or the new
value would be read. On the other hand, if Global_Variable's type is
pass-by-copy, then the old value would always be read, and there is no
error. Similarly, if Global_Variable's type is defined by the language
to be pass-by-reference, then the new value would always be read, and
again there is no error. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>12.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Reason: </B>We are saying
<I>assign</I> here, not <I>update</I>, because updating any subcomponent
is considered to update the enclosing object.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>12.c</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">The ``still exists'' part is
so that a read after the subprogram returns is OK.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>12.d</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">If the parameter is of a by-copy
type, then there is no issue here -- the formal is not a view of the
actual. If the parameter is of a by-reference type, then the programmer
may depend on updates through one access path being visible through some
other access path, just as if the parameter were of an access type. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>12.e</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Implementation Note: </B>The
implementation can keep a copy in a register of a parameter whose parameter-passing
mechanism is not specified. If a different access path is used to update
the object (creating a bounded error situation), then the implementation
can still use the value of the register, even though the in-memory version
of the object has been changed. However, to keep the error properly bounded,
if the implementation chooses to read the in-memory version, it has to
be consistent -- it cannot then assume that something it has proven about
the register is true of the memory location. For example, suppose the
formal parameter is L, the value of L(6) is now in a register, and L(6)
is used in an <FONT FACE="Arial, Helvetica">indexed_component</FONT>
as in ``A(L(6)) := 99;'', where A has bounds 1..3. If the implementation
can prove that the value for L(6) in the register is in the range 1..3,
then it need not perform the constraint check if it uses the register
value. However, if the memory value of L(6) has been changed to 4, and
the implementation uses that memory value, then it had better not alter
memory outside of A.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>12.f</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">Note that the rule allows the
implementation to pass a parameter by reference and then keep just part
of it in a register, or, equivalently, to pass part of the parameter
by reference and another part by copy. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>12.g</FONT></DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><FONT SIZE="-1"><B>Reason:
</B>We do not want to go so far as to say that the mere presence of aliasing
is wrong. We wish to be able to write the following sorts of things in
standard Ada: </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>12.h</FONT></DIV>
<DIV Class="SmallExamples"><TT><B>procedure</B>&nbsp;Move&nbsp;(&nbsp;Source&nbsp;&nbsp;:&nbsp;<B>in</B>&nbsp;&nbsp;String;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Target&nbsp;&nbsp;:&nbsp;<B>out</B>&nbsp;String;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Drop&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;<B>in</B>&nbsp;&nbsp;Truncation&nbsp;:=&nbsp;Error;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Justify&nbsp;:&nbsp;<B>in</B>&nbsp;&nbsp;Alignment&nbsp;&nbsp;:=&nbsp;Left;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pad&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;<B>in</B>&nbsp;&nbsp;Character&nbsp;&nbsp;:=&nbsp;Space);<BR>
--<I>&nbsp;Copies&nbsp;elements&nbsp;from&nbsp;Source&nbsp;to&nbsp;Target&nbsp;(safely&nbsp;if&nbsp;they&nbsp;overlap)</I></TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>12.i</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">This is from the standard string
handling package. It would be embarrassing if this couldn't be written
in Ada!</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>12.j</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">The ``then'' before ``read''
in the rule implies that the implementation can move a read to an earlier
place in the code, but not to a later place after a potentially aliased
assignment. Thus, if the subprogram reads one of its parameters into
a local variable, and then updates another potentially aliased one, the
local copy is safe -- it is known to have the old value. For example,
the above-mentioned Move subprogram can be implemented by copying Source
into a local variable before assigning into Target.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>12.k</FONT></DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><FONT SIZE="-1">For
an <FONT FACE="Arial, Helvetica">assignment_statement</FONT> assigning
one array parameter to another, the implementation has to check which
direction to copy at run time, in general, in case the actual parameters
are overlapping slices. For example: </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>12.l</FONT></DIV>
<DIV Class="SmallExamples"><TT><B>procedure</B>&nbsp;Copy(X&nbsp;:&nbsp;<B>in&nbsp;out</B>&nbsp;String;&nbsp;Y:&nbsp;String)&nbsp;<B>is</B><BR>
<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;:=&nbsp;Y;<BR>
<B>end</B>&nbsp;Copy;</TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>12.m</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">It would be wrong for the compiler
to assume that X and Y do not overlap (unless, of course, it can prove
otherwise). </FONT></DIV>
<DIV Class="NotesHeader"><FONT SIZE="-1">NOTES</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>13</FONT></DIV>
<DIV Class="Notes"><FONT SIZE="-1">5&nbsp;&nbsp;A formal parameter of
mode <B>in</B> is a constant view (see <A HREF="AA-3-3.html">3.3</A>);
it cannot be updated within the <FONT FACE="Arial, Helvetica">subprogram_body</FONT>.
</FONT></DIV>

<H4 ALIGN=CENTER>Extensions to Ada 83</H4>
<DIV Class="Paranum"><FONT SIZE=-2>13.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">{<I>extensions to Ada 83</I>}
<A NAME="I3078"></A>The value of an <B>out</B> parameter may be read.
An <B>out</B> parameter is treated like a declared variable without an
explicit initial expression. </FONT></DIV>

<H4 ALIGN=CENTER>Wording Changes from Ada 83</H4>
<DIV Class="Paranum"><FONT SIZE=-2>13.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">Discussion of copy-in for parts
of out parameters is now covered in <A HREF="AA-6-4-1.html">6.4.1</A>,
``<A HREF="AA-6-4-1.html">Parameter Associations</A>''.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>13.c</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">The concept of a by-reference
type is new to Ada 95.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>13.d</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">We now cover in a general way
in <A HREF="AA-3-7-2.html">3.7.2</A> the rule regarding erroneous execution
when a discriminant is changed and one of the parameters depends on the
discriminant. </FONT></DIV>

<HR>
<P><A HREF="AA-TOC.html">Contents</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-0-29.html">Index</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-SRCH.html">Search</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-6-1.html">Previous</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-6-3.html">Next</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-TTL.html">Legal</A></P>
</BODY>
</HTML>
