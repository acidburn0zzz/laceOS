<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML><HEAD>
<TITLE>Ada 83 LRM, Sec 3.5: Scalar Types</TITLE>
</HEAD><BODY>
<hr><a href="ada_lrm.html"><IMG SRC="adass.gif" align=LEFT hspace=6 vspace=6 alt="Lady Ada"></a><H1>Ada '83 Language Reference Manual</H1>
<h6><a href="ada_legal.html">Copyright</a> 1980, 1982, 1983 owned by the United States Government. Direct reproduction and usage requests to the <a href="mailto://adainfo@sw-eng.falls-church.va.us">Ada Information Clearinghouse</a>.</h6>
<br clear=LEFT>
<hr>

<H2><A NAME="3.5">3.5</A>.  Scalar Types  </H2>
<A HREF="lrm-03-04.html#3.4"><img src="lrm-prev.gif" alt="[PREVIOUS]"></A><A HREF="lrm-03.html#3"><img src="lrm-up.gif" alt="[UP]"></A><A HREF="lrm-03-06.html#3.6"><img src="lrm-next.gif" alt="[NEXT]"></A>
<P>
Scalar  types  comprise  enumeration  types, integer types, and real types.
Enumeration types and integer types are called discrete types;  each  value
of  a  discrete  type  has  a  position  number  which is an integer value.  
<P>
Integer types and real types are called numeric types.   All  scalar  types
are  ordered,  that  is,  all relational operators are predefined for their
values. 
<pre>
    range_constraint ::=  range range 

    range ::=  range_attribute
       | simple_expression .. simple_expression                                                 
</pre>
<P>
A range specifies a subset of values of a scalar type.  The range  L  ..  R
specifies  the values from L to R inclusive if the relation L &lt;= R is true.
The values L and R are called the lower bound and upper bound of the range,
respectively.  A value V is said  to  satisfy  a  range  constraint  if  it
belongs  to  the  range;  the value V is said to belong to the range if the
relations L &lt;= V and V &lt;= R are both TRUE.  A null range  is  a  range  for
which  the  relation R &lt; L is TRUE;  no value belongs to a null range.  The
operators &lt;= and &lt; in the above definitions are the predefined operators of
the scalar type. 
<P>
If a range constraint is used in a subtype indication, either  directly  or
as  part  of  a  floating or fixed point constraint, the type of the simple
expressions (likewise,  of the bounds of a range  attribute)  must  be  the
same  as the base type of the type mark of the subtype indication.  A range
constraint is compatible with a subtype if each bound of the range  belongs
to the subtype, or if the range constraint defines a null range;  otherwise
the range constraint is not compatible with the subtype. 
<P>
The  elaboration  of  a  range constraint consists of the evaluation of the
range.  The evaluation of a range defines its lower  bound  and  its  upper
bound.   If  simple  expressions  are  given  to  specify  the  bounds, the  
evaluation of the range evaluates these simple expressions  in  some  order
that is not defined by the language. 

<H4>Attributes</H4>

For  any scalar type T or for any subtype T of a scalar type, the following
attributes are defined: 
<ul>
<li> T'FIRST     
Yields the lower bound of T.  The value of this  attribute  has
the same type as T.<br><br> 
<li> T'LAST      
Yields the upper bound of T.  The value of this  attribute  has
the same type as T.
</ul>
<P>
Note: 
<P>
Indexing and iteration rules use values of discrete types. 
<P>
<b>References:</b>   <A HREF="lrm-04-01.html#4.1.4">attribute</A>,
<A HREF="lrm-03-03.html#3.3">constraint</A>,
<A HREF="#3.5.1">enumeration  type</A>,
<A HREF="lrm-01-06.html#1.6">erroneous</A>,
<A HREF="lrm-04-05.html#4.5">evaluation</A>,
<A HREF="#3.5.9">fixed point constraint</A>,
<A HREF="#3.5.7">floating point constraint</A>,
<A HREF="lrm-03-06.html#3.6">index</A>,
<A HREF="#3.5.4">integer type</A>,
<A HREF="lrm-05-05.html#5.5">loop statement</A>,
<A HREF="lrm-03-06.html#3.6.2">range attribute</A>,
<A HREF="#3.5.6">real type</A>,
<A HREF="lrm-04-05.html#4.5">relational operator</A>,
 and <A HREF="lrm-04-05.html#4.5.2">4.5.2</A>,
<A HREF="lrm-03-03.html#3.3">satisfy a constraint</A>,
<A HREF="lrm-04-04.html#4.4">simple expression</A>,
<A HREF="lrm-03-03.html#3.3.2">subtype indication</A>,
<A HREF="lrm-03-03.html#3.3.2">type  mark</A>.
<P>
<b>Rationale references:</b> 
<a href="http://archive.adaic.com/standards/83rat/html/ratl-05.html">5&nbsp;Numeric Types</a>,
<a href="http://archive.adaic.com/standards/83rat/html/ratl-05-01.html#5.1">5.1&nbsp;Introduction</a>,
<a href="http://archive.adaic.com/standards/83rat/html/ratl-05-02.html#5.2">5.2&nbsp;The Integer Types</a>,
<a href="http://archive.adaic.com/standards/83rat/html/ratl-05-03.html#5.3">5.3&nbsp;The Real Types</a>
<p>
<b>Style Guide references:</b> 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-03-04.html#3.4.1">3.4.1&nbsp;Declaring Types</a>, 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-05-03.html#5.3.1">5.3.1&nbsp;Derived Types and Subtypes</a>, 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-05-05.html#5.5.1">5.5.1&nbsp;Range Values</a>
<p>Sub-topics:
<ul>
<li><A HREF="#3.5.1">3.5.1</A> Enumeration Types  
<li><A HREF="#3.5.2">3.5.2</A> Character Types  
<li><A HREF="#3.5.3">3.5.3</A> Boolean Types  
<li><A HREF="#3.5.4">3.5.4</A> Integer Types  
<li><A HREF="#3.5.5">3.5.5</A> Operations of Discrete Types  
<li><A HREF="#3.5.6">3.5.6</A> Real Types  
<li><A HREF="#3.5.7">3.5.7</A> Floating Point Types  
<li><A HREF="#3.5.8">3.5.8</A> Operations of Floating Point Types  
<li><A HREF="#3.5.9">3.5.9</A> Fixed Point Types  
<li><A HREF="#3.5.10">3.5.10</A> Operations of Fixed Point Types  
</ul>

<H3><A NAME="3.5.1">3.5.1</A>.  Enumeration Types  </H3>
<A HREF="#3.5"><img src="lrm-up.gif" alt="[UP]"></A><A HREF="#3.5.2"><img src="lrm-next.gif" alt="[NEXT]"></A>
<P>
An enumeration type definition defines an enumeration type. 
<pre>
    enumeration_type_definition ::=
       (enumeration_literal_specification {, enumeration_literal_specification})  

    enumeration_literal_specification ::=  enumeration_literal 

    enumeration_literal ::=  identifier | character_literal 
</pre>
<P>
The  identifiers  and  character  literals  listed  by  an enumeration type
definition must be distinct.  Each enumeration literal specification is the
declaration of the corresponding enumeration literal:  this declaration  is
equivalent  to  the declaration of a parameterless function, the designator
being the enumeration literal, and the result type  being  the  enumeration
type.   The  elaboration  of  an  enumeration  type  definition  creates an
enumeration type;  this elaboration  includes  that  of  every  enumeration
literal specification.                                             
<P>
Each  enumeration  literal  yields  a  different  enumeration  value.   The
predefined order relations between enumeration values follow the  order  of
corresponding  position  numbers.   The position number of the value of the
first listed enumeration literal is zero;  the  position  number  for  each
other enumeration literal is one more than for its predecessor in the list. 
<P>
If  the  same identifier or character literal is specified in more than one
enumeration type definition, the corresponding  literals  are  said  to  be
overloaded.  At any place where an overloaded enumeration literal occurs in
the  text  of  a  program,  the  type  of  the  enumeration literal must be
determinable from the context (see <a href="lrm-08-07.html#8.7">8.7</a>). 
<P>
Examples: 
<pre>
  type DAY    is (MON, TUE, WED, THU, FRI, SAT, SUN);
  type SUIT   is (CLUBS, DIAMONDS, HEARTS, SPADES);
  type GENDER is (M, F);
  type LEVEL  is (LOW, MEDIUM, URGENT);
  type COLOR  is (WHITE, RED, YELLOW, GREEN, BLUE, BROWN, BLACK);
  type LIGHT  is (RED, AMBER, GREEN); -- RED and GREEN are overloaded

  type HEXA   is ('A', 'B', 'C', 'D', 'E', 'F');
  type MIXED  is ('A', 'B', '*', B, NONE, '?', '%');

  subtype WEEKDAY is DAY   range MON .. FRI;
  subtype MAJOR   is SUIT  range HEARTS .. SPADES;
  subtype RAINBOW is COLOR range RED .. BLUE;  --  the color RED, not the
                                                   light
</pre>
<P>
Note:
<P>
If an enumeration literal occurs in  a  context  that  does  not  otherwise
suffice  to  determine  the  type of the literal, then qualification by the
name of the enumeration type is one way to resolve the ambiguity (see <a href="lrm-08-07.html#8.7">8.7</a>).  
<P>
<b>References:</b>   <A HREF="lrm-02-05.html#2.5">character  literal</A>,
<A HREF="lrm-03-01.html#3.1">declaration</A>,
<A HREF="lrm-06-01.html#6.1">designator</A>,
<A HREF="lrm-03-09.html#3.9">elaboration</A>,
 and <A HREF="lrm-06-01.html#6.1">6.1</A>,
<A HREF="lrm-06-05.html#6.5">function</A>,
<A HREF="lrm-02-03.html#2.3">identifier</A>,
<A HREF="lrm-04-01.html#4.1">name</A>,
<A HREF="lrm-06-06.html#6.6">overloading</A>,
 and <A HREF="lrm-08-07.html#8.7">8.7</A>,
<A HREF="#3.5">position number</A>,
<A HREF="lrm-04-07.html#4.7">qualified expression</A>,
<A HREF="lrm-04-05.html#4.5">relational operator</A>,
 and <A HREF="lrm-04-05.html#4.5.2">4.5.2</A>,
<A HREF="lrm-03-03.html#3.3">type</A>,
<A HREF="lrm-03-03.html#3.3.1">type definition</A>.
<P>
<b>Style Guide references:</b> 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-02-01.html#2.1.4">2.1.4&nbsp;Alignment of Declarations</a>, 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-03-04.html#3.4.2">3.4.2&nbsp;Enumeration Types</a>, 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-05-06.html#5.6.3">5.6.3&nbsp;Case Statements</a>, 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-05-07.html#5.7.1">5.7.1&nbsp;The Use Clause</a>

<H3><A NAME="3.5.2">3.5.2</A>.  Character Types  </H3>
<A HREF="#3.5.1"><img src="lrm-prev.gif" alt="[PREVIOUS]"></A><A HREF="#3.5"><img src="lrm-up.gif" alt="[UP]"></A><A HREF="#3.5.3"><img src="lrm-next.gif" alt="[NEXT]"></A>
<P>
An enumeration type is said to be a character type if at least one  of  its
enumeration literals is a character literal.  The predefined type CHARACTER
is  a  character  type  whose  values  are  the 128 characters of the ASCII
character set.  Each of the 95 graphic characters of this character set  is
denoted by the corresponding character literal. 
<P>
Example: 
<pre>
    type ROMAN_DIGIT is ('I', 'V', 'X', 'L', 'C', 'D', 'M');   
</pre>
<P>
Notes: 
<P>
The predefined package ASCII includes the declaration of constants denoting
control  characters  and  of constants denoting graphic characters that are
not in the basic character set.                                                    
<P>
A conventional character set such as EBCDIC can be declared as a  character
type;   the  internal  codes  of  the  characters  can  be  specified by an
enumeration representation clause as explained in <a href="lrm-13-03.html#13.3">section 13.3</a>. 
<P>
<b>References:</b>  <A HREF="lrm-C.html#C">package</A>,
<A HREF="lrm-02-01.html#2.1">basic  character</A>,
<A HREF="lrm-02-05.html#2.5">character literal</A>,
<A HREF="lrm-03-02.html#3.2.1">constant</A>,
<A HREF="lrm-03-01.html#3.1">declaration</A>,
<A HREF="#3.5.1">enumeration type</A>,
<A HREF="lrm-C.html#C">type</A>,
<A HREF="lrm-03-03.html#3.3">type</A>.

<H3><A NAME="3.5.3">3.5.3</A>.  Boolean Types  </H3>
<A HREF="#3.5.2"><img src="lrm-prev.gif" alt="[PREVIOUS]"></A><A HREF="#3.5"><img src="lrm-up.gif" alt="[UP]"></A><A HREF="#3.5.4"><img src="lrm-next.gif" alt="[NEXT]"></A>
<P>
There is a predefined enumeration type named BOOLEAN.  It contains the  two
literals  FALSE and TRUE ordered with the relation FALSE < TRUE.  A boolean
type is either the type BOOLEAN or a type  that  is  derived,  directly  or  
indirectly, from a boolean type. 
<P>
<b>References:</b>   <A HREF="lrm-03-04.html#3.4">derived type</A>,
<A HREF="#3.5.1">enumeration literal</A>,
<A HREF="#3.5.1">enumeration type</A>,
<A HREF="lrm-04-05.html#4.5">relational operator</A>,
 and <A HREF="lrm-04-05.html#4.5.2">4.5.2</A>,
<A HREF="lrm-03-03.html#3.3">type</A>.
<P>
<b>Style Guide references:</b> 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-03-02.html#3.2.3">3.2.3&nbsp;Object Names</a>

<H3><A NAME="3.5.4">3.5.4</A>.  Integer Types  </H3>
<A HREF="#3.5.3"><img src="lrm-prev.gif" alt="[PREVIOUS]"></A><A HREF="#3.5"><img src="lrm-up.gif" alt="[UP]"></A><A HREF="#3.5.5"><img src="lrm-next.gif" alt="[NEXT]"></A>
<P>
An integer type definition defines an integer  type  whose  set  of  values
includes at least those of the specified range.
<pre>
    integer_type_definition ::=  range_constraint 
</pre>
<P>
If  a range constraint is used as an integer type definition, each bound of
the range must be defined by a static expression of some integer type,  but
the  two  bounds need not have the same integer type.  (Negative bounds are
allowed.) 
<P>
A type declaration of the form: 
<pre>
    type T is range L .. R; 
</pre>
<P>
is, by definition, equivalent to the following declarations: 
<pre>
    type integer_type is new predefined_integer_type;
    subtype T is integer_type range integer_type(L) .. integer_type(R); 
</pre>
<P>
where integer_type is an anonymous type, and where the  predefined  integer
type  is  implicitly  selected  by the implementation, so as to contain the
values L to R inclusive.  The integer type declaration is illegal  if  none
of  the  predefined  integer  types  satisfies  this requirement, excepting
universal_integer.  The elaboration of the declaration of an  integer  type
consists   of   the   elaboration   of  the  equivalent  type  and  subtype
declarations.    
<P>
The predefined integer types include the type INTEGER.   An  implementation
may  also  have  predefined  types  such as SHORT_INTEGER and LONG_INTEGER,
which have (substantially) shorter and longer  ranges,  respectively,  than
INTEGER.   The  range  of each of these types must be symmetric about zero,
excepting an extra negative value which may exist in some  implementations.
The base type of each of these types is the type itself.                                                      
<P>
Integer  literals  are the literals of an anonymous predefined integer type
that is called universal_integer in this reference manual.   Other  integer
types  have  no  literals.   However, for each integer type there exists an
implicit conversion  that  converts  a  universal_integer  value  into  the
corresponding  value (if any) of the integer type.  The circumstances under
which these implicit conversions are invoked are described in <a href="lrm-04-06.html#4.6">section  4.6</a>. 
The  position  number of an integer value is the corresponding value of the
type universal_integer. 
<P>
The same arithmetic operators are predefined for  all  integer  types  (see
<a href="lrm-04-05.html#4.5">4.5</a>).   The  exception  NUMERIC_ERROR  is  raised  by  the  execution of an
operation (in particular an implicit conversion) that  cannot  deliver  the
correct  result  (that  is,  if the value corresponding to the mathematical
result is not a  value of the integer type).  However, an implementation is
not required to raise the exception NUMERIC_ERROR if the operation is  part
of a larger expression whose result can be computed correctly, as described
in <a href="lrm-11-06.html#11.6">section 11.6</a>. 
<P>
Examples: 
<pre>
    type PAGE_NUM  is range 1 .. 2_ 
    type LINE_SIZE is range 1 .. MAX_LINE_SIZE; 

    subtype SMALL_INT   is INTEGER   range -10 .. 10;
    subtype COLUMN_PTR  is LINE_SIZE range 1 .. 10;
    subtype BUFFER_SIZE is INTEGER   range 0 .. MAX; 
</pre>
<P>
Notes: 
<P>
The name declared by an integer type declaration is a subtype name.  On the
other  hand,  the  predefined  operators of an integer type deliver results
whose range is defined by the parent predefined type;  such a  result  need
not  belong to the declared subtype, in which case an attempt to assign the  
result  to  a  variable  of  the  integer  subtype  raises  the   exception
CONSTRAINT_ERROR. 
<P>
The  smallest  (most  negative)  value  supported by the predefined integer
types of an implementation is  the  named  number  SYSTEM.MIN_INT  and  the
largest (most positive) value is SYSTEM.MAX_INT (see <a href="lrm-13-07.html#13.7">13.7</a>).
<P>
<b>References:</b>   <A HREF="lrm-03-03.html#3.3.1">anonymous  type</A>,
<A HREF="lrm-03-03.html#3.3">belong  to a subtype</A>,
<A HREF="#3.5">bound of a range</A>,
<A HREF="lrm-11-01.html#11.1">constraint_error exception</A>,
<A HREF="lrm-04-06.html#4.6">conversion</A>,
<A HREF="lrm-02-03.html#2.3">identifier</A>,
<A HREF="lrm-02-04.html#2.4">integer literal</A>,
<A HREF="lrm-04-02.html#4.2">literal</A>,
<A HREF="lrm-11-01.html#11.1">numeric_error exception</A>,
<A HREF="lrm-03-04.html#3.4">parent type</A>,
<A HREF="lrm-04-05.html#4.5">predefined operator</A>,
<A HREF="#3.5">range constraint</A>,
<A HREF="lrm-04-09.html#4.9">static expression</A>,
<A HREF="lrm-03-03.html#3.3.2">subtype  declaration</A>,
<A HREF="lrm-13-07.html#13.7">system predefined package</A>,
<A HREF="lrm-03-03.html#3.3">type</A>,
<A HREF="lrm-03-03.html#3.3.1">type declaration</A>,
<A HREF="lrm-03-03.html#3.3.1">type definition</A>,
<A HREF="lrm-04-01.html#4.1">universal type</A>,
 and <A HREF="lrm-04.html#4">4</A>.
<P>
<b>Style Guide references:</b> 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-07-01.html#7.1.1">7.1.1&nbsp;Global Assumptions</a>, 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-07-01.html#7.1.2">7.1.2&nbsp;Actual Limits</a>, 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-07-02.html#7.2.1">7.2.1&nbsp;Predefined Numeric Types</a>, 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-07-02.html#7.2.5">7.2.5&nbsp;Comments</a>

<H3><A NAME="3.5.5">3.5.5</A>.  Operations of Discrete Types  </H3>
<A HREF="#3.5.4"><img src="lrm-prev.gif" alt="[PREVIOUS]"></A><A HREF="#3.5"><img src="lrm-up.gif" alt="[UP]"></A><A HREF="#3.5.6"><img src="lrm-next.gif" alt="[NEXT]"></A>
<P>
The basic operations of a discrete type include the operations involved  in
assignment,  the  membership  tests, and qualification;  for a boolean type  
they include the short-circuit control forms;  for  an  integer  type  they
include  the  explicit  conversion  of values of other numeric types to the
integer  type,  and  the  implicit  conversion  of  values  of   the   type
universal_integer to the type. 
<P>
Finally, for every discrete type or subtype T, the basic operations include
the  attributes  listed  below.   In this presentation, T is referred to as
being  a  subtype  (the  subtype  T)  for  any  property  that  depends  on
constraints imposed by T;  other properties are stated in terms of the base
type of T.                                                                               
<P>
The first group of attributes yield characteristics of the subtype T.  This  
group  includes  the  attribute  BASE (see <a href="lrm-03-03.html#3.3.2">3.3.2</a>), the attributes FIRST and
LAST (see <a href="lrm-03-05.html#3.5">3.5</a>), the representation attribute SIZE (see  <a href="lrm-13-07.html#13.7.2">13.7.2</a>),  and   the
attribute WIDTH defined as follows: 
<ul>
<li> T'WIDTH     
Yields the maximum image length over all values of the  subtype
T  (the  image  is  the  sequence of characters returned by the
attribute IMAGE, see below).  Yields zero  for  a  null  range.
The  value  of this attribute is of the type universal_integer. 
</ul>
<P>
All attributes of the second group are functions with a  single  parameter.
The corresponding actual parameter is indicated below by X. 
<ul>
<li> T'POS       
This attribute is a function.  The parameter X must be a  value
of   the  base  type  of  T.   The  result  type  is  the  type
universal_integer.  The result is the position  number  of  the
value of the parameter.<br><br> 
<li> T'VAL       
This attribute is a special function with  a  single  parameter
which  can be of any integer type.  The result type is the base
type of T.  The result is the value whose  position  number  is
the  universal_integer value corresponding to X.  The exception
CONSTRAINT_ERROR  is  raised  if  the  universal_integer  value
corresponding  to  X is not in the range T'POS(T'BASE'FIRST) ..
T'POS(T'BASE'LAST).<br><br> 
<li> T'SUCC      
This attribute is a function.  The parameter X must be a  value
of  the base type of T.  The result type is the base type of T.
The result is the value whose position number  is  one  greater
than  that of X.  The exception CONSTRAINT_ERROR is raised if X
equals T'BASE'LAST.<br><br> 
<li> T'PRED      
This attribute is a function.  The parameter X must be a  value
of  the base type of T.  The result type is the base type of T.   
The result is the value whose position number is one less  than
that  of  X.   The  exception  CONSTRAINT_ERROR  is raised if X
equals T'BASE'FIRST.<br><br> 
<li> T'IMAGE     
This attribute is a function.  The parameter X must be a  value
of  the base type of T.  The result type is the predefined type
STRING.  The result is the image of the value of X, that is,  a
sequence  of characters representing the value in display form.
The image of an integer  value  is  the  corresponding  decimal
literal;   without  underlines,  leading  zeros,  exponent,  or
trailing spaces;  but with a single leading character  that  is
either  a  minus sign or a space.  The lower bound of the image
is one. 
</ul>
<pre>
            The image of an enumeration value is either  the  corresponding
            identifier in upper case or the corresponding character literal
            (including  the two apostrophes);  neither leading nor trailing
            spaces are included.  The image of a character C, other than  a
            graphic   character,   is   implementation-defined;   the  only
            requirement is that the  image  must  be  such  that  C  equals
            CHARACTER'VALUE(CHARACTER'IMAGE(C)).  
</pre>
<ul>
<li> T'VALUE     
This attribute is a function.  The parameter X must be a  value
of  the  predefined  type  STRING.  The result type is the base
type of T.  Any leading and any trailing spaces of the sequence
of characters that corresponds to the parameter are ignored. 
</ul>
<pre>
            For an enumeration type, if the sequence of characters has  the
            syntax of an enumeration literal and if this literal exists for
            the base type of T, the result is the corresponding enumeration   
            value.   For an integer type, if the sequence of characters has
            the syntax of an  integer  literal,  with  an  optional  single
            leading character that is a plus or minus sign, and if there is
            a corresponding value in the base type of T, the result is this
            value.   In  any  other case, the exception CONSTRAINT_ERROR is
            raised.                                                                     
</pre>
<P>
In addition, the attributes A'SIZE and A'ADDRESS are defined for an  object
A of a discrete type (see <a href="lrm-13-07.html#13.7.2">13.7.2</a>).
<P>
Besides the basic operations, the operations of a discrete type include the
predefined relational operators.  For enumeration types, operations include
enumeration literals.  For boolean types, operations include the predefined
unary  logical negation operator not, and the predefined logical operators.
For integer types, operations include the predefined arithmetic  operators:
these  are  the  binary and unary adding operators - and +, all multiplying
operators, the unary operator abs, and the exponentiating operator. 
<P>
The operations of a subtype are the corresponding operations  of  its  base
type   except   for   the   following:    assignment,   membership   tests,
qualification, explicit type conversions, and the attributes of  the  first
group;   the  effect  of  each  of  these operations depends on the subtype
(assignments, membership tests, qualifications, and conversions  involve  a
subtype check;  attributes of the first group yield a characteristic of the
subtype). 
<P>
Notes: 
<P>
For  a  subtype of a discrete type, the results delivered by the attributes
SUCC, PRED, VAL, and VALUE need not belong to the subtype;  similarly,  the 
actual  parameters  of  the  attributes POS, SUCC, PRED, and IMAGE need not
belong to the subtype.  The  following  relations  are  satisfied  (in  the
absence of an exception) by these attributes: 
<pre>
    T'POS(T'SUCC(X)) = T'POS(X) + 1
    T'POS(T'PRED(X)) = T'POS(X) - 1 

    T'VAL(T'POS(X))  = X
    T'POS(T'VAL(N))  = N 
</pre>
<P>
Examples: 
<pre>
    --  For the types and subtypes declared in <a href="#3.5.1">section 3.5.1</a> we have: 

    --  COLOR'FIRST   = WHITE,   COLOR'LAST   = BLACK
    --  RAINBOW'FIRST = RED,     RAINBOW'LAST = BLUE 

    --  COLOR'SUCC(BLUE) = RAINBOW'SUCC(BLUE) = BROWN
    --  COLOR'POS(BLUE)  = RAINBOW'POS(BLUE)  = 4
    --  COLOR'VAL(0)     = RAINBOW'VAL(0)     = WHITE  
</pre>
<P>
<b>References:</b>   <A HREF="lrm-04-05.html#4.5">abs operator</A>,
 and <A HREF="lrm-04-05.html#4.5.6">4.5.6</A>,
<A HREF="lrm-05-02.html#5.2">assignment</A>,
<A HREF="lrm-04-01.html#4.1.4">attribute</A>,
<A HREF="lrm-03-03.html#3.3">base type</A>,
<A HREF="lrm-03-03.html#3.3.3">basic operation</A>,
<A HREF="lrm-04-05.html#4.5">binary adding operator</A>,
 and <A HREF="lrm-04-05.html#4.5.3">4.5.3</A>,
<A HREF="#3.5.3">boolean type</A>,
<A HREF="#3.5">bound  of a range</A>,
<A HREF="lrm-02-05.html#2.5">character literal</A>,
<A HREF="lrm-03-03.html#3.3">constraint</A>,
<A HREF="lrm-11-01.html#11.1">constraint_error  exception</A>,
<A HREF="lrm-04-06.html#4.6">conversion</A>,
<A HREF="#3.5">discrete  type</A>,
<A HREF="#3.5.1">enumeration literal</A>,
<A HREF="lrm-04-05.html#4.5">exponentiating operator</A>,
 and <A HREF="lrm-04-05.html#4.5.6">4.5.6</A>,
<A HREF="lrm-06-05.html#6.5">function</A>,
<A HREF="lrm-02-01.html#2.1">graphic character</A>,
<A HREF="lrm-02-03.html#2.3">identifier</A>,
<A HREF="#3.5.4">integer type</A>,
<A HREF="lrm-04-05.html#4.5">logical operator</A>,
 and <A HREF="lrm-04-05.html#4.5.1">4.5.1</A>,
<A HREF="lrm-04-05.html#4.5">membership test</A>,
 and <A HREF="lrm-04-05.html#4.5.2">4.5.2</A>,
<A HREF="lrm-04-05.html#4.5">multiplying operator</A>,
 and <A HREF="lrm-04-05.html#4.5.5">4.5.5</A>,
<A HREF="lrm-04-05.html#4.5">not operator</A>,
 and <A HREF="lrm-04-05.html#4.5.6">4.5.6</A>,
<A HREF="lrm-02-04.html#2.4">numeric literal</A>,
<A HREF="#3.5">numeric  type</A>,
<A HREF="lrm-03-02.html#3.2">object</A>,
<A HREF="lrm-03-03.html#3.3">operation</A>,
<A HREF="#3.5">position  number</A>,
<A HREF="lrm-04-05.html#4.5">predefined operator</A>,
<A HREF="lrm-C.html#C">type</A>,
<A HREF="lrm-04-07.html#4.7">qualified  expression</A>,
<A HREF="lrm-04-05.html#4.5">relational   operator</A>,
 and <A HREF="lrm-04-05.html#4.5.2">4.5.2</A>,
<A HREF="lrm-04-05.html#4.5">short-circuit  control form</A>,
 and <A HREF="lrm-04-05.html#4.5.1">4.5.1</A>,
<A HREF="lrm-03-06.html#3.6.3">string type</A>,
<A HREF="lrm-03-03.html#3.3">subtype</A>,
<A HREF="lrm-03-03.html#3.3">type</A>,
<A HREF="lrm-04-05.html#4.5">unary  adding  operator</A>,
 and <A HREF="lrm-04-05.html#4.5.4">4.5.4</A>,
<A HREF="#3.5.4">universal_integer  type</A>,
<A HREF="lrm-04-01.html#4.1">universal type</A>,
 and <A HREF="lrm-04.html#4">4</A>.

<H3><A NAME="3.5.6">3.5.6</A>.  Real Types  </H3>
<A HREF="#3.5.5"><img src="lrm-prev.gif" alt="[PREVIOUS]"></A><A HREF="#3.5"><img src="lrm-up.gif" alt="[UP]"></A><A HREF="#3.5.7"><img src="lrm-next.gif" alt="[NEXT]"></A>
<P>
Real types provide approximations to the real numbers, with relative bounds
on  errors  for  floating  point  types, and with absolute bounds for fixed
point types. 
<pre>
    real_type_definition ::=
       floating_point_constraint | fixed_point_constraint 
</pre>
<P>
A set of numbers called model numbers is associated with  each  real  type.
Error  bounds  on the predefined operations are given in terms of the model
numbers.  An implementation of the type must include at least  these  model
numbers and represent them exactly. 
<P>
An  implementation-dependent  set  of  numbers, called the safe numbers, is
also associated with each real type.  The set of safe  numbers  of  a  real
type must include at least the set of model numbers of the type.  The range
of  safe  numbers  is allowed to be larger than the range of model numbers,
but error bounds on the predefined operations for safe numbers are given by
the same rules as  for  model  numbers.   Safe  numbers  therefore  provide
guaranteed error bounds for operations on an implementation-dependent range
of  numbers;   in  contrast, the range of model numbers depends only on the
real type definition and is therefore independent of the implementation. 
<P>
Real literals are the literals of an anonymous predefined real type that is
called universal_real in this reference manual.  Other real types  have  no
literals.  However, for each real type, there exists an implicit conversion
that  converts  a  universal_real value into a value of the real type.  The
conditions under which these implicit conversions are invoked are described
in section <a href="lrm-04-06.html#4.6">4.6</a>.   If  the  universal_real  value  is  a  safe  number,  the
implicit conversion delivers the corresponding value;  if it belongs to the
range  of  safe  numbers but is not a safe number, then the converted value
can be any value within the range defined by the safe  numbers  next  above
and below the universal_real value. 
<P>
The  execution of an operation that yields a value of a real type may raise
the exception NUMERIC_ERROR, as explained in <a href="lrm-04-05.html#4.5.7">section 4.5.7</a>,  if  it  cannot
deliver a correct result (that is, if the value corresponding to one of the
possible  mathematical  results  does  not  belong  to  the  range  of safe
numbers);  in particular, this exception  can  be  raised  by  an  implicit
conversion.   However,  an  implementation  is  not  required  to raise the
exception NUMERIC_ERROR if the operation is part  of  a  larger  expression
whose result can be computed correctly (see <a href="lrm-11-06.html#11.6">11.6</a>). 
<P>
The  elaboration  of a real type definition includes the elaboration of the
floating or fixed point constraint and creates a real type.
<P>
Note: 
<P>
An algorithm written to rely only upon  the  minimum  numerical  properties
guaranteed  by  the  type  definition  for  model  numbers will be portable
without further precautions.    
<P>
<b>References:</b>  <A HREF="lrm-04-06.html#4.6">conversion</A>,
<A HREF="lrm-03-09.html#3.9">elaboration</A>,
<A HREF="#3.5.9">fixed point constraint</A>,
<A HREF="#3.5.7">floating point constraint</A>,
<A HREF="lrm-04-02.html#4.2">literal</A>,
<A HREF="lrm-11-01.html#11.1">numeric_error exception</A>,
<A HREF="lrm-03-03.html#3.3.3">predefined operation</A>,
<A HREF="lrm-02-04.html#2.4">real literal</A>,
<A HREF="lrm-03-03.html#3.3">type</A>,
<A HREF="lrm-03-03.html#3.3.1">type  definition</A>,
<A HREF="lrm-04-10.html#4.10">universal type</A>.
<P>
<b>Style Guide references:</b> 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-05-05.html#5.5.6">5.5.6&nbsp;Accuracy of Operations With Real Operands</a>, 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-07-01.html#7.1.1">7.1.1&nbsp;Global Assumptions</a>, 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-07-01.html#7.1.2">7.1.2&nbsp;Actual Limits</a>, 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-07-02.html#7.2.5">7.2.5&nbsp;Comments</a>
<H3><A NAME="3.5.7">3.5.7</A>.  Floating Point Types  </H3>
<A HREF="#3.5.6"><img src="lrm-prev.gif" alt="[PREVIOUS]"></A><A HREF="#3.5"><img src="lrm-up.gif" alt="[UP]"></A><A HREF="#3.5.8"><img src="lrm-next.gif" alt="[NEXT]"></A>
<P>
For  floating  point  types,  the  error  bound  is specified as a relative
precision by giving the required  minimum  number  of  significant  decimal
digits. 
<pre>
    floating_point_constraint ::=
       floating_accuracy_definition [range_constraint] 

    floating_accuracy_definition ::=  digits static_simple_expression 
</pre>
<P>
The  minimum number of significant decimal digits is specified by the value
of the static simple expression of the floating accuracy definition.   This
value  must belong to some integer type and must be positive (nonzero);  it
is denoted by D in the remainder of this section.  If  the  floating  point
constraint  is  used  as  a  real  type  definition  and  includes  a range
constraint, then each bound of the  range  must  be  defined  by  a  static
expression  of  some  real  type, but the two bounds need not have the same
real type. 
<P>
For a given radix, the following canonical form is defined for any floating
point model number other than zero: 
<pre>
    sign * mantissa * (radix ** exponent) 
</pre>
<P>
In this form: sign is either +1 or -1;  mantissa is expressed in  a  number
base  given by radix; and exponent is an integer number (possibly negative)
such that the integer part of mantissa is zero and the first digit  of  its
fractional part is not a zero. 
<P>
The  specified  number  D  is the minimum number of decimal digits required
after the point in the decimal mantissa (that is, if radix  is  ten).   The
value  of D in turn determines a corresponding number B that is the minimum
number of binary digits required after the point  in  the  binary  mantissa
(that is, if radix is two).  The number B associated with D is the smallest
value  such  that the relative precision of the binary form is no less than
that specified for the decimal form.  (The number B  is  the  integer  next
above (D*log(10)/log(2)) + 1.) 
<P>
The  model  numbers defined by a floating accuracy definition comprise zero
and all numbers whose binary canonical form has exactly B digits after  the
point  in  the  mantissa  and  an  exponent in the range -4*B .. +4*B.  The
guaranteed minimum accuracy of operations  of  a  floating  point  type  is   
defined in terms of the model numbers of the floating point constraint that
forms the corresponding real type definition (see <a href="lrm-04-05.html#4.5.7">4.5.7</a>). 
<P>
The   predefined   floating   point  types  include  the  type  FLOAT.   An
implementation may also have  predefined  types  such  as  SHORT_FLOAT  and
LONG_FLOAT,   which   have   (substantially)   less   and   more  accuracy,
respectively, than FLOAT.  The base type of each predefined floating  point
type  is  the  type  itself.  The model numbers of each predefined floating
point type are defined in terms of the number D of decimal digits  returned
by the attribute DIGITS (see <a href="lrm-03-05.html#3.5.8">3.5.8</a>).   
<P>
For  each  predefined  floating point type (consequently also for each type
derived therefrom), a set of safe numbers is defined as follows.  The  safe
numbers  have  the same number B of mantissa digits as the model numbers of
the type  and  have  an  exponent  in  the  range  -E  ..  +E  where  E  is
implementation-defined  and  at  least  equal  to the 4*B of model numbers.
(Consequently, the safe numbers include  the  model  numbers.)   The  rules
defining  the  accuracy of operations with model and safe numbers are given
in <a href="lrm-04-05.html#4.5.7">section 4.5.7</a>.  The safe numbers of a subtype  are  those  of  its  base
type.                                                
<P>
A floating point type declaration of one of the two forms (that is, with or
without the optional range constraint indicated by the square brackets): 
<pre>
    type T is digits D [range L .. R]; 
</pre>
<P>
is, by definition, equivalent to the following declarations: 
<pre>
    type floating_point_type is new predefined_floating_point_type;
    subtype T is floating_point_type digits D
       [range floating_point_type(L) .. floating_point_type(R)]; 
</pre>
<P>
where  floating_point_type  is  an anonymous type, and where the predefined
floating point type is implicitly selected by the  implementation  so  that
its  model numbers include the model numbers defined by D;  furthermore, if
a range L .. R is supplied, then both L and R must belong to the  range  of
safe  numbers.   The  floating  point declaration is illegal if none of the
predefined floating point types  satisfies  these  requirements,  excepting
universal_real.   The  maximum  number of digits that can be specified in a
floating accuracy definition is given by the system-dependent named  number
SYSTEM.MAX_DIGITS (see <a href="lrm-13-07.html#13.7.1">13.7.1</a>). 
<P>
The  elaboration  of  a  floating  point  type  declaration consists of the
elaboration of the equivalent type and subtype declarations. 
<P>
If a floating point constraint follows a type mark in a subtype indication,
the type mark must denote a floating point type or subtype.   The  floating
point  constraint  is  compatible  with  the type mark only if the number D
specified in the floating accuracy  definition  is  not  greater  than  the
corresponding  number  D  for the type or subtype denoted by the type mark.
Furthermore, if the floating point constraint includes a range  constraint,
the  floating point constraint is compatible with the type mark only if the
range constraint is, itself, compatible with the type mark. 
<P>
The elaboration of such a subtype indication includes  the  elaboration  of
the range constraint, if there is one;  it creates a floating point subtype
whose  model  numbers  are  defined  by the corresponding floating accuracy
definition.  A value of a floating point type belongs to a  floating  point
subtype if and only if it belongs to the range defined by the subtype. 
<P>
The  same  arithmetic operators are predefined for all floating point types
(see <a href="lrm-04-05.html#4.5">4.5</a>). 
<P>
Notes:  
<P>
A range constraint is allowed  in  a  floating  point  subtype  indication,
either  directly  after  the  type  mark,  or  as  part of a floating point
constraint.  In either case the bounds of the range must belong to the base
type of the type mark (see  <a href="lrm-03-05.html#3.5">3.5</a>).   The  imposition  of  a  floating  point
constraint on a type mark in a subtype indication cannot reduce the allowed
range  of  values unless it includes a range constraint (the range of model
numbers that correspond to the specified number of digits  can  be  smaller
than  the  range  of  numbers of the type mark).  A value that belongs to a
floating point subtype need not be a model number of the subtype.    
<P>
Examples: 
<pre>
    type COEFFICIENT is digits 10 range -1.0 .. 1.0; 

    type REAL is digits 8;
    type MASS is digits 7 range 0.0 .. 1.0E35; 

    subtype SHORT_COEFF is COEFFICIENT digits 5;    --   a subtype with less accuracy
    subtype PROBABILITY is REAL range 0.0 .. 1.0;   --   a subtype with a smaller range                                                
</pre>
<P>
Notes on the examples: 
<P>
The implemented accuracy for COEFFICIENT  is  that  of  a  predefined  type
having  at least 10 digits of precision.  Consequently the specification of
5 digits of precision for the subtype SHORT_COEFF is allowed.  The  largest
model number for the type MASS is approximately 1.27E30 and hence less than
the  specified  upper bound (1.0E35).  Consequently the declaration of this
type is legal only if this upper bound is in the range of the safe  numbers
of  a predefined floating point type having at least 7 digits of precision.    
<P>
<b>References:</b>  <A HREF="lrm-03-03.html#3.3.1">anonymous type</A>,
<A HREF="#3.5.5">arithmetic  operator</A>,
 and <A HREF="lrm-04-05.html#4.5">4.5</A>,
<A HREF="lrm-02-04.html#2.4.2">based literal</A>,
<A HREF="lrm-03-03.html#3.3">belong  to a subtype</A>,
<A HREF="#3.5">bound of a range</A>,
<A HREF="lrm-03-03.html#3.3.2">compatible</A>,
<A HREF="lrm-03-04.html#3.4">derived type</A>,
<A HREF="lrm-02-01.html#2.1">digit</A>,
<A HREF="lrm-03-01.html#3.1">elaboration</A>,
 and <A HREF="lrm-03-09.html#3.9">3.9</A>,
<A HREF="#3.5.6">error bound</A>,
<A HREF="lrm-02-04.html#2.4.1">exponent</A>,
<A HREF="#3.5.4">integer type</A>,
<A HREF="#3.5.6">model  number</A>,
<A HREF="lrm-03-03.html#3.3">operation</A>,
<A HREF="lrm-C.html#C">type</A>,
<A HREF="#3.5">range constraint</A>,
<A HREF="#3.5.6">real type</A>,
<A HREF="#3.5.6">real  type  definition</A>,
<A HREF="#3.5.6">safe number</A>,
<A HREF="lrm-04-04.html#4.4">simple expression</A>,
<A HREF="lrm-04-09.html#4.9">static expression</A>,
<A HREF="lrm-03-03.html#3.3.2">subtype declaration</A>,
<A HREF="lrm-03-03.html#3.3.2">subtype  indication</A>,
<A HREF="lrm-03-03.html#3.3">subtype</A>,
<A HREF="lrm-03-03.html#3.3">type</A>,
<A HREF="lrm-03-03.html#3.3.1">type declaration</A>,
<A HREF="lrm-03-03.html#3.3.2">type mark</A>.
<P>
<b>Style Guide references:</b> 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-07-02.html#7.2.1">7.2.1&nbsp;Predefined Numeric Types</a>, 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-07-02.html#7.2.2">7.2.2&nbsp;Ada Model</a>, 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-07-02.html#7.2.3">7.2.3&nbsp;Analysis</a>

<H3><A NAME="3.5.8">3.5.8</A>.  Operations of Floating Point Types  </H3>
<A HREF="#3.5.7"><img src="lrm-prev.gif" alt="[PREVIOUS]"></A><A HREF="#3.5"><img src="lrm-up.gif" alt="[UP]"></A><A HREF="#3.5.9"><img src="lrm-next.gif" alt="[NEXT]"></A>
<P>
The  basic  operations  of  a  floating  point  type include the operations
involved in  assignment,  membership  tests,  qualification,  the  explicit
conversion of values of other numeric types to the floating point type, and
the  implicit  conversion of values of the type universal_real to the type. 
<P>
In addition, for  every  floating  point  type  or  subtype  T,  the  basic
operations include the attributes listed below.  In this presentation, T is
referred  to  as  being  a  subtype  (the  subtype T) for any property that
depends on constraints imposed by T;  other properties are stated in  terms
of the base type of T. 
<P>
The  first group of attributes yield characteristics of the subtype T.  The
attributes of this group are the attribute BASE (see <a href="lrm-03-03.html#3.3.2">3.3.2</a>), the attributes
FIRST and LAST (see <a href="lrm-03-05.html#3.5">3.5</a>), the representation attribute SIZE  (see  <a href="lrm-13-07.html#13.7.2">13.7.2</a>),
and the following attributes: 
<ul>
<li> T'DIGITS     
Yields the number of decimal digits in the decimal mantissa of
model  numbers  of  the subtype T.  (This attribute yields the
number D of <a href="#3.5.7">section 3.5.7</a>.)  The value of this attribute is of
the type universal_integer.<br><br> 
<li> T'MANTISSA   
Yields the number of binary digits in the binary  mantissa  of 
model  numbers  of  the subtype T.  (This attribute yields the
number B of <a href="#3.5.7">section 3.5.7</a>.)  The value of this attribute is of
the type universal_integer.<br><br> 
<li> T'EPSILON    
Yields the absolute value of the difference between the  model
number 1.0 and the next model number above, for the subtype T.
The value of this attribute is of the type universal_real.<br><br>    
<li> T'EMAX       
Yields the largest exponent value in the binary canonical form
of model numbers of the subtype T.  (This attribute yields the
product 4*B of <a href="#3.5.7">section 3.5.7</a>.)  The value of this attribute is
of the type  universal_integer.<br><br> 
<li> T'SMALL      
Yields the smallest positive (nonzero)  model  number  of  the
subtype  T.   The  value  of  this  attribute  is  of the type
universal_real.<br><br> 
<li> T'LARGE      
Yields the largest positive model number  of  the  subtype  T.
The value of this attribute is of the type universal_real.
</ul>
<p>                                              
The  attributes  of the second group include the following attributes which
yield characteristics of the safe numbers: 
<ul>
<li> T'SAFE_EMAX  
Yields the largest exponent value in the binary canonical form
of safe numbers of the base type of T.  (This attribute yields
the number E of <a href="lrm-03-05.html#3.5.7">section 3.5.7</a>.)  The value of  this  attribute
is of the type universal_integer.<br><br> 
<li> T'SAFE_SMALL 
Yields the smallest positive (nonzero) safe number of the base
type  of  T.   The  value  of  this  attribute  is of the type
universal_real.<br><br>   
<li> T'SAFE_LARGE 
Yields the largest positive safe number of the base type of T.
The value of this attribute is of the type universal_real. 
</ul>
<P>
In addition, the attributes A'SIZE and A'ADDRESS are defined for an  object
A  of a floating point type (see <a href="lrm-13-07.html#13.7.2">13.7.2</a>).  Finally, for each floating point
type there are machine-dependent attributes that are not related  to  model
numbers  and  safe  numbers.   They correspond to the attribute designators
MACHINE_RADIX,      MACHINE_MANTISSA,      MACHINE_EMAX,      MACHINE_EMIN,
MACHINE_ROUNDS, and MACHINE_OVERFLOWS (see <a href="lrm-13-07.html#13.7.3">13.7.3</a>). 
<P>
Besides  the  basic  operations,  the  operations  of a floating point type
include the relational operators, and the following  predefined  arithmetic
operators:   the binary and unary adding operators - and +, the multiplying
operators * and /, the unary operator abs, and the exponentiating operator. 
<P>
The operations of a subtype are the corresponding operations  of  the  type
except  for  the  following:   assignment, membership tests, qualification,
explicit conversion, and the attributes of the first group;  the effects of
these operations are redefined in terms of the subtype. 
<P>
Notes: 
<P>
The  attributes  EMAX,  SMALL,  LARGE,  and  EPSILON   are   provided   for
convenience.   They  are all related to MANTISSA by the following formulas: 
<pre>
    T'EMAX    = 4*T'MANTISSA
    T'EPSILON = 2.0**(1 - T'MANTISSA)
    T'SMALL   = 2.0**(-T'EMAX - 1)
    T'LARGE   = 2.0**T'EMAX * (1.0 - 2.0**(-T'MANTISSA)) 
</pre>
<P>
The attribute MANTISSA, giving the number of binary digits in the mantissa,
is itself related to DIGITS.  The  following  relations  hold  between  the
characteristics of the model numbers and those of the safe numbers: 
<pre>
    T'BASE'EMAX  &lt;= T'SAFE_EMAX
    T'BASE'SMALL >= T'SAFE_SMALL
    T'BASE'LARGE &lt;= T'SAFE_LARGE 
</pre>
<P>
The attributes T'FIRST and T'LAST need not yield model or safe numbers.  If  
a  certain  number  of  digits is specified in the declaration of a type or
subtype T, the attribute T'DIGITS yields this number.    
<P>
<b>References:</b>   <A HREF="lrm-04-05.html#4.5">abs  operator</A>,
 and <A HREF="lrm-04-05.html#4.5.6">4.5.6</A>,
<A HREF="#3.5.5">arithmetic  operator</A>,
 and <A HREF="lrm-04-05.html#4.5">4.5</A>,
<A HREF="lrm-05-02.html#5.2">assignment</A>,
<A HREF="lrm-04-01.html#4.1.4">attribute</A>,
<A HREF="lrm-03-03.html#3.3">base  type</A>,
<A HREF="lrm-03-03.html#3.3.3">basic operation</A>,
<A HREF="lrm-04-05.html#4.5">binary adding operator</A>,
 and <A HREF="lrm-04-05.html#4.5.3">4.5.3</A>,
<A HREF="#3.5">bound of a  range</A>,
<A HREF="lrm-03-03.html#3.3">constraint</A>,
<A HREF="lrm-04-06.html#4.6">conversion</A>,
<A HREF="lrm-02-01.html#2.1">digit</A>,
<A HREF="lrm-04-05.html#4.5">exponentiating  operator</A>,
 and <A HREF="lrm-04-05.html#4.5.6">4.5.6</A>,
<A HREF="#3.5.7">floating point  type</A>,
<A HREF="lrm-04-05.html#4.5">membership  test</A>,
 and <A HREF="lrm-04-05.html#4.5.2">4.5.2</A>,
<A HREF="#3.5.6">model   number</A>,
<A HREF="lrm-04-05.html#4.5">multiplying  operator</A>,
 and <A HREF="lrm-04-05.html#4.5.5">4.5.5</A>,
<A HREF="#3.5">numeric type</A>,
<A HREF="lrm-03-02.html#3.2">object</A>,
<A HREF="lrm-03-03.html#3.3">operation</A>,
<A HREF="lrm-04-05.html#4.5">predefined operator</A>,
<A HREF="lrm-04-07.html#4.7">qualified expression</A>,
<A HREF="lrm-04-05.html#4.5">relational operator</A>,
 and <A HREF="lrm-04-05.html#4.5.2">4.5.2</A>,
<A HREF="#3.5.6">safe number</A>,
<A HREF="lrm-03-03.html#3.3">subtype</A>,
<A HREF="lrm-03-03.html#3.3">type</A>,
<A HREF="lrm-04-05.html#4.5">unary adding  operator</A>,
 and <A HREF="lrm-04-05.html#4.5.4">4.5.4</A>,
<A HREF="lrm-04-10.html#4.10">universal   type</A>,
<A HREF="#3.5.4">universal_integer   type</A>,
<A HREF="#3.5.6">universal_real type</A>.

<H3><A NAME="3.5.9">3.5.9</A>.  Fixed Point Types  </H3>
<A HREF="#3.5.8"><img src="lrm-prev.gif" alt="[PREVIOUS]"></A><A HREF="#3.5"><img src="lrm-up.gif" alt="[UP]"></A><A HREF="#3.5.10"><img src="lrm-next.gif" alt="[NEXT]"></A>
<P>
For fixed point types, the error bound is specified as an  absolute  value,
called the delta of the fixed point type. 
<pre>
    fixed_point_constraint ::=
       fixed_accuracy_definition [range_constraint] 

    fixed_accuracy_definition ::=  delta static_simple_expression 
</pre>
<P>
The  delta is specified by the value of the static simple expression of the
fixed accuracy definition.  This value must belong to some  real  type  and
must  be  positive  (nonzero).   If the fixed point constraint is used as a
real type definition, then it must include a range constraint;  each  bound
of  the specified range must be defined by a static expression of some real
type but the two bounds need not have the same real  type.   If  the  fixed
point  constraint  is used in a subtype indication, the range constraint is
optional. 
<P>
A canonical form is defined for any fixed point  model  number  other  than
zero.   In  this  form:   sign  is either +1 or -1;  mantissa is a positive
(nonzero) integer;  and any  model  number  is  a  multiple  of  a  certain
positive real number called small, as follows: 
<pre>
    sign * mantissa * small 
</pre>
<P>
For the model numbers defined by a fixed point constraint, the number small
is chosen as the largest power of two that is not greater than the delta of
the  fixed  accuracy  definition.  Alternatively, it is possible to specify
the value of small by a length clause  (see  <a href="lrm-13-02.html#13.2">13.2</a>),  in  which  case  model
numbers  are  multiples  of  the  specified  value.  The guaranteed minimum
accuracy of operations of a fixed point type is defined  in  terms  of  the
model  numbers  of  the fixed point constraint that forms the corresponding
real type definition (see <a href="lrm-04-05.html#4.5.7">4.5.7</a>). 
<P>
For a fixed point constraint that includes a range  constraint,  the  model
numbers  comprise  zero  and  all  multiples of small whose mantissa can be
expressed using exactly B binary digits, where the value of B is chosen  as
the  smallest integer number for which each bound of the specified range is
either a model number or lies at most small distant from  a  model  number.
For a fixed point constraint that does not include a range constraint (this
is  only  allowed  after  a  type mark, in a subtype indication), the model
numbers are defined by the delta of the fixed accuracy  definition  and  by
the range of the subtype denoted by the type mark. 
<P>
An  implementation  must have at least one anonymous predefined fixed point
type.  The base type of each such fixed point type is the type itself.  The
model numbers of each predefined fixed point type  comprise  zero  and  all
numbers for which mantissa (in the canonical form) has the number of binary  
digits  returned  by the attribute MANTISSA, and for which the number small
has the value returned by the attribute SMALL. 
<P>
A fixed point type declaration of the form:   
<pre>
    type T is delta D range L .. R; 
</pre>
<P>
is, by definition, equivalent to the following declarations: 
<pre>
    type fixed_point_type is new predefined_fixed_point_type;
    subtype T is fixed_point_type
       range fixed_point_type(L) .. fixed_point_type(R);                                                  
</pre>
<P>
In these declarations, fixed_point_type  is  an  anonymous  type,  and  the
predefined fixed point type is implicitly selected by the implementation so
that its model numbers include the model numbers defined by the fixed point
constraint  (that  is,  by  D,  L,  and  R, and possibly by a length clause
specifying small). 
<P>
The fixed point declaration is illegal  if  no  predefined  type  satisfies
these  requirements.   The safe numbers of a fixed point type are the model
numbers of its base type. 
<P>
The  elaboration  of  a  fixed  point  type  declaration  consists  of  the
elaboration of the equivalent type and subtype declarations. 
<P>
If  the fixed point constraint follows a type mark in a subtype indication,
the type mark must denote a fixed point type or subtype.  The  fixed  point
constraint  is compatible with the type mark only if the delta specified by
the fixed accuracy definition is not smaller than the delta for the type or
subtype denoted  by  the  type  mark.   Furthermore,  if  the  fixed  point
constraint  includes  a  range  constraint,  the  fixed point constraint is 
compatible with the type mark only if  the  range  constraint  is,  itself,
compatible with the type mark. 
<P>
The  elaboration  of  such a subtype indication includes the elaboration of
the range constraint, if there is one;  it creates a  fixed  point  subtype
whose model numbers are defined by the corresponding fixed point constraint
and  also  by the length clause specifying small, if there is one.  A value
of a fixed point type belongs to a fixed point subtype if and  only  if  it
belongs to the range defined by the subtype. 
<P>
The same arithmetic operators are predefined for all fixed point types (see
<a href="lrm-04-05.html#4.5">4.5</a>).  Multiplication and division of fixed point values deliver results of
an  anonymous predefined fixed point type that is called universal_fixed in
this reference manual;  the accuracy of this type is arbitrarily fine.  The
values of this type must be converted explicitly to some numeric type. 
<P>
Notes: 
<P>
If S is a subtype of a fixed point type or subtype T, then the set of model
numbers of S is a subset of those of T.  If a length clause has been  given
for  T,  then both S and T have the same value for small.  Otherwise, since
small is a power of two, the small  of  S  is  equal  to  the  small  of  T
multiplied by a nonnegative power of two. 
<P>
A  range  constraint is allowed in a fixed point subtype indication, either
directly after the type mark, or as part of a fixed point  constraint.   In
either  case  the  bounds  of the range must belong to the base type of the
type mark (see <a href="lrm-03-05.html#3.5">3.5</a>). 
<P>
Examples: 
<pre>
    type VOLT is delta 0.125 range 0.0 .. 255.0;
    subtype ROUGH_VOLTAGE is VOLT delta 1.0;  --  same range as VOLT 

    --  A pure fraction which requires all the available space in a word
    --  on a two's complement machine can be declared as the type FRACTION:  

    DEL : constant := 1.0/2**(WORD_LENGTH - 1);   
    type FRACTION is delta DEL range -1.0 .. 1.0 - DEL; 
</pre>
<P>
<b>References:</b>  <A HREF="lrm-03-03.html#3.3.1">anonymous type</A>,
<A HREF="#3.5.5">arithmetic operator</A>,
 and <A HREF="lrm-04-05.html#4.5">4.5</A>,
<A HREF="lrm-03-03.html#3.3">base type</A>,
<A HREF="lrm-03-03.html#3.3">belong to a subtype</A>,
<A HREF="#3.5">bound  of  a  range</A>,
<A HREF="lrm-03-03.html#3.3.2">compatible</A>,
<A HREF="lrm-04-06.html#4.6">conversion</A>,
<A HREF="lrm-03-09.html#3.9">elaboration</A>,
<A HREF="#3.5.6">error bound</A>,
<A HREF="lrm-13-02.html#13.2">length clause</A>,
<A HREF="#3.5.6">model number</A>,
<A HREF="#3.5">numeric type</A>,
<A HREF="lrm-03-03.html#3.3">operation</A>,
<A HREF="lrm-04-05.html#4.5">predefined  operator</A>,
<A HREF="#3.5">range  constraint</A>,
<A HREF="#3.5.6">real type</A>,
<A HREF="#3.5.6">real type definition</A>,
<A HREF="#3.5.6">safe number</A>,
<A HREF="lrm-04-04.html#4.4">simple expression</A>,
<A HREF="lrm-04-09.html#4.9">static  expression</A>,
<A HREF="lrm-03-03.html#3.3">subtype</A>,
<A HREF="lrm-03-03.html#3.3.2">subtype  declaration</A>,
<A HREF="lrm-03-03.html#3.3.2">subtype indication</A>,
<A HREF="lrm-03-03.html#3.3">type</A>,
<A HREF="lrm-03-03.html#3.3.1">type declaration</A>,
<A HREF="lrm-03-03.html#3.3.2">type mark</A>.
<P>
<b>Style Guide references:</b> 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-07-01.html#7.1.1">7.1.1&nbsp;Global Assumptions</a>, 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-07-02.html#7.2.1">7.2.1&nbsp;Predefined Numeric Types</a>

<H3><A NAME="3.5.10">3.5.10</A>.  Operations of Fixed Point Types  </H3>
<A HREF="#3.5.9"><img src="lrm-prev.gif" alt="[PREVIOUS]"></A><A HREF="#3.5"><img src="lrm-up.gif" alt="[UP]"></A>
<P>
The basic operations of a fixed point type include the operations  involved
in  assignment, membership tests, qualification, the explicit conversion of
values of other numeric types to the fixed point  type,  and  the  implicit
conversion of values of the type universal_real to the type. 
<P>
In  addition,  for every fixed point type or subtype T the basic operations
include the attributes listed below.  In this presentation T is referred to
as being a subtype (the  subtype  T)  for  any  property  that  depends  on
constraints imposed by T;  other properties are stated in terms of the base
type of T. 
<P>
The  first group of attributes yield characteristics of the subtype T.  The
attributes  of  this  group  are  the  attributes  BASE  (see  <a href="lrm-03-03.html#3.3.2">3.3.2</a>),  the
attributes FIRST and LAST (see <a href="lrm-03-05.html#3.5">3.5</a>), the representation attribute SIZE (see
<a href="lrm-13-07.html#13.7.2">13.7.2</a>) and the following attributes: 
<ul>
<li> T'DELTA      
Yields the value of the delta specified in the fixed  accuracy
definition  for the subtype T.  The value of this attribute is
of the type universal_real.<br><br> 
<li> T'MANTISSA   
Yields the number of binary digits in the  mantissa  of  model
numbers of the subtype T.  (This attribute yields the number B
of <a href="#3.5.9">section 3.5.9</a>.)  The value of this attribute is of the type
universal_integer.<br><br>
<li> T'SMALL      
Yields the smallest positive (nonzero)  model  number  of  the
subtype  T.   The  value  of  this  attribute  is  of the type
universal_real.<br><br>
<li> T'LARGE      
Yields the largest positive model number  of  the  subtype  T.
The value of this attribute is of the type universal_real.<br><br> 
<li> T'FORE       
Yields the minimum number of characters needed for the integer
part of the decimal representation of any value of the subtype
T,  assuming  that  the  representation  does  not  include an
exponent, but includes a one-character prefix that is either a
minus sign or a space.  (This minimum number does not  include
superfluous  zeros  or  underlines, and is at least two.)  The
value of this attribute is of the type universal_integer.<br><br>
<li> T'AFT        
Yields the number of decimal digits needed after the point  to
accommodate  the  precision of the subtype T, unless the delta
of the subtype T is  greater  than  0.1,  in  which  case  the
attribute  yields  the  value  one.   (T'AFT  is  the smallest
positive integer N for which (10**N)*T'DELTA is  greater  than
or  equal to one.)  The value of this attribute is of the type
universal_integer.<br><br>
</ul>
<P>
The attributes of the second group include the following  attributes  which
yield characteristics of the safe numbers:    
<ul>
<li> T'SAFE_SMALL 
Yields the smallest positive (nonzero) safe number of the base   
type  of  T.   The  value  of  this  attribute  is of the type
universal_real.<br><br>
<li> T'SAFE_LARGE 
Yields the largest positive safe number of the base type of T.
The value of this attribute is of the type universal_real. 
</ul>
<P>
In addition, the attributes A'SIZE and A'ADDRESS are defined for an  object
A  of  a fixed point type (see <a href="lrm-13-07.html#13.7.2">13.7.2</a>).  Finally, for each fixed point type
or subtype T, there are the machine-dependent  attributes  T'MACHINE_ROUNDS
and T'MACHINE_OVERFLOWS (see <a href="lrm-13-07.html#13.7.3">13.7.3</a>).                                              
<P>
Besides  the basic operations, the operations of a fixed point type include
the  relational  operators,  and  the   following   predefined   arithmetic
operators:   the binary and unary adding operators - and +, the multiplying
operators * and /, and the operator abs. 
<P>
The operations of a subtype are the corresponding operations  of  the  type
except  for  the  following:   assignment, membership tests, qualification,
explicit conversion, and the attributes of the first group;  the effects of
these operations are redefined in terms of the subtype. 
<P>
Notes: 
<P>
The value of the attribute T'FORE depends only on the range of the  subtype
T.   The value of the attribute T'AFT depends only on the value of T'DELTA.
The following relations exist between attributes of a fixed point type: 
<pre>
    T'LARGE      = (2**T'MANTISSA - 1) * T'SMALL
    T'SAFE_LARGE = T'BASE'LARGE
    T'SAFE_SMALL = T'BASE'SMALL 
</pre>
<P>
<b>References:</b>   <A HREF="lrm-04-05.html#4.5">abs  operator</A>,
 and <A HREF="lrm-04-05.html#4.5.6">4.5.6</A>,
<A HREF="#3.5.5">arithmetic  operator</A>,
 and <A HREF="lrm-04-05.html#4.5">4.5</A>,
<A HREF="lrm-05-02.html#5.2">assignment</A>,
<A HREF="lrm-03-03.html#3.3">base  type</A>,
<A HREF="lrm-03-03.html#3.3.3">basic  operation</A>,
<A HREF="lrm-04-05.html#4.5">binary adding operator</A>,
 and <A HREF="lrm-04-05.html#4.5.3">4.5.3</A>,
<A HREF="#3.5">bound of a range</A>,
<A HREF="lrm-04-06.html#4.6">conversion</A>,
<A HREF="#3.5.9">delta</A>,
<A HREF="#3.5.9">fixed  point  type</A>,
<A HREF="lrm-04-05.html#4.5">membership  test</A>,
 and <A HREF="lrm-04-05.html#4.5.2">4.5.2</A>,
<A HREF="#3.5.6">model number</A>,
<A HREF="lrm-04-05.html#4.5">multiplying operator</A>,
 and <A HREF="lrm-04-05.html#4.5.5">4.5.5</A>,
<A HREF="#3.5">numeric type</A>,
<A HREF="lrm-03-02.html#3.2">object</A>,
<A HREF="lrm-03-03.html#3.3">operation</A>,
<A HREF="lrm-04-07.html#4.7">qualified  expression</A>,
<A HREF="lrm-04-05.html#4.5">relational operator</A>,
 and <A HREF="lrm-04-05.html#4.5.2">4.5.2</A>,
<A HREF="#3.5.6">safe number</A>,
<A HREF="lrm-03-03.html#3.3">subtype</A>,
<A HREF="lrm-04-05.html#4.5">unary adding operator</A>,
 and <A HREF="lrm-04-05.html#4.5.4">4.5.4</A>,
<A HREF="#3.5.4">universal_integer type</A>,
<A HREF="#3.5.6">universal_real type</A>.
<P>


<A HREF="lrm-IDX.html"><img src="lrm-idx.gif" alt="[INDEX]"></A><A HREF="lrm-TOC.html"><img src="lrm-toc.gif" alt="[CONTENTS]"></A>

<hr>
<address><a href="htttp://www.adaic.com/"><IMG SRC="small_adaic_logo.gif" ALT="[Ada Information Clearinghouse]"></a><p>
Address any questions or comments to
<A HREF="mailto://adainfo@sw-eng.falls-church.va.us">adainfo@sw-eng.falls-church.va.us</A>.</address>
</BODY></HTML>
