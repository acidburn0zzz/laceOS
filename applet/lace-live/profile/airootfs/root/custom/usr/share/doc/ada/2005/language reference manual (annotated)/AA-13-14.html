<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Freezing Rules</TITLE>
    <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    H4.centered {text-align: center}
    SPAN.swiss {font-family: Arial, Helvetica, sans-serif; font-size: 92%}
    SPAN.roman {font-family: "Times New Roman", Times, serif}
    DIV.paranum {float: left; font-family: Arial, Helvetica, sans-serif; font-size: 64%; width: 2.8em; margin-left: -0.4em; margin-right: -3.0em; margin-top: 0.2em}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    SPAN.insert1 {text-decoration: underline; color: rgb(0,51,51) }
    SPAN.delete1 {text-decoration: line-through; color: rgb(0,51,51) }
    SPAN.insert2 {text-decoration: underline; color: rgb(0,102,0) }
    SPAN.delete2 {text-decoration: line-through; color: rgb(0,102,0) }
    DIV.Normal {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.2em; margin-bottom: 0.6em}
    DIV.Annotations {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 6.2em; margin-bottom: 0.6em}
    DIV.SmallExamples {font-family: "Courier New", monospace; font-size: 72%; line-height: 122%; margin-left: 9.6em; margin-bottom: 0.6em}
    UL.Bulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.SmallBulleted {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 8.7em; margin-right: 2.5em; margin-top: 0em; margin-bottom: 0.5em}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#000080" VLINK="#330033" ALINK="#0000FF">
<DIV><B><SPAN Style="font-size:200%; color: rgb(0,51,153)">Annotated</SPAN><SPAN Style="font-size:200%; color: rgb(0,0,102)">&nbsp;Ada Reference Manual</SPAN></B> &mdash; <A HREF="AA-TTL.html"><B>Legal Information</B></A></DIV>
<DIV Style="margin-top: 0.6em; margin-bottom: 0.0em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-13-13-2.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-4.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<HR>
<H1>13.14 Freezing Rules</H1>
<DIV Class="paranum">1</DIV>
<DIV Class="Normal">[This clause defines a place in the program text 
where each declared entity becomes &ldquo;frozen.&rdquo; A use of an 
entity, such as a reference to it by name, or (for a type) an expression 
of the type, causes freezing of the entity in some contexts, as described 
below. The Legality Rules forbid certain kinds of uses of an entity in 
the region of text where it is frozen.]&nbsp;</DIV>
<DIV Class="paranum">1.a</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>This concept has two purposes: 
a compile-time one and a run-time one.</DIV>
<DIV Class="paranum">1.b</DIV>
<DIV Class="Annotations">The compile-time purpose of the freezing rules 
comes from the fact that the evaluation of static expressions depends 
on overload resolution, and overload resolution sometimes depends on 
the value of a static expression. (The dependence of static evaluation 
upon overload resolution is obvious. The dependence in the other direction 
is more subtle. There are three rules that require static expressions 
in contexts that can appear in declarative places: The expression in 
an <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0101">attribute_designator</A></SPAN> 
shall be static. In a record aggregate, variant-controlling discriminants 
shall be static. In an array aggregate with more than one named association, 
the choices shall be static. The compiler needs to know the value of 
these expressions in order to perform overload resolution and legality 
checking.) We wish to allow a compiler to evaluate static expressions 
when it sees them in a single pass over the <SPAN Class="swiss"><A HREF="AA-10-1-1.html#S0229">compilation_unit</A></SPAN>. 
The freezing rules ensure that.</DIV>
<DIV Class="paranum">1.c</DIV>
<DIV Class="Annotations">The run-time purpose of the freezing rules is 
called the &ldquo;linear elaboration model.&rdquo; This means that declarations 
are elaborated in the order in which they appear in the program text, 
and later elaborations can depend on the results of earlier ones. The 
elaboration of the declarations of certain entities requires run-time 
information about the implementation details of other entities. The freezing 
rules ensure that this information has been calculated by the time it 
is used. For example, suppose the initial value of a constant is the 
result of a function call that takes a parameter of type <I>T</I>. In 
order to pass that parameter, the size of type <I>T</I> has to be known. 
If <I>T</I> is composite, that size might be known only at run time.</DIV>
<DIV Class="paranum">1.d</DIV>
<DIV Class="Annotations">(Note that in these discussions, words like 
&ldquo;before&rdquo; and &ldquo;after&rdquo; generally refer to places 
in the program text, as opposed to times at run time.)&nbsp;</DIV>
<DIV Class="paranum">1.e</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><B>Discussion: 
</B>The &ldquo;implementation details&rdquo; we're talking about above 
are:&nbsp;</DIV>
<DIV Class="paranum">1.f</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>For a tagged type, the implementations 
of all the primitive subprograms of the type &mdash; that is (in the 
canonical implementation model), the contents of the type descriptor, 
which contains pointers to the code for each primitive subprogram.</LI></UL>
<DIV Class="paranum">1.g</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>For a type, the full type declaration 
of any parts (including the type itself) that are private.</LI></UL>
<DIV Class="paranum">1.h</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>For a deferred constant, the 
full constant declaration, which gives the constant's value. (Since this 
information necessarily comes after the constant's type and subtype are 
fully known, there's no need to worry about its type or subtype.)</LI></UL>
<DIV Class="paranum">1.i</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>For any entity, representation 
information specified by the user via representation items. Most representation 
items are for types or subtypes; however, various other kinds of entities, 
such as objects and subprograms, are possible.&nbsp;</LI></UL>
<DIV Class="paranum">1.j</DIV>
<DIV Class="Annotations">Similar issues arise for incomplete types. However, 
we do not use freezing there; incomplete types have different, more severe, 
restrictions. Similar issues also arise for subprograms, protected operations, 
tasks and generic units. However, we do not use freezing there either; 
<A HREF="AA-3-11.html">3.11</A> prevents problems with run-time Elaboration_Checks. 
</DIV>

<H4 Class="centered">Language Design Principles</H4>
<DIV Class="paranum">1.k</DIV>
<DIV Class="Annotations">An evaluable construct should freeze anything 
that's needed to evaluate it.</DIV>
<DIV Class="paranum">1.l</DIV>
<DIV Class="Annotations">However, if the construct is not evaluated where 
it appears, let it cause freezing later, when it is evaluated. This is 
the case for <SPAN Class="swiss"><A HREF="AA-3-7.html#S0063">default_expression</A></SPAN>s 
and <SPAN Class="swiss"><A HREF="AA-12-6.html#S0279">default_name</A></SPAN>s. 
(Formal parameters, generic formal parameters, and components can have 
<SPAN Class="swiss"><A HREF="AA-3-7.html#S0063">default_expression</A></SPAN>s 
or <SPAN Class="swiss"><A HREF="AA-12-6.html#S0279">default_name</A></SPAN>s.)</DIV>
<DIV Class="paranum">1.m</DIV>
<DIV Class="Annotations">The compiler should be allowed to evaluate static 
expressions without knowledge of their context. (I.e. there should not 
be any special rules for static expressions that happen to occur in a 
context that requires a static expression.)</DIV>
<DIV Class="paranum">1.n</DIV>
<DIV Class="Annotations">Compilers should be allowed to evaluate static 
expressions (and record the results) using the run-time representation 
of the type. For example, suppose Color'Pos(Red) = 1, but the internal 
code for Red is 37. If the value of a static expression is Red, some 
compilers might store 1 in their symbol table, and other compilers might 
store 37. Either compiler design should be feasible.</DIV>
<DIV Class="paranum">1.o</DIV>
<DIV Class="Annotations">Compilers should never be required to detect 
erroneousness or exceptions at compile time (although it's very nice 
if they do). This implies that we should not require code-generation 
for a nonstatic expression of type <I>T</I> too early, even if we can 
prove that that expression will be erroneous, or will raise an exception.</DIV>
<DIV Class="paranum">1.p</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em">Here's an example 
(modified from AI83-00039, Example 3):&nbsp;</DIV>
<DIV Class="paranum">1.q</DIV>
<DIV Class="SmallExamples"><B>type</B>&nbsp;T&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>record</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;<B>record</B>;<BR>
<B>function</B>&nbsp;F&nbsp;<B>return</B>&nbsp;T;<BR>
<B>function</B>&nbsp;G(X&nbsp;:&nbsp;T)&nbsp;<B>return</B>&nbsp;Boolean;<BR>
Y&nbsp;:&nbsp;Boolean&nbsp;:=&nbsp;G(F);&nbsp;--<SPAN Class="roman"><I>&nbsp;doesn't&nbsp;force&nbsp;T&nbsp;in&nbsp;Ada&nbsp;83</I></SPAN><BR>
<B>for</B>&nbsp;T&nbsp;<B>use</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>record</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;<B>record</B>;</DIV>
<DIV Class="paranum">1.r</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em">AI83-00039 says 
this is legal. Of course, it raises Program_Error because the function 
bodies aren't elaborated yet. A one-pass compiler has to generate code 
for an expression of type T before it knows the representation of T. 
Here's a similar example, which AI83-00039 also says is legal:&nbsp;</DIV>
<DIV Class="paranum">1.s</DIV>
<DIV Class="SmallExamples"><B>package</B>&nbsp;P&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T&nbsp;<B>is</B>&nbsp;<B>private</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;F&nbsp;<B>return</B>&nbsp;T;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>function</B>&nbsp;G(X&nbsp;:&nbsp;T)&nbsp;<B>return</B>&nbsp;Boolean;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Y&nbsp;:&nbsp;Boolean&nbsp;:=&nbsp;G(F);&nbsp;--<SPAN Class="roman"><I>&nbsp;doesn't&nbsp;force&nbsp;T&nbsp;in&nbsp;Ada&nbsp;83</I></SPAN><BR>
<B>private</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>record</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;<B>record</B>;<BR>
<B>end</B>&nbsp;P;</DIV>
<DIV Class="paranum">1.t</DIV>
<DIV Class="Annotations">If T's size were dynamic, that size would be 
stored in some compiler-generated dope; this dope would be initialized 
at the place of the full type declaration. However, the generated code 
for the function calls would most likely allocate a temp of the size 
specified by the dope <I>before</I> checking for Program_Error. That 
dope would contain uninitialized junk, resulting in disaster. To avoid 
doing that, the compiler would have to determine, at compile time, that 
the expression will raise Program_Error.</DIV>
<DIV Class="paranum">1.u</DIV>
<DIV Class="Annotations">This is silly. If we're going to require compilers 
to detect the exception at compile time, we might as well formulate the 
rule as a legality rule.</DIV>
<DIV Class="paranum">1.v</DIV>
<DIV Class="Annotations">Compilers should not be required to generate 
code to load the value of a variable before the address of the variable 
has been determined.</DIV>
<DIV Class="paranum">1.w</DIV>
<DIV Class="Annotations">After an entity has been frozen, no further 
requirements may be placed on its representation (such as by a representation 
item or a <SPAN Class="swiss"><A HREF="AA-3-2-1.html#S0024">full_type_declaration</A></SPAN>). 
</DIV>
<DIV Class="paranum">2</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>freezing (entity)</I> 
[distributed]}</SPAN> <A NAME="I5313"></A><SPAN STYLE="font-size: 80%">{<I>freezing 
points (entity)</I>}</SPAN> <A NAME="I5314"></A>The <I>freezing</I> of 
an entity occurs at one or more places (<I>freezing points</I>) in the 
program text where the representation for the entity has to be fully 
determined. Each entity is frozen from its first freezing point to the 
end of the program text (given the ordering of compilation units defined 
in <A HREF="AA-10-1-4.html">10.1.4</A>).&nbsp;</DIV>
<DIV Class="paranum">2.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>The &ldquo;representation&rdquo; 
for a subprogram includes its calling convention and means for referencing 
the subprogram body, either a &ldquo;link-name&rdquo; or specified address. 
It does not include the code for the subprogram body itself, nor its 
address if a link-name is used to reference the body.&nbsp;</DIV>
<DIV Class="paranum">3/1</DIV>
<DIV Class="Normal">{<I><A HREF="defect1.html#8652/0014">8652/0014</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>freezing (entity caused by the end of 
an enclosing construct)</I>}</SPAN> <A NAME="I5315"></A>The end of a 
<SPAN Class="swiss"><A HREF="AA-3-11.html#S0086">declarative_part</A></SPAN>, 
<SPAN Class="swiss"><A HREF="AA-9-4.html#S0198">protected_body</A></SPAN>, 
or a declaration of a library package or generic library package, causes 
<I>freezing</I> of each entity declared within it, except for incomplete 
types. <SPAN STYLE="font-size: 80%">{<I>freezing (entity caused by a 
body)</I>}</SPAN> <A NAME="I5316"></A>A noninstance body<SPAN class="insert1">&nbsp;other than a renames-as-body</SPAN> causes freezing of each entity declared 
before it within the same <SPAN Class="swiss"><A HREF="AA-3-11.html#S0086">declarative_part</A></SPAN>. 
</DIV>
<DIV Class="paranum">3.a</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>This is worded carefully 
to handle nested packages and private types. Entities declared in a nested 
<SPAN Class="swiss"><A HREF="AA-7-1.html#S0174">package_specification</A></SPAN> 
will be frozen by some containing construct.</DIV>
<DIV Class="paranum">3.b</DIV>
<DIV Class="Annotations">An incomplete type declared in the private part 
of a library <SPAN Class="swiss"><A HREF="AA-7-1.html#S0174">package_specification</A></SPAN> 
can be completed in the body.&nbsp;</DIV>
<DIV Class="paranum">3.c</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>The part about bodies does 
not say <I>immediately</I> within. A renaming-as-body does not have this 
property. Nor does a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN> 
Import.&nbsp;</DIV>
<DIV Class="paranum">3.d</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>The reason bodies cause freezing 
is because we want <SPAN Class="swiss">proper_bodies</SPAN> and <SPAN Class="swiss"><A HREF="AA-10-1-3.html#S0240">body_stub</A></SPAN>s 
to be interchangeable &mdash; one should be able to move a <SPAN Class="swiss"><A HREF="AA-3-11.html#S0090">proper_body</A></SPAN> 
to a <SPAN Class="swiss"><A HREF="AA-10-1-3.html#S0245">subunit</A></SPAN>, 
and vice-versa, without changing the semantics. Clearly, anything that 
should cause freezing should do so even if it's inside a <SPAN Class="swiss"><A HREF="AA-3-11.html#S0090">proper_body</A></SPAN>. 
However, if we make it a <SPAN Class="swiss"><A HREF="AA-10-1-3.html#S0240">body_stub</A></SPAN>, 
then the compiler can't see that thing that should cause freezing. So 
we make <SPAN Class="swiss"><A HREF="AA-10-1-3.html#S0240">body_stub</A></SPAN>s 
cause freezing, just in case they contain something that should cause 
freezing. But that means we need to do the same for <SPAN Class="swiss">proper_bodies</SPAN>.</DIV>
<DIV Class="paranum">3.e</DIV>
<DIV Class="Annotations">Another reason for bodies to cause freezing, 
there could be an added implementation burden if an entity declared in 
an enclosing <SPAN Class="swiss"><A HREF="AA-3-11.html#S0086">declarative_part</A></SPAN> 
is frozen within a nested body, since some compilers look at bodies after 
looking at the containing <SPAN Class="swiss"><A HREF="AA-3-11.html#S0086">declarative_part</A></SPAN>. 
</DIV>
<DIV Class="paranum">4/1</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">{<I><A HREF="defect1.html#8652/0046">8652/0046</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00106.TXT">AI95-00106-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>freezing (entity caused by a construct)</I> 
[distributed]}</SPAN> <A NAME="I5317"></A>A construct that (explicitly 
or implicitly) references an entity can cause the <I>freezing</I> of 
the entity, as defined by subsequent paragraphs. <SPAN STYLE="font-size: 80%">{<I>freezing 
(by a constituent of a construct)</I> [partial]}</SPAN> <A NAME="I5318"></A>At 
the place where a construct causes freezing, each <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>, 
<SPAN class="insert1"><SPAN Class="swiss"><A HREF="AA-4-4.html#S0115">expression</A></SPAN>, 
<SPAN Class="swiss"><A HREF="AA-4-1.html#S0095">implicit_dereference</A></SPAN></SPAN><SPAN class="delete1">&nbsp;expression</SPAN>[, 
or <SPAN Class="swiss"><A HREF="AA-3-5.html#S0037">range</A></SPAN>] 
within the construct causes freezing:&nbsp;</DIV>
<DIV Class="paranum">4.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>Note that in the sense 
of this paragraph, a <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0028">subtype_mark</A></SPAN> 
&ldquo;references&rdquo; the denoted subtype, but not the type.&nbsp;</DIV>
<DIV Class="paranum">5</DIV>
<UL Class="Bulleted" Style="margin-bottom: 0.3em"><LI TYPE=DISC><SPAN STYLE="font-size: 80%">{<I>freezing 
(generic_instantiation)</I> [partial]}</SPAN> <A NAME="I5319"></A>The 
occurrence of a <SPAN Class="swiss"><A HREF="AA-12-3.html#S0257">generic_instantiation</A></SPAN> 
causes freezing; also, if a parameter of the instantiation is defaulted, 
the <SPAN Class="swiss"><A HREF="AA-3-7.html#S0063">default_expression</A></SPAN> 
or <SPAN Class="swiss"><A HREF="AA-12-6.html#S0279">default_name</A></SPAN> 
for that parameter causes freezing.</LI></UL>
<DIV Class="paranum">6</DIV>
<UL Class="Bulleted" Style="margin-bottom: 0.3em"><LI TYPE=DISC><SPAN STYLE="font-size: 80%">{<I>freezing 
(object_declaration)</I> [partial]}</SPAN> <A NAME="I5320"></A>The occurrence 
of an <SPAN Class="swiss"><A HREF="AA-3-3-1.html#S0032">object_declaration</A></SPAN> 
that has no corresponding completion causes freezing.&nbsp;</LI></UL>
<DIV Class="paranum">6.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>Note that this does not 
include a <SPAN Class="swiss"><A HREF="AA-12-4.html#S0261">formal_object_declaration</A></SPAN>. 
</DIV>
<DIV Class="paranum">7</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN STYLE="font-size: 80%">{<I>freezing 
(subtype caused by a record extension)</I> [partial]}</SPAN> <A NAME="I5321"></A>The 
declaration of a record extension causes freezing of the parent subtype. 
</LI></UL>
<DIV Class="paranum">7.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>This combined with another 
rule specifying that primitive subprogram declarations shall precede 
freezing ensures that all descendants of a tagged type implement all 
of its dispatching operations.</DIV>
<DIV Class="paranum">7.b/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
The declaration of a private extension does not cause freezing. The freezing 
is deferred until the full type declaration, which will necessarily be 
for a record extension<SPAN class="insert2">, task, or protected type 
(the latter only for a limited private extension derived from an interface)</SPAN>. 
</DIV>
<DIV Class="paranum">7.1/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
<SPAN class="insert2">The declaration of a record extension, interface 
type, task unit, or protected unit causes freezing of any progenitor 
types specified in the declaration.</SPAN>&nbsp;</LI></UL>
<DIV Class="paranum">7.b.1/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Reason:&nbsp;</B>This rule 
has the same purpose as the one above: ensuring that all descendants 
of an interface tagged type implement all of its dispatching operations. 
As with the previous rule, a private extension does not freeze its progenitors; 
the full type declaration (which must have the same progenitors) will 
do that.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">7.b.2/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Ramification:&nbsp;</B>An 
interface type can be a parent as well as a progenitor; these rules are 
similar so that the location of an interface in a record extension does 
not have an effect on the freezing of the interface type.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">8/1</DIV>
<DIV Class="Normal">{<I><A HREF="defect1.html#8652/0046">8652/0046</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00106.TXT">AI95-00106-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>freezing (by an expression)</I> [partial]}</SPAN> 
<A NAME="I5322"></A>A static expression causes freezing where it occurs. 
<SPAN class="insert1"><SPAN STYLE="font-size: 80%">{<I>freezing (by an 
object name)</I> [partial]}</SPAN> <A NAME="I5323"></A>An object name 
or</SPAN><SPAN class="delete1">&nbsp;A</SPAN> nonstatic expression causes 
freezing where it occurs, unless the <SPAN class="insert1">name or&nbsp;</SPAN>expression 
is part of a <SPAN Class="swiss"><A HREF="AA-3-7.html#S0063">default_expression</A></SPAN>, 
a <SPAN Class="swiss"><A HREF="AA-12-6.html#S0279">default_name</A></SPAN>, 
or a per-object expression of a component's <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0029">constraint</A></SPAN>, 
in which case, the freezing occurs later as part of another construct.</DIV>
<DIV Class="paranum">8.1/1</DIV>
<DIV Class="Normal">&nbsp;&nbsp;{<I><A HREF="defect1.html#8652/0046">8652/0046</A></I>} 
<SPAN class="insert1"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00106.TXT">AI95-00106-01</A></I>} 
<SPAN class="insert1"><SPAN STYLE="font-size: 80%">{<I>freezing (by an 
implicit call)</I> [partial]}</SPAN> <A NAME="I5324"></A>An implicit 
call freezes the same entities that would be frozen by an explicit call. 
This is true even if the implicit call is removed via implementation 
permissions.</SPAN></DIV>
<DIV Class="paranum">8.2/1</DIV>
<DIV Class="Normal">&nbsp;&nbsp;{<I><A HREF="defect1.html#8652/0046">8652/0046</A></I>} 
<SPAN class="insert1"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00106.TXT">AI95-00106-01</A></I>} 
<SPAN class="insert1"><SPAN STYLE="font-size: 80%">{<I>freezing (subtype 
caused by an implicit conversion)</I> [partial]}</SPAN> <A NAME="I5325"></A>If 
an expression is implicitly converted to a type or subtype <I>T</I>, 
then at the place where the expression causes freezing, <I>T</I> is frozen.</SPAN></DIV>
<DIV Class="paranum">9</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">The following rules 
define which entities are frozen at the place where a construct causes 
freezing:&nbsp;</DIV>
<DIV Class="paranum">10</DIV>
<UL Class="Bulleted" Style="margin-bottom: 0.3em"><LI TYPE=DISC><SPAN STYLE="font-size: 80%">{<I>freezing 
(type caused by an expression)</I> [partial]}</SPAN> <A NAME="I5326"></A>At 
the place where an expression causes freezing, the type of the expression 
is frozen, unless the expression is an enumeration literal used as a 
<SPAN Class="swiss"><A HREF="AA-3-8-1.html#S0074">discrete_choice</A></SPAN> 
of the <SPAN Class="swiss"><A HREF="AA-4-3-3.html#S0111">array_aggregate</A></SPAN> 
of an <SPAN Class="swiss"><A HREF="AA-13-4.html#S0287">enumeration_representation_clause</A></SPAN>. 
</LI></UL>
<DIV Class="paranum">10.a</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>We considered making enumeration 
literals never cause freezing, which would be more upward compatible, 
but examples like the variant record aggregate (Discrim =&gt; Red, ...) 
caused us to change our mind. Furthermore, an enumeration literal is 
a static expression, so the implementation should be allowed to represent 
it using its representation.&nbsp;</DIV>
<DIV Class="paranum">10.b</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><B>Ramification: 
</B>The following pathological example was legal in Ada 83, but is illegal 
in Ada 95:&nbsp;</DIV>
<DIV Class="paranum">10.c</DIV>
<DIV Class="SmallExamples"><B>package</B>&nbsp;P1&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T&nbsp;<B>is</B>&nbsp;<B>private</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>package</B>&nbsp;P2&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Composite(D&nbsp;:&nbsp;Boolean)&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>record</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>case</B>&nbsp;D&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>when</B>&nbsp;False&nbsp;=&gt;&nbsp;Cf&nbsp;:&nbsp;Integer;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>when</B>&nbsp;True&nbsp;&nbsp;=&gt;&nbsp;Ct&nbsp;:&nbsp;T;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;<B>case</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;<B>record</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;P2;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;:&nbsp;Boolean&nbsp;:=&nbsp;P2.&quot;=&quot;(&nbsp;(False,1),&nbsp;(False,1)&nbsp;);<BR>
<B>private</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T&nbsp;<B>is</B>&nbsp;<B>array</B>(1..Func_Call)&nbsp;<B>of</B>&nbsp;Integer;<BR>
<B>end</B>;</DIV>
<DIV Class="paranum">10.d</DIV>
<DIV Class="Annotations">In Ada 95, the declaration of X freezes Composite 
(because it contains an expression of that type), which in turn freezes 
T (even though Ct does not exist in this particular case). But type T 
is not completely defined at that point, violating the rule that a type 
shall be completely defined before it is frozen. In Ada 83, on the other 
hand, there is no occurrence of the name T, hence no forcing occurrence 
of T.&nbsp;</DIV>
<DIV Class="paranum">11</DIV>
<UL Class="Bulleted" Style="margin-bottom: 0.3em"><LI TYPE=DISC><SPAN STYLE="font-size: 80%">{<I>freezing 
(entity caused by a name)</I> [partial]}</SPAN> <A NAME="I5327"></A>At 
the place where a <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
causes freezing, the entity denoted by the <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
is frozen, unless the <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
is a <SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN> 
of an expanded name; <SPAN STYLE="font-size: 80%">{<I>freezing (nominal 
subtype caused by a name)</I> [partial]}</SPAN> <A NAME="I5328"></A>at 
the place where an object <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
causes freezing, the nominal subtype associated with the <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
is frozen.&nbsp;</LI></UL>
<DIV Class="paranum">11.a/2</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00114.TXT">AI95-00114-01</A></I>} 
This only matters in the presence of deferred constants or access types; 
an <SPAN Class="swiss"><A HREF="AA-3-3-1.html#S0032">object_declaration</A></SPAN> 
other than a <SPAN class="insert2">deferred constant declaration</SPAN><SPAN class="delete2"><SPAN Class="swiss">&nbsp;deferred_constant_declaration</SPAN></SPAN> 
causes freezing of the nominal subtype, plus all component junk.</DIV>
<DIV Class="paranum">11.b/1</DIV>
<DIV Class="Annotations"><SPAN STYLE="font-size: 80%"><I>This paragraph 
was deleted.</I></SPAN><SPAN class="delete1"></SPAN>{<I><A HREF="defect1.html#8652/0046">8652/0046</A></I>} 
<SPAN class="delete1"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00106.TXT">AI95-00106-01</A></I>} 
<SPAN class="delete1"><SPAN Class="swiss"><A HREF="AA-4-1.html#S0095">Implicit_dereference</A></SPAN>s 
are covered by <SPAN Class="swiss"><A HREF="AA-4-4.html#S0115">expression</A></SPAN>.</SPAN> 
</DIV>
<DIV Class="paranum">11.1/1</DIV>
<UL Class="Bulleted" Style="margin-bottom: 0.3em"><LI TYPE=DISC>{<I><A HREF="defect1.html#8652/0046">8652/0046</A></I>} 
<SPAN class="insert1"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00106.TXT">AI95-00106-01</A></I>} 
<SPAN class="insert1"><SPAN STYLE="font-size: 80%">{<I>freezing (subtype 
caused by an implicit dereference)</I> [partial]}</SPAN> <A NAME="I5329"></A>At 
the place where an <SPAN Class="swiss"><A HREF="AA-4-1.html#S0095">implicit_dereference</A></SPAN> 
causes freezing, the nominal subtype associated with the <SPAN Class="swiss"><A HREF="AA-4-1.html#S0095">implicit_dereference</A></SPAN> 
is frozen.</SPAN></LI></UL>
<DIV Class="paranum">11.c/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Discussion:&nbsp;</B>This 
rule ensures that X.D freezes the same entities that X.<B>all</B>.D does. 
Note that an <SPAN Class="swiss"><A HREF="AA-4-1.html#S0095">implicit_dereference</A></SPAN> 
is neither a <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
nor <SPAN Class="swiss"><A HREF="AA-4-4.html#S0115">expression</A></SPAN> 
by itself, so it isn't covered by other rules.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">12</DIV>
<UL Class="Bulleted" Style="margin-bottom: 0.3em"><LI TYPE=DISC>[<SPAN STYLE="font-size: 80%">{<I>freezing 
(type caused by a range)</I> [partial]}</SPAN> <A NAME="I5330"></A>At 
the place where a <SPAN Class="swiss"><A HREF="AA-3-5.html#S0037">range</A></SPAN> 
causes freezing, the type of the <SPAN Class="swiss"><A HREF="AA-3-5.html#S0037">range</A></SPAN> 
is frozen.]&nbsp;</LI></UL>
<DIV Class="paranum">12.a</DIV>
<DIV Class="Annotations"><B>Proof:&nbsp;</B>This is consequence of the facts 
that expressions freeze their type, and the Range attribute is defined 
to be equivalent to a pair of expressions separated by &ldquo;..&rdquo;.} 
</DIV>
<DIV Class="paranum">13</DIV>
<UL Class="Bulleted" Style="margin-bottom: 0.3em"><LI TYPE=DISC><SPAN STYLE="font-size: 80%">{<I>freezing 
(designated subtype caused by an allocator)</I> [partial]}</SPAN> <A NAME="I5331"></A>At 
the place where an <SPAN Class="swiss"><A HREF="AA-4-8.html#S0129">allocator</A></SPAN> 
causes freezing, the designated subtype of its type is frozen. If the 
type of the <SPAN Class="swiss"><A HREF="AA-4-8.html#S0129">allocator</A></SPAN> 
is a derived type, then all ancestor types are also frozen.&nbsp;</LI></UL>
<DIV Class="paranum">13.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B><SPAN Class="swiss"><A HREF="AA-4-8.html#S0129">Allocator</A></SPAN>s 
also freeze the named subtype, as a consequence of other rules.</DIV>
<DIV Class="paranum">13.b</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em">The ancestor types 
are frozen to prevent things like this:&nbsp;</DIV>
<DIV Class="paranum">13.c</DIV>
<DIV Class="SmallExamples"><B>type</B>&nbsp;Pool_Ptr&nbsp;<B>is</B>&nbsp;<B>access</B>&nbsp;System.Storage_Pools.Root_Storage_Pool'Class;<BR>
<B>function</B>&nbsp;F&nbsp;<B>return</B>&nbsp;Pool_Ptr;</DIV>
<DIV Class="paranum">13.d</DIV>
<DIV Class="SmallExamples"><B>package</B>&nbsp;P&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;A1&nbsp;<B>is</B>&nbsp;<B>access</B>&nbsp;Boolean;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;A2&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;A1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;A3&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;A2;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;:&nbsp;A3&nbsp;:=&nbsp;<B>new</B>&nbsp;Boolean;&nbsp;--<SPAN Class="roman"><I>&nbsp;Don't&nbsp;know&nbsp;what&nbsp;pool&nbsp;yet!</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>for</B>&nbsp;A1'Storage_Pool&nbsp;<B>use</B>&nbsp;F.all;<BR>
<B>end</B>&nbsp;P;</DIV>
<DIV Class="paranum">13.e</DIV>
<DIV Class="Annotations">This is necessary because derived access types 
share their parent's pool.&nbsp;</DIV>
<DIV Class="paranum">14</DIV>
<UL Class="Bulleted" Style="margin-bottom: 0.3em"><LI TYPE=DISC><SPAN STYLE="font-size: 80%">{<I>freezing 
(subtypes of the profile of a callable entity)</I> [partial]}</SPAN> 
<A NAME="I5332"></A>At the place where a callable entity is frozen, each 
subtype of its profile is frozen. If the callable entity is a member 
of an entry family, the index subtype of the family is frozen. <SPAN STYLE="font-size: 80%">{<I>freezing 
(function call)</I> [partial]}</SPAN> <A NAME="I5333"></A>At the place 
where a function call causes freezing, if a parameter of the call is 
defaulted, the <SPAN Class="swiss"><A HREF="AA-3-7.html#S0063">default_expression</A></SPAN> 
for that parameter causes freezing.&nbsp;</LI></UL>
<DIV Class="paranum">14.a</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>We don't worry about freezing 
for procedure calls or entry calls, since a body freezes everything that 
precedes it, and the end of a declarative part freezes everything in 
the declarative part.&nbsp;</DIV>
<DIV Class="paranum">15</DIV>
<UL Class="Bulleted" Style="margin-bottom: 0.3em"><LI TYPE=DISC><SPAN STYLE="font-size: 80%">{<I>freezing 
(type caused by the freezing of a subtype)</I> [partial]}</SPAN> <A NAME="I5334"></A>At 
the place where a subtype is frozen, its type is frozen. <SPAN STYLE="font-size: 80%">{<I>freezing 
(constituents of a full type definition)</I> [partial]}</SPAN> <A NAME="I5335"></A><SPAN STYLE="font-size: 80%">{<I>freezing 
(first subtype caused by the freezing of the type)</I> [partial]}</SPAN> 
<A NAME="I5336"></A>At the place where a type is frozen, any expressions 
or <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>s within 
the full type definition cause freezing; the first subtype, and any component 
subtypes, index subtypes, and parent subtype of the type are frozen as 
well. <SPAN STYLE="font-size: 80%">{<I>freezing (class-wide type caused 
by the freezing of the specific type)</I> [partial]}</SPAN> <A NAME="I5337"></A><SPAN STYLE="font-size: 80%">{<I>freezing 
(specific type caused by the freezing of the class-wide type)</I> [partial]}</SPAN> 
<A NAME="I5338"></A>For a specific tagged type, the corresponding class-wide 
type is frozen as well. For a class-wide type, the corresponding specific 
type is frozen as well.&nbsp;</LI></UL>
<DIV Class="paranum">15.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>Freezing a type needs to 
freeze its first subtype in order to preserve the property that the subtype-specific 
aspects of statically matching subtypes are the same.</DIV>
<DIV Class="paranum">15.b</DIV>
<DIV Class="Annotations">Freezing an access type does not freeze its 
designated subtype.&nbsp;</DIV>
<DIV Class="paranum">15.1/2</DIV>
<UL Class="Bulleted" Style="margin-bottom: 0.3em"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00341.TXT">AI95-00341-01</A></I>} 
<SPAN class="insert2">At the place where a specific tagged type is frozen, 
the primitive subprograms of the type are frozen.</SPAN>&nbsp;</LI></UL>
<DIV Class="paranum">15.c/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Reason:&nbsp;</B>We have 
a language design principle that all of the details of a specific tagged 
type are known at its freezing point. But that is only true if the primitive 
subprograms are frozen at this point as well. Late changes of Import 
and address clauses violate the principle.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">15.d/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Implementation Note: 
</B>This rule means that no implicit call to Initialize or Adjust can 
freeze a subprogram (the type and thus subprograms would have been frozen 
at worst at the same point).</SPAN>&nbsp;</DIV>

<H4 Class="centered">Legality Rules</H4>
<DIV Class="paranum">16</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">[The explicit declaration 
of a primitive subprogram of a tagged type shall occur before the type 
is frozen (see <A HREF="AA-3-9-2.html">3.9.2</A>).]&nbsp;</DIV>
<DIV Class="paranum">16.a</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>This rule is needed because (1) 
we don't want people dispatching to things that haven't been declared 
yet, and (2) we want to allow tagged type descriptors to be static (allocated 
statically, and initialized to link-time-known symbols). Suppose T2 inherits 
primitive P from T1, and then overrides P. Suppose P is called <I>before</I> 
the declaration of the overriding P. What should it dispatch to? If the 
answer is the new P, we've violated the first principle above. If the 
answer is the old P, we've violated the second principle. (A call to 
the new one necessarily raises Program_Error, but that's beside the point.)</DIV>
<DIV Class="paranum">16.b</DIV>
<DIV Class="Annotations">Note that a call upon a dispatching operation 
of type <I>T</I> will freeze <I>T</I>.</DIV>
<DIV Class="paranum">16.c</DIV>
<DIV Class="Annotations">We considered applying this rule to all derived 
types, for uniformity. However, that would be upward incompatible, so 
we rejected the idea. As in Ada 83, for an untagged type, the above call 
upon P will call the old P (which is arguably confusing).&nbsp;</DIV>
<DIV Class="paranum">17</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">[A type shall be completely 
defined before it is frozen (see <A HREF="AA-3-11-1.html">3.11.1</A> 
and <A HREF="AA-7-3.html">7.3</A>).]</DIV>
<DIV Class="paranum">18</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">[The completion of 
a deferred constant declaration shall occur before the constant is frozen 
(see <A HREF="AA-7-4.html">7.4</A>).]</DIV>
<DIV Class="paranum">18.a/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Proof:&nbsp;</B></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00114.TXT">AI95-00114-01</A></I>} 
<SPAN class="insert2">The above Legality Rules are stated &ldquo;officially&rdquo; 
in the referenced clauses.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">19/1</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;{<I><A HREF="defect1.html#8652/0009">8652/0009</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00137.TXT">AI95-00137-01</A></I>} 
<SPAN class="insert1">An operational or</SPAN><SPAN class="delete1">&nbsp;A</SPAN> 
representation item that directly specifies an aspect of an entity shall 
appear before the entity is frozen (see <A HREF="AA-13-1.html">13.1</A>). 
</DIV>
<DIV Class="paranum">19.a/1</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>{<I><A HREF="defect1.html#8652/0009">8652/0009</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00137.TXT">AI95-00137-01</A></I>} 
From RM83-13.1(7). The wording here forbids freezing within the <SPAN class="insert1"><SPAN Class="swiss"><A HREF="AA-13-1.html#S0283">aspect_clause</A></SPAN></SPAN><SPAN class="delete1"><SPAN Class="swiss"><A HREF="AA-13-1.html#S0284">&nbsp;representation_clause</A></SPAN></SPAN> 
itself, which was not true of the Ada 83 wording. The wording of this 
rule is carefully written to work properly for type-related representation 
items. For example, an <SPAN Class="swiss"><A HREF="AA-13-4.html#S0287">enumeration_representation_clause</A></SPAN> 
is illegal after the type is frozen, even though the <SPAN Class="swiss">_clause</SPAN> 
refers to the first subtype.</DIV>
<DIV Class="paranum">19.a.1/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00114.TXT">AI95-00114-01</A></I>} 
<SPAN class="insert2">The above Legality Rule is stated for types and 
subtypes in <A HREF="AA-13-1.html">13.1</A>, but the rule here covers 
all other entities as well.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">19.b/2</DIV>
<DIV Class="Annotations"><SPAN STYLE="font-size: 80%"><I>This paragraph 
was deleted.</I></SPAN><SPAN class="delete2"><B>Proof:&nbsp;</B></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00114.TXT">AI95-00114-01</A></I>} 
<SPAN class="delete2">The above Legality Rules are stated &ldquo;officially&rdquo; 
in the referenced clauses</SPAN>.&nbsp;</DIV>
<DIV Class="paranum">19.c</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><B>Discussion: 
</B>Here's an example that illustrates when freezing occurs in the presence 
of defaults:&nbsp;</DIV>
<DIV Class="paranum">19.d</DIV>
<DIV Class="SmallExamples"><B>type</B>&nbsp;T&nbsp;<B>is</B>&nbsp;...;<BR>
<B>function</B>&nbsp;F&nbsp;<B>return</B>&nbsp;T;<BR>
<B>type</B>&nbsp;R&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>record</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C&nbsp;:&nbsp;T&nbsp;:=&nbsp;F;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;D&nbsp;:&nbsp;Boolean&nbsp;:=&nbsp;F&nbsp;=&nbsp;F;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;<B>record</B>;<BR>
X&nbsp;:&nbsp;R;</DIV>
<DIV Class="paranum">19.e</DIV>
<DIV Class="Annotations">Since the elaboration of R's declaration does 
not allocate component C, there is no need to freeze C's subtype at that 
place. Similarly, since the elaboration of R does not evaluate the <SPAN Class="swiss"><A HREF="AA-3-7.html#S0063">default_expression</A></SPAN> 
&ldquo;F = F&rdquo;, there is no need to freeze the types involved at 
that point. However, the declaration of X <I>does</I> need to freeze 
these things. Note that even if component C did not exist, the elaboration 
of the declaration of X would still need information about T &mdash; 
even though D is not of type T, its <SPAN Class="swiss"><A HREF="AA-3-7.html#S0063">default_expression</A></SPAN> 
requires that information.&nbsp;</DIV>
<DIV Class="paranum">19.f</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>Although we define freezing 
in terms of the program text as a whole (i.e. after applying the rules 
of Section 10), the freezing rules actually have no effect beyond compilation 
unit boundaries.&nbsp;</DIV>
<DIV Class="paranum">19.g</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>That is important, because Section 
10 allows some implementation definedness in the order of things, and 
we don't want the freezing rules to be implementation defined.&nbsp;</DIV>
<DIV Class="paranum">19.h</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>These rules also have no 
effect in <SPAN Class="swiss"><A HREF="AA-5-1.html#S0131">statement</A></SPAN>s 
&mdash; they only apply within a single <SPAN Class="swiss"><A HREF="AA-3-11.html#S0086">declarative_part</A></SPAN>, 
<SPAN Class="swiss"><A HREF="AA-7-1.html#S0174">package_specification</A></SPAN>, 
<SPAN Class="swiss"><A HREF="AA-9-1.html#S0190">task_definition</A></SPAN>, 
<SPAN Class="swiss"><A HREF="AA-9-4.html#S0195">protected_definition</A></SPAN>, 
or <SPAN Class="swiss"><A HREF="AA-9-4.html#S0198">protected_body</A></SPAN>. 
</DIV>
<DIV Class="paranum">19.i</DIV>
<DIV Class="Annotations"><B>Implementation Note:&nbsp;</B>An implementation 
may choose to generate code for <SPAN Class="swiss"><A HREF="AA-3-7.html#S0063">default_expression</A></SPAN>s 
and <SPAN Class="swiss"><A HREF="AA-12-6.html#S0279">default_name</A></SPAN>s 
in line at the place of use. {<I>thunk</I>} <A NAME="I5339"></A>Alternatively, 
an implementation may choose to generate thunks (subprograms implicitly 
generated by the compiler) for evaluation of defaults. Thunk generation 
cannot, in general, be done at the place of the declaration that includes 
the default. Instead, they can be generated at the first freezing point 
of the type(s) involved. (It is impossible to write a purely one-pass 
Ada compiler, for various reasons. This is one of them &mdash; the compiler 
needs to store a representation of defaults in its symbol table, and 
then walk that representation later, no earlier than the first freezing 
point.)</DIV>
<DIV Class="paranum">19.j</DIV>
<DIV Class="Annotations">In implementation terms, the linear elaboration 
model can be thought of as preventing uninitialized dope. For example, 
the implementation might generate dope to contain the size of a private 
type. This dope is initialized at the place where the type becomes completely 
defined. It cannot be initialized earlier, because of the order-of-elaboration 
rules. The freezing rules prevent elaboration of earlier declarations 
from accessing the size dope for a private type before it is initialized.</DIV>
<DIV Class="paranum">19.k</DIV>
<DIV Class="Annotations"><A HREF="AA-2-8.html">2.8</A> overrides the 
freezing rules in the case of unrecognized <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN>s.</DIV>
<DIV Class="paranum">19.l/1</DIV>
<DIV Class="Annotations">{<I><A HREF="defect1.html#8652/0009">8652/0009</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00137.TXT">AI95-00137-01</A></I>} 
<SPAN class="insert1">An <SPAN Class="swiss"><A HREF="AA-13-1.html#S0283">aspect_clause</A></SPAN></SPAN><SPAN class="delete1">&nbsp;A 
<SPAN Class="swiss"><A HREF="AA-13-1.html#S0284">representation_clause</A></SPAN></SPAN> 
for an entity should most certainly <I>not</I> be a freezing point for 
the entity.&nbsp;</DIV>

<H4 Class="centered">Dynamic Semantics</H4>
<DIV Class="paranum">20/2</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00279.TXT">AI95-00279-01</A></I>} 
<SPAN class="insert2">The tag (see <A HREF="AA-3-9.html">3.9</A>) of 
a tagged type T is created at the point where T is frozen.<SPAN STYLE="font-size: 80%">{<I>creation 
(of a tag)</I> [partial]}</SPAN> <A NAME="I5340"></A></SPAN></DIV>

<H4 Class="centered">Incompatibilities With Ada 83</H4>
<DIV Class="paranum">20.a</DIV>
<DIV Class="Annotations">{<I>incompatibilities with Ada 83</I>} <A NAME="I5341"></A>RM83 
defines a forcing occurrence of a type as follows: &ldquo;A forcing occurrence 
is any occurrence [of the name of the type, subtypes of the type, or 
types or subtypes with subcomponents of the type] other than in a type 
or subtype declaration, a subprogram specification, an entry declaration, 
a deferred constant declaration, a <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN>, 
or a <SPAN Class="swiss">representation_clause</SPAN> for the type itself. 
In any case, an occurrence within an expression is always forcing.&rdquo;</DIV>
<DIV Class="paranum">20.b</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em">It seems like 
the wording allows things like this:&nbsp;</DIV>
<DIV Class="paranum">20.c</DIV>
<DIV Class="SmallExamples"><B>type</B>&nbsp;A&nbsp;<B>is</B>&nbsp;<B>array</B>(Integer&nbsp;<B>range</B>&nbsp;1..10)&nbsp;<B>of</B>&nbsp;Boolean;<BR>
<B>subtype</B>&nbsp;S&nbsp;<B>is</B>&nbsp;Integer&nbsp;<B>range</B>&nbsp;A'Range;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;not&nbsp;forcing&nbsp;for&nbsp;A</I></SPAN></DIV>
<DIV Class="paranum">20.d</DIV>
<DIV Class="Annotations">Occurrences within <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN>s 
can cause freezing in Ada 95. (Since such <SPAN Class="swiss"><A HREF="AA-2-8.html#S0019">pragma</A></SPAN>s 
are ignored in Ada 83, this will probably fix more bugs than it causes.) 
</DIV>

<H4 Class="centered">Extensions to Ada 83</H4>
<DIV Class="paranum">20.e</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em">{<I>extensions 
to Ada 83</I>} <A NAME="I5342"></A>In Ada 95, <SPAN Class="swiss"><A HREF="AA-12-1.html#S0256">generic_formal_parameter_declaration</A></SPAN>s 
do not normally freeze the entities from which they are defined. For 
example:&nbsp;</DIV>
<DIV Class="paranum">20.f</DIV>
<DIV Class="SmallExamples"><B>package</B>&nbsp;Outer&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T&nbsp;<B>is</B>&nbsp;<B>tagged</B>&nbsp;<B>limited</B>&nbsp;<B>private</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>generic</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T2&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>new</B>&nbsp;T&nbsp;<B>with</B>&nbsp;<B>private</B>;&nbsp;--<SPAN Class="roman"><I>&nbsp;Does&nbsp;not&nbsp;freeze&nbsp;T</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;in&nbsp;Ada&nbsp;95.</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>package</B>&nbsp;Inner&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;Inner;<BR>
<B>private</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T&nbsp;<B>is</B>&nbsp;...;<BR>
<B>end</B>&nbsp;Outer;</DIV>
<DIV Class="paranum">20.g</DIV>
<DIV Class="Annotations">This is important for the usability of generics. 
The above example uses the Ada 95 feature of formal derived types. Examples 
using the kinds of formal parameters already allowed in Ada 83 are well 
known. See, for example, comments 83-00627 and 83-00688. The extensive 
use expected for formal derived types makes this issue even more compelling 
than described by those comments. Unfortunately, we are unable to solve 
the problem that <SPAN Class="swiss"><A HREF="AA-12-3.html#S0260">explicit_generic_actual_parameter</A></SPAN>s 
cause freezing, even though a package equivalent to the instance would 
not cause freezing. This is primarily because such an equivalent package 
would have its body in the body of the containing program unit, whereas 
an instance has its body right there.&nbsp;</DIV>

<H4 Class="centered">Wording Changes from Ada 83</H4>
<DIV Class="paranum">20.h</DIV>
<DIV Class="Annotations">The concept of freezing is based on Ada 83's 
concept of &ldquo;forcing occurrences.&rdquo; The first freezing point 
of an entity corresponds roughly to the place of the first forcing occurrence, 
in Ada 83 terms. The reason for changing the terminology is that the 
new rules do not refer to any particular &ldquo;occurrence&rdquo; of 
a name of an entity. Instead, we refer to &ldquo;uses&rdquo; of an entity, 
which are sometimes implicit.</DIV>
<DIV Class="paranum">20.i</DIV>
<DIV Class="Annotations">In Ada 83, forcing occurrences were used only 
in rules about <SPAN Class="swiss">representation_clause</SPAN>s. We 
have expanded the concept to cover private types, because the rules stated 
in RM83-7.4.1(4) are almost identical to the forcing occurrence rules.</DIV>
<DIV Class="paranum">20.j</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em">The Ada 83 rules 
are changed in Ada 95 for the following reasons:&nbsp;</DIV>
<DIV Class="paranum">20.k</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>The Ada 83 rules do not work 
right for subtype-specific aspects. In an earlier version of Ada 9X, 
we considered allowing representation items to apply to subtypes other 
than the first subtype. This was part of the reason for changing the 
Ada 83 rules. However, now that we have dropped that functionality, we 
still need the rules to be different from the Ada 83 rules.</LI></UL>
<DIV Class="paranum">20.l</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>The Ada 83 rules do not achieve 
the intended effect. In Ada 83, either with or without the AIs, it is 
possible to force the compiler to generate code that references uninitialized 
dope, or force it to detect erroneousness and exception raising at compile 
time.</LI></UL>
<DIV Class="paranum">20.m</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>It was a goal of Ada 83 to avoid 
uninitialized access values. However, in the case of deferred constants, 
this goal was not achieved.</LI></UL>
<DIV Class="paranum">20.n</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>The Ada 83 rules are not only 
too weak &mdash; they are also too strong. They allow loopholes (as described 
above), but they also prevent certain kinds of <SPAN Class="swiss"><A HREF="AA-3-7.html#S0063">default_expression</A></SPAN>s 
that are harmless, and certain kinds of <SPAN Class="swiss"><A HREF="AA-12-1.html#S0252">generic_declaration</A></SPAN>s 
that are both harmless and very useful.</LI></UL>
<DIV Class="paranum">20.o/2</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00114.TXT">AI95-00114-01</A></I>} 
Ada 83 had a case where a <SPAN class="insert2"><SPAN Class="swiss"><A HREF="AA-13-1.html#S0283">aspect_clause</A></SPAN></SPAN><SPAN class="delete2"><SPAN Class="swiss"><A HREF="AA-13-1.html#S0284">&nbsp;representation_clause</A></SPAN></SPAN> 
had a strong effect on the semantics of the program &mdash; 'Small. This 
caused certain semantic anomalies. There are more cases in Ada 95, because 
the <SPAN class="insert2"><SPAN Class="swiss"><A HREF="AA-13-3.html#S0286">attribute_definition_clause</A></SPAN></SPAN><SPAN class="delete2"><SPAN Class="swiss">&nbsp;attribute_representation_clause</SPAN></SPAN> 
has been generalized.&nbsp;</LI></UL>

<H4 Class="centered">Incompatibilities With Ada 95</H4>
<DIV Class="paranum">20.p/2</DIV>
<DIV Class="Annotations">{<I><A HREF="defect1.html#8652/0046">8652/0046</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00106.TXT">AI95-00106-01</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00341.TXT">AI95-00341-01</A></I>} 
<SPAN class="insert2">{<I>incompatibilities with Ada 95</I>} <A NAME="I5343"></A><B>Corrigendum:</B> 
Various freezing rules were added to fix holes in the rules. Most importantly, 
implicit calls are now freezing, which make some representation clauses 
illegal in Ada 2005 that were legal (but dubious) in Ada 95. <B>Amendment 
Correction:</B> Similarly, the primitive subprograms of a specific tagged 
type are frozen when the type is frozen, preventing dubious convention 
changes (and address clauses) after the freezing point. In both cases, 
the code is dubious and the workaround is easy.</SPAN>&nbsp;</DIV>

<H4 Class="centered">Wording Changes from Ada 95</H4>
<DIV Class="paranum">20.q/2</DIV>
<DIV Class="Annotations">{<I><A HREF="defect1.html#8652/0009">8652/0009</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00137.TXT">AI95-00137-01</A></I>} 
<SPAN class="insert2"><B>Corrigendum:</B> Added wording to specify that 
both operational and representation attributes must be specified before 
the type is frozen.</SPAN></DIV>
<DIV Class="paranum">20.r/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
<SPAN class="insert2">Added wording that declaring a specific descendant 
of an interface type freezes the interface type.</SPAN></DIV>
<DIV Class="paranum">20.s/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00279.TXT">AI95-00279-01</A></I>} 
<SPAN class="insert2">Added wording that defines when a tag is created 
for a type (at the freezing point of the type). This is used to specify 
checking for uncreated tags (see <A HREF="AA-3-9.html">3.9</A>).</SPAN> 
</DIV>

<HR>
<DIV Style="margin-top: 0.0em; margin-bottom: 0.6em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-13-13-2.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-4.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<DIV Style="margin-top:0.0em"><IMG SRC="AE_logo.gif" height=100 width=113 align=right ALT="Ada-Europe">
<SPAN Style="font-size: 125%">Sponsored by <SPAN Style="font-size: 125%"><A HREF="http://www.ada-europe.org/"><B>Ada-Europe</B></A></SPAN></SPAN></DIV>
</BODY>
</HTML>
