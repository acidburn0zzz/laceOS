<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML><HEAD>
<TITLE>Ada '83 Quality and Style, Section 8.5: Chapter 8 Summary
</TITLE>
</HEAD><BODY>

<a href="http://sw-eng.falls-church.va.us/AdaIC/"><IMG SRC="small_adaic_logo.gif" ALT="[Ada Information Clearinghouse]"></a>
<hr>
<H1>Ada '83 Quality and Style:</h1>
<h2>Guidelines for Professional Programmers</H2>
<h6><a href="sty-00.html">Copyright</a> 1989, 1991,1992
<a href="http://software.org/">Software Productivity Consortium, Inc.</a>, Herndon, Virginia.</h6>
<hr>
<H2>CHAPTER 8: Reusability</H2>

<H3><a name="8.5">Chapter 8 Summary</a></H3>

<center><TABLE BORDER CELLPADDING=6>
   <TR>
      <TD>
<b><font size=+1>In this section...</font><BR>
<a href="#8.5.1">8.1 understanding and clarity</a><BR>
<a href="#8.5.2">8.2 robustness</a><BR>
<a href="#8.5.3">8.3 adaptability</a><BR>
<a href="#8.5.4">8.4 independence</a><BR>
</b>
     </TD>
   </TR>
</TABLE></center>


<H4><a name="8.5.1">8.1 understanding and clarity</a></H4>
<UL>
<li>Select the least restrictive names possible for reusable parts and  
their identifiers. 
<li>Select the generic name to avoid conflicting with the naming  
conventions of instantiations of the generic. 
<li> Use names which indicate the behavioral characteristics of the 
reusable part, as well as its abstraction. 
<li>Do not use any abbreviations in identifier or unit names. 
<li> Document the expected behavior of generic formal parameters just as 
any package specification is documented. 
</UL>

<H4><a name="8.5.2">8.2 robustness</a></H4>
<UL>
<li> Use named numbers and static expressions to allow multiple 
dependencies to be linked to a small number of symbols. 
<li>Use unconstrained array types for array formal parameters and array  
return values. 
<li>Make the size of local variables depend on actual parameter size where  
appropriate. 
<li>Minimize the number of assumptions made by a unit. 
<li>For assumptions which cannot be avoided, use types to automatically  
enforce conformance. 
<li>For assumptions which cannot be automatically enforced by types, add  
explicit checks to the code. 
<li>Document all assumptions. 
<li>Beware of using subtypes as type marks when declaring generic formal  
objects of type <CODE>in out</CODE>. 
<li>Beware of using subtypes as type marks when declaring parameters or  
return values of generic formal subprograms. 
<li>Use attributes rather than literal values. 
<li>Be careful about overloading the names of subprograms exported by the  
same generic package. 
<li>Within a specification, document any tasks that would be activated by  
<b>with</b>'ing the specification and by using any part of the specification. 
<li>Document which generic formal parameters are accessed from a task  
hidden inside the generic unit. 
<li>Propagate exceptions out of reusable parts. Handle exceptions within  
reusable parts only when you are certain that the handling is appropriate in  
all circumstances. 
<li> Propagate exceptions raised by generic formal subprograms after 
performing any cleanup necessary to the correct operation of future 
invocations of the generic instantiation. 
<li>Leave state variables in a valid state when raising an exception. 
<li>Leave parameters unmodified when raising an exception. 
</UL>

<H4><a name="8.5.3">8.3 adaptability</a></H4>
<UL>
<li>Provide complete functionality in a reusable part or set of parts.  
Build in complete functionality, including end conditions, even if some  
functionality is not needed in this application. 
<li>More specifically, provide initialization and finalization procedures  
for every data structure that may contain dynamic data. 
<li>Use generic units to avoid code duplication. 
<li>Parameterize generic units for maximum adaptability. 
<li>Reuse common instantiations of generic units, as well as the generic  
units themselves. 
<li>Use generic units to encapsulate algorithms independently of data type. 
<li>Use abstract data types in preference to abstract data objects. 
<li>Use generic units to implement abstract data types independently of  
their component data type. 
<li>Provide iterators for traversing complex data structures within  
reusable parts. 
<li>Provide both active and passive iterators. 
<li>Protect the iterators from errors due to modification of the data  
structure during iteration. 
<li>Document the behavior of the iterators when the data structure is  
modified during traversal. 
<li>Use limited private (not private) for generic formal types, explicitly  
importing assignment and equality operations if required. 
<li>Export the least restrictive type that maintains the integrity of the  
data and abstraction while allowing alternate implementations. 
<li>Use mode <CODE>in out</CODE> rather than <CODE>out</CODE> for parameters of a generic formal  
subprogram, when the parameters are of an imported limited type. 
</UL>

<H4><a name="8.5.4">8.4 independence</a></H4>
<UL>
<li>Minimize <CODE>with</CODE> clauses on reusable parts, especially on their  
specifications. 
<li>Use generic parameters instead of <CODE>with</CODE> statements to reduce the number  
of context clauses on a reusable part. 
<li> Use generic parameters instead of <CODE>with</CODE> statements to import portions 
of a package rather than the entire package. 
<li>For nongenerics named in a context clause, avoid pragma <CODE>Elaborate</CODE>. 
<li>Use a pragma <CODE>Elaborate</CODE> for generics named in a context clause. 
<li>Avoid pragma <CODE>Priority</CODE> in tasks hidden in reusable parts. 
<li>Create families of generic or other parts with similar specifications. 
<li>Structure reusable code to take advantage of dead code removal by the  
compiler. 
<li>Write table-driven reusable parts where possible and appropriate. 
</UL>
<hr>
<A HREF="index.html">Back to document index</A>
</BODY></HTML>
