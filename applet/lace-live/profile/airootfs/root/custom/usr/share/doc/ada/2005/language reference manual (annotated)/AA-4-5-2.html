<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Relational Operators and Membership Tests</TITLE>
    <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    H4.centered {text-align: center}
    SPAN.swiss {font-family: Arial, Helvetica, sans-serif; font-size: 92%}
    SPAN.roman {font-family: "Times New Roman", Times, serif}
    DIV.paranum {float: left; font-family: Arial, Helvetica, sans-serif; font-size: 64%; width: 2.8em; margin-left: -0.4em; margin-right: -3.0em; margin-top: 0.2em}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    SPAN.insert1 {text-decoration: underline; color: rgb(0,51,51) }
    SPAN.delete1 {text-decoration: line-through; color: rgb(0,51,51) }
    SPAN.insert2 {text-decoration: underline; color: rgb(0,102,0) }
    SPAN.delete2 {text-decoration: line-through; color: rgb(0,102,0) }
    DIV.Normal {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.2em; margin-bottom: 0.6em}
    DIV.Annotations {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 6.2em; margin-bottom: 0.6em}
    DIV.Notes {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em; margin-bottom: 0.6em}
    DIV.NotesHeader {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em}
    DIV.Examples {font-family: "Courier New", monospace; font-size: 90%; line-height: 122%; margin-left: 3.4em; margin-bottom: 0.6em}
    DIV.SmallExamples {font-family: "Courier New", monospace; font-size: 72%; line-height: 122%; margin-left: 9.6em; margin-bottom: 0.6em}
    UL.Bulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.NestedBulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 5.2em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#000080" VLINK="#330033" ALINK="#0000FF">
<DIV><B><SPAN Style="font-size:200%; color: rgb(0,51,153)">Annotated</SPAN><SPAN Style="font-size:200%; color: rgb(0,0,102)">&nbsp;Ada Reference Manual</SPAN></B> &mdash; <A HREF="AA-TTL.html"><B>Legal Information</B></A></DIV>
<DIV Style="margin-top: 0.6em; margin-bottom: 0.0em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-4-5-1.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-4-5-3.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<HR>
<H1>4.5.2 Relational Operators and Membership Tests</H1>
<DIV Class="paranum">1</DIV>
<DIV Class="Normal">[<SPAN STYLE="font-size: 80%">{<I>relational operator</I>}</SPAN> 
<A NAME="I2841"></A><SPAN STYLE="font-size: 80%">{<I>operator (relational)</I>}</SPAN> 
<A NAME="I2842"></A><SPAN STYLE="font-size: 80%">{<I>comparison operator: 
See relational operator</I>}</SPAN> <A NAME="I2843"></A><SPAN STYLE="font-size: 80%">{<I>equality 
operator</I>}</SPAN> <A NAME="I2844"></A><SPAN STYLE="font-size: 80%">{<I>operator 
(equality)</I>}</SPAN> <A NAME="I2845"></A>The <I>equality operators</I> 
= (equals) and /= (not equals) are predefined for nonlimited types. <SPAN STYLE="font-size: 80%">{<I>ordering 
operator</I>}</SPAN> <A NAME="I2846"></A><SPAN STYLE="font-size: 80%">{<I>operator 
(ordering)</I>}</SPAN> <A NAME="I2847"></A>The other <SPAN Class="swiss"><A HREF="AA-4-5.html#S0122">relational_operator</A></SPAN>s 
are the <I>ordering operators</I> &lt; (less than), &lt;= (less than 
or equal), &gt; (greater than), and &gt;= (greater than or equal). <SPAN STYLE="font-size: 80%">{<I>= 
operator</I>}</SPAN> <A NAME="I2848"></A><SPAN STYLE="font-size: 80%">{<I>operator 
(=)</I>}</SPAN> <A NAME="I2849"></A><SPAN STYLE="font-size: 80%">{<I>equal 
operator</I>}</SPAN> <A NAME="I2850"></A><SPAN STYLE="font-size: 80%">{<I>operator 
(equal)</I>}</SPAN> <A NAME="I2851"></A><SPAN STYLE="font-size: 80%">{<I>/= 
operator</I>}</SPAN> <A NAME="I2852"></A><SPAN STYLE="font-size: 80%">{<I>operator 
(/=)</I>}</SPAN> <A NAME="I2853"></A><SPAN STYLE="font-size: 80%">{<I>not 
equal operator</I>}</SPAN> <A NAME="I2854"></A><SPAN STYLE="font-size: 80%">{<I>operator 
(not equal)</I>}</SPAN> <A NAME="I2855"></A><SPAN STYLE="font-size: 80%">{<I>&lt; 
operator</I>}</SPAN> <A NAME="I2856"></A><SPAN STYLE="font-size: 80%">{<I>operator 
(&lt;)</I>}</SPAN> <A NAME="I2857"></A><SPAN STYLE="font-size: 80%">{<I>less 
than operator</I>}</SPAN> <A NAME="I2858"></A><SPAN STYLE="font-size: 80%">{<I>operator 
(less than)</I>}</SPAN> <A NAME="I2859"></A><SPAN STYLE="font-size: 80%">{<I>&lt;= 
operator</I>}</SPAN> <A NAME="I2860"></A><SPAN STYLE="font-size: 80%">{<I>operator 
(&lt;=)</I>}</SPAN> <A NAME="I2861"></A><SPAN STYLE="font-size: 80%">{<I>less 
than or equal operator</I>}</SPAN> <A NAME="I2862"></A><SPAN STYLE="font-size: 80%">{<I>operator 
(less than or equal)</I>}</SPAN> <A NAME="I2863"></A><SPAN STYLE="font-size: 80%">{<I>&gt; 
operator</I>}</SPAN> <A NAME="I2864"></A><SPAN STYLE="font-size: 80%">{<I>operator 
(&gt;)</I>}</SPAN> <A NAME="I2865"></A><SPAN STYLE="font-size: 80%">{<I>greater 
than operator</I>}</SPAN> <A NAME="I2866"></A><SPAN STYLE="font-size: 80%">{<I>operator 
(greater than)</I>}</SPAN> <A NAME="I2867"></A><SPAN STYLE="font-size: 80%">{<I>&gt;= 
operator</I>}</SPAN> <A NAME="I2868"></A><SPAN STYLE="font-size: 80%">{<I>operator 
(&gt;=)</I>}</SPAN> <A NAME="I2869"></A><SPAN STYLE="font-size: 80%">{<I>greater 
than or equal operator</I>}</SPAN> <A NAME="I2870"></A><SPAN STYLE="font-size: 80%">{<I>operator 
(greater than or equal)</I>}</SPAN> <A NAME="I2871"></A><SPAN STYLE="font-size: 80%">{<I>discrete 
array type</I>}</SPAN> <A NAME="I2872"></A>The ordering operators are 
predefined for scalar types, and for <I>discrete array types</I>, that 
is, one-dimensional array types whose components are of a discrete type. 
</DIV>
<DIV Class="paranum">1.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>The equality operators 
are not defined for <I>every</I> nonlimited type &mdash; see below for 
the exact rule.&nbsp;</DIV>
<DIV Class="paranum">2</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>membership test</I>}</SPAN> 
<A NAME="I2873"></A><SPAN STYLE="font-size: 80%">{<I>in (membership test)</I>}</SPAN> 
<A NAME="I2874"></A><SPAN STYLE="font-size: 80%">{<I>not in (membership 
test)</I>}</SPAN> <A NAME="I2875"></A>A <I>membership test</I>, using 
<B>in</B> or <B>not in</B>, determines whether or not a value belongs 
to a given subtype or range, or has a tag that identifies a type that 
is covered by a given type. Membership tests are allowed for all types.]</DIV>

<H4 Class="centered">Name Resolution Rules</H4>
<DIV Class="paranum">3/2</DIV>
<DIV Class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>expected type (membership test simple_expression)</I> 
[partial]}</SPAN> <A NAME="I2876"></A><SPAN STYLE="font-size: 80%">{<I>tested 
type (of a membership test)</I>}</SPAN> <A NAME="I2877"></A>The <I>tested 
type</I> of a membership test is the type of the <SPAN Class="swiss"><A HREF="AA-3-5.html#S0037">range</A></SPAN> 
or the type determined by the <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0028">subtype_mark</A></SPAN>. 
If the tested type is tagged, then the <SPAN Class="swiss"><A HREF="AA-4-4.html#S0117">simple_expression</A></SPAN> 
shall resolve to be of a type that <SPAN class="insert2">is convertible 
(see <A HREF="AA-4-6.html">4.6</A>) to</SPAN><SPAN class="delete2">&nbsp;covers 
or is covered by</SPAN> the tested type; if untagged, the expected type 
for the <SPAN Class="swiss"><A HREF="AA-4-4.html#S0117">simple_expression</A></SPAN> 
is the tested type.</DIV>
<DIV Class="paranum">3.a/2</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00230.TXT">AI95-00230-01</A></I>} 
The part of the rule for untagged types is stated in a way that ensures 
that operands like <SPAN class="insert2">a string literal</SPAN><SPAN class="delete2"><B>&nbsp;null</B></SPAN> 
are still legal as operands of a membership test.</DIV>
<DIV Class="paranum">3.b/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
The significance of &ldquo;<SPAN class="insert2">is convertible to</SPAN><SPAN class="delete2">&nbsp;covers 
or is covered by</SPAN>&rdquo; is that we allow the <SPAN Class="swiss"><A HREF="AA-4-4.html#S0117">simple_expression</A></SPAN> 
to be of any class-wide type that <SPAN class="insert2">could be converted 
to</SPAN><SPAN class="delete2">&nbsp;covers</SPAN> the tested type, not just 
the one rooted at the tested type.<SPAN class="insert2">&nbsp;This includes 
any class-wide type that covers the tested type, along with class-wide 
interfaces in some cases.</SPAN>&nbsp;</DIV>

<H4 Class="centered">Legality Rules</H4>
<DIV Class="paranum">4</DIV>
<DIV Class="Normal">For a membership test, if the <SPAN Class="swiss"><A HREF="AA-4-4.html#S0117">simple_expression</A></SPAN> 
is of a tagged class-wide type, then the tested type shall be (visibly) 
tagged.&nbsp;</DIV>
<DIV Class="paranum">4.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>Untagged types covered 
by the tagged class-wide type are not permitted. Such types can exist 
if they are descendants of a private type whose full type is tagged. 
This rule is intended to avoid confusion since such derivatives don't 
have their &ldquo;own&rdquo; tag, and hence are indistinguishable from 
one another at run time once converted to a covering class-wide type. 
</DIV>

<H4 Class="centered">Static Semantics</H4>
<DIV Class="paranum">5</DIV>
<DIV Class="Normal">The result type of a membership test is the predefined 
type Boolean.</DIV>
<DIV Class="paranum">6</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">The equality operators 
are predefined for every specific type <I>T</I> that is not limited, 
and not an anonymous access type, with the following specifications: 
</DIV>
<DIV Class="paranum">7</DIV>
<DIV Class="Examples"><B>function</B>&nbsp;&quot;=&quot;&nbsp;(Left,&nbsp;Right&nbsp;:&nbsp;<SPAN Class="roman"><I>T</I></SPAN>)&nbsp;<B>return</B>&nbsp;Boolean<BR>
<B>function</B>&nbsp;&quot;/=&quot;(Left,&nbsp;Right&nbsp;:&nbsp;<SPAN Class="roman"><I>T</I></SPAN>)&nbsp;<B>return</B>&nbsp;Boolean</DIV>
<DIV Class="paranum">7.1/2</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00230.TXT">AI95-00230-01</A></I>} 
<SPAN class="insert2">The following additional equality operators for 
the <I>universal_access</I> type are declared in package Standard for 
use with anonymous access types:</SPAN>&nbsp;</DIV>
<DIV Class="paranum">7.2/2</DIV>
<DIV Class="Examples"><SPAN class="insert2"><B>function</B>&nbsp;&quot;=&quot;&nbsp;(Left,&nbsp;Right&nbsp;:&nbsp;<I>universal_access</I>)&nbsp;<B>return</B>&nbsp;Boolean<BR>
<B>function</B>&nbsp;&quot;/=&quot;(Left,&nbsp;Right&nbsp;:&nbsp;<I>universal_access</I>)&nbsp;<B>return</B>&nbsp;Boolean</SPAN></DIV>
<DIV Class="paranum">8</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">The ordering operators 
are predefined for every specific scalar type <I>T</I>, and for every 
discrete array type <I>T</I>, with the following specifications:&nbsp;</DIV>
<DIV Class="paranum">9</DIV>
<DIV Class="Examples"><B>function</B>&nbsp;&quot;&lt;&quot;&nbsp;(Left,&nbsp;Right&nbsp;:&nbsp;<SPAN Class="roman"><I>T</I></SPAN>)&nbsp;<B>return</B>&nbsp;Boolean<BR>
<B>function</B>&nbsp;&quot;&lt;=&quot;(Left,&nbsp;Right&nbsp;:&nbsp;<SPAN Class="roman"><I>T</I></SPAN>)&nbsp;<B>return</B>&nbsp;Boolean<BR>
<B>function</B>&nbsp;&quot;&gt;&quot;&nbsp;(Left,&nbsp;Right&nbsp;:&nbsp;<SPAN Class="roman"><I>T</I></SPAN>)&nbsp;<B>return</B>&nbsp;Boolean<BR>
<B>function</B>&nbsp;&quot;&gt;=&quot;(Left,&nbsp;Right&nbsp;:&nbsp;<SPAN Class="roman"><I>T</I></SPAN>)&nbsp;<B>return</B>&nbsp;Boolean</DIV>

<H4 Class="centered">Name Resolution Rules</H4>
<DIV Class="paranum">9.1/2</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00230.TXT">AI95-00230-01</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00420.TXT">AI95-00420-01</A></I>} 
<SPAN class="insert2">At least one of the operands of an equality operator 
for <I>universal_access</I> shall be of a specific anonymous access type. 
Unless the predefined equality operator is identified using an expanded 
name with <SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN> 
denoting the package Standard, neither operand shall be of an access-to-object 
type whose designated type is <I>D</I> or <I>D</I>'Class, where <I>D</I> 
has a user-defined primitive equality operator such that:</SPAN>&nbsp;</DIV>
<DIV Class="paranum">9.2/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN class="insert2">its result type 
is Boolean;</SPAN></LI></UL>
<DIV Class="paranum">9.3/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN class="insert2">it is declared 
immediately within the same declaration list as <I>D</I>; and</SPAN></LI></UL>
<DIV Class="paranum">9.4/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN class="insert2">at least one 
of its operands is an access parameter with designated type <I>D</I>.</SPAN> 
</LI></UL>
<DIV Class="paranum">9.a/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Reason:&nbsp;</B>The first 
sentence prevents compatibility problems by ensuring that these operators 
are not used for named access types. Also, universal access types do 
not count for the purposes of this rule. Otherwise, equality expressions 
like (X = <B>null</B>) would be ambiguous for normal access types.</SPAN></DIV>
<DIV Class="paranum">9.b/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2">The rest of the rule makes 
it possible to call (including a dispatching call) user-defined &quot;=&quot; 
operators for anonymous access-to-object types (they'd be hidden otherwise), 
and to write user-defined &quot;=&quot; operations for anonymous access 
types (by making it possible to see the universal operator using the 
Standard prefix).</SPAN>&nbsp;</DIV>
<DIV Class="paranum">9.c/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Ramification:&nbsp;</B>We 
don't need a similar rule for anonymous access-to-subprogram types because 
they can't be primitive for any type. Note that any non-primitive user-defined 
equality operators still are hidden by the universal operators; they'll 
have to be called with a package prefix, but they are likely to be very 
uncommon.</SPAN>&nbsp;</DIV>

<H4 Class="centered">Legality Rules</H4>
<DIV Class="paranum">9.5/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00230.TXT">AI95-00230-01</A></I>} 
<SPAN class="insert2">At least one of the operands of the equality operators 
for <I>universal_access</I> shall be of type <I>universal_access</I>, 
or both shall be of access-to-object types, or both shall be of access-to-subprogram 
types. Further:</SPAN>&nbsp;</DIV>
<DIV Class="paranum">9.6/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN class="insert2">When both are 
of access-to-object types, the designated types shall be the same or 
one shall cover the other, and if the designated types are elementary 
or array types, then the designated subtypes shall statically match;</SPAN></LI></UL>
<DIV Class="paranum">9.7/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN class="insert2">When both are 
of access-to-subprogram types, the designated profiles shall be subtype 
conformant.</SPAN>&nbsp;</LI></UL>
<DIV Class="paranum">9.d/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Reason:&nbsp;</B>We don't 
want to allow completely arbitrary comparisons, as we don't want to insist 
that all access types are represented in ways that are convertible to 
one another. For instance, a compiler could use completely separate address 
spaces or incompatible representations. Instead, we allow compares if 
there exists an access parameter to which both operands could be converted. 
Since the user could write such an subprogram, and any reasonable meaning 
for &quot;=&quot; would allow using it in such a subprogram, this doesn't 
impose any further restrictions on Ada implementations.</SPAN>&nbsp;</DIV>

<H4 Class="centered">Dynamic Semantics</H4>
<DIV Class="paranum">10</DIV>
<DIV Class="Normal">For discrete types, the predefined relational operators 
are defined in terms of corresponding mathematical operations on the 
position numbers of the values of the operands.</DIV>
<DIV Class="paranum">11</DIV>
<DIV Class="Normal">For real types, the predefined relational operators 
are defined in terms of the corresponding mathematical operations on 
the values of the operands, subject to the accuracy of the type.&nbsp;</DIV>
<DIV Class="paranum">11.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>For floating point types, 
the results of comparing <I>nearly</I> equal values depends on the accuracy 
of the implementation (see <A HREF="AA-G-2-1.html">G.2.1</A>, &ldquo;<A HREF="AA-G-2-1.html">Model 
of Floating Point Arithmetic</A>&rdquo; for implementations that support 
the Numerics Annex).&nbsp;</DIV>
<DIV Class="paranum">11.b</DIV>
<DIV Class="Annotations"><B>Implementation Note:&nbsp;</B>On a machine with 
signed zeros, if the generated code generates both plus zero and minus 
zero, plus and minus zero must be equal by the predefined equality operators. 
</DIV>
<DIV Class="paranum">12</DIV>
<DIV Class="Normal">Two access-to-object values are equal if they designate 
the same object, or if both are equal to the null value of the access 
type.</DIV>
<DIV Class="paranum">13</DIV>
<DIV Class="Normal">Two access-to-subprogram values are equal if they 
are the result of the same evaluation of an Access <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0100">attribute_reference</A></SPAN>, 
or if both are equal to the null value of the access type. Two access-to-subprogram 
values are unequal if they designate different subprograms. <SPAN STYLE="font-size: 80%">{<I>unspecified</I> 
[partial]}</SPAN> <A NAME="I2878"></A>[It is unspecified whether two 
access values that designate the same subprogram but are the result of 
distinct evaluations of Access <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0100">attribute_reference</A></SPAN>s 
are equal or unequal.]&nbsp;</DIV>
<DIV Class="paranum">13.a</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>This allows each Access <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0100">attribute_reference</A></SPAN> 
for a subprogram to designate a distinct &ldquo;wrapper&rdquo; subprogram 
if necessary to support an indirect call.&nbsp;</DIV>
<DIV Class="paranum">14</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>equality operator 
(special inheritance rule for tagged types)</I>}</SPAN> <A NAME="I2879"></A>For 
a type extension, predefined equality is defined in terms of the primitive 
[(possibly user-defined)] equals operator of the parent type and of any 
tagged components of the extension part, and predefined equality for 
any other components not inherited from the parent type.&nbsp;</DIV>
<DIV Class="paranum">14.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>Two values of a type extension 
are not equal if there is a <SPAN Class="swiss"><A HREF="AA-3-8-1.html#S0071">variant_part</A></SPAN> 
in the extension part and the two values have different <SPAN Class="swiss"><A HREF="AA-3-8-1.html#S0072">variant</A></SPAN>s 
present. This is a ramification of the requirement that a discriminant 
governing such a <SPAN Class="swiss"><A HREF="AA-3-8-1.html#S0071">variant_part</A></SPAN> 
has to be a &ldquo;new&rdquo; discriminant, and so has to be equal in 
the two values for the values to be equal. Note that <SPAN Class="swiss"><A HREF="AA-3-8-1.html#S0071">variant_part</A></SPAN>s 
in the parent part need not match if the primitive equals operator for 
the parent type considers them equal.</DIV>
<DIV Class="paranum">14.b/2</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00349.TXT">AI95-00349-01</A></I>} 
<SPAN class="insert2">The full type extension's operation is used for 
a private extension. This follows as only full types have parent types; 
the type specified in a private extension is an ancestor, but not necessarily 
the parent type. For instance, in:</SPAN>&nbsp;</DIV>
<DIV Class="paranum">14.c/2</DIV>
<DIV Class="SmallExamples"><SPAN class="insert2"><B>with</B>&nbsp;Pak1;<BR>
<B>package</B>&nbsp;Pak2&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Typ3&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Pak1.Typ1&nbsp;<B>with</B>&nbsp;<B>private</B>;<BR>
<B>private</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Typ3&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Pak1.Typ2&nbsp;<B>with</B>&nbsp;<B>null</B>&nbsp;<B>record</B>;<BR>
<B>end</B>&nbsp;Pak2;</SPAN><BR>
&nbsp;&nbsp;</DIV>
<DIV Class="paranum">14.d/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2">the parent type is Pak1.Typ2, 
not Pak1.Typ1, and the equality operator of Pak1.Typ2 is used to create 
predefined equality for Typ3.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">15</DIV>
<DIV Class="Normal">For a private type, if its full type is tagged, predefined 
equality is defined in terms of the primitive equals operator of the 
full type; if the full type is untagged, predefined equality for the 
private type is that of its full type.</DIV>
<DIV Class="paranum">16</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em"><SPAN STYLE="font-size: 80%">{<I>matching 
components</I>}</SPAN> <A NAME="I2880"></A>For other composite types, 
the predefined equality operators [(and certain other predefined operations 
on composite types &mdash; see <A HREF="AA-4-5-1.html">4.5.1</A> and 
<A HREF="AA-4-6.html">4.6</A>)] are defined in terms of the corresponding 
operation on <I>matching components</I>, defined as follows:&nbsp;</DIV>
<DIV Class="paranum">17</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>For two composite objects or values 
of the same non-array type, matching components are those that correspond 
to the same <SPAN Class="swiss"><A HREF="AA-3-8.html#S0070">component_declaration</A></SPAN> 
or <SPAN Class="swiss"><A HREF="AA-3-7.html#S0062">discriminant_specification</A></SPAN>;</LI></UL>
<DIV Class="paranum">18</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>For two one-dimensional arrays of 
the same type, matching components are those (if any) whose index values 
match in the following sense: the lower bounds of the index ranges are 
defined to match, and the successors of matching indices are defined 
to match;</LI></UL>
<DIV Class="paranum">19</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>For two multidimensional arrays of 
the same type, matching components are those whose index values match 
in successive index positions.&nbsp;</LI></UL>
<DIV Class="paranum">20</DIV>
<DIV Class="Normal">The analogous definitions apply if the types of the 
two objects or values are convertible, rather than being the same.&nbsp;</DIV>
<DIV Class="paranum">20.a</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>Ada 83 seems to omit this 
part of the definition, though it is used in array type conversions. 
See <A HREF="AA-4-6.html">4.6</A>.&nbsp;</DIV>
<DIV Class="paranum">21</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">Given the above definition 
of matching components, the result of the predefined equals operator 
for composite types (other than for those composite types covered earlier) 
is defined as follows:&nbsp;</DIV>
<DIV Class="paranum">22</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>If there are no components, the result 
is defined to be True;</LI></UL>
<DIV Class="paranum">23</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>If there are unmatched components, 
the result is defined to be False;</LI></UL>
<DIV Class="paranum">24</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>Otherwise, the result is defined in 
terms of the primitive equals operator for any matching tagged components, 
and the predefined equals for any matching untagged components.&nbsp;</LI></UL>
<DIV Class="paranum">24.a</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>This asymmetry between tagged 
and untagged components is necessary to preserve upward compatibility 
and corresponds with the corresponding situation with generics, where 
the predefined operations &ldquo;reemerge&rdquo; in a generic for untagged 
types, but do not for tagged types. Also, only tagged types support user-defined 
assignment (see <A HREF="AA-7-6.html">7.6</A>), so only tagged types 
can fully handle levels of indirection in the implementation of the type. 
For untagged types, one reason for a user-defined equals operator might 
be to allow values with different bounds or discriminants to compare 
equal in certain cases. When such values are matching components, the 
bounds or discriminants will necessarily match anyway if the discriminants 
of the enclosing values match.&nbsp;</DIV>
<DIV Class="paranum">24.b</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>Two null arrays of the 
same type are always equal; two null records of the same type are always 
equal.</DIV>
<DIV Class="paranum">24.c</DIV>
<DIV Class="Annotations">Note that if a composite object has a component 
of a floating point type, and the floating point type has both a plus 
and minus zero, which are considered equal by the predefined equality, 
then a block compare cannot be used for the predefined composite equality. 
Of course, with user-defined equals operators for tagged components, 
a block compare breaks down anyway, so this is not the only special case 
that requires component-by-component comparisons. On a one's complement 
machine, a similar situation might occur for integer types, since one's 
complement machines typically have both a plus and minus (integer) zero. 
</DIV>
<DIV Class="paranum">24.d/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>To be honest:&nbsp;</B></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00230.TXT">AI95-00230-01</A></I>} 
<SPAN class="insert2">For a component with an anonymous access type, 
&ldquo;predefined equality&rdquo; is that defined for the <I>universal_access</I> 
type (anonymous access types have no equality operators of their own).</SPAN></DIV>
<DIV Class="paranum">24.e/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2">For a component with a 
tagged type <I>T</I>, &ldquo;the primitive equals operator&rdquo; is 
the one with two parameters of <I>T</I> which returns Boolean. We're 
not talking about some random other primitive function named &quot;=&quot;.</SPAN> 
</DIV>
<DIV Class="paranum">24.1/1</DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="defect1.html#8652/0016">8652/0016</A></I>} 
<SPAN class="insert1"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00123.TXT">AI95-00123-01</A></I>} 
<SPAN class="insert1">For any composite type, the order in which &quot;=&quot; 
is called for components is unspecified. Furthermore, if the result can 
be determined before calling &quot;=&quot; on some components, it is 
unspecified whether &quot;=&quot; is called on those components.<SPAN STYLE="font-size: 80%">{<I>Unspecified</I> 
[partial]}</SPAN> <A NAME="I2881"></A></SPAN></DIV>
<DIV Class="paranum">25</DIV>
<DIV Class="Normal">The predefined &quot;/=&quot; operator gives the 
complementary result to the predefined &quot;=&quot; operator.&nbsp;</DIV>
<DIV Class="paranum">25.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>Furthermore, if the user 
defines an &quot;=&quot; operator that returns Boolean, then a &quot;/=&quot; 
operator is implicitly declared in terms of the user-defined &quot;=&quot; 
operator so as to give the complementary result. See <A HREF="AA-6-6.html">6.6</A>. 
</DIV>
<DIV Class="paranum">26</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>lexicographic order</I>}</SPAN> 
<A NAME="I2882"></A>For a discrete array type, the predefined ordering 
operators correspond to <I>lexicographic order</I> using the predefined 
order relation of the component type: A null array is lexicographically 
less than any array having at least one component. In the case of nonnull 
arrays, the left operand is lexicographically less than the right operand 
if the first component of the left operand is less than that of the right; 
otherwise the left operand is lexicographically less than the right operand 
only if their first components are equal and the tail of the left operand 
is lexicographically less than that of the right (the <I>tail</I> consists 
of the remaining components beyond the first and can be null).</DIV>
<DIV Class="paranum">27</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>evaluation (membership 
test)</I> [partial]}</SPAN> <A NAME="I2883"></A>For the evaluation of 
a membership test, the <SPAN Class="swiss"><A HREF="AA-4-4.html#S0117">simple_expression</A></SPAN> 
and the <SPAN Class="swiss"><A HREF="AA-3-5.html#S0037">range</A></SPAN> 
(if any) are evaluated in an arbitrary order.</DIV>
<DIV Class="paranum">28</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">A membership test using 
<B>in</B> yields the result True if:&nbsp;</DIV>
<DIV Class="paranum">29</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>The tested type is scalar, and the 
value of the <SPAN Class="swiss"><A HREF="AA-4-4.html#S0117">simple_expression</A></SPAN> 
belongs to the given <SPAN Class="swiss"><A HREF="AA-3-5.html#S0037">range</A></SPAN>, 
or the range of the named subtype; or&nbsp;</LI></UL>
<DIV Class="paranum">29.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>The scalar membership test 
only does a range check. It does not perform any other check, such as 
whether a value falls in a &ldquo;hole&rdquo; of a &ldquo;holey&rdquo; 
enumeration type. The Pos attribute function can be used for that purpose.</DIV>
<DIV Class="paranum">29.b</DIV>
<DIV Class="Annotations">Even though Standard.Float is an unconstrained 
subtype, the test &ldquo;X in Float&rdquo; will still return False (presuming 
the evaluation of X does not raise Constraint_Error) when X is outside 
Float'Range.&nbsp;</DIV>
<DIV Class="paranum">30/2</DIV>
<UL Class="Bulleted" Style="margin-bottom: 0.3em"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00231.TXT">AI95-00231-01</A></I>} 
<SPAN class="insert2"></SPAN>The tested type is not scalar, and the value 
of the <SPAN Class="swiss"><A HREF="AA-4-4.html#S0117">simple_expression</A></SPAN> 
satisfies any constraints of the named subtype, and<SPAN class="insert2">:</SPAN><SPAN class="delete2">, 
if the type of the <SPAN Class="swiss"><A HREF="AA-4-4.html#S0117">simple_expression</A></SPAN> 
is class-wide, the value has a tag that identifies a type covered by 
the tested type.</SPAN>&nbsp;</LI></UL>
<DIV Class="paranum">30.1/2</DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00231.TXT">AI95-00231-01</A></I>} 
<SPAN class="insert2">if the type of the <SPAN Class="swiss"><A HREF="AA-4-4.html#S0117">simple_expression</A></SPAN> 
is class-wide, the value has a tag that identifies a type covered by 
the tested type;</SPAN>&nbsp;</LI></UL>
<DIV Class="paranum">30.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>Note that the tag is not 
checked if the <SPAN Class="swiss"><A HREF="AA-4-4.html#S0117">simple_expression</A></SPAN> 
is of a specific type.&nbsp;</DIV>
<DIV Class="paranum">30.2/2</DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00231.TXT">AI95-00231-01</A></I>} 
<SPAN class="insert2">if the tested type is an access type and the named 
subtype excludes null, the value of the <SPAN Class="swiss"><A HREF="AA-4-4.html#S0117">simple_expression</A></SPAN> 
is not null.</SPAN>&nbsp;</LI></UL>
<DIV Class="paranum">31</DIV>
<DIV Class="Normal">Otherwise the test yields the result False.</DIV>
<DIV Class="paranum">32</DIV>
<DIV Class="Normal">A membership test using <B>not in</B> gives the complementary 
result to the corresponding membership test using <B>in</B>.&nbsp;</DIV>

<H4 Class="centered">Implementation Requirements</H4>
<DIV Class="paranum">32.1/1</DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="defect1.html#8652/0016">8652/0016</A></I>} 
<SPAN class="insert1"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00123.TXT">AI95-00123-01</A></I>} 
<SPAN class="insert1">For all nonlimited types declared in language-defined 
packages, the &quot;=&quot; and &quot;/=&quot; operators of the type 
shall behave as if they were the predefined equality operators for the 
purposes of the equality of composite types and generic formal types.</SPAN> 
</DIV>
<DIV Class="paranum">32.a.1/1</DIV>
<DIV Class="Annotations"><SPAN class="insert1"><B>Ramification:&nbsp;</B>If 
any language-defined types are implemented with a user-defined &quot;=&quot; 
operator, then either the full type must be tagged, or the compiler must 
use &ldquo;magic&rdquo; to implement equality for this type. A normal 
user-defined &quot;=&quot; operator for an untagged type does <I>not</I> 
meet this requirement.</SPAN>&nbsp;</DIV>
<DIV Class="NotesHeader">NOTES</DIV>
<DIV Class="paranum">33/2</DIV>
<DIV Class="Notes"><SPAN STYLE="font-size: 80%"><I>This paragraph was 
deleted.</I></SPAN><SPAN class="delete2">13&nbsp;&nbsp;</SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00230.TXT">AI95-00230-01</A></I>} 
<SPAN class="delete2">No exception is ever raised by a membership test, 
by a predefined ordering operator, or by a predefined equality operator 
for an elementary type, but an exception can be raised by the evaluation 
of the operands. A predefined equality operator for a composite type 
can only raise an exception if the type has a tagged part whose primitive 
equals operator propagates an exception.</SPAN></DIV>
<DIV Class="paranum">34</DIV>
<DIV Class="Notes">14&nbsp;&nbsp;If a composite type has components that 
depend on discriminants, two values of this type have matching components 
if and only if their discriminants are equal. Two nonnull arrays have 
matching components if and only if the length of each dimension is the 
same for both.&nbsp;</DIV>

<H4 Class="centered">Examples</H4>
<DIV Class="paranum">35</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em"><I>Examples of expressions 
involving relational operators and membership tests:</I>&nbsp;</DIV>
<DIV Class="paranum">36</DIV>
<DIV Class="Examples">X&nbsp;/=&nbsp;Y</DIV>
<DIV Class="paranum">37</DIV>
<DIV Class="Examples">&quot;&quot;&nbsp;&lt;&nbsp;&quot;A&quot;&nbsp;<B>and</B>&nbsp;&quot;A&quot;&nbsp;&lt;&nbsp;&quot;Aa&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;&nbsp;True</I></SPAN><BR>
&quot;Aa&quot;&nbsp;&lt;&nbsp;&quot;B&quot;&nbsp;<B>and</B>&nbsp;&quot;A&quot;&nbsp;&lt;&nbsp;&quot;A&nbsp;&nbsp;&quot;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;&nbsp;True</I></SPAN></DIV>
<DIV Class="paranum">38</DIV>
<DIV Class="Examples">My_Car&nbsp;=&nbsp;<B>null</B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;true&nbsp;if&nbsp;My_Car&nbsp;has&nbsp;been&nbsp;set&nbsp;to&nbsp;null&nbsp;(see&nbsp;<A HREF="AA-3-10-1.html">3.10.1</A>)</I></SPAN><BR>
My_Car&nbsp;=&nbsp;Your_Car&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;true&nbsp;if&nbsp;we&nbsp;both&nbsp;share&nbsp;the&nbsp;same&nbsp;car</I></SPAN><BR>
My_Car.<B>all</B>&nbsp;=&nbsp;Your_Car.<B>all</B>&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;true&nbsp;if&nbsp;the&nbsp;two&nbsp;cars&nbsp;are&nbsp;identical</I></SPAN></DIV>
<DIV Class="paranum">39</DIV>
<DIV Class="Examples">N&nbsp;<B>not</B>&nbsp;<B>in</B>&nbsp;1&nbsp;..&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;range&nbsp;membership&nbsp;test</I></SPAN><BR>
Today&nbsp;<B>in</B>&nbsp;Mon&nbsp;..&nbsp;Fri&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;range&nbsp;membership&nbsp;test</I></SPAN><BR>
Today&nbsp;<B>in</B>&nbsp;Weekday&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;subtype&nbsp;membership&nbsp;test&nbsp;(see&nbsp;<A HREF="AA-3-5-1.html">3.5.1</A>)</I></SPAN><BR>
Archive&nbsp;<B>in</B>&nbsp;Disk_Unit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;subtype&nbsp;membership&nbsp;test&nbsp;(see&nbsp;<A HREF="AA-3-8-1.html">3.8.1</A>)</I></SPAN><BR>
Tree.<B>all</B>&nbsp;<B>in</B>&nbsp;Addition'Class&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;class&nbsp;membership&nbsp;test&nbsp;(see&nbsp;<A HREF="AA-3-9-1.html">3.9.1</A>)</I></SPAN></DIV>

<H4 Class="centered">Extensions to Ada 83</H4>
<DIV Class="paranum">39.a</DIV>
<DIV Class="Annotations">{<I>extensions to Ada 83</I>} <A NAME="I2884"></A>Membership 
tests can be used to test the tag of a class-wide value.</DIV>
<DIV Class="paranum">39.b</DIV>
<DIV Class="Annotations">Predefined equality for a composite type is 
defined in terms of the primitive equals operator for tagged components 
or the parent part.&nbsp;</DIV>

<H4 Class="centered">Wording Changes from Ada 83</H4>
<DIV Class="paranum">39.c</DIV>
<DIV Class="Annotations">The term &ldquo;membership test&rdquo; refers 
to the <SPAN Class="swiss"><A HREF="AA-4-4.html#S0116">relation</A></SPAN> 
&quot;X in S&quot; rather to simply the reserved word <B>in</B> or <B>not 
in</B>.</DIV>
<DIV Class="paranum">39.d</DIV>
<DIV Class="Annotations">We use the term &ldquo;equality operator&rdquo; 
to refer to both the = (equals) and /= (not equals) operators. Ada 83 
referred to = as <I>the</I> equality operator, and /= as the inequality 
operator. The new wording is more consistent with the ISO 10646 name 
for &quot;=&quot; (equals sign) and provides a category similar to &ldquo;ordering 
operator&rdquo; to refer to both = and /=.</DIV>
<DIV Class="paranum">39.e</DIV>
<DIV Class="Annotations">We have changed the term &ldquo;catenate&rdquo; 
to &ldquo;concatenate&rdquo;.&nbsp;</DIV>

<H4 Class="centered">Extensions to Ada 95</H4>
<DIV Class="paranum">39.f/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00230.TXT">AI95-00230-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00420.TXT">AI95-00420-01</A></I>} 
<SPAN class="insert2">{<I>extensions to Ada 95</I>} <A NAME="I2885"></A>The 
<I>universal_access</I> equality operators are new. They provide equality 
operations (most importantly, testing against <B>null</B>) for anonymous 
access types.</SPAN>&nbsp;</DIV>

<H4 Class="centered">Wording Changes from Ada 95</H4>
<DIV Class="paranum">39.g/2</DIV>
<DIV Class="Annotations">{<I><A HREF="defect1.html#8652/0016">8652/0016</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00123.TXT">AI95-00123-01</A></I>} 
<SPAN class="insert2"><B>Corrigendum:</B> Wording was added to clarify 
that the order of calls (and whether the calls are made at all) on &quot;=&quot; 
for components is unspecified. Also clarified that &quot;=&quot; must 
compose properly for language-defined types.</SPAN></DIV>
<DIV Class="paranum">39.h/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
<SPAN class="insert2">Memberships were adjusted to allow interfaces which 
don't cover the tested type, in order to be consistent with type conversions.</SPAN> 
</DIV>

<HR>
<DIV Style="margin-top: 0.0em; margin-bottom: 0.6em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-4-5-1.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-4-5-3.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<DIV Style="margin-top:0.0em"><IMG SRC="AE_logo.gif" height=100 width=113 align=right ALT="Ada-Europe">
<SPAN Style="font-size: 125%">Sponsored by <SPAN Style="font-size: 125%"><A HREF="http://www.ada-europe.org/"><B>Ada-Europe</B></A></SPAN></SPAN></DIV>
</BODY>
</HTML>
