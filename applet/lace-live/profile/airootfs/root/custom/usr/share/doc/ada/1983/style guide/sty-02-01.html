<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML><HEAD>
<TITLE>Ada '83 Quality and Style, Sec 2.1: Code Formatting
</TITLE>
</HEAD><BODY bgcolor=#ffffff>
<a href="/AdaIC/"><IMG SRC="small_adaic_logo.gif" ALT="[Ada Information Clearinghouse]"></a>
<hr>

<H1>Ada '83 Quality and Style:</h1>
<h2>Guidelines for Professional Programmers</H2>
<h6><a href="sty-00.html">Copyright</a> 1989, 1991,1992
Software Productivity Consortium, Inc., Herndon, Virginia.</h6>

<hr>

<H2><BR>CHAPTER 2: Source Code Presentation</H2>

<H3><a name="2.1">2.1     Code Formatting</a></H3>

The &quot;code formatting&quot; of Ada source code affects how the code looks, not what  
the code does. Topics included here are horizontal spacing, indentation,  
alignment, pagination, and line length. The most important guideline is to be  
consistent throughout the compilation unit as well as the project.
<center><TABLE BORDER CELLPADDING=6>
   <TR>
      <TD>
<b><font size=+1>In this section...</font><br>
<a href="#2.1.1">2.1.1   Horizontal Spacing</a><BR>
<a href="#2.1.2">2.1.2   Indentation</a><BR>
<a href="#2.1.3">2.1.3   Alignment of Operators</a><BR>
<a href="#2.1.4">2.1.4   Alignment of Declarations</a><BR>
<a href="#2.1.5">2.1.5   More on Alignment</a><BR>
<a href="#2.1.6">2.1.6   Blank Lines</a><BR>
<a href="#2.1.7">2.1.7   Pagination</a><BR>
<a href="#2.1.8">2.1.8   Number of Statements Per Line</a><BR>
<a href="#2.1.9">2.1.9   Source Code Line Length</a></b>
     </TD>
   </TR>
   <TR>
      <TD>
<b><a href="sty-02-02.html#2.2.1"> Summary of Guidelines from this section</a></b>
     </TD>
   </TR>
</TABLE></center>


<H3><BR><a name="2.1.1">2.1.1   Horizontal Spacing</a></H3>
<H4>guideline</H4>
<ul>
<li>Use consistent spacing around delimiters.
<li>Use the same spacing as you would in regular prose.
</ul>
<H4>instantiation</H4>

Specifically, leave at least one blank space in the following places, as shown  
in the examples throughout this book. More spaces may be required for the  
vertical alignment recommended in subsequent guidelines.

<UL TYPE=square>
<li>Before and after the following delimiters and binary operators: 
<pre>        +      -      *      /      &amp; 
        &lt;      =      &gt;      /=     &lt;=     &gt;= 
        :=     =&gt;     |      .. 
        : 
        &lt;&gt;
</pre>
<li>Outside of the quotes for string (&quot;) and character (') literals, 
except where prohibited. 
<li>Outside, but not inside, of parentheses.
<li>After commas (,) and semicolons (;).
</UL>
Do not leave any blank spaces in the following places, even if this conflicts  
with the above recommendation. 
<UL TYPE=square>
<li>After the plus (+) and minus (-) signs when used as unary operators. 
<li>After a function call. 
<li>Inside of label delimiters (&lt;&lt; &gt;&gt;). 
<li>Before and after the apostrophe (') and period (.) 
<li>Between multiple consecutive opening or closing parentheses. 
<li>Before commas (,) and semicolons (;). 
</UL>
When superfluous parentheses are omitted because of operator precedence rules,  
spaces may optionally be removed around the highest precedence operators in  
that expression.

<H4>example</H4>
<table border cellpadding=6><tr><td><pre>Default_String : constant String := 
      &quot;This is the long string returned by&quot; &amp; 
      &quot; default.  It is broken into multiple&quot; &amp; 
      &quot; Ada source lines for convenience.&quot;;

type Signed_Whole_16 is range -2**15 .. 2**15 - 1; 
type Address_Area    is array (Natural range &lt;&gt;) of Signed_Whole_16; 

Register : Address_Area (16#7FF0# .. 16#7FFF#); 
Memory   : Address_Area (       0 .. 16#7FEC#); 

Register(Pc) := Register(A); 

X := Signed_Whole_16(Radius * Sin(Angle)); 

Register(Index) := Memory(Base_Address + Index * Element_Length); 

Get(Value =&gt; Sensor); 

Error_Term := 1.0 - (Cos(Theta)**2 + Sin(Theta)**2); 

Z      := X**3; 
Y      := C * X + B; 
Volume := Length * Width * Height; </pre></td></tr></table>
<H4>rationale</H4>
It is a good idea to use white space around delimiters and operators because 
they are typically short (one or two character) sequences that can easily get 
lost among the longer keywords and identifiers. Putting white space around 
them makes them stand out. Consistency in spacing also helps make the source 
code easier to scan visually.
<P>
However, many of the delimiters (commas, semicolons, parentheses, etc.) are 
familiar as normal punctuation marks. It is distracting to see them spaced 
differently in a computer program than in normal text. Therefore, they should 
be spaced the same (no spaces before commas and semicolons, no spaces inside 
of parentheses, etc.).

<H4>exception</H4>
The one notable exception is the colon (:). In Ada, it is useful to use the 
colon as a tabulator or a column separator (see <a href="#2.1.4">Guideline 2.1.4</a>). In this context, 
it makes sense to put spaces before and after the colon, rather than only 
after as in normal text.

<H4>automation notes</H4>
The guidelines in this section are easily enforced with an automatic code  
formatter.
<P>
<b>Language Ref Manual references:</b> 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-02-02.html#2.2">2.2&nbsp;Lexical Elements, Separators, and Delimiters</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-02-06.html#2.6">2.6&nbsp;String Literals</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-03-06.html#3.6.3">3.6.3&nbsp;The Type String</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-04-04.html#4.4">4.4&nbsp;Expressions</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-04-05.html#4.5">4.5&nbsp;Operators and Expression Evaluation</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-04-05.html#4.5.2">4.5.2&nbsp;Relational Operators and Membership Tests</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-04-05.html#4.5.3">4.5.3&nbsp;Binary Adding Operators</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-06-04.html#6.4">6.4&nbsp;Subprogram Calls</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-06-05.html#6.5">6.5&nbsp;Function Subprograms</A>

<H3><BR><a name="2.1.2">2.1.2   Indentation</a></H3>
<H4>guideline</H4>
<UL>
<li>Indent and align nested control structures, continuation lines, and  
embedded units consistently.  
<li>Distinguish between indentation for nested control structures and for  
continuation lines. 
<li>Use spaces for indentation, not the tab character (Nissen and Wallis  
1984, w2.2). 
</UL>
<H4>instantiation</H4>
Specifically, the following indentation conventions are recommended, as shown  
in the examples throughout this book. Note that the minimum indentation is  
described. More spaces may be required for the vertical alignment recommended  
in subsequent guidelines.
<UL TYPE=square>
<li>Use the recommended paragraphing shown in the Ada Language Reference  
Manual (Department of Defense 1983). 
<li>Use three spaces as the basic unit of indentation for nesting. 
<li>Use two spaces as the basic unit of indentation for continuation lines.
</UL>
A label is outdented three spaces. A continuation line is indented two spaces:
<table border cellpadding=6><tr><td><pre>begin 
&lt;&lt;label&gt;&gt;                            | &lt;long statement with line break&gt; 
   &lt;statement&gt;                       |   &lt;trailing part of same statement&gt; 
end; </pre></td></tr></table>
<P>
The if statement and the plain loop:
<table border cellpadding=6><tr><td><pre>   if &lt;condition&gt; then               | &lt;name&gt;: 
      &lt;statements&gt;                   |    loop 
   elsif &lt;condition&gt; then            |       &lt;statements&gt; 
      &lt;statements&gt;                   |       exit when &lt;condition&gt;; 
   else                              |       &lt;statements&gt; 
      &lt;statements&gt;                   |    end loop &lt;name&gt;; 
   end if;                           | </pre></td></tr></table>
<P>
Loops with the for and while iteration schemes:
<table border cellpadding=6><tr><td><pre>   &lt;name&gt;:                           | &lt;name&gt;: 
      for &lt;scheme&gt; loop              |    while &lt;condition&gt; loop 
         &lt;statements&gt;                |       &lt;statements&gt; 
      end loop &lt;name&gt;;               |    end loop &lt;name&gt;; </pre>
</td></tr></table>
<P>
The block and the case statement as recommended in the Ada Language Reference  
Manual (Department of Defense 1983):
<table border cellpadding=6><tr><td><pre>   &lt;name&gt;:                           | case &lt;expression&gt; is 
      declare                        |    when &lt;choice&gt; =&gt; 
         &lt;declarations&gt;              |       &lt;statements&gt; 
      begin                          |    when &lt;choice&gt; =&gt; 
         &lt;statements&gt;                |       &lt;statements&gt; 
      exception                      |    when others =&gt; 
         when &lt;choice&gt; =&gt;            |       &lt;statements&gt; 
            &lt;statements&gt;             | end case;  --&lt;comment&gt; 
         when others =&gt;              | 
            &lt;statements&gt;             | 
      end &lt;name&gt;;                    |</pre></td></tr></table>
<P>
These case statements save space over the the Ada Language Reference Manual  
(Department of Defense 1983) recommendation and depend on very short statement  
lists, respectively. Whichever you choose, be consistent.
<table border cellpadding=6><tr><td><pre>   case &lt;expression&gt; is              | case &lt;expression&gt; is 
   when &lt;choice&gt; =&gt;                  |    when &lt;choice&gt; =&gt; &lt;statements&gt; 
        &lt;statements&gt;                 |                     &lt;statements&gt; 
   when &lt;choice&gt; =&gt;                  |    when &lt;choice&gt; =&gt; &lt;statements&gt; 
        &lt;statements&gt;                 |    when others   =&gt; &lt;statements&gt; 
   when others =&gt;                    | end case; 
        &lt;statements&gt;                 | 
   end case;                         |</pre></td></tr></table>
<P>
The various forms of selective wait and the timed and conditional entry calls:
<table border cellpadding=6><tr><td><pre>   select                            | select 
      when &lt;guard&gt; =&gt;                |    &lt;entry call&gt;; 
         &lt;accept statement&gt;          |    &lt;statements&gt; 
         &lt;statements&gt;                | or 
   or                                |    delay &lt;interval&gt;; 
      &lt;accept statement&gt;             |    &lt;statements&gt; 
      &lt;statements&gt;                   | end select; 
   or                                | 
      when &lt;guard&gt; =&gt;                | 
         delay &lt;interval&gt;;           | 
         &lt;statements&gt;                | 
   or                                | select 
      when &lt;guard&gt; =&gt;                |    &lt;entry call&gt;; 
         terminate;                  |    &lt;statements&gt; 
   else                              | else 
      &lt;statements&gt;                   |    &lt;statements&gt; 
   end select;                       | end select;</pre></td></tr></table>
<P>
The accept statement and a subunit:
<table border cellpadding=6><tr><td><pre>   accept &lt;specification&gt; do         | separate (&lt;parent unit&gt;) 
      &lt;statements&gt;                   | &lt;proper body&gt; 
   end &lt;name&gt;;                       |</pre></td></tr></table>
<P>
Proper bodies of program units:
<table border cellpadding=6><tr><td><pre>   procedure &lt;specification&gt; is      | package body &lt;name&gt; is 
      &lt;declarations&gt;                 |    &lt;declarations&gt; 
   begin                             | begin 
      &lt;statements&gt;                   |    &lt;statements&gt; 
   exception                         | exception 
      when &lt;choice&gt; =&gt;               |    when &lt;choice&gt; =&gt; 
         &lt;statements&gt;                |       &lt;statements&gt; 
   end &lt;name&gt;;                       | end &lt;name&gt;; 
                                     | 
   function  &lt;specification&gt;         | task body &lt;name&gt; is 
     return  &lt;type name&gt; is          |    &lt;declarations&gt; 
      &lt;declarations&gt;                 | begin 
   begin                             |    &lt;statements&gt; 
      &lt;statements&gt;                   | exception 
   exception                         |    when &lt;choice&gt; =&gt; 
      when &lt;choice&gt; =&gt;               |       &lt;statements&gt; 
         &lt;statements&gt;                | end &lt;name&gt;; 
   end &lt;name&gt;;                       |</pre></td></tr></table>
<P>
Context clauses on compilation units are arranged as a table. Generic formal  
parameters do not obscure the unit itself. Function, package, and task  
specifications use standard indentation:
<table border cellpadding=6><tr><td><pre>   with &lt;name&gt;;                      | function  &lt;specification&gt; 
   with &lt;name&gt;;                      |   return &lt;type&gt;; 
   with &lt;name&gt;;                      | 
                                     | package &lt;name&gt; is 
   use  &lt;name&gt;;                      |    &lt;declarations&gt; 
                                     | private 
   &lt;compilation unit&gt;                |    &lt;declarations&gt; 
                                     | end &lt;name&gt;; 
                                     | 
   generic                           | task type &lt;name&gt; is 
      &lt;formal parameters&gt;            |    &lt;entry declarations&gt; 
   &lt;compilation unit&gt;                | end &lt;name&gt;;</pre></td></tr></table>
<P>
Instantiations of generic units and record indentation:
<table border cellpadding=6><tr><td><pre>   procedure &lt;name&gt; is               |type ... is 
      new &lt;generic name&gt; &lt;actuals&gt;   |   record 
                                     |      &lt;component list&gt; 
   function &lt;name&gt; is                |      case &lt;discriminant name&gt; is 
      new &lt;generic name&gt; &lt;actuals&gt;|            when &lt;choice&gt; =&gt; 
                                     |            &lt;component list&gt; 
   package &lt;name&gt; is                 |         when &lt;choice&gt; =&gt; 
      new &lt;generic name&gt; &lt;actuals&gt;   |            &lt;component list&gt; 
                                     |      end case; 
                                     |   end record;</pre></td></tr></table>
<P>
Indentation for record alignment:
<table border cellpadding=6><tr><td><pre>   for &lt;name&gt; use 
      record &lt;alignment clause&gt; 
         &lt;component clause&gt; 
      end record;</pre></td></tr></table>

<H4>example</H4>
<table border cellpadding=6><tr><td><pre>Default_String : constant String := 
      &quot;This is the long string returned by&quot; &amp; 
      &quot; default.  It is broken into multiple&quot; &amp; 
      &quot; Ada source lines for convenience.&quot;;

loop
   if Input_Found then 
      Count_Characters;
      
   else  --not Input_Found 
      Reset_State; 
      Character_Total := 
            First_Part_Total  * First_Part_Scale_Factor  + 
            Second_Part_Total * Second_Part_Scale_Factor + 
            Default_String'Length + Delimiter_Size; 
   end if;
   
end loop;</pre></td></tr></table>
<H4>rationale</H4>
Indentation improves the readability of the code because it gives the reader a 
visual indicator of the program structure. The levels of nesting are clearly 
identified by indentation and the first and last keywords in a construct can 
be matched visually.<P>
While there is much discussion on the number of spaces to indent, the reason  
for indentation is code clarity. The fact that the code is indented  
consistently is more important than the number of spaces used for indentation.<P>
Additionally, in <a href="http://archive.adaic.com/standards/83lrm/html/lrm-01-05.html#1.5">Section 1.5, the Ada Language Reference Manual</a> says that the 
layout shown in the examples and syntax rules in the Ada Language Reference 
Manual is the recommended code layout to be used for Ada programs. &quot;The syntax 
rules describing structured constructs are presented in a form that 
corresponds to the recommended paragraphing. ... Different lines are used for 
parts of a syntax rule if the corresponding parts of the construct described 
by the rule are intended to be on different lines. ... It is recommended that 
all indentation be by multiples of a basic step of indentation (the number of 
spaces for the basic step is not defined).&quot;<P>
It is important to indent continuation lines differently from nested control  
structures to make them visually distinct. This prevents them from obscuring  
the structure of the code as the user scans it.<P>
Indenting with spaces is more portable than indenting with tabs because tab  
characters are displayed differently by different terminals and printers.
<H4>automation notes</H4>
The guidelines in this section are easily enforced with an automatic code  
formatter.<P>
<b>Language Ref Manual references:</b> 
        <a href="http://archive.adaic.com/standards/83lrm/html/lrm-01-05.html#1.5">1.5&nbsp;Method of Description and Syntax Notation</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-02-06.html#2.6">2.6&nbsp;String Literals</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-03-07.html#3.7">3.7&nbsp;Record Types</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-05.html#5">5&nbsp;Statements</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-06-01.html#6.1">6.1&nbsp;Subprogram Declarations</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-07.html#7">7&nbsp;Packages</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-09-07.html#9.7">9.7&nbsp;Select Statements</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-10-01.html#10.1.1">10.1.1&nbsp;Context Clauses - With Clauses</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-11-02.html#11.2">11.2&nbsp;Exception Handlers</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-12-01.html#12.1">12.1&nbsp;Generic Declarations</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-12-03.html#12.3">12.3&nbsp;Generic Instantiation</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-13-04.html#13.4">13.4&nbsp;Record Representation Clauses</A>

<H3><BR><a name="2.1.3">2.1.3   Alignment of Operators</a></H3>
<H4>guideline</H4>
<UL>
<li>Align operators vertically to emphasize local program structure and  
semantics. 
</UL>
<H4>example </H4>
<table border cellpadding=6><tr><td><pre>if Slot_A &gt;= Slot_B then 
   Temporary := Slot_A; 
   Slot_A    := Slot_B; 
   Slot_B    := Temporary; 
end if;

Numerator   := B**2 - 4.0 * A * C; 
Denominator := 2.0 * A;

Solution_1 := -B + Square_Root(Numerator / Denominator); 
Solution_2 :=  B + Square_Root(Numerator / Denominator);

X := A * B + 
     C * D + 
     E * F;
     
Y := (A   * B + C) +  -- basic equation 
     (2.0 * D - E) -  -- 
     3.5;             -- account for error factor</pre></td></tr></table>
<H4>rationale</H4>
Alignment makes it easier to see the position of the operators and, therefore,  
puts visual emphasis on what the code is doing.<P>
The use of lines and spacing on long expressions can emphasize terms,  
precedence of operators, and other semantics. It can also leave room for  
highlighting comments within an expression.
<H4>exceptions</H4>
If vertical alignment of operators forces a statement to be broken over two  
lines, and especially if the break is at an inappropriate spot, it may be  
preferable to relax the alignment guideline.
<H4>automation notes</H4>
The last example above shows a type of &quot;semantic alignment&quot; which is not 
typically enforced or even preserved by automatic code formatters. If you 
break expressions into semantic parts and put each on a separate line, beware 
of using a code formatter later. It is likely to move the entire expression to 
a single line and accumulate all the comments at the end. However, there are 
some formatters which are intelligent enough to leave a line break intact when 
the line contains a comment.  A good formatter will recognize that the last 
example above does not violate the guidelines and would therefore preserve it 
as written.<P>
<b>Language Ref Manual references:</b> 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-04-04.html#4.4">4.4&nbsp;Expressions</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-04-05.html#4.5">4.5&nbsp;Operators and Expression Evaluation</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-05-02.html#5.2">5.2&nbsp;Assignment Statement</A>

<H3><BR><a name="2.1.4">2.1.4   Alignment of Declarations</a></H3>
<H4>guideline</H4>
<UL>
<li>Use vertical alignment to enhance the readability of declarations. 
<li>Provide at most one declaration per line. 
<li>Indent all declarations in a single declarative part at the same level. 
</UL>
<H3><BR>instantiation</H3>
For declarations not separated by blank lines, follow these alignment rules.
<UL TYPE=square>
<li>Align the colon delimeters. 
<li>Align the initialization delimeter, &quot;:=&quot;. 
<li>When trailing comments are used, align the comment delimeter. 
<li>When the declaration overflows a line, break the line and add an 
indentation level for those lines that wrap.  The preferred places to break, 
in order are: 1) The comment delimeter; 2) The initialization delimeter; 3) 
The colon delimeter. 
<li> For enumeration type declarations which do not fit on a single line, 
put each literal on a separate line, using the next level of indentation. 
When appropriate, semantically related literals can be arranged by row or 
column to form a table. 
</UL>
<H4>example</H4>
Variable and constant declarations can be laid out in a table with columns  
separated by the symbols :, :=, and --
<table border cellpadding=6><tr><td><pre>Prompt_Column : constant        := 40; 
Question_Mark : constant String := &quot; ? &quot;; -- prompt on error input 
Prompt_String : constant String := &quot; ==&gt; &quot;;</pre></td></tr></table>
<P>
If this results in lines that are too long, they can be laid out with each 
part on a separate line with its unique indentation level.
<table border cellpadding=6><tr><td><pre>subtype User_Response_Text_Frame is String (1 .. 72);

-- If the declaration needed a comment, it would fit here. 
Input_Line_Buffer : User_Response_Text_Frame 
       := Prompt_String &amp; 
          String'(1 .. User_Response_Text_Frame'Length - 
                       Prompt_String'Length =&gt; ' ');</pre></td></tr></table>
<p>
Declarations of enumeration literals can be listed in one or more columns as:
<table border cellpadding=6><tr><td><pre>type Op_Codes_In_Column is 
      (Push, 
       Pop, 
       Add, 
       Subtract, 
       Multiply, 
       Divide, 
       Subroutine_Call, 
       Subroutine_Return, 
       Branch, 
       Branch_On_Zero, 
       Branch_On_Negative);</pre></td></tr></table>
<p>
or, to save space:
<table border cellpadding=6><tr><td><pre>type Op_Codes_Multiple_Columns is 
      (Push,            Pop,                Add, 
       Subtract,        Multiply,           Divide, 
       Subroutine_Call, Subroutine_Return,  Branch, 
       Branch_On_Zero,  Branch_On_Negative);</pre></td></tr></table>
<P>
or, to emphasize related groups of values:
<table border cellpadding=6><tr><td><pre>type Op_Codes_In_Table is 
      (Push,            Pop, 
       Add,             Subtract,          Multiply,          Divide, 
       Subroutine_Call, Subroutine_Return, 
       Branch,          Branch_On_Zero,    Branch_On_Negative);</pre></td></tr></table>

<H4>rationale</H4>
Many programming standards documents require tabular repetition of names,  
types, initial values, and meaning in unit header comments. These comments are  
redundant and can become inconsistent with the code. Aligning the declarations  
themselves in tabular fashion (see the examples above) provides identical  
information to both compiler and reader, enforces at most one declaration per  
line, and eases maintenance by providing space for initializations and  
necessary comments. A tabular layout enhances readability, thus preventing  
names from &quot;hiding&quot; in a mass of declarations. This applies to type 
declarations as well as object declarations.
<H4>automation notes</H4>
Most of the guidelines in this section are easily enforced with an automatic 
code formatter. The one exception is the last enumerated type example, which 
is laid out in rows based on the semantics of the enumeration literals. An 
automatic code formatter will not be able to do this, and will likely move the 
enumeration literals to different lines.  However, tools that are only 
checking for violations of the guidelines should accept the tabular form of an 
enumeration type declaration.<P>
<b>Language Ref Manual references:</b> 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-02-06.html#2.6">2.6&nbsp;String Literals</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-02-07.html#2.7">2.7&nbsp;Comments</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-03-05.html#3.5.1">3.5.1&nbsp;Enumeration Types</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-03-09.html#3.9">3.9&nbsp;Declarative Parts</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-03.html#3">3&nbsp;Declarations and Types</A>

<H3><BR><a name="2.1.5">2.1.5   More on Alignment</a></H3>
<H4>guideline</H4>
<UL>
<li>Align parameter modes and parentheses vertically.  
</UL>
<H4>instantiation</H4>
Specifically it is recommended that you:
<UL TYPE=square>
<li>Place one formal parameter specification per line. 
<li>Vertically align parameter names, colons, the reserved word in, the  
reserved word out, and parameter types. 
<li>Place the first parameter specification on the same line as the  
subprogram or entry name. If any of the parameter types are forced beyond the  
line length limit, place the first parameter specification on a new line  
indented as for continuation lines. 
</UL>
<H4>example</H4>
<table border cellpadding=6><tr><td><pre>procedure Display_Menu (Title   : in     String;  
                        Options : in     Menus; 
                        Choice  :    out Alpha_Numerics);</pre></td></tr></table>
<P>
or
<table border cellpadding=6><tr><td><pre>procedure Display_Menu_On_Primary_Window 
      (Title   : in     String; 
       Options : in     Menus; 
       Choice  :    out Alpha_Numerics);</pre></td></tr></table>
<P>
or
<table border cellpadding=6><tr><td><pre>procedure Display_Menu_On_Screen ( 
      Title   : in     String; 
      Options : in     Menus; 
      Choice  :    out Alpha_Numerics 
      );
</pre></td></tr></table>
<P>
Aligning parentheses makes complicated relational expressions more clear:
<table border cellpadding=6><tr><td><pre>if not (First_Character in Alpha_Numerics and then 
        Valid_Option(First_Character))        then</pre></td></tr></table>

<H4>rationale</H4>
This facilitates readability and understandability. Aligning parameter modes  
provides the effect of a table with columns for parameter name, mode, type,  
and, if necessary, parameter-specific comments. Vertical alignment of 
parameters across subprograms within a compilation unit increases the  
readability even more.
<H4>note</H4>
Various options are available for subprogram layout. The second example above  
aligns all of the subprogram names and parameter names in a program.This has  
the disadvantage of occupying an unnecessary line where subprogram names are  
short and looking awkward if there is only one parameter.<P>
The third example is a format commonly used to reduce the amount of editing 
required when parameter lines are added, deleted, or reordered. The 
parentheses don't have to be moved from line to line. However, the last 
parameter line is the only one without a semicolon.

<H4>automation notes</H4>
Most of the guidelines in this section are easily enforced with an automatic 
code formatter. The one exception is the last example, which shows vertical 
alignment of parentheses to emphasize terms of an expression. This is 
difficult to achieve with an automatic code formatter unless the relevant 
terms of the expression can be determined strictly through operator 
precedence.

<b>Language Ref Manual references:</b> 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-04-04.html#4.4">4.4&nbsp;Expressions</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-05-03.html#5.3">5.3&nbsp;If Statements</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-06-02.html#6.2">6.2&nbsp;Formal Parameter Modes</A>

<H3><BR><a name="2.1.6">2.1.6   Blank Lines</a></H3>
<H4>guideline</H4>
<UL>
<li>Use blank lines to group logically related lines of text (NASA 1987). 
</UL>
<H4>example</H4>
<table border cellpadding=6><tr><td><pre>if ... then

   for ... loop 
      ... 
   end loop;
   
end if;</pre></td></tr></table>
<P>
This example separates different kinds of declarations with blank lines:
<table border cellpadding=6><tr><td><pre>type Employee_Record is 
   record 
      Legal_Name    : Name; 
      Date_Of_Birth : Date; 
      Date_Of_Hire  : Date; 
      Salary        : Money; 
   end record;
   
type Day is 
      (Monday,    Tuesday,   Wednesday, Thursday,  Friday, 
       Saturday,  Sunday);
       
subtype Weekday is Day range Monday   .. Friday; 
subtype Weekend is Day range Saturday .. Sunday;</pre></td></tr></table>

<H4>rationale</H4>
When blank lines are used in a thoughtful and consistent manner, sections of  
related code are more visible to readers.
<H4>automation notes</H4>
Automatic formatters do not enforce this guideline well because the decision 
on where to insert blank lines is a semantic one. However, many formatters 
have the ability to leave existing blank lines intact. Thus, you can manually 
insert the lines and not lose the effect when you run such a formatter.<P>
<b>Language Ref Manual references:</b> 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-03.html#3">3&nbsp;Declarations and Types</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-05.html#5">5&nbsp;Statements</a>

<H3><BR><a name="2.1.7">2.1.7   Pagination</a></H3>
<H4>guideline</H4>
<UL>
<li>Highlight the top of each package or task specification, the top of  
each program unit body, and the end statement of each program unit. 
</UL>
<H4>instantiation</H4>
Specifically, it is recommended that you:
<UL TYPE=square>
<li>Use file prologues, specification headers, and body headers to  
highlight those structures as recommended in <a href="sty-03-03.html#3.3">Guideline 3.3</a>. 
<li>Use a line of dashes, beginning at the same column as the current  
indentation to highlight the definition of subunits embedded in a declarative  
part.  Insert the line of dashes immediately before and immediately after the  
definition. 
<li>If two dashed lines are adjacent, omit the longer of the two. 
</UL>
<H4>example</H4>
<table border cellpadding=6><tr><td><pre>with Basic_Types;

package body SPC_Numeric_Types is

...

   --------------------------------------------------------------------- 
   function Max 
         (Left  : in     Basic_Types.Tiny_Integer; 
          Right : in     Basic_Types.Tiny_Integer) 
         return Basic_Types.Tiny_Integer is 
   begin 
      if Right &lt; Left then 
         return Left; 
      else 
         return Right; 
      end if; 
   end Max;
   
   --------------------------------------------------------------------- 
   function Min 
         (Left  : in     Basic_Types.Tiny_Integer; 
          Right : in     Basic_Types.Tiny_Integer) 
         return Basic_Types.Tiny_Integer is 
   begin 
      if Left &lt; Right then 
         return Left; 
      else 
         return Right; 
      end if; 
   end Min;
   
   ---------------------------------------------------------------------
   
   use Basic_Types;
   
begin  -- SPC_Numeric_Types 
   Max_Tiny_Integer := Min(System_Max, Local_Max); 
   Min_Tiny_Integer := Max(System_Min, Local_Min); 
   -- ... 
end SPC_Numeric_Types;
</pre></td></tr></table>
<H4>rationale</H4>
It is easy to overlook parts of program units that are not visible on the  
current page or screen. The page lengths of presentation hardware and software  
vary widely. By clearly marking the program's logical page boundaries (e.g.,  
with a dashed line), you enable a reader to quickly check whether all of a  
program unit is visible. Such pagination also makes it easier to scan a large  
file quickly, looking for a particular program unit.

<H4>note</H4>
This guideline does not address code layout on the physical &quot;page&quot; because the 
dimensions of such pages vary widely and no single guideline is appropriate.
<H4>automation notes</H4>
The guidelines in this section are easily enforced with an automatic code  
formatter.<P>
<b>Language Ref Manual references:</b> 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-02-07.html#2.7">2.7&nbsp;Comments</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-06-03.html#6.3">6.3&nbsp;Subprogram Bodies</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-07-02.html#7.2">7.2&nbsp;Package Specifications and Declarations</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-07-03.html#7.3">7.3&nbsp;Package Bodies</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-09-01.html#9.1">9.1&nbsp;Abort Statements</A>

<H3><BR><a name="2.1.8">2.1.8   Number of Statements Per Line</a></H3>
<H4>guideline</H4>
<UL>
<li>Start each statement on a new line.
<li>Write no more than one simple statement per line.
<li>Break compound statements over multiple lines.
</UL>
<H4>example</H4>
Use
<table border cellpadding=6><tr><td><pre>if End_Of_File then 
   Close_File; 
else 
   Get_Next_Record; 
end if;</pre></td></tr></table>
<P>
rather than
<table border cellpadding=6><tr><td><pre>if End_Of_File then Close_File; else Get_Next_Record; end if;

exceptional case

Put(&quot;A=&quot;);    Natural_IO.Put(A);    New_Line; 
Put(&quot;B=&quot;);    Natural_IO.Put(B);    New_Line; 
Put(&quot;C=&quot;);    Natural_IO.Put(C);    New_Line;</pre></td></tr></table>

<H4>rationale</H4>
A single statement on each line enhances the reader's ability to find  
statements and helps prevent statements being missed. Similarly, the structure  
of a compound statement is clearer when its parts are on separate lines.
<H4>note</H4>
If a statement is longer than the remaining space on the line, continue it on  
the next line. This guideline includes declarations, context clauses, and  
subprogram parameters.<P>
According to the Ada Language Reference Manual (Department of Defense 1983),  
&quot;The preferred places for other line breaks are after semicolons.&quot;
<H4>exceptions</H4>
The example of Put and Newline statements shows a legitimate exception. This  
grouping of closely related statements on the same line makes the structural  
relationship between the groups clear.
<H4>automation notes</H4>
The guidelines in this section are easily enforced with an automatic code 
formatter, with the single exception of the last example which shows a 
semantic grouping of multiple statements onto a single line.
<P>
<b>Language Ref Manual references:</b> 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-01-05.html#1.5">1.5&nbsp;Method of Description and Syntax Notation</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-03.html#3">3&nbsp;Declarations and Types</A>, 
        <A HREF="http://archive.adaic.com/standards/83lrm/html/lrm-05.html#5">5&nbsp;Statements</A>

<H3><BR><a name="2.1.9">2.1.9   Source Code Line Length</a></H3>
<H4>guideline</H4>
<UL>
<li>Adhere to a maximum line length limit for source code (Nissen and  
Wallis 1984, w2.3).
</UL>
<H4>instantiation</H4>
Specifically, it is recommended that you:
<UL TYPE=square>
<li>Limit source code line lengths to a maximum of 72 characters. 
</UL>
<H4>rationale</H4>
When Ada code is ported from one system to another, there may be restrictions  
on the record size of source line statements possibly for one of the following  
reasons: some operating systems may not support variable length records for  
tape I/O or some printers and terminals support an 80-character line width with 
no line-wrap. See further rationale in the note for <a href="sty-07-01.html#7.1.1">Guideline 7.1.1</a>.<P>
Source code must sometimes be published for various reasons, and letter-size 
paper is not as forgiving as a computer listing in terms of the number of  
usable columns.<P>
In addition, there are human limitations in the width of the field of view for  
understanding at the level required for reading source code. These limitations  
correspond roughly to the 70 to 80 column range.
<H4>automation notes</H4>
The guidelines in this section are easily enforced with an automatic code  
formatter.

<hr>
<A HREF="index.html">Back to document index</A><P>

</BODY></HTML>
