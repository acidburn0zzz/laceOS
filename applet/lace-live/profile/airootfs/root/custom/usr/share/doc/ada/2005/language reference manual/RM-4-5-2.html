<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Relational Operators and Membership Tests</TITLE>
    <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    H4.centered {text-align: center}
    SPAN.swiss {font-family: Arial, Helvetica, sans-serif; font-size: 92%}
    SPAN.roman {font-family: "Times New Roman", Times, serif}
    DIV.paranum {float: left; font-family: Arial, Helvetica, sans-serif; font-size: 64%; width: 2.8em; margin-left: -0.4em; margin-right: -3.0em; margin-top: 0.2em}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    DIV.Normal {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.2em; margin-bottom: 0.6em}
    DIV.Notes {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em; margin-bottom: 0.6em}
    DIV.NotesHeader {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em}
    DIV.Examples {font-family: "Courier New", monospace; font-size: 90%; line-height: 122%; margin-left: 3.4em; margin-bottom: 0.6em}
    UL.Bulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.NestedBulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 5.2em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#000080" VLINK="#330033" ALINK="#0000FF">
<DIV><SPAN Style="font-size:200%; color: rgb(0,0,153)"><B>Ada Reference Manual</B></SPAN> &mdash; <A HREF="RM-TTL.html"><B>Legal Information</B></A></DIV>
<DIV Style="margin-top: 0.6em; margin-bottom: 0.0em"><A HREF="RM-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RM-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RM-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RM-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RM-4-5-1.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RM-4-5-3.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<HR>
<H1>4.5.2 Relational Operators and Membership Tests</H1>
<DIV Class="paranum">1</DIV>
<DIV Class="Normal"><A NAME="I2607"></A><A NAME="I2608"></A><A NAME="I2609"></A><A NAME="I2610"></A><A NAME="I2611"></A>The 
<I>equality operators</I> = (equals) and /= (not equals) are predefined 
for nonlimited types. <A NAME="I2612"></A><A NAME="I2613"></A>The other 
<SPAN Class="swiss"><A HREF="RM-4-5.html#S0122">relational_operator</A></SPAN>s 
are the <I>ordering operators</I> &lt; (less than), &lt;= (less than 
or equal), &gt; (greater than), and &gt;= (greater than or equal). <A NAME="I2614"></A><A NAME="I2615"></A><A NAME="I2616"></A><A NAME="I2617"></A><A NAME="I2618"></A><A NAME="I2619"></A><A NAME="I2620"></A><A NAME="I2621"></A><A NAME="I2622"></A><A NAME="I2623"></A><A NAME="I2624"></A><A NAME="I2625"></A><A NAME="I2626"></A><A NAME="I2627"></A><A NAME="I2628"></A><A NAME="I2629"></A><A NAME="I2630"></A><A NAME="I2631"></A><A NAME="I2632"></A><A NAME="I2633"></A><A NAME="I2634"></A><A NAME="I2635"></A><A NAME="I2636"></A><A NAME="I2637"></A><A NAME="I2638"></A>The 
ordering operators are predefined for scalar types, and for <I>discrete 
array types</I>, that is, one-dimensional array types whose components 
are of a discrete type.&nbsp;</DIV>
<DIV Class="paranum">2</DIV>
<DIV Class="Normal"><A NAME="I2639"></A><A NAME="I2640"></A><A NAME="I2641"></A>A 
<I>membership test</I>, using <B>in</B> or <B>not in</B>, determines 
whether or not a value belongs to a given subtype or range, or has a 
tag that identifies a type that is covered by a given type. Membership 
tests are allowed for all types.</DIV>

<H4 Class="centered">Name Resolution Rules</H4>
<DIV Class="paranum">3/2</DIV>
<DIV Class="Normal"><A NAME="I2642"></A><A NAME="I2643"></A>The <I>tested 
type</I> of a membership test is the type of the <SPAN Class="swiss"><A HREF="RM-3-5.html#S0037">range</A></SPAN> 
or the type determined by the <SPAN Class="swiss"><A HREF="RM-3-2-2.html#S0028">subtype_mark</A></SPAN>. 
If the tested type is tagged, then the <SPAN Class="swiss"><A HREF="RM-4-4.html#S0117">simple_expression</A></SPAN> 
shall resolve to be of a type that is convertible (see <A HREF="RM-4-6.html">4.6</A>) 
to the tested type; if untagged, the expected type for the <SPAN Class="swiss"><A HREF="RM-4-4.html#S0117">simple_expression</A></SPAN> 
is the tested type.</DIV>

<H4 Class="centered">Legality Rules</H4>
<DIV Class="paranum">4</DIV>
<DIV Class="Normal">For a membership test, if the <SPAN Class="swiss"><A HREF="RM-4-4.html#S0117">simple_expression</A></SPAN> 
is of a tagged class-wide type, then the tested type shall be (visibly) 
tagged.&nbsp;</DIV>

<H4 Class="centered">Static Semantics</H4>
<DIV Class="paranum">5</DIV>
<DIV Class="Normal">The result type of a membership test is the predefined 
type Boolean.</DIV>
<DIV Class="paranum">6</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">The equality operators 
are predefined for every specific type <I>T</I> that is not limited, 
and not an anonymous access type, with the following specifications: 
</DIV>
<DIV Class="paranum">7</DIV>
<DIV Class="Examples"><B>function</B>&nbsp;&quot;=&quot;&nbsp;(Left,&nbsp;Right&nbsp;:&nbsp;<SPAN Class="roman"><I>T</I></SPAN>)&nbsp;<B>return</B>&nbsp;Boolean<BR>
<B>function</B>&nbsp;&quot;/=&quot;(Left,&nbsp;Right&nbsp;:&nbsp;<SPAN Class="roman"><I>T</I></SPAN>)&nbsp;<B>return</B>&nbsp;Boolean</DIV>
<DIV Class="paranum">7.1/2</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;&nbsp;The following additional 
equality operators for the <I>universal_access</I> type are declared 
in package Standard for use with anonymous access types:&nbsp;</DIV>
<DIV Class="paranum">7.2/2</DIV>
<DIV Class="Examples"><B>function</B>&nbsp;&quot;=&quot;&nbsp;(Left,&nbsp;Right&nbsp;:&nbsp;<I>universal_access</I>)&nbsp;<B>return</B>&nbsp;Boolean<BR>
<B>function</B>&nbsp;&quot;/=&quot;(Left,&nbsp;Right&nbsp;:&nbsp;<I>universal_access</I>)&nbsp;<B>return</B>&nbsp;Boolean</DIV>
<DIV Class="paranum">8</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">The ordering operators 
are predefined for every specific scalar type <I>T</I>, and for every 
discrete array type <I>T</I>, with the following specifications:&nbsp;</DIV>
<DIV Class="paranum">9</DIV>
<DIV Class="Examples"><B>function</B>&nbsp;&quot;&lt;&quot;&nbsp;(Left,&nbsp;Right&nbsp;:&nbsp;<SPAN Class="roman"><I>T</I></SPAN>)&nbsp;<B>return</B>&nbsp;Boolean<BR>
<B>function</B>&nbsp;&quot;&lt;=&quot;(Left,&nbsp;Right&nbsp;:&nbsp;<SPAN Class="roman"><I>T</I></SPAN>)&nbsp;<B>return</B>&nbsp;Boolean<BR>
<B>function</B>&nbsp;&quot;&gt;&quot;&nbsp;(Left,&nbsp;Right&nbsp;:&nbsp;<SPAN Class="roman"><I>T</I></SPAN>)&nbsp;<B>return</B>&nbsp;Boolean<BR>
<B>function</B>&nbsp;&quot;&gt;=&quot;(Left,&nbsp;Right&nbsp;:&nbsp;<SPAN Class="roman"><I>T</I></SPAN>)&nbsp;<B>return</B>&nbsp;Boolean</DIV>

<H4 Class="centered">Name Resolution Rules</H4>
<DIV Class="paranum">9.1/2</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;&nbsp;At least one of the 
operands of an equality operator for <I>universal_access</I> shall be 
of a specific anonymous access type. Unless the predefined equality operator 
is identified using an expanded name with <SPAN Class="swiss"><A HREF="RM-4-1.html#S0093">prefix</A></SPAN> 
denoting the package Standard, neither operand shall be of an access-to-object 
type whose designated type is <I>D</I> or <I>D</I>'Class, where <I>D</I> 
has a user-defined primitive equality operator such that:&nbsp;</DIV>
<DIV Class="paranum">9.2/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>its result type is Boolean;</LI></UL>
<DIV Class="paranum">9.3/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>it is declared immediately within 
the same declaration list as <I>D</I>; and</LI></UL>
<DIV Class="paranum">9.4/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>at least one of its operands is an 
access parameter with designated type <I>D</I>.&nbsp;</LI></UL>

<H4 Class="centered">Legality Rules</H4>
<DIV Class="paranum">9.5/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;At least one of the operands of the equality operators 
for <I>universal_access</I> shall be of type <I>universal_access</I>, 
or both shall be of access-to-object types, or both shall be of access-to-subprogram 
types. Further:&nbsp;</DIV>
<DIV Class="paranum">9.6/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>When both are of access-to-object 
types, the designated types shall be the same or one shall cover the 
other, and if the designated types are elementary or array types, then 
the designated subtypes shall statically match;</LI></UL>
<DIV Class="paranum">9.7/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>When both are of access-to-subprogram 
types, the designated profiles shall be subtype conformant.&nbsp;</LI></UL>

<H4 Class="centered">Dynamic Semantics</H4>
<DIV Class="paranum">10</DIV>
<DIV Class="Normal">For discrete types, the predefined relational operators 
are defined in terms of corresponding mathematical operations on the 
position numbers of the values of the operands.</DIV>
<DIV Class="paranum">11</DIV>
<DIV Class="Normal">For real types, the predefined relational operators 
are defined in terms of the corresponding mathematical operations on 
the values of the operands, subject to the accuracy of the type.&nbsp;</DIV>
<DIV Class="paranum">12</DIV>
<DIV Class="Normal">Two access-to-object values are equal if they designate 
the same object, or if both are equal to the null value of the access 
type.</DIV>
<DIV Class="paranum">13</DIV>
<DIV Class="Normal">Two access-to-subprogram values are equal if they 
are the result of the same evaluation of an Access <SPAN Class="swiss"><A HREF="RM-4-1-4.html#S0100">attribute_reference</A></SPAN>, 
or if both are equal to the null value of the access type. Two access-to-subprogram 
values are unequal if they designate different subprograms. <A NAME="I2644"></A>It 
is unspecified whether two access values that designate the same subprogram 
but are the result of distinct evaluations of Access <SPAN Class="swiss"><A HREF="RM-4-1-4.html#S0100">attribute_reference</A></SPAN>s 
are equal or unequal.&nbsp;</DIV>
<DIV Class="paranum">14</DIV>
<DIV Class="Normal"><A NAME="I2645"></A>For a type extension, predefined 
equality is defined in terms of the primitive (possibly user-defined) 
equals operator of the parent type and of any tagged components of the 
extension part, and predefined equality for any other components not 
inherited from the parent type.&nbsp;</DIV>
<DIV Class="paranum">15</DIV>
<DIV Class="Normal">For a private type, if its full type is tagged, predefined 
equality is defined in terms of the primitive equals operator of the 
full type; if the full type is untagged, predefined equality for the 
private type is that of its full type.</DIV>
<DIV Class="paranum">16</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em"><A NAME="I2646"></A>For 
other composite types, the predefined equality operators (and certain 
other predefined operations on composite types &mdash; see <A HREF="RM-4-5-1.html">4.5.1</A> 
and <A HREF="RM-4-6.html">4.6</A>) are defined in terms of the corresponding 
operation on <I>matching components</I>, defined as follows:&nbsp;</DIV>
<DIV Class="paranum">17</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>For two composite objects or values 
of the same non-array type, matching components are those that correspond 
to the same <SPAN Class="swiss"><A HREF="RM-3-8.html#S0070">component_declaration</A></SPAN> 
or <SPAN Class="swiss"><A HREF="RM-3-7.html#S0062">discriminant_specification</A></SPAN>;</LI></UL>
<DIV Class="paranum">18</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>For two one-dimensional arrays of 
the same type, matching components are those (if any) whose index values 
match in the following sense: the lower bounds of the index ranges are 
defined to match, and the successors of matching indices are defined 
to match;</LI></UL>
<DIV Class="paranum">19</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>For two multidimensional arrays of 
the same type, matching components are those whose index values match 
in successive index positions.&nbsp;</LI></UL>
<DIV Class="paranum">20</DIV>
<DIV Class="Normal">The analogous definitions apply if the types of the 
two objects or values are convertible, rather than being the same.&nbsp;</DIV>
<DIV Class="paranum">21</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">Given the above definition 
of matching components, the result of the predefined equals operator 
for composite types (other than for those composite types covered earlier) 
is defined as follows:&nbsp;</DIV>
<DIV Class="paranum">22</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>If there are no components, the result 
is defined to be True;</LI></UL>
<DIV Class="paranum">23</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>If there are unmatched components, 
the result is defined to be False;</LI></UL>
<DIV Class="paranum">24</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>Otherwise, the result is defined in 
terms of the primitive equals operator for any matching tagged components, 
and the predefined equals for any matching untagged components.&nbsp;</LI></UL>
<DIV Class="paranum">24.1/1</DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;For any composite type, the order in which &quot;=&quot; 
is called for components is unspecified. Furthermore, if the result can 
be determined before calling &quot;=&quot; on some components, it is 
unspecified whether &quot;=&quot; is called on those components.<A NAME="I2647"></A></DIV>
<DIV Class="paranum">25</DIV>
<DIV Class="Normal">The predefined &quot;/=&quot; operator gives the 
complementary result to the predefined &quot;=&quot; operator.&nbsp;</DIV>
<DIV Class="paranum">26</DIV>
<DIV Class="Normal"><A NAME="I2648"></A>For a discrete array type, the 
predefined ordering operators correspond to <I>lexicographic order</I> 
using the predefined order relation of the component type: A null array 
is lexicographically less than any array having at least one component. 
In the case of nonnull arrays, the left operand is lexicographically 
less than the right operand if the first component of the left operand 
is less than that of the right; otherwise the left operand is lexicographically 
less than the right operand only if their first components are equal 
and the tail of the left operand is lexicographically less than that 
of the right (the <I>tail</I> consists of the remaining components beyond 
the first and can be null).</DIV>
<DIV Class="paranum">27</DIV>
<DIV Class="Normal"><A NAME="I2649"></A>For the evaluation of a membership 
test, the <SPAN Class="swiss"><A HREF="RM-4-4.html#S0117">simple_expression</A></SPAN> 
and the <SPAN Class="swiss"><A HREF="RM-3-5.html#S0037">range</A></SPAN> 
(if any) are evaluated in an arbitrary order.</DIV>
<DIV Class="paranum">28</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">A membership test using 
<B>in</B> yields the result True if:&nbsp;</DIV>
<DIV Class="paranum">29</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>The tested type is scalar, and the 
value of the <SPAN Class="swiss"><A HREF="RM-4-4.html#S0117">simple_expression</A></SPAN> 
belongs to the given <SPAN Class="swiss"><A HREF="RM-3-5.html#S0037">range</A></SPAN>, 
or the range of the named subtype; or&nbsp;</LI></UL>
<DIV Class="paranum">30/2</DIV>
<UL Class="Bulleted" Style="margin-bottom: 0.3em"><LI TYPE=DISC>The 
tested type is not scalar, and the value of the <SPAN Class="swiss"><A HREF="RM-4-4.html#S0117">simple_expression</A></SPAN> 
satisfies any constraints of the named subtype, and:&nbsp;</LI></UL>
<DIV Class="paranum">30.1/2</DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>if the type of the <SPAN Class="swiss"><A HREF="RM-4-4.html#S0117">simple_expression</A></SPAN> 
is class-wide, the value has a tag that identifies a type covered by 
the tested type;&nbsp;</LI></UL>
<DIV Class="paranum">30.2/2</DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>if the tested type is an access 
type and the named subtype excludes null, the value of the <SPAN Class="swiss"><A HREF="RM-4-4.html#S0117">simple_expression</A></SPAN> 
is not null.&nbsp;</LI></UL>
<DIV Class="paranum">31</DIV>
<DIV Class="Normal">Otherwise the test yields the result False.</DIV>
<DIV Class="paranum">32</DIV>
<DIV Class="Normal">A membership test using <B>not in</B> gives the complementary 
result to the corresponding membership test using <B>in</B>.&nbsp;</DIV>

<H4 Class="centered">Implementation Requirements</H4>
<DIV Class="paranum">32.1/1</DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;For all nonlimited types declared in language-defined 
packages, the &quot;=&quot; and &quot;/=&quot; operators of the type 
shall behave as if they were the predefined equality operators for the 
purposes of the equality of composite types and generic formal types. 
</DIV>
<DIV Class="NotesHeader">NOTES</DIV>
<DIV Class="paranum">33/2</DIV>
<DIV Class="Notes"><SPAN STYLE="font-size: 80%"><I>This paragraph was 
deleted.</I></SPAN></DIV>
<DIV Class="paranum">34</DIV>
<DIV Class="Notes">13&nbsp;&nbsp;If a composite type has components that 
depend on discriminants, two values of this type have matching components 
if and only if their discriminants are equal. Two nonnull arrays have 
matching components if and only if the length of each dimension is the 
same for both.&nbsp;</DIV>

<H4 Class="centered">Examples</H4>
<DIV Class="paranum">35</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em"><I>Examples of expressions 
involving relational operators and membership tests:</I>&nbsp;</DIV>
<DIV Class="paranum">36</DIV>
<DIV Class="Examples">X&nbsp;/=&nbsp;Y</DIV>
<DIV Class="paranum">37</DIV>
<DIV Class="Examples">&quot;&quot;&nbsp;&lt;&nbsp;&quot;A&quot;&nbsp;<B>and</B>&nbsp;&quot;A&quot;&nbsp;&lt;&nbsp;&quot;Aa&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;&nbsp;True</I></SPAN><BR>
&quot;Aa&quot;&nbsp;&lt;&nbsp;&quot;B&quot;&nbsp;<B>and</B>&nbsp;&quot;A&quot;&nbsp;&lt;&nbsp;&quot;A&nbsp;&nbsp;&quot;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;&nbsp;True</I></SPAN></DIV>
<DIV Class="paranum">38</DIV>
<DIV Class="Examples">My_Car&nbsp;=&nbsp;<B>null</B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;true&nbsp;if&nbsp;My_Car&nbsp;has&nbsp;been&nbsp;set&nbsp;to&nbsp;null&nbsp;(see&nbsp;<A HREF="RM-3-10-1.html">3.10.1</A>)</I></SPAN><BR>
My_Car&nbsp;=&nbsp;Your_Car&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;true&nbsp;if&nbsp;we&nbsp;both&nbsp;share&nbsp;the&nbsp;same&nbsp;car</I></SPAN><BR>
My_Car.<B>all</B>&nbsp;=&nbsp;Your_Car.<B>all</B>&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;true&nbsp;if&nbsp;the&nbsp;two&nbsp;cars&nbsp;are&nbsp;identical</I></SPAN></DIV>
<DIV Class="paranum">39</DIV>
<DIV Class="Examples">N&nbsp;<B>not</B>&nbsp;<B>in</B>&nbsp;1&nbsp;..&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;range&nbsp;membership&nbsp;test</I></SPAN><BR>
Today&nbsp;<B>in</B>&nbsp;Mon&nbsp;..&nbsp;Fri&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;range&nbsp;membership&nbsp;test</I></SPAN><BR>
Today&nbsp;<B>in</B>&nbsp;Weekday&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;subtype&nbsp;membership&nbsp;test&nbsp;(see&nbsp;<A HREF="RM-3-5-1.html">3.5.1</A>)</I></SPAN><BR>
Archive&nbsp;<B>in</B>&nbsp;Disk_Unit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;subtype&nbsp;membership&nbsp;test&nbsp;(see&nbsp;<A HREF="RM-3-8-1.html">3.8.1</A>)</I></SPAN><BR>
Tree.<B>all</B>&nbsp;<B>in</B>&nbsp;Addition'Class&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;class&nbsp;membership&nbsp;test&nbsp;(see&nbsp;<A HREF="RM-3-9-1.html">3.9.1</A>)</I></SPAN></DIV>

<HR>
<DIV Style="margin-top: 0.0em; margin-bottom: 0.6em"><A HREF="RM-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RM-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RM-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RM-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RM-4-5-1.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RM-4-5-3.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<DIV Style="margin-top:0.0em"><IMG SRC="AE_logo.gif" height=100 width=113 align=right ALT="Ada-Europe">
<SPAN Style="vertical-align: middle">Sponsored by <SPAN Style="font-size: 125%"><A HREF="http://www.ada-europe.org/"><B>Ada-Europe</B></A></SPAN></SPAN></DIV>
</BODY>
</HTML>
