<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>User-Defined Assignment and Finalization</TITLE>
    <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    H4.centered {text-align: center}
    SPAN.swiss {font-family: Arial, Helvetica, sans-serif; font-size: 92%}
    SPAN.roman {font-family: "Times New Roman", Times, serif}
    DIV.paranum {float: left; font-family: Arial, Helvetica, sans-serif; font-size: 64%; width: 2.8em; margin-left: -0.4em; margin-right: -3.0em; margin-top: 0.2em}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    SPAN.insert1 {text-decoration: underline; color: rgb(0,51,51) }
    SPAN.delete1 {text-decoration: line-through; color: rgb(0,51,51) }
    SPAN.insert2 {text-decoration: underline; color: rgb(0,102,0) }
    SPAN.delete2 {text-decoration: line-through; color: rgb(0,102,0) }
    DIV.Normal {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.2em; margin-bottom: 0.6em}
    DIV.Annotations {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 6.2em; margin-bottom: 0.6em}
    DIV.Examples {font-family: "Courier New", monospace; font-size: 90%; line-height: 122%; margin-left: 3.4em; margin-bottom: 0.6em}
    DIV.SmallExamples {font-family: "Courier New", monospace; font-size: 72%; line-height: 122%; margin-left: 9.6em; margin-bottom: 0.6em}
    UL.Bulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#000080" VLINK="#330033" ALINK="#0000FF">
<DIV><B><SPAN Style="font-size:200%; color: rgb(0,51,153)">Annotated</SPAN><SPAN Style="font-size:200%; color: rgb(0,0,102)">&nbsp;Ada Reference Manual</SPAN></B> &mdash; <A HREF="AA-TTL.html"><B>Legal Information</B></A></DIV>
<DIV Style="margin-top: 0.6em; margin-bottom: 0.0em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-7-5.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-7-6-1.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<HR>
<H1>7.6 User-Defined Assignment and Finalization</H1>
<DIV Class="paranum">1</DIV>
<DIV Class="Normal">[<SPAN STYLE="font-size: 80%">{<I>user-defined assignment</I>}</SPAN> 
<A NAME="I3626"></A><SPAN STYLE="font-size: 80%">{<I>assignment (user-defined)</I>}</SPAN> 
<A NAME="I3627"></A>Three kinds of actions are fundamental to the manipulation 
of objects: initialization, finalization, and assignment. Every object 
is initialized, either explicitly or by default, after being created 
(for example, by an <SPAN Class="swiss"><A HREF="AA-3-3-1.html#S0032">object_declaration</A></SPAN> 
or <SPAN Class="swiss"><A HREF="AA-4-8.html#S0129">allocator</A></SPAN>). 
Every object is finalized before being destroyed (for example, by leaving 
a <SPAN Class="swiss"><A HREF="AA-6-3.html#S0162">subprogram_body</A></SPAN> 
containing an <SPAN Class="swiss"><A HREF="AA-3-3-1.html#S0032">object_declaration</A></SPAN>, 
or by a call to an instance of Unchecked_Deallocation). An assignment 
operation is used as part of <SPAN Class="swiss"><A HREF="AA-5-2.html#S0137">assignment_statement</A></SPAN>s, 
explicit initialization, parameter passing, and other operations. <SPAN STYLE="font-size: 80%">{<I>constructor: 
See initialization</I>}</SPAN> <A NAME="I3628"></A><SPAN STYLE="font-size: 80%">{<I>constructor: 
See Initialize</I>}</SPAN> <A NAME="I3629"></A><SPAN STYLE="font-size: 80%">{<I>destructor: 
See finalization</I>}</SPAN> <A NAME="I3630"></A></DIV>
<DIV Class="paranum">2</DIV>
<DIV Class="Normal">Default definitions for these three fundamental operations 
are provided by the language, but <SPAN STYLE="font-size: 80%">{<I>controlled 
type</I>}</SPAN> <A NAME="I3631"></A>a <I>controlled</I> type gives the 
user additional control over parts of these operations. <SPAN STYLE="font-size: 80%">{<I>Initialize</I>}</SPAN> 
<A NAME="I3632"></A><SPAN STYLE="font-size: 80%">{<I>Finalize</I>}</SPAN> 
<A NAME="I3633"></A><SPAN STYLE="font-size: 80%">{<I>Adjust</I>}</SPAN> 
<A NAME="I3634"></A>In particular, the user can define, for a controlled 
type, an Initialize procedure which is invoked immediately after the 
normal default initialization of a controlled object, a Finalize procedure 
which is invoked immediately before finalization of any of the components 
of a controlled object, and an Adjust procedure which is invoked as the 
last step of an assignment to a (nonlimited) controlled object.]&nbsp;</DIV>
<DIV Class="paranum">2.a</DIV>
<DIV Class="Annotations"><B>Glossary entry:&nbsp;</B>{<I>Controlled type</I>} 
A controlled type supports user-defined assignment and finalization. 
Objects are always finalized before being destroyed.</DIV>
<DIV Class="paranum">2.b/2</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00114.TXT">AI95-00114-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00287.TXT">AI95-00287-01</A></I>} 
Here's the basic idea of initialization, value adjustment, and finalization, 
whether or not user defined: When an object is created, if it is explicitly 
assigned an initial value, <SPAN class="insert2">the object is either 
built-in-place from an <SPAN Class="swiss"><A HREF="AA-4-3.html#S0104">aggregate</A></SPAN> 
or function call (in which case neither Adjust nor Initialize is applied), 
or&nbsp;</SPAN>the assignment copies and adjusts the initial value. Otherwise, 
Initialize is applied to it (except in the case of an <SPAN Class="swiss"><A HREF="AA-4-3.html#S0104">aggregate</A></SPAN> 
as a whole). An <SPAN Class="swiss"><A HREF="AA-5-2.html#S0137">assignment_statement</A></SPAN> 
finalizes the target before copying in and adjusting the new value. Whenever 
an object goes away, it is finalized. Calls on Initialize and Adjust 
happen bottom-up; that is, components first, followed by the containing 
object. Calls on Finalize <SPAN class="insert2">happen</SPAN><SPAN class="delete2">&nbsp;happens</SPAN> 
top-down; that is, first the containing object, and then its components. 
These ordering rules ensure that any components will be in a well-defined 
state when Initialize, Adjust, or Finalize is applied to the containing 
object.&nbsp;</DIV>

<H4 Class="centered">Static Semantics</H4>
<DIV Class="paranum">3</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">The following language-defined 
library package exists:&nbsp;</DIV>
<DIV Class="paranum">4/1</DIV>
<DIV Class="Examples">{<I><A HREF="defect1.html#8652/0020">8652/0020</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00126.TXT">AI95-00126-01</A></I>} 
<B>package</B>&nbsp;Ada.Finalization&nbsp;<B>is</B><A NAME="I3635"></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>pragma</B>&nbsp;Preelaborate(Finalization);<SPAN class="insert1"><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>pragma</B>&nbsp;Remote_Types(Finalization);</SPAN></DIV>
<DIV Class="paranum">5/2</DIV>
<DIV Class="Examples">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00161.TXT">AI95-00161-01</A></I>} 
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;<A NAME="I3636"></A>Controlled&nbsp;<B>is&nbsp;abstract&nbsp;tagged&nbsp;private</B>;<SPAN class="insert2"><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>pragma</B>&nbsp;Preelaborable_Initialization(Controlled);</SPAN></DIV>
<DIV Class="paranum">6/2</DIV>
<DIV Class="Examples">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00348.TXT">AI95-00348-01</A></I>} 
&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;<A NAME="I3637"></A>Initialize&nbsp;(Object&nbsp;:&nbsp;<B>in&nbsp;out</B>&nbsp;Controlled)<SPAN class="insert2">&nbsp;<B>is&nbsp;null</B></SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;<A NAME="I3638"></A>Adjust&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Object&nbsp;:&nbsp;<B>in&nbsp;out</B>&nbsp;Controlled)<SPAN class="insert2">&nbsp;<B>is&nbsp;null</B></SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;<A NAME="I3639"></A>Finalize&nbsp;&nbsp;&nbsp;(Object&nbsp;:&nbsp;<B>in&nbsp;out</B>&nbsp;Controlled)<SPAN class="insert2">&nbsp;<B>is&nbsp;null</B></SPAN>;</DIV>
<DIV Class="paranum">7/2</DIV>
<DIV Class="Examples">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00161.TXT">AI95-00161-01</A></I>} 
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;<A NAME="I3640"></A>Limited_Controlled&nbsp;<B>is&nbsp;abstract&nbsp;tagged&nbsp;limited&nbsp;private</B>;<SPAN class="insert2"><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>pragma</B>&nbsp;Preelaborable_Initialization(Limited_Controlled);</SPAN></DIV>
<DIV Class="paranum">8/2</DIV>
<DIV Class="Examples">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00348.TXT">AI95-00348-01</A></I>} 
&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;<A NAME="I3641"></A>Initialize&nbsp;(Object&nbsp;:&nbsp;<B>in&nbsp;out</B>&nbsp;Limited_Controlled)<SPAN class="insert2">&nbsp;<B>is&nbsp;null</B></SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;<A NAME="I3642"></A>Finalize&nbsp;&nbsp;&nbsp;(Object&nbsp;:&nbsp;<B>in&nbsp;out</B>&nbsp;Limited_Controlled)<SPAN class="insert2">&nbsp;<B>is&nbsp;null</B></SPAN>;<BR>
<B>private</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;--&nbsp;<SPAN Class="roman"><I>not&nbsp;specified&nbsp;by&nbsp;the&nbsp;language</I></SPAN><BR>
<B>end</B>&nbsp;Ada.Finalization;</DIV>
<DIV Class="paranum">9/2</DIV>
<DIV Class="Normal">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00348.TXT">AI95-00348-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>controlled type</I>}</SPAN> <A NAME="I3643"></A>A 
controlled type is a descendant of Controlled or Limited_Controlled. 
<SPAN class="delete2">The (default) implementations of Initialize, Adjust, 
and Finalize have no effect.&nbsp;</SPAN>The predefined &quot;=&quot; operator 
of type Controlled always returns True, [since this operator is incorporated 
into the implementation of the predefined equality operator of types 
derived from Controlled, as explained in <A HREF="AA-4-5-2.html">4.5.2</A>.] 
The type Limited_Controlled is like Controlled, except that it is limited 
and it lacks the primitive subprogram Adjust.&nbsp;</DIV>
<DIV Class="paranum">9.a</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>We say &ldquo;nonlimited 
controlled type&rdquo;&nbsp;(rather than just &ldquo;controlled type&rdquo;; 
when we want to talk about descendants of Controlled only.&nbsp;</DIV>
<DIV Class="paranum">9.b</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>We considered making Adjust and 
Finalize abstract. However, a reasonable coding convention is e.g. for 
Finalize to always call the parent's Finalize after doing whatever work 
is needed for the extension part. (Unlike CLOS, we have no way to do 
that automatically in Ada 95.) For this to work, Finalize cannot be abstract. 
In a generic unit, for a generic formal abstract derived type whose ancestor 
is Controlled or Limited_Controlled, calling the ancestor's Finalize 
would be illegal if it were abstract, even though the actual type might 
have a concrete version.</DIV>
<DIV Class="paranum">9.c</DIV>
<DIV Class="Annotations">Types Controlled and Limited_Controlled are 
abstract, even though they have no abstract primitive subprograms. It 
is not clear that they need to be abstract, but there seems to be no 
harm in it, and it might make an implementation's life easier to know 
that there are no objects of these types &mdash; in case the implementation 
wishes to make them &ldquo;magic&rdquo; in some way.</DIV>
<DIV Class="paranum">9.d/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00251.TXT">AI95-00251-01</A></I>} 
<SPAN class="insert2">For Ada 2005, we considered making these types 
interfaces. That would have the advantage of allowing them to be added 
to existing trees. But that was rejected both because it would cause 
massive disruption to existing implementations, and because it would 
be very incompatible due to the &quot;no hidden interfaces&quot; rule. 
The latter rule would prevent a tagged private type from being completed 
with a derivation from Controlled or Limited_Controlled &mdash; a very 
common idiom.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">9.1/2</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00360.TXT">AI95-00360-01</A></I>} 
<SPAN class="insert2">A type is said to <I>need finalization</I> if:<SPAN STYLE="font-size: 80%">{<I>needs 
finalization</I>}</SPAN> <A NAME="I3644"></A><SPAN STYLE="font-size: 80%">{<I>type 
(needs finalization)</I>}</SPAN> <A NAME="I3645"></A></SPAN></DIV>
<DIV Class="paranum">9.2/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN class="insert2">it is a controlled 
type, a task type or a protected type; or</SPAN></LI></UL>
<DIV Class="paranum">9.3/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN class="insert2">it has a component 
that needs finalization; or</SPAN></LI></UL>
<DIV Class="paranum">9.4/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN class="insert2">it is a limited 
type that has an access discriminant whose designated type needs finalization; 
or</SPAN></LI></UL>
<DIV Class="paranum">9.5/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN class="insert2">it is one of 
a number of language-defined types that are explicitly defined to need 
finalization.</SPAN></LI></UL>
<DIV Class="paranum">9.e/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Ramification:&nbsp;</B>The 
fact that a type needs finalization does not require it to be implemented 
with a controlled type. It just has to be recognized by the No_Nested_Finalization 
restriction.</SPAN></DIV>
<DIV Class="paranum">9.f/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2">This property is defined 
for the type, not for a particular view. That's necessary as restrictions 
look in private parts to enforce their restrictions; the point is to 
eliminate all controlled parts, not just ones that are visible.</SPAN> 
</DIV>

<H4 Class="centered">Dynamic Semantics</H4>
<DIV Class="paranum">10/2</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00373.TXT">AI95-00373-01</A></I>} 
<SPAN class="delete2"><SPAN STYLE="font-size: 80%">{<I>elaboration (object_declaration)</I> 
[partial]}</SPAN> <A NAME="I3646"></A></SPAN>During the elaboration <SPAN class="insert2">or 
evaluation of a construct that causes an object to be initialized by 
default</SPAN><SPAN class="delete2">&nbsp;of an <SPAN Class="swiss"><A HREF="AA-3-3-1.html#S0032">object_declaration</A></SPAN></SPAN>, 
for every controlled subcomponent of the object that is not assigned 
an initial value (as defined in <A HREF="AA-3-3-1.html">3.3.1</A>), Initialize 
is called on that subcomponent. Similarly, if the object <SPAN class="insert2">that 
is initialized by default&nbsp;</SPAN>as a whole is controlled<SPAN class="delete2">&nbsp;and is not assigned an initial value</SPAN>, Initialize is called on 
the object.<SPAN class="delete2">&nbsp;The same applies to the evaluation 
of an <SPAN Class="swiss"><A HREF="AA-4-8.html#S0129">allocator</A></SPAN>, 
as explained in <A HREF="AA-4-8.html">4.8</A>.</SPAN></DIV>
<DIV Class="paranum">11/2</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="defect1.html#8652/0021">8652/0021</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00182.TXT">AI95-00182-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00373.TXT">AI95-00373-01</A></I>} 
For an <SPAN Class="swiss"><A HREF="AA-4-3-2.html#S0109">extension_aggregate</A></SPAN> 
whose <SPAN Class="swiss"><A HREF="AA-4-3-2.html#S0110">ancestor_part</A></SPAN> 
is a <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0028">subtype_mark</A></SPAN><SPAN class="insert2">&nbsp;denoting a</SPAN><SPAN class="delete2">,&nbsp;</SPAN><SPAN class="insert1"><SPAN class="delete2">for 
each controlled subcomponent of the ancestor part, either Initialize 
is called, or its initial value is assigned, as appropriate</SPAN></SPAN><SPAN class="delete2"></SPAN><SPAN class="delete1">&nbsp;Initialize 
is called on all controlled subcomponents of the ancestor part</SPAN><SPAN class="delete2">; 
if the type of the ancestor part is itself</SPAN> controlled<SPAN class="insert2">&nbsp;subtype</SPAN>, the Initialize procedure of the ancestor type is called, 
unless that Initialize procedure is abstract.&nbsp;</DIV>
<DIV Class="paranum">11.a</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><B>Discussion: 
</B>Example:&nbsp;</DIV>
<DIV Class="paranum">11.b</DIV>
<DIV Class="SmallExamples"><B>type</B>&nbsp;T1&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Controlled&nbsp;<B>with</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>record</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;--<SPAN Class="roman"><I>&nbsp;some&nbsp;components&nbsp;might&nbsp;have&nbsp;defaults</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;<B>record</B>;</DIV>
<DIV Class="paranum">11.c</DIV>
<DIV Class="SmallExamples"><B>type</B>&nbsp;T2&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Controlled&nbsp;<B>with</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>record</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;:&nbsp;T1;&nbsp;--<SPAN Class="roman"><I>&nbsp;no&nbsp;default</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y&nbsp;:&nbsp;T1&nbsp;:=&nbsp;...;&nbsp;--<SPAN Class="roman"><I>&nbsp;default</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;<B>record</B>;</DIV>
<DIV Class="paranum">11.d</DIV>
<DIV Class="SmallExamples">A&nbsp;:&nbsp;T2;<BR>
B&nbsp;:&nbsp;T2&nbsp;:=&nbsp;...;</DIV>
<DIV Class="paranum">11.e</DIV>
<DIV Class="Annotations">As part of the elaboration of A's declaration, 
A.Y is assigned a value; therefore Initialize is not applied to A.Y. 
Instead, Adjust is applied to A.Y as part of the assignment operation. 
Initialize is applied to A.X and to A, since those objects are not assigned 
an initial value. The assignment to A.Y is not considered an assignment 
to A.</DIV>
<DIV Class="paranum">11.f</DIV>
<DIV Class="Annotations">For the elaboration of B's declaration, Initialize 
is not called at all. Instead the assignment adjusts B's value; that 
is, it applies Adjust to B.X, B.Y, and B.</DIV>
<DIV Class="paranum">11.f.1/2</DIV>
<DIV Class="Annotations">{<I><A HREF="defect1.html#8652/0021">8652/0021</A></I>} 
<SPAN class="insert1"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00182.TXT">AI95-00182-01</A></I>} 
<SPAN class="insert1"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00373.TXT">AI95-00373-01</A></I>} 
<SPAN class="insert1">The <SPAN Class="swiss"><A HREF="AA-4-3-2.html#S0110">ancestor_part</A></SPAN> 
of an <SPAN Class="swiss"><A HREF="AA-4-3-2.html#S0109">extension_aggregate</A></SPAN></SPAN><SPAN class="insert2">, 
&lt;&gt; in aggregates, and the return object of an <SPAN Class="swiss"><A HREF="AA-6-5.html#S0170">extended_return_statement</A></SPAN> 
are</SPAN><SPAN class="insert1"></SPAN><SPAN class="insert1"><SPAN class="delete2">&nbsp;is</SPAN></SPAN><SPAN class="insert1">&nbsp;handled similarly.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">12</DIV>
<DIV Class="Normal">Initialize and other initialization operations are 
done in an arbitrary order, except as follows. Initialize is applied 
to an object after initialization of its subcomponents, if any [(including 
both implicit initialization and Initialize calls)]. If an object has 
a component with an access discriminant constrained by a per-object expression, 
Initialize is applied to this component after any components that do 
not have such discriminants. For an object with several components with 
such a discriminant, Initialize is applied to them in order of their 
<SPAN Class="swiss"><A HREF="AA-3-8.html#S0070">component_declaration</A></SPAN>s. 
For an <SPAN Class="swiss"><A HREF="AA-4-8.html#S0129">allocator</A></SPAN>, 
any task activations follow all calls on Initialize.&nbsp;</DIV>
<DIV Class="paranum">12.a</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>The fact that Initialize is done 
for subcomponents first allows Initialize for a composite object to refer 
to its subcomponents knowing they have been properly initialized.</DIV>
<DIV Class="paranum">12.b</DIV>
<DIV Class="Annotations">The fact that Initialize is done for components 
with access discriminants after other components allows the Initialize 
operation for a component with a self-referential access discriminant 
to assume that other components of the enclosing object have already 
been properly initialized. For multiple such components, it allows some 
predictability.&nbsp;</DIV>
<DIV Class="paranum">13</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em"><SPAN STYLE="font-size: 80%">{<I>assignment 
operation</I>}</SPAN> <A NAME="I3647"></A>When a target object with any 
controlled parts is assigned a value, [either when created or in a subsequent 
<SPAN Class="swiss"><A HREF="AA-5-2.html#S0137">assignment_statement</A></SPAN>,] 
the <I>assignment operation</I> proceeds as follows:&nbsp;</DIV>
<DIV Class="paranum">14</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>The value of the target becomes the 
assigned value.</LI></UL>
<DIV Class="paranum">15</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN STYLE="font-size: 80%">{<I>adjusting 
the value of an object</I>}</SPAN> <A NAME="I3648"></A><SPAN STYLE="font-size: 80%">{<I>adjustment</I>}</SPAN> 
<A NAME="I3649"></A>The value of the target is <I>adjusted.</I>&nbsp;</LI></UL>
<DIV Class="paranum">15.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>If any parts of the object 
are controlled, abort is deferred during the assignment operation.&nbsp;</DIV>
<DIV Class="paranum">16</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>adjusting the value 
of an object</I>}</SPAN> <A NAME="I3650"></A><SPAN STYLE="font-size: 80%">{<I>adjustment</I>}</SPAN> 
<A NAME="I3651"></A>To adjust the value of a [(nonlimited)] composite 
object, the values of the components of the object are first adjusted 
in an arbitrary order, and then, if the object is controlled, Adjust 
is called. Adjusting the value of an elementary object has no effect[, 
nor does adjusting the value of a composite object with no controlled 
parts.]&nbsp;</DIV>
<DIV Class="paranum">16.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>Adjustment is never performed 
for values of a by-reference limited type, since these types do not support 
copying.&nbsp;</DIV>
<DIV Class="paranum">16.b</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>The verbiage in the Initialize 
rule about access discriminants constrained by per-object expressions 
is not necessary here, since such types are limited, and therefore are 
never adjusted.&nbsp;</DIV>
<DIV Class="paranum">17</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>execution (assignment_statement)</I> 
[partial]}</SPAN> <A NAME="I3652"></A>For an <SPAN Class="swiss"><A HREF="AA-5-2.html#S0137">assignment_statement</A></SPAN>, 
[ after the <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
and <SPAN Class="swiss"><A HREF="AA-4-4.html#S0115">expression</A></SPAN> 
have been evaluated, and any conversion (including constraint checking) 
has been done,] an anonymous object is created, and the value is assigned 
into it; [that is, the assignment operation is applied]. [(Assignment 
includes value adjustment.)] The target of the <SPAN Class="swiss"><A HREF="AA-5-2.html#S0137">assignment_statement</A></SPAN> 
is then finalized. The value of the anonymous object is then assigned 
into the target of the <SPAN Class="swiss"><A HREF="AA-5-2.html#S0137">assignment_statement</A></SPAN>. 
Finally, the anonymous object is finalized. [As explained below, the 
implementation may eliminate the intermediate anonymous object, so this 
description subsumes the one given in <A HREF="AA-5-2.html">5.2</A>, 
&ldquo;<A HREF="AA-5-2.html">Assignment Statements</A>&rdquo;.]&nbsp;</DIV>
<DIV Class="paranum">17.a</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><B>Reason:&nbsp;</B>An 
alternative design for user-defined assignment might involve an Assign 
operation instead of Adjust:&nbsp;</DIV>
<DIV Class="paranum">17.b</DIV>
<DIV Class="SmallExamples"><B>procedure</B>&nbsp;Assign(Target&nbsp;:&nbsp;<B>in</B>&nbsp;<B>out</B>&nbsp;Controlled;&nbsp;Source&nbsp;:&nbsp;<B>in</B>&nbsp;<B>out</B>&nbsp;Controlled);</DIV>
<DIV Class="paranum">17.c</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em">Or perhaps even 
a syntax like this:&nbsp;</DIV>
<DIV Class="paranum">17.d</DIV>
<DIV Class="SmallExamples"><B>procedure</B>&nbsp;&quot;:=&quot;(Target&nbsp;:&nbsp;<B>in</B>&nbsp;<B>out</B>&nbsp;Controlled;&nbsp;Source&nbsp;:&nbsp;<B>in</B>&nbsp;<B>out</B>&nbsp;Controlled);</DIV>
<DIV Class="paranum">17.e</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em">Assign (or &quot;:=&quot;) 
would have the responsibility of doing the copy, as well as whatever 
else is necessary. This would have the advantage that the Assign operation 
knows about both the target and the source at the same time &mdash; it 
would be possible to do things like reuse storage belonging to the target, 
for example, which Adjust cannot do. However, this sort of design would 
not work in the case of unconstrained discriminated variables, because 
there is no way to change the discriminants individually. For example: 
</DIV>
<DIV Class="paranum">17.f</DIV>
<DIV Class="SmallExamples"><B>type</B>&nbsp;Mutable(D&nbsp;:&nbsp;Integer&nbsp;:=&nbsp;0)&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>record</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;:&nbsp;Array_Of_Controlled_Things(1..D);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>case</B>&nbsp;D&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>when</B>&nbsp;17&nbsp;=&gt;&nbsp;Y&nbsp;:&nbsp;Controlled_Thing;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>when</B>&nbsp;<B>others</B>&nbsp;=&gt;&nbsp;<B>null</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;D;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;<B>record</B>;</DIV>
<DIV Class="paranum">17.g</DIV>
<DIV Class="Annotations">An assignment to an unconstrained variable of 
type Mutable can cause some of the components of X, and the component 
Y, to appear and/or disappear. There is no way to write the Assign operation 
to handle this sort of case.</DIV>
<DIV Class="paranum">17.h</DIV>
<DIV Class="Annotations">Forbidding such cases is not an option &mdash; 
it would cause generic contract model violations.&nbsp;</DIV>

<H4 Class="centered">Implementation Requirements</H4>
<DIV Class="paranum">17.1/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="defect1.html#8652/0022">8652/0022</A></I>} 
<SPAN class="insert1"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00083.TXT">AI95-00083-01</A></I>} 
<SPAN class="insert1"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10318.TXT">AI95-00318-02</A></I>} 
<SPAN class="insert1">For an <SPAN Class="swiss"><A HREF="AA-4-3.html#S0104">aggregate</A></SPAN> 
of a controlled type whose value is assigned, other than by an <SPAN Class="swiss"><A HREF="AA-5-2.html#S0137">assignment_statement</A></SPAN></SPAN><SPAN class="insert1"><SPAN class="delete2">&nbsp;or a <SPAN Class="swiss"><A HREF="AA-6-5.html#S0169">return_statement</A></SPAN></SPAN></SPAN><SPAN class="insert1">, 
the implementation shall not create a separate anonymous object for the 
<SPAN Class="swiss"><A HREF="AA-4-3.html#S0104">aggregate</A></SPAN>. 
The aggregate value shall be constructed directly in the target of the 
assignment operation and Adjust is not called on the target object.</SPAN> 
</DIV>
<DIV Class="paranum">17.h.1/2</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><SPAN class="insert1"><B>Reason: 
</B></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10318.TXT">AI95-00318-02</A></I>} 
<SPAN class="insert1"></SPAN><SPAN class="insert2">{<I>build-in-place</I> 
[partial]} <A NAME="I3653"></A></SPAN><SPAN class="insert1">This</SPAN><SPAN class="insert2">&nbsp;<I>build-in-place</I> requirement</SPAN><SPAN class="insert1">&nbsp;is necessary 
to prevent elaboration problems with deferred constants of controlled 
types. Consider:</SPAN>&nbsp;</DIV>
<DIV Class="paranum">17.h.2/1</DIV>
<DIV Class="SmallExamples"><SPAN class="insert1"><B>package</B>&nbsp;P&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Dyn_String&nbsp;<B>is&nbsp;private</B>;<BR>
&nbsp;&nbsp;&nbsp;Null_String&nbsp;:&nbsp;<B>constant</B>&nbsp;Dyn_String;<BR>
&nbsp;&nbsp;&nbsp;...<BR>
<B>private</B><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Dyn_String&nbsp;<B>is&nbsp;new</B>&nbsp;Ada.Finalization.Controlled&nbsp;<B>with</B>&nbsp;...<BR>
&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Finalize(X&nbsp;:&nbsp;<B>in&nbsp;out</B>&nbsp;Dyn_String);<BR>
&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Adjust(X&nbsp;:&nbsp;<B>in&nbsp;out</B>&nbsp;Dyn_String);<BR>
<BR>
&nbsp;&nbsp;&nbsp;Null_String&nbsp;:&nbsp;<B>constant</B>&nbsp;Dyn_String&nbsp;:=<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Ada.Finalization.Controlled&nbsp;<B>with</B>&nbsp;...);<BR>
&nbsp;&nbsp;&nbsp;...<BR>
<B>end</B>&nbsp;P;</SPAN></DIV>
<DIV Class="paranum">17.h.3/1</DIV>
<DIV Class="Annotations"><SPAN class="insert1">When Null_String is elaborated, 
the bodies of Finalize and Adjust clearly have not been elaborated. Without 
this rule, this declaration would necessarily raise Program_Error (unless 
the permissions given below are used by the implementation).</SPAN>&nbsp;</DIV>
<DIV Class="paranum">17.i/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Ramification:&nbsp;</B>An 
<SPAN Class="swiss"><A HREF="AA-4-3.html#S0104">aggregate</A></SPAN> 
used in the return expression of a <SPAN Class="swiss"><A HREF="AA-6-5.html#S0168">simple_return_statement</A></SPAN> 
has to be built-in-place in the anonymous return object, as this is similar 
to an object declaration. (This is a change from Ada 95, but it is not 
an inconsistency as it only serves to restrict implementation choices.) 
But this only covers the <SPAN Class="swiss"><A HREF="AA-4-3.html#S0104">aggregate</A></SPAN>; 
a separate anonymous return object can still be used unless it too is 
required to be built-in-place (see <A HREF="AA-7-5.html">7.5</A>).</SPAN> 
</DIV>

<H4 Class="centered">Implementation Permissions</H4>
<DIV Class="paranum">18</DIV>
<DIV Class="Normal">An implementation is allowed to relax the above rules 
[(for nonlimited controlled types)] in the following ways:&nbsp;</DIV>
<DIV Class="paranum">18.a</DIV>
<DIV Class="Annotations"><B>Proof:&nbsp;</B>The phrase &ldquo;for nonlimited 
controlled types&rdquo; follows from the fact that all of the following 
permissions apply to cases involving assignment. It is important because 
the programmer can count on a stricter semantics for limited controlled 
types.&nbsp;</DIV>
<DIV Class="paranum">19</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>For an <SPAN Class="swiss"><A HREF="AA-5-2.html#S0137">assignment_statement</A></SPAN> 
that assigns to an object the value of that same object, the implementation 
need not do anything.&nbsp;</LI></UL>
<DIV Class="paranum">19.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>In other words, even if 
an object is controlled and a combination of Finalize and Adjust on the 
object might have a net side effect, they need not be performed.&nbsp;</DIV>
<DIV Class="paranum">20</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>For an <SPAN Class="swiss"><A HREF="AA-5-2.html#S0137">assignment_statement</A></SPAN> 
for a noncontrolled type, the implementation may finalize and assign 
each component of the variable separately (rather than finalizing the 
entire variable and assigning the entire new value) unless a discriminant 
of the variable is changed by the assignment.&nbsp;</LI></UL>
<DIV Class="paranum">20.a</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>For example, in a slice assignment, 
an anonymous object is not necessary if the slice is copied component-by-component 
in the right direction, since array types are not controlled (although 
their components may be). Note that the direction, and even the fact 
that it's a slice assignment, can in general be determined only at run 
time.&nbsp;</DIV>
<DIV Class="paranum">21/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00147.TXT">AI95-00147-01</A></I>} 
For an <SPAN Class="swiss"><A HREF="AA-4-3.html#S0104">aggregate</A></SPAN> 
or function call whose value is assigned into a target object, the implementation 
need not create a separate anonymous object if it can safely create the 
value of the <SPAN Class="swiss"><A HREF="AA-4-3.html#S0104">aggregate</A></SPAN> 
or function call directly in the target object. Similarly, for an <SPAN Class="swiss"><A HREF="AA-5-2.html#S0137">assignment_statement</A></SPAN>, 
the implementation need not create an anonymous object if the value being 
assigned is the result of evaluating a <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
denoting an object (the source object) whose storage cannot overlap with 
the target. If the source object might overlap with the target object, 
then the implementation can avoid the need for an intermediary anonymous 
object by exercising one of the above permissions and perform the assignment 
one component at a time (for an overlapping array assignment), or not 
at all (for an assignment where the target and the source of the assignment 
are the same object).<SPAN class="delete2">&nbsp;Even if an anonymous object 
is created, the implementation may move its value to the target object 
as part of the assignment without re-adjusting so long as the anonymous 
object has no aliased subcomponents.</SPAN>&nbsp;</LI></UL>
<DIV Class="paranum">21.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>In the <SPAN Class="swiss"><A HREF="AA-4-3.html#S0104">aggregate</A></SPAN> 
case, only one value adjustment is necessary, and there is no anonymous 
object to be finalized.</DIV>
<DIV Class="paranum">21.b/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00147.TXT">AI95-00147-01</A></I>} 
<SPAN class="insert2">Similarly, in the function call case, the anonymous 
object can be eliminated. Note, however, that Adjust must be called</SPAN><SPAN class="delete2">&nbsp;In 
the <SPAN Class="swiss"><A HREF="AA-5-2.html#S0137">assignment_statement</A></SPAN> 
case as well, no finalization of the anonymous object is needed. On the 
other hand, if the target has aliased subcomponents, then an adjustment 
takes place</SPAN> directly on the target object as the last step of 
the assignment, since some of the subcomponents may be self-referential 
or otherwise position-dependent.<SPAN class="insert2">&nbsp;This Adjust can 
be eliminated only by using one of the following permissions.</SPAN> 
</DIV>
<DIV Class="paranum">22/2</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00147.TXT">AI95-00147-01</A></I>} 
<SPAN class="insert2">Furthermore, an implementation is permitted to 
omit implicit Initialize, Adjust, and Finalize calls and associated assignment 
operations on an object of a nonlimited controlled type provided that:</SPAN></DIV>
<DIV Class="paranum">23/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN class="insert2">any omitted 
Initialize call is not a call on a user-defined Initialize procedure, 
and</SPAN>&nbsp;</LI></UL>
<DIV Class="paranum">23.a/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>To be honest:&nbsp;</B>This 
does not apply to any calls to a user-defined Initialize routine that 
happen to occur in an Adjust or Finalize routine. It is intended that 
it is never necessary to look inside of an Adjust or Finalize routine 
to determine if the call can be omitted.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">23.b/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Reason:&nbsp;</B>We don't 
want to eliminate objects for which the Initialize might have side effects 
(such as locking a resource).</SPAN>&nbsp;</DIV>
<DIV Class="paranum">24/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN class="insert2">any usage of 
the value of the object after the implicit Initialize or Adjust call 
and before any subsequent Finalize call on the object does not change 
the external effect of the program, and</SPAN></LI></UL>
<DIV Class="paranum">25/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN class="insert2">after the omission 
of such calls and operations, any execution of the program that executes 
an Initialize or Adjust call on an object or initializes an object by 
an <SPAN Class="swiss"><A HREF="AA-4-3.html#S0104">aggregate</A></SPAN> 
will also later execute a Finalize call on the object and will always 
do so prior to assigning a new value to the object, and</SPAN></LI></UL>
<DIV Class="paranum">26/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN class="insert2">the assignment 
operations associated with omitted Adjust calls are also omitted.</SPAN> 
</LI></UL>
<DIV Class="paranum">27/2</DIV>
<DIV Class="Normal">&nbsp;<SPAN class="insert2">This permission applies to 
Adjust and Finalize calls even if the implicit calls have additional 
external effects.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">27.a/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Reason:&nbsp;</B>The goal 
of the above permissions is to allow typical dead assignment and dead 
variable removal algorithms to work for nonlimited controlled types. 
We require that &ldquo;pairs&rdquo; of Initialize/Adjust/Finalize operations 
are removed. (These aren't always pairs, which is why we talk about &ldquo;any 
execution of the program&rdquo;.)</SPAN>&nbsp;</DIV>

<H4 Class="centered">Extensions to Ada 83</H4>
<DIV Class="paranum">27.b</DIV>
<DIV Class="Annotations">{<I>extensions to Ada 83</I>} <A NAME="I3654"></A>Controlled 
types and user-defined finalization are new to Ada 95. (Ada 83 had finalization 
semantics only for masters of tasks.)&nbsp;</DIV>

<H4 Class="centered">Extensions to Ada 95</H4>
<DIV Class="paranum">27.c/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00161.TXT">AI95-00161-01</A></I>} 
<SPAN class="insert2">{<I>extensions to Ada 95</I>} <A NAME="I3655"></A><B>Amendment 
Correction:</B> Types Controlled and Limited_Controlled now have Preelaborable_Initialization, 
so that objects of types derived from these types can be used in preelaborated 
packages.</SPAN>&nbsp;</DIV>

<H4 Class="centered">Wording Changes from Ada 95</H4>
<DIV Class="paranum">27.d/2</DIV>
<DIV Class="Annotations">{<I><A HREF="defect1.html#8652/0020">8652/0020</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00126.TXT">AI95-00126-01</A></I>} 
<SPAN class="insert2"><B>Corrigendum:</B> Clarified that Ada.Finalization 
is a remote types package.</SPAN></DIV>
<DIV Class="paranum">27.e/2</DIV>
<DIV Class="Annotations">{<I><A HREF="defect1.html#8652/0021">8652/0021</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00182.TXT">AI95-00182-01</A></I>} 
<SPAN class="insert2"><B>Corrigendum:</B> Added wording to clarify that 
the default initialization (whatever it is) of an ancestor part is used.</SPAN></DIV>
<DIV Class="paranum">27.f/2</DIV>
<DIV Class="Annotations">{<I><A HREF="defect1.html#8652/0022">8652/0022</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00083.TXT">AI95-00083-01</A></I>} 
<SPAN class="insert2"><B>Corrigendum:</B> Clarified that Adjust is never 
called on an aggregate used for the initialization of an object or subaggregate, 
or passed as a parameter.</SPAN></DIV>
<DIV Class="paranum">27.g/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00147.TXT">AI95-00147-01</A></I>} 
<SPAN class="insert2">Additional optimizations are allowed for nonlimited 
controlled types. These allow traditional dead variable elimination to 
be applied to such types.</SPAN></DIV>
<DIV Class="paranum">27.h/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-10318.TXT">AI95-00318-02</A></I>} 
<SPAN class="insert2">Corrected the build-in-place requirement for controlled 
<SPAN Class="swiss"><A HREF="AA-4-3.html#S0104">aggregate</A></SPAN>s 
to be consistent with the requirements for limited types.</SPAN></DIV>
<DIV Class="paranum">27.i/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00348.TXT">AI95-00348-01</A></I>} 
<SPAN class="insert2">The operations of types Controlled and Limited_Controlled 
are now declared as null procedures (see <A HREF="AA-6-7.html">6.7</A>) 
to make the semantics clear (and to provide a good example of what null 
procedures can be used for).</SPAN></DIV>
<DIV Class="paranum">27.j/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00360.TXT">AI95-00360-01</A></I>} 
<SPAN class="insert2">Types that need finalization are defined; this 
is used by the No_Nested_Finalization restriction (see <A HREF="AA-D-7.html">D.7</A>, 
&ldquo;<A HREF="AA-D-7.html">Tasking Restrictions</A>&rdquo;).</SPAN></DIV>
<DIV Class="paranum">27.k/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00373.TXT">AI95-00373-01</A></I>} 
<SPAN class="insert2">Generalized the description of objects that have 
Initialize called for them to say that it is done for all objects that 
are initialized by default. This is needed so that all of the new cases 
are covered.</SPAN>&nbsp;</DIV>

<HR>
<DIV Style="margin-top: 0.0em; margin-bottom: 0.6em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-7-5.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-7-6-1.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<DIV Style="margin-top:0.0em"><IMG SRC="AE_logo.gif" height=100 width=113 align=right ALT="Ada-Europe">
<SPAN Style="font-size: 125%">Sponsored by <SPAN Style="font-size: 125%"><A HREF="http://www.ada-europe.org/"><B>Ada-Europe</B></A></SPAN></SPAN></DIV>
</BODY>
</HTML>
