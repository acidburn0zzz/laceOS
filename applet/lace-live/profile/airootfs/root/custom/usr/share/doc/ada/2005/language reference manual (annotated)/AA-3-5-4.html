<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Integer Types</TITLE>
    <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    H4.centered {text-align: center}
    SPAN.swiss {font-family: Arial, Helvetica, sans-serif; font-size: 92%}
    SPAN.roman {font-family: "Times New Roman", Times, serif}
    DIV.paranum {float: left; font-family: Arial, Helvetica, sans-serif; font-size: 64%; width: 2.8em; margin-left: -0.4em; margin-right: -3.0em; margin-top: 0.2em}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    SPAN.insert1 {text-decoration: underline; color: rgb(0,51,51) }
    SPAN.delete1 {text-decoration: line-through; color: rgb(0,51,51) }
    SPAN.insert2 {text-decoration: underline; color: rgb(0,102,0) }
    SPAN.delete2 {text-decoration: line-through; color: rgb(0,102,0) }
    DIV.Normal {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.2em; margin-bottom: 0.6em}
    DIV.Wide {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.2em; margin-top: 0.6em; margin-bottom: 0.6em}
    DIV.Annotations {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 6.2em; margin-bottom: 0.6em}
    DIV.Notes {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em; margin-bottom: 0.6em}
    DIV.NotesHeader {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em}
    DIV.SyntaxIndented {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-bottom: 0.4em}
    DIV.Examples {font-family: "Courier New", monospace; font-size: 90%; line-height: 122%; margin-left: 3.4em; margin-bottom: 0.6em}
    DIV.IndentedExamples {font-family: "Courier New", monospace; font-size: 90%; line-height: 122%; margin-left:  10.0em; margin-bottom: 0.6em}
    DIV.Hanging-Body {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 7.2em; margin-top: 0em; margin-bottom: 0.6em}
    DIV.Hanging-Term {float: left; font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.2em; margin-top: 0em; margin-bottom: 0em}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#000080" VLINK="#330033" ALINK="#0000FF">
<DIV><B><SPAN Style="font-size:200%; color: rgb(0,51,153)">Annotated</SPAN><SPAN Style="font-size:200%; color: rgb(0,0,102)">&nbsp;Ada Reference Manual</SPAN></B> &mdash; <A HREF="AA-TTL.html"><B>Legal Information</B></A></DIV>
<DIV Style="margin-top: 0.6em; margin-bottom: 0.0em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-3-5-3.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-3-5-5.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<HR>
<H1>3.5.4 Integer Types</H1>
<DIV Class="paranum">1</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>integer type</I>}</SPAN> 
<A NAME="I1792"></A><SPAN STYLE="font-size: 80%">{<I>signed integer type</I>}</SPAN> 
<A NAME="I1793"></A><SPAN STYLE="font-size: 80%">{<I>modular type</I>}</SPAN> 
<A NAME="I1794"></A>An <SPAN Class="swiss"><A HREF="AA-3-5-4.html#S0041">integer_type_definition</A></SPAN> 
defines an integer type; it defines either a <I>signed</I> integer type, 
or a <I>modular</I> integer type. The base range of a signed integer 
type includes at least the values of the specified range. A modular type 
is an integer type with all arithmetic modulo a specified positive <I>modulus</I>; 
such a type corresponds to an unsigned type with wrap-around semantics. 
<SPAN STYLE="font-size: 80%">{<I>unsigned type: See modular type</I>}</SPAN> 
<A NAME="I1795"></A></DIV>

<H4 Class="centered">Syntax</H4>
<DIV Class="paranum">2</DIV>
<DIV Class="SyntaxIndented"><SPAN Class="swiss">integer_type_definition</SPAN><A NAME="I1796"></A><A NAME="S0041"></A><SPAN Class="swiss">&nbsp;::=&nbsp;</SPAN><A NAME="I1797"></A><SPAN Class="swiss"><A HREF="AA-3-5-4.html#S0042">signed_integer_type_definition</A></SPAN>&nbsp;|&nbsp;<A NAME="I1798"></A><SPAN Class="swiss"><A HREF="AA-3-5-4.html#S0043">modular_type_definition</A></SPAN></DIV>
<DIV Class="paranum">3</DIV>
<DIV Class="SyntaxIndented"><SPAN Class="swiss">signed_integer_type_definition</SPAN><A NAME="I1799"></A><A NAME="S0042"></A><SPAN Class="swiss">&nbsp;::=&nbsp;</SPAN><B>range</B>&nbsp;<I>static_</I><A NAME="I1800"></A><SPAN Class="swiss"><A HREF="AA-4-4.html#S0117">simple_expression</A></SPAN>&nbsp;..&nbsp;<I>static_</I><A NAME="I1801"></A><SPAN Class="swiss"><A HREF="AA-4-4.html#S0117">simple_expression</A></SPAN></DIV>
<DIV Class="paranum">3.a</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>We don't call this a <SPAN Class="swiss"><A HREF="AA-3-5.html#S0036">range_constraint</A></SPAN>, 
because it is rather different &mdash; not only is it required to be 
static, but the associated overload resolution rules are different than 
for normal range constraints. A similar comment applies to <SPAN Class="swiss"><A HREF="AA-3-5-7.html#S0046">real_range_specification</A></SPAN>. 
This used to be <SPAN Class="swiss">integer_range_specification</SPAN> 
but when we added support for modular types, it seemed overkill to have 
three levels of syntax rules, and just calling these <SPAN Class="swiss">signed_integer_range_specification</SPAN> 
and <SPAN Class="swiss">modular_range_specification</SPAN> loses the 
fact that they are defining different classes of types, which is important 
for the generic type matching rules.&nbsp;</DIV>
<DIV Class="paranum">4</DIV>
<DIV Class="SyntaxIndented"><SPAN Class="swiss">modular_type_definition</SPAN><A NAME="I1802"></A><A NAME="S0043"></A><SPAN Class="swiss">&nbsp;::=&nbsp;</SPAN><B>mod</B>&nbsp;<I>static_</I><A NAME="I1803"></A><SPAN Class="swiss"><A HREF="AA-4-4.html#S0115">expression</A></SPAN></DIV>

<H4 Class="centered">Name Resolution Rules</H4>
<DIV Class="paranum">5</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>expected type (signed_integer_type_definition 
simple_expression)</I> [partial]}</SPAN> <A NAME="I1804"></A>Each <SPAN Class="swiss"><A HREF="AA-4-4.html#S0117">simple_expression</A></SPAN> 
in a <SPAN Class="swiss"><A HREF="AA-3-5-4.html#S0042">signed_integer_type_definition</A></SPAN> 
is expected to be of any integer type; they need not be of the same type. 
<SPAN STYLE="font-size: 80%">{<I>expected type (modular_type_definition 
expression)</I> [partial]}</SPAN> <A NAME="I1805"></A>The <SPAN Class="swiss"><A HREF="AA-4-4.html#S0115">expression</A></SPAN> 
in a <SPAN Class="swiss"><A HREF="AA-3-5-4.html#S0043">modular_type_definition</A></SPAN> 
is likewise expected to be of any integer type.&nbsp;</DIV>

<H4 Class="centered">Legality Rules</H4>
<DIV Class="paranum">6</DIV>
<DIV Class="Normal">The <SPAN Class="swiss"><A HREF="AA-4-4.html#S0117">simple_expression</A></SPAN>s 
of a <SPAN Class="swiss"><A HREF="AA-3-5-4.html#S0042">signed_integer_type_definition</A></SPAN> 
shall be static, and their values shall be in the range System.Min_Int 
.. System.Max_Int.</DIV>
<DIV Class="paranum">7</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>modulus (of a modular 
type)</I>}</SPAN> <A NAME="I1806"></A><SPAN STYLE="font-size: 80%">{<I>Max_Binary_Modulus</I>}</SPAN> 
<A NAME="I1807"></A><SPAN STYLE="font-size: 80%">{<I>Max_Nonbinary_Modulus</I>}</SPAN> 
<A NAME="I1808"></A>The <SPAN Class="swiss"><A HREF="AA-4-4.html#S0115">expression</A></SPAN> 
of a <SPAN Class="swiss"><A HREF="AA-3-5-4.html#S0043">modular_type_definition</A></SPAN> 
shall be static, and its value (the <I>modulus</I>) shall be positive, 
and shall be no greater than System.Max_Binary_Modulus if a power of 
2, or no greater than System.Max_Nonbinary_Modulus if not.&nbsp;</DIV>
<DIV Class="paranum">7.a</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>For a 2's-complement machine, 
supporting nonbinary moduli greater than System.Max_Int can be quite 
difficult, whereas essentially any binary moduli are straightforward 
to support, up to 2*System.Max_Int+2, so this justifies having two separate 
limits.&nbsp;</DIV>

<H4 Class="centered">Static Semantics</H4>
<DIV Class="paranum">8</DIV>
<DIV Class="Normal">The set of values for a signed integer type is the 
(infinite) set of mathematical integers[, though only values of the base 
range of the type are fully supported for run-time operations]. The set 
of values for a modular integer type are the values from 0 to one less 
than the modulus, inclusive.</DIV>
<DIV Class="paranum">9</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>base range (of a 
signed integer type)</I> [partial]}</SPAN> <A NAME="I1809"></A>A <SPAN Class="swiss"><A HREF="AA-3-5-4.html#S0042">signed_integer_type_definition</A></SPAN> 
defines an integer type whose base range includes at least the values 
of the <SPAN Class="swiss"><A HREF="AA-4-4.html#S0117">simple_expression</A></SPAN>s 
and is symmetric about zero, excepting possibly an extra negative value. 
<SPAN STYLE="font-size: 80%">{<I>constrained (subtype)</I>}</SPAN> <A NAME="I1810"></A><SPAN STYLE="font-size: 80%">{<I>unconstrained 
(subtype)</I>}</SPAN> <A NAME="I1811"></A>A <SPAN Class="swiss"><A HREF="AA-3-5-4.html#S0042">signed_integer_type_definition</A></SPAN> 
also defines a constrained first subtype of the type, with a range whose 
bounds are given by the values of the <SPAN Class="swiss"><A HREF="AA-4-4.html#S0117">simple_expression</A></SPAN>s, 
converted to the type being defined.&nbsp;</DIV>
<DIV Class="paranum">9.a/2</DIV>
<DIV Class="Annotations"><B>Implementation Note:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00114.TXT">AI95-00114-01</A></I>} 
The base range of a signed integer type might be much larger than is 
necessary to satisfy the <SPAN class="insert2">above</SPAN><SPAN class="delete2">&nbsp;aboved</SPAN> 
requirements.&nbsp;</DIV>
<DIV Class="paranum">9.a.1/1</DIV>
<DIV Class="Annotations"><SPAN class="insert1"><B>To be honest:&nbsp;</B>The 
conversion mentioned above is not an <I>implicit subtype conversion</I> 
(which is something that happens at overload resolution, see <A HREF="AA-4-6.html">4.6</A>), 
although it happens implicitly. Therefore, the freezing rules are not 
invoked on the type (which is important so that representation items 
can be given for the type). {<I>subtype conversion (bounds of signed 
integer type)</I> [partial]} <A NAME="I1812"></A></SPAN></DIV>
<DIV Class="paranum">10</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>base range (of a 
modular type)</I> [partial]}</SPAN> <A NAME="I1813"></A>A <SPAN Class="swiss"><A HREF="AA-3-5-4.html#S0043">modular_type_definition</A></SPAN> 
defines a modular type whose base range is from zero to one less than 
the given modulus. <SPAN STYLE="font-size: 80%">{<I>constrained (subtype)</I>}</SPAN> 
<A NAME="I1814"></A><SPAN STYLE="font-size: 80%">{<I>unconstrained (subtype)</I>}</SPAN> 
<A NAME="I1815"></A>A <SPAN Class="swiss"><A HREF="AA-3-5-4.html#S0043">modular_type_definition</A></SPAN> 
also defines a constrained first subtype of the type with a range that 
is the same as the base range of the type.</DIV>
<DIV Class="paranum">11</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>Integer</I>}</SPAN> 
<A NAME="I1816"></A>There is a predefined signed integer subtype named 
Integer[, declared in the visible part of package Standard]. It is constrained 
to the base range of its type.&nbsp;</DIV>
<DIV Class="paranum">11.a</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>Integer is a constrained subtype, 
rather than an unconstrained subtype. This means that on assignment to 
an object of subtype Integer, a range check is required. On the other 
hand, an object of subtype Integer'Base is unconstrained, and no range 
check (only overflow check) is required on assignment. For example, if 
the object is held in an extended-length register, its value might be 
outside of Integer'First .. Integer'Last. All parameter and result subtypes 
of the predefined integer operators are of such unconstrained subtypes, 
allowing extended-length registers to be used as operands or for the 
result. In an earlier version of Ada 95, Integer was unconstrained. However, 
the fact that certain Constraint_Errors might be omitted or appear elsewhere 
was felt to be an undesirable upward inconsistency in this case. Note 
that for Float, the opposite conclusion was reached, partly because of 
the high cost of performing range checks when not actually necessary. 
Objects of subtype Float are unconstrained, and no range checks, only 
overflow checks, are performed for them.&nbsp;</DIV>
<DIV Class="paranum">12</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em"><SPAN STYLE="font-size: 80%">{<I>Natural</I>}</SPAN> 
<A NAME="I1817"></A><SPAN STYLE="font-size: 80%">{<I>Positive</I>}</SPAN> 
<A NAME="I1818"></A>Integer has two predefined subtypes, [declared in 
the visible part of package Standard:]&nbsp;</DIV>
<DIV Class="paranum">13</DIV>
<DIV Class="Examples"><B>subtype</B>&nbsp;Natural&nbsp;&nbsp;<B>is</B>&nbsp;Integer&nbsp;<B>range</B>&nbsp;0&nbsp;..&nbsp;Integer'Last;<BR>
<B>subtype</B>&nbsp;Positive&nbsp;<B>is</B>&nbsp;Integer&nbsp;<B>range</B>&nbsp;1&nbsp;..&nbsp;Integer'Last;</DIV>
<DIV Class="paranum">14</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>root_integer</I>}</SPAN> 
<A NAME="I1819"></A><SPAN STYLE="font-size: 80%">{<I>Min_Int</I>}</SPAN> 
<A NAME="I1820"></A><SPAN STYLE="font-size: 80%">{<I>Max_Int</I>}</SPAN> 
<A NAME="I1821"></A>A type defined by an <SPAN Class="swiss"><A HREF="AA-3-5-4.html#S0041">integer_type_definition</A></SPAN> 
is implicitly derived from <I>root_integer</I>, an anonymous predefined 
(specific) integer type, whose base range is System.Min_Int .. System.Max_Int. 
However, the base range of the new type is not inherited from <I>root_integer</I>, 
but is instead determined by the range or modulus specified by the <SPAN Class="swiss"><A HREF="AA-3-5-4.html#S0041">integer_type_definition</A></SPAN>. 
<SPAN STYLE="font-size: 80%">{<I>universal_integer</I> [partial]}</SPAN> 
<A NAME="I1822"></A><SPAN STYLE="font-size: 80%">{<I>integer literals</I>}</SPAN> 
<A NAME="I1823"></A>[Integer literals are all of the type <I>universal_integer</I>, 
the universal type (see <A HREF="AA-3-4-1.html">3.4.1</A>) for the class 
rooted at <I>root_integer</I>, allowing their use with the operations 
of any integer type.]&nbsp;</DIV>
<DIV Class="paranum">14.a</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>This implicit derivation 
is not considered exactly equivalent to explicit derivation via a <SPAN Class="swiss"><A HREF="AA-3-4.html#S0035">derived_type_definition</A></SPAN>. 
In particular, integer types defined via a <SPAN Class="swiss"><A HREF="AA-3-4.html#S0035">derived_type_definition</A></SPAN> 
inherit their base range from their parent type. A type defined by an 
<SPAN Class="swiss"><A HREF="AA-3-5-4.html#S0041">integer_type_definition</A></SPAN> 
does not necessarily inherit its base range from <I>root_integer</I>. 
It is not specified whether the implicit derivation from <I>root_integer</I> 
is direct or indirect, not that it really matters. All we want is for 
all integer types to be descendants of <I>root_integer</I>.</DIV>
<DIV Class="paranum">14.a.1/1</DIV>
<DIV Class="Annotations">{<I><A HREF="defect2.html#8652/0099">8652/0099</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00152.TXT">AI95-00152-01</A></I>} 
<SPAN class="insert1">Note that this derivation does not imply any inheritance 
of subprograms. Subprograms are inherited only for types derived by a 
<SPAN Class="swiss"><A HREF="AA-3-4.html#S0035">derived_type_definition</A></SPAN> 
(see <A HREF="AA-3-4.html">3.4</A>), or a <SPAN Class="swiss"><A HREF="AA-7-3.html#S0177">private_extension_declaration</A></SPAN> 
(see <A HREF="AA-7-3.html">7.3</A>, <A HREF="AA-7-3-1.html">7.3.1</A>, 
and <A HREF="AA-12-5-1.html">12.5.1</A>).</SPAN>&nbsp;</DIV>
<DIV Class="paranum">14.b</DIV>
<DIV Class="Annotations"><B>Implementation Note:&nbsp;</B>It is the intent 
that even nonstandard integer types (see below) will be descendants of 
<I>root_integer</I>, even though they might have a base range that exceeds 
that of <I>root_integer</I>. This causes no problem for static calculations, 
which are performed without range restrictions (see <A HREF="AA-4-9.html">4.9</A>). 
However for run-time calculations, it is possible that Constraint_Error 
might be raised when using an operator of <I>root_integer</I> on the 
result of 'Val applied to a value of a nonstandard integer type.&nbsp;</DIV>
<DIV Class="paranum">15</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>position number 
(of an integer value)</I> [partial]}</SPAN> <A NAME="I1824"></A>The <I>position 
number</I> of an integer value is equal to the value.</DIV>
<DIV Class="paranum">16/2</DIV>
<DIV Class="Wide" Style="margin-bottom: 0.4em">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00340.TXT">AI95-00340-01</A></I>} 
For every modular subtype S, the following <SPAN class="insert2">attributes 
are</SPAN><SPAN class="delete2">&nbsp;attribute is</SPAN> defined:&nbsp;</DIV>
<DIV Class="paranum">16.1/2</DIV>
<DIV Class="Hanging-Term" Style="margin-bottom: 0.4em">&nbsp;&nbsp;&nbsp;<SPAN class="insert2">S'Mod</SPAN></DIV><DIV Class="Hanging-Body">
<SPAN class="insert2"><A NAME="I1825"></A><A NAME="I1826"></A></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00340.TXT">AI95-00340-01</A></I>} 
<SPAN class="insert2"></SPAN><SPAN class="insert2">S'Mod denotes a function 
with the following specification:</SPAN></DIV>
<DIV Class="paranum">16.2/2</DIV>
<DIV Class="IndentedExamples"><SPAN class="insert2"><B>function</B>&nbsp;S'Mod&nbsp;(<SPAN Class="roman"><I>Arg</I></SPAN>&nbsp;:&nbsp;<SPAN Class="roman"><I>universal_integer</I></SPAN>)<BR>
&nbsp;&nbsp;<B>return</B>&nbsp;S'Base</SPAN></DIV>
<DIV Class="paranum">16.3/2</DIV>
<DIV Class="Hanging-Body"><SPAN class="insert2">This function returns 
<I>Arg</I> <B>mod</B> S'Modulus, as a value of the type of S.</SPAN></DIV>
<DIV Class="paranum">17</DIV>
<DIV Class="Hanging-Term">S'Modulus</DIV><DIV Class="Hanging-Body">
<A NAME="I1827"></A><A NAME="I1828"></A>S'Modulus yields the modulus 
of the type of S, as a value of the type <I>universal_integer</I>.&nbsp;</DIV>

<H4 Class="centered">Dynamic Semantics</H4>
<DIV Class="paranum">18</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>elaboration (integer_type_definition)</I> 
[partial]}</SPAN> <A NAME="I1829"></A>The elaboration of an <SPAN Class="swiss"><A HREF="AA-3-5-4.html#S0041">integer_type_definition</A></SPAN> 
creates the integer type and its first subtype.</DIV>
<DIV Class="paranum">19</DIV>
<DIV Class="Normal">For a modular type, if the result of the execution 
of a predefined operator (see <A HREF="AA-4-5.html">4.5</A>) is outside 
the base range of the type, the result is reduced modulo the modulus 
of the type to a value that is within the base range of the type.</DIV>
<DIV Class="paranum">20</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>Overflow_Check</I> 
[partial]}</SPAN> <A NAME="I1830"></A><SPAN STYLE="font-size: 80%">{<I>check, 
language-defined (Overflow_Check)</I>}</SPAN> <A NAME="I1831"></A><SPAN STYLE="font-size: 80%">{<I>Constraint_Error 
(raised by failure of run-time check)</I>}</SPAN> <A NAME="I1832"></A>For 
a signed integer type, the exception Constraint_Error is raised by the 
execution of an operation that cannot deliver the correct result because 
it is outside the base range of the type. [<SPAN STYLE="font-size: 80%">{<I>Division_Check</I> 
[partial]}</SPAN> <A NAME="I1833"></A><SPAN STYLE="font-size: 80%">{<I>check, 
language-defined (Division_Check)</I>}</SPAN> <A NAME="I1834"></A><SPAN STYLE="font-size: 80%">{<I>Constraint_Error 
(raised by failure of run-time check)</I>}</SPAN> <A NAME="I1835"></A>For 
any integer type, Constraint_Error is raised by the operators &quot;/&quot;, 
&quot;<B>rem</B>&quot;, and &quot;<B>mod</B>&quot; if the right operand 
is zero.]</DIV>

<H4 Class="centered">Implementation Requirements</H4>
<DIV Class="paranum">21</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>Integer</I>}</SPAN> 
<A NAME="I1836"></A>In an implementation, the range of Integer shall 
include the range &ndash;2**15+1 .. +2**15&ndash;1.</DIV>
<DIV Class="paranum">22</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>Long_Integer</I>}</SPAN> 
<A NAME="I1837"></A>If Long_Integer is predefined for an implementation, 
then its range shall include the range &ndash;2**31+1 .. +2**31&ndash;1.</DIV>
<DIV Class="paranum">23</DIV>
<DIV Class="Normal">System.Max_Binary_Modulus shall be at least 2**16. 
</DIV>

<H4 Class="centered">Implementation Permissions</H4>
<DIV Class="paranum">24</DIV>
<DIV Class="Normal">For the execution of a predefined operation of a 
signed integer type, the implementation need not raise Constraint_Error 
if the result is outside the base range of the type, so long as the correct 
result is produced.&nbsp;</DIV>
<DIV Class="paranum">24.a</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>Constraint_Error is never 
raised for operations on modular types, except for divide-by-zero (and 
<B>rem</B>/<B>mod</B>-by-zero).&nbsp;</DIV>
<DIV Class="paranum">25</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>Long_Integer</I>}</SPAN> 
<A NAME="I1838"></A><SPAN STYLE="font-size: 80%">{<I>Short_Integer</I>}</SPAN> 
<A NAME="I1839"></A>An implementation may provide additional predefined 
signed integer types[, declared in the visible part of Standard], whose 
first subtypes have names of the form Short_Integer, Long_Integer, Short_Short_Integer, 
Long_Long_Integer, etc. Different predefined integer types are allowed 
to have the same base range. However, the range of Integer should be 
no wider than that of Long_Integer. Similarly, the range of Short_Integer 
(if provided) should be no wider than Integer. Corresponding recommendations 
apply to any other predefined integer types. There need not be a named 
integer type corresponding to each distinct base range supported by an 
implementation. The range of each first subtype should be the base range 
of its type.&nbsp;</DIV>
<DIV Class="paranum">25.a</DIV>
<DIV Class="Annotations"><B>Implementation defined:&nbsp;</B>The predefined 
integer types declared in Standard.</DIV>
<DIV Class="paranum">26</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>nonstandard integer 
type</I>}</SPAN> <A NAME="I1840"></A>An implementation may provide <I>nonstandard 
integer types</I>, descendants of <I>root_integer</I> that are declared 
outside of the specification of package Standard, which need not have 
all the standard characteristics of a type defined by an <SPAN Class="swiss"><A HREF="AA-3-5-4.html#S0041">integer_type_definition</A></SPAN>. 
For example, a nonstandard integer type might have an asymmetric base 
range or it might not be allowed as an array or loop index (a very long 
integer). Any type descended from a nonstandard integer type is also 
nonstandard. An implementation may place arbitrary restrictions on the 
use of such types; it is implementation defined whether operators that 
are predefined for &ldquo;any integer type&rdquo; are defined for a particular 
nonstandard integer type. [In any case, such types are not permitted 
as <SPAN Class="swiss"><A HREF="AA-12-3.html#S0260">explicit_generic_actual_parameter</A></SPAN>s 
for formal scalar types &mdash; see <A HREF="AA-12-5-2.html">12.5.2</A>.] 
</DIV>
<DIV Class="paranum">26.a</DIV>
<DIV Class="Annotations"><B>Implementation defined:&nbsp;</B>Any nonstandard 
integer types and the operators defined for them.</DIV>
<DIV Class="paranum">27</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>one's complement 
(modular types)</I> [partial]}</SPAN> <A NAME="I1841"></A>For a one's 
complement machine, the high bound of the base range of a modular type 
whose modulus is one less than a power of 2 may be equal to the modulus, 
rather than one less than the modulus. It is implementation defined for 
which powers of 2, if any, this permission is exercised.</DIV>
<DIV Class="paranum">27.1/1</DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="defect1.html#8652/0003">8652/0003</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00095.TXT">AI95-00095-01</A></I>} 
<SPAN class="insert1">For a one's complement machine, implementations 
may support non-binary modulus values greater than System.Max_Nonbinary_Modulus. 
It is implementation defined which specific values greater than System.Max_Nonbinary_Modulus, 
if any, are supported.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">27.a.1/1</DIV>
<DIV Class="Annotations"><SPAN class="insert1"><B>Reason:&nbsp;</B>On a one's 
complement machine, the natural full word type would have a modulus of 
2**Word_Size&ndash;1. However, we would want to allow the all-ones bit 
pattern (which represents negative zero as a number) in logical operations. 
These permissions are intended to allow that and the natural modulus 
value without burdening implementations with supporting expensive modulus 
values.</SPAN>&nbsp;</DIV>

<H4 Class="centered">Implementation Advice</H4>
<DIV Class="paranum">28</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>Long_Integer</I>}</SPAN> 
<A NAME="I1842"></A>An implementation should support Long_Integer in 
addition to Integer if the target machine supports 32-bit (or longer) 
arithmetic. No other named integer subtypes are recommended for package 
Standard. Instead, appropriate named integer subtypes should be provided 
in the library package Interfaces (see <A HREF="AA-B-2.html">B.2</A>). 
</DIV>
<DIV Class="paranum">28.a.1/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Implementation Advice: 
</B></SPAN><SPAN class="insert2">Long_Integer should be declared in Standard 
if the target supports 32-bit arithmetic. No other named integer subtypes 
should be declared in Standard.</SPAN></DIV>
<DIV Class="paranum">28.a</DIV>
<DIV Class="Annotations"><B>Implementation Note:&nbsp;</B>To promote portability, 
implementations should explicitly declare the integer (sub)types Integer 
and Long_Integer in Standard, and leave other predefined integer types 
anonymous. For implementations that already support Byte_Integer, etc., 
upward compatibility argues for keeping such declarations in Standard 
during the transition period, but perhaps generating a warning on use. 
A separate package Interfaces in the predefined environment is available 
for pre-declaring types such as Integer_8, Integer_16, etc. See <A HREF="AA-B-2.html">B.2</A>. 
In any case, if the user declares a subtype (first or not) whose range 
fits in, for example, a byte, the implementation can store variables 
of the subtype in a single byte, even if the base range of the type is 
wider.&nbsp;</DIV>
<DIV Class="paranum">29</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>two's complement 
(modular types)</I> [partial]}</SPAN> <A NAME="I1843"></A>An implementation 
for a two's complement machine should support modular types with a binary 
modulus up to System.Max_Int*2+2. An implementation should support a 
nonbinary modulus up to Integer'Last.&nbsp;</DIV>
<DIV Class="paranum">29.a.1/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Implementation Advice: 
</B></SPAN><SPAN class="insert2">For a two's complement target, modular 
types with a binary modulus up to System.Max_Int*2+2 should be supported. 
A nonbinary modulus up to Integer'Last should be supported.</SPAN></DIV>
<DIV Class="paranum">29.a</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>Modular types provide bit-wise 
&quot;<B>and</B>&quot;, &quot;<B>or</B>&quot;, &quot;<B>xor</B>&quot;, 
and &quot;<B>not</B>&quot; operations. It is important for systems programming 
that these be available for all integer types of the target hardware. 
</DIV>
<DIV Class="paranum">29.b</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>Note that on a one's complement 
machine, the largest supported modular type would normally have a nonbinary 
modulus. On a two's complement machine, the largest supported modular 
type would normally have a binary modulus.&nbsp;</DIV>
<DIV Class="paranum">29.c</DIV>
<DIV Class="Annotations"><B>Implementation Note:&nbsp;</B>Supporting a nonbinary 
modulus greater than Integer'Last can impose an undesirable implementation 
burden on some machines.&nbsp;</DIV>
<DIV Class="NotesHeader">NOTES</DIV>
<DIV Class="paranum">30</DIV>
<DIV Class="Notes">27&nbsp;&nbsp;<SPAN STYLE="font-size: 80%">{<I>universal_integer</I>}</SPAN> 
<A NAME="I1844"></A><SPAN STYLE="font-size: 80%">{<I>integer literals</I>}</SPAN> 
<A NAME="I1845"></A>Integer literals are of the anonymous predefined 
integer type <I>universal_integer</I>. Other integer types have no literals. 
However, the overload resolution rules (see <A HREF="AA-8-6.html">8.6</A>, 
&ldquo;<A HREF="AA-8-6.html">The Context of Overload Resolution</A>&rdquo;) 
allow expressions of the type <I>universal_integer</I> whenever an integer 
type is expected.</DIV>
<DIV Class="paranum">31</DIV>
<DIV Class="Notes">28&nbsp;&nbsp;The same arithmetic operators are predefined 
for all signed integer types defined by a <SPAN Class="swiss"><A HREF="AA-3-5-4.html#S0042">signed_integer_type_definition</A></SPAN> 
(see <A HREF="AA-4-5.html">4.5</A>, &ldquo;<A HREF="AA-4-5.html">Operators 
and Expression Evaluation</A>&rdquo;). For modular types, these same 
operators are predefined, plus bit-wise logical operators (<B>and</B>, 
<B>or</B>, <B>xor</B>, and <B>not</B>). In addition, for the unsigned 
types declared in the language-defined package Interfaces (see <A HREF="AA-B-2.html">B.2</A>), 
functions are defined that provide bit-wise shifting and rotating.</DIV>
<DIV Class="paranum">32</DIV>
<DIV Class="Notes">29&nbsp;&nbsp;Modular types match a <SPAN Class="swiss"><A HREF="AA-12-1.html#S0256">generic_formal_parameter_declaration</A></SPAN> 
of the form &quot;<B>type</B> T <B>is mod</B> &lt;&gt;;&quot;; signed 
integer types match &quot;<B>type</B> T <B>is range</B> &lt;&gt;;&quot; 
(see <A HREF="AA-12-5-2.html">12.5.2</A>).&nbsp;</DIV>

<H4 Class="centered">Examples</H4>
<DIV Class="paranum">33</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em"><I>Examples of integer 
types and subtypes:&nbsp;</I></DIV>
<DIV Class="paranum">34</DIV>
<DIV Class="Examples"><B>type</B>&nbsp;Page_Num&nbsp;&nbsp;<B>is</B>&nbsp;<B>range</B>&nbsp;1&nbsp;..&nbsp;2_000;<BR>
<B>type</B>&nbsp;Line_Size&nbsp;<B>is</B>&nbsp;<B>range</B>&nbsp;1&nbsp;..&nbsp;Max_Line_Size;</DIV>
<DIV Class="paranum">35</DIV>
<DIV Class="Examples"><B>subtype</B>&nbsp;Small_Int&nbsp;&nbsp;&nbsp;<B>is</B>&nbsp;Integer&nbsp;&nbsp;&nbsp;<B>range</B>&nbsp;-10&nbsp;..&nbsp;10;<BR>
<B>subtype</B>&nbsp;Column_Ptr&nbsp;&nbsp;<B>is</B>&nbsp;Line_Size&nbsp;<B>range</B>&nbsp;1&nbsp;..&nbsp;10;<BR>
<B>subtype</B>&nbsp;Buffer_Size&nbsp;<B>is</B>&nbsp;Integer&nbsp;&nbsp;&nbsp;<B>range</B>&nbsp;0&nbsp;..&nbsp;Max;</DIV>
<DIV Class="paranum">36</DIV>
<DIV Class="Examples"><B>type</B>&nbsp;Byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>is</B>&nbsp;<B>mod</B>&nbsp;256;&nbsp;--<SPAN Class="roman"><I>&nbsp;an&nbsp;unsigned&nbsp;byte</I></SPAN><BR>
<B>type</B>&nbsp;Hash_Index&nbsp;&nbsp;<B>is</B>&nbsp;<B>mod</B>&nbsp;97;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;modulus&nbsp;is&nbsp;prime</I></SPAN></DIV>

<H4 Class="centered">Extensions to Ada 83</H4>
<DIV Class="paranum">36.a</DIV>
<DIV Class="Annotations">{<I>extensions to Ada 83</I>} <A NAME="I1846"></A>An 
implementation is allowed to support any number of distinct base ranges 
for integer types, even if fewer integer types are explicitly declared 
in Standard.</DIV>
<DIV Class="paranum">36.b</DIV>
<DIV Class="Annotations">Modular (unsigned, wrap-around) types are new. 
</DIV>

<H4 Class="centered">Wording Changes from Ada 83</H4>
<DIV Class="paranum">36.c</DIV>
<DIV Class="Annotations">Ada 83's integer types are now called &quot;signed&quot; 
integer types, to contrast them with &quot;modular&quot; integer types.</DIV>
<DIV Class="paranum">36.d</DIV>
<DIV Class="Annotations">Standard.Integer, Standard.Long_Integer, etc., 
denote constrained subtypes of predefined integer types, consistent with 
the Ada 95 model that only subtypes have names.</DIV>
<DIV Class="paranum">36.e</DIV>
<DIV Class="Annotations">We now impose minimum requirements on the base 
range of Integer and Long_Integer.</DIV>
<DIV Class="paranum">36.f</DIV>
<DIV Class="Annotations">We no longer explain integer type definition 
in terms of an equivalence to a normal type derivation, except to say 
that all integer types are by definition implicitly derived from <I>root_integer</I>. 
This is for various reasons.</DIV>
<DIV Class="paranum">36.g</DIV>
<DIV Class="Annotations">First of all, the equivalence with a type derivation 
and a subtype declaration was not perfect, and was the source of various 
AIs (for example, is the conversion of the bounds static? Is a numeric 
type a derived type with respect to other rules of the language?)</DIV>
<DIV Class="paranum">36.h</DIV>
<DIV Class="Annotations">Secondly, we don't want to require that every 
integer size supported shall have a corresponding named type in Standard. 
Adding named types to Standard creates nonportabilities.</DIV>
<DIV Class="paranum">36.i</DIV>
<DIV Class="Annotations">Thirdly, we don't want the set of types that 
match a formal derived type &quot;type T is new Integer;&quot; to depend 
on the particular underlying integer representation chosen to implement 
a given user-defined integer type. Hence, we would have needed anonymous 
integer types as parent types for the implicit derivation anyway. We 
have simply chosen to identify only one anonymous integer type &mdash; 
<I>root_integer</I>, and stated that every integer type is derived from 
it.</DIV>
<DIV Class="paranum">36.j</DIV>
<DIV Class="Annotations">Finally, the &ldquo;fiction&rdquo; that there 
were distinct preexisting predefined types for every supported representation 
breaks down for fixed point with arbitrary smalls, and was never exploited 
for enumeration types, array types, etc. Hence, there seems little benefit 
to pushing an explicit equivalence between integer type definition and 
normal type derivation.&nbsp;</DIV>

<H4 Class="centered">Extensions to Ada 95</H4>
<DIV Class="paranum">36.k/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00340.TXT">AI95-00340-01</A></I>} 
<SPAN class="insert2">{<I>extensions to Ada 95</I>} <A NAME="I1847"></A>The 
Mod attribute is new. It eases mixing of signed and unsigned values in 
an expression, which can be difficult as there may be no type which can 
contain all of the values of both of the types involved.</SPAN>&nbsp;</DIV>

<H4 Class="centered">Wording Changes from Ada 95</H4>
<DIV Class="paranum">36.l/2</DIV>
<DIV Class="Annotations">{<I><A HREF="defect1.html#8652/0003">8652/0003</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00095.TXT">AI95-00095-01</A></I>} 
<SPAN class="insert2"><B>Corrigendum:</B> Added additional permissions 
for modular types on one's complement machines.</SPAN>&nbsp;</DIV>

<HR>
<DIV Style="margin-top: 0.0em; margin-bottom: 0.6em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-3-5-3.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-3-5-5.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<DIV Style="margin-top:0.0em"><IMG SRC="AE_logo.gif" height=100 width=113 align=right ALT="Ada-Europe">
<SPAN Style="font-size: 125%">Sponsored by <SPAN Style="font-size: 125%"><A HREF="http://www.ada-europe.org/"><B>Ada-Europe</B></A></SPAN></SPAN></DIV>
</BODY>
</HTML>
