<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Static Expressions and Static Subtypes</TITLE>
    <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    H4.centered {text-align: center}
    SPAN.swiss {font-family: Arial, Helvetica, sans-serif; font-size: 92%}
    SPAN.roman {font-family: "Times New Roman", Times, serif}
    DIV.paranum {float: left; font-family: Arial, Helvetica, sans-serif; font-size: 64%; width: 2.8em; margin-left: -0.4em; margin-right: -3.0em; margin-top: 0.2em}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    SPAN.insert2 {text-decoration: underline; color: rgb(0,102,0) }
    SPAN.delete2 {text-decoration: line-through; color: rgb(0,102,0) }
    DIV.Normal {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.2em; margin-bottom: 0.6em}
    DIV.Annotations {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 6.2em; margin-bottom: 0.6em}
    DIV.Notes {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em; margin-bottom: 0.6em}
    DIV.NotesHeader {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em}
    DIV.Examples {font-family: "Courier New", monospace; font-size: 90%; line-height: 122%; margin-left: 3.4em; margin-bottom: 0.6em}
    DIV.SmallExamples {font-family: "Courier New", monospace; font-size: 72%; line-height: 122%; margin-left: 9.6em; margin-bottom: 0.6em}
    UL.Bulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.SmallBulleted {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 8.7em; margin-right: 2.5em; margin-top: 0em; margin-bottom: 0.5em}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#000080" VLINK="#330033" ALINK="#0000FF">
<DIV><B><SPAN Style="font-size:200%; color: rgb(0,51,153)">Annotated</SPAN><SPAN Style="font-size:200%; color: rgb(0,0,102)">&nbsp;Ada Reference Manual</SPAN></B> &mdash; <A HREF="AA-TTL.html"><B>Legal Information</B></A></DIV>
<DIV Style="margin-top: 0.6em; margin-bottom: 0.0em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-4-8.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-4-9-1.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<HR>
<H1>4.9 Static Expressions and Static Subtypes</H1>
<DIV Class="paranum">1</DIV>
<DIV Class="Normal">Certain expressions of a scalar or string type are 
defined to be static. Similarly, certain discrete ranges are defined 
to be static, and certain scalar and string subtypes are defined to be 
static subtypes. [<SPAN STYLE="font-size: 80%">{<I>static</I>}</SPAN> 
<A NAME="I3148"></A><I>Static</I> means determinable at compile time, 
using the declared properties or values of the program entities.] <SPAN STYLE="font-size: 80%">{<I>constant: 
See also static</I>}</SPAN> <A NAME="I3149"></A></DIV>
<DIV Class="paranum">1.a</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>As opposed to more elaborate 
data flow analysis, etc.&nbsp;</DIV>

<H4 Class="centered">Language Design Principles</H4>
<DIV Class="paranum">1.b</DIV>
<DIV Class="Annotations">For an expression to be static, it has to be 
calculable at compile time.</DIV>
<DIV Class="paranum">1.c</DIV>
<DIV Class="Annotations">Only scalar and string expressions are static.</DIV>
<DIV Class="paranum">1.d</DIV>
<DIV Class="Annotations">To be static, an expression cannot have any 
nonscalar, nonstring subexpressions (though it can have nonscalar constituent 
<SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN>s). A 
static scalar expression cannot have any nonscalar subexpressions. There 
is one exception &mdash; a membership test for a string subtype can be 
static, and the result is scalar, even though a subexpression is nonscalar.</DIV>
<DIV Class="paranum">1.e</DIV>
<DIV Class="Annotations">The rules for evaluating static expressions 
are designed to maximize portability of static calculations.&nbsp;</DIV>
<DIV Class="paranum">2</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em"><SPAN STYLE="font-size: 80%">{<I>static 
(expression)</I>}</SPAN> <A NAME="I3150"></A>A static expression is [a 
scalar or string expression that is] one of the following:</DIV>
<DIV Class="paranum">3</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>a <SPAN Class="swiss"><A HREF="AA-2-4.html#S0006">numeric_literal</A></SPAN>; 
</LI></UL>
<DIV Class="paranum">3.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>A <SPAN Class="swiss"><A HREF="AA-2-4.html#S0006">numeric_literal</A></SPAN> 
is always a static expression, even if its expected type is not that 
of a static subtype. However, if its value is explicitly converted to, 
or qualified by, a nonstatic subtype, the resulting expression is nonstatic. 
</DIV>
<DIV Class="paranum">4</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>a <SPAN Class="swiss"><A HREF="AA-2-6.html#S0016">string_literal</A></SPAN> 
of a static string subtype;&nbsp;</LI></UL>
<DIV Class="paranum">4.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>That is, the constrained 
subtype defined by the index range of the string is static. Note that 
elementary values don't generally have subtypes, while composite values 
do (since the bounds or discriminants are inherent in the value).&nbsp;</DIV>
<DIV Class="paranum">5</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>a <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
that denotes the declaration of a named number or a static constant; 
</LI></UL>
<DIV Class="paranum">5.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>Note that enumeration literals 
are covered by the <SPAN Class="swiss"><A HREF="AA-6-4.html#S0164">function_call</A></SPAN> 
case.&nbsp;</DIV>
<DIV Class="paranum">6</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>a <SPAN Class="swiss"><A HREF="AA-6-4.html#S0164">function_call</A></SPAN> 
whose <I>function_</I><SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
or <I>function_</I><SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN> 
statically denotes a static function, and whose actual parameters, if 
any (whether given explicitly or by default), are all static expressions; 
</LI></UL>
<DIV Class="paranum">6.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>This includes uses of operators 
that are equivalent to <SPAN Class="swiss"><A HREF="AA-6-4.html#S0164">function_call</A></SPAN>s. 
</DIV>
<DIV Class="paranum">7</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>an <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0100">attribute_reference</A></SPAN> 
that denotes a scalar value, and whose <SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN> 
denotes a static scalar subtype;</LI></UL>
<DIV Class="paranum">7.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>Note that this does not 
include the case of an attribute that is a function; a reference to such 
an attribute is not even an expression. See above for function <I>calls</I>.</DIV>
<DIV Class="paranum">7.b</DIV>
<DIV Class="Annotations">An implementation may define the staticness 
and other properties of implementation-defined attributes.&nbsp;</DIV>
<DIV Class="paranum">8</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>an <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0100">attribute_reference</A></SPAN> 
whose <SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN> 
statically denotes a statically constrained array object or array subtype, 
and whose <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0101">attribute_designator</A></SPAN> 
is First, Last, or Length, with an optional dimension;</LI></UL>
<DIV Class="paranum">9</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>a <SPAN Class="swiss"><A HREF="AA-4-6.html#S0127">type_conversion</A></SPAN> 
whose <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0028">subtype_mark</A></SPAN> 
denotes a static scalar subtype, and whose operand is a static expression;</LI></UL>
<DIV Class="paranum">10</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>a <SPAN Class="swiss"><A HREF="AA-4-7.html#S0128">qualified_expression</A></SPAN> 
whose <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0028">subtype_mark</A></SPAN> 
denotes a static [(scalar or string)] subtype, and whose operand is a 
static expression;&nbsp;</LI></UL>
<DIV Class="paranum">10.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>This rules out the <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0028">subtype_mark</A></SPAN>'<SPAN Class="swiss"><A HREF="AA-4-3.html#S0104">aggregate</A></SPAN> 
case.&nbsp;</DIV>
<DIV Class="paranum">10.b</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>Adding qualification to an expression 
shouldn't make it nonstatic, even for strings.&nbsp;</DIV>
<DIV Class="paranum">11</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>a membership test whose <SPAN Class="swiss"><A HREF="AA-4-4.html#S0117">simple_expression</A></SPAN> 
is a static expression, and whose <SPAN Class="swiss"><A HREF="AA-3-5.html#S0037">range</A></SPAN> 
is a static range or whose <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0028">subtype_mark</A></SPAN> 
denotes a static [(scalar or string)] subtype;&nbsp;</LI></UL>
<DIV Class="paranum">11.a</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>Clearly, we should allow membership 
tests in exactly the same cases where we allow <SPAN Class="swiss"><A HREF="AA-4-7.html#S0128">qualified_expression</A></SPAN>s. 
</DIV>
<DIV Class="paranum">12</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>a short-circuit control form both 
of whose <SPAN Class="swiss"><A HREF="AA-4-4.html#S0116">relation</A></SPAN>s 
are static expressions;</LI></UL>
<DIV Class="paranum">13</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>a static expression enclosed in parentheses. 
</LI></UL>
<DIV Class="paranum">13.a</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>{<I>static (value)</I>} <A NAME="I3151"></A>Informally, 
we talk about a <I>static value</I>. When we do, we mean a value specified 
by a static expression.&nbsp;</DIV>
<DIV Class="paranum">13.b</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>The language requires a 
static expression in a <SPAN Class="swiss"><A HREF="AA-3-3-2.html#S0034">number_declaration</A></SPAN>, 
a numeric type definition, a <SPAN Class="swiss"><A HREF="AA-3-8-1.html#S0074">discrete_choice</A></SPAN> 
(sometimes), certain representation items, an <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0101">attribute_designator</A></SPAN>, 
and when specifying the value of a discriminant governing a <SPAN Class="swiss"><A HREF="AA-3-8-1.html#S0071">variant_part</A></SPAN> 
in a <SPAN Class="swiss"><A HREF="AA-4-3-1.html#S0105">record_aggregate</A></SPAN> 
or <SPAN Class="swiss"><A HREF="AA-4-3-2.html#S0109">extension_aggregate</A></SPAN>. 
</DIV>
<DIV Class="paranum">14</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em"><SPAN STYLE="font-size: 80%">{<I>statically 
(denote)</I>}</SPAN> <A NAME="I3152"></A>A <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
<I>statically denotes</I> an entity if it denotes the entity and:&nbsp;</DIV>
<DIV Class="paranum">15</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>It is a <SPAN Class="swiss"><A HREF="AA-4-1.html#S0092">direct_name</A></SPAN>, 
expanded name, or <SPAN Class="swiss"><A HREF="AA-2-5.html#S0015">character_literal</A></SPAN>, 
and it denotes a declaration other than a <SPAN Class="swiss"><A HREF="AA-8-5.html#S0182">renaming_declaration</A></SPAN>; 
or</LI></UL>
<DIV Class="paranum">16</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>It is an <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0100">attribute_reference</A></SPAN> 
whose <SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN> 
statically denotes some entity; or</LI></UL>
<DIV Class="paranum">17</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>It denotes a <SPAN Class="swiss"><A HREF="AA-8-5.html#S0182">renaming_declaration</A></SPAN> 
with a <SPAN Class="swiss"><A HREF="AA-4-1.html#S0091">name</A></SPAN> 
that statically denotes the renamed entity.&nbsp;</LI></UL>
<DIV Class="paranum">17.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B><SPAN Class="swiss"><A HREF="AA-4-1-3.html#S0098">Selected_component</A></SPAN>s 
that are not expanded names and <SPAN Class="swiss"><A HREF="AA-4-1-1.html#S0096">indexed_component</A></SPAN>s 
do not statically denote things.&nbsp;</DIV>
<DIV Class="paranum">18</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em"><SPAN STYLE="font-size: 80%">{<I>static 
(function)</I>}</SPAN> <A NAME="I3153"></A>A <I>static function</I> is 
one of the following:&nbsp;</DIV>
<DIV Class="paranum">18.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>These are the functions 
whose calls can be static expressions.&nbsp;</DIV>
<DIV Class="paranum">19</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>a predefined operator whose parameter 
and result types are all scalar types none of which are descendants of 
formal scalar types;</LI></UL>
<DIV Class="paranum">20</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>a predefined concatenation operator 
whose result type is a string type;</LI></UL>
<DIV Class="paranum">21</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>an enumeration literal;</LI></UL>
<DIV Class="paranum">22</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>a language-defined attribute that 
is a function, if the <SPAN Class="swiss"><A HREF="AA-4-1.html#S0093">prefix</A></SPAN> 
denotes a static scalar subtype, and if the parameter and result types 
are scalar.&nbsp;</LI></UL>
<DIV Class="paranum">23</DIV>
<DIV Class="Normal">In any case, a generic formal subprogram is not a 
static function.</DIV>
<DIV Class="paranum">24</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>static (constant)</I>}</SPAN> 
<A NAME="I3154"></A>A <I>static constant</I> is a constant view declared 
by a full constant declaration or an <SPAN Class="swiss"><A HREF="AA-8-5-1.html#S0183">object_renaming_declaration</A></SPAN> 
with a static nominal subtype, having a value defined by a static scalar 
expression or by a static string expression whose value has a length 
not exceeding the maximum length of a <SPAN Class="swiss"><A HREF="AA-2-6.html#S0016">string_literal</A></SPAN> 
in the implementation.&nbsp;</DIV>
<DIV Class="paranum">24.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>A deferred constant is 
not static; the view introduced by the corresponding full constant declaration 
can be static.&nbsp;</DIV>
<DIV Class="paranum">24.b</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>The reason for restricting the 
length of static string constants is so that compilers don't have to 
store giant strings in their symbol tables. Since most string constants 
will be initialized from <SPAN Class="swiss"><A HREF="AA-2-6.html#S0016">string_literal</A></SPAN>s, 
the length limit seems pretty natural. The reason for avoiding nonstring 
types is also to save symbol table space. We're trying to keep it cheap 
and simple (from the implementer's viewpoint), while still allowing, 
for example, the link name of a pragma Import to contain a concatenation.</DIV>
<DIV Class="paranum">24.c</DIV>
<DIV Class="Annotations">The length we're talking about is the maximum 
number of characters in the value represented by a <SPAN Class="swiss"><A HREF="AA-2-6.html#S0016">string_literal</A></SPAN>, 
not the number of characters in the source representation; the quotes 
don't count.</DIV>
<DIV Class="paranum">25</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>static (range)</I>}</SPAN> 
<A NAME="I3155"></A>A <I>static range</I> is a <SPAN Class="swiss"><A HREF="AA-3-5.html#S0037">range</A></SPAN> 
whose bounds are static expressions, [or a <SPAN Class="swiss"><A HREF="AA-4-1-4.html#S0102">range_attribute_reference</A></SPAN> 
that is equivalent to such a <SPAN Class="swiss"><A HREF="AA-3-5.html#S0037">range</A></SPAN>.] 
<SPAN STYLE="font-size: 80%">{<I>static (discrete_range)</I>}</SPAN> 
<A NAME="I3156"></A>A <I>static&nbsp;</I><SPAN Class="swiss"><I><A HREF="AA-3-6-1.html#S0058">discrete_range</A></I></SPAN><I></I> 
is one that is a static range or is a <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0027">subtype_indication</A></SPAN> 
that defines a static scalar subtype. The base range of a scalar type 
is a static range, unless the type is a descendant of a formal scalar 
type.</DIV>
<DIV Class="paranum">26/2</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00263.TXT">AI95-00263-01</A></I>} 
<SPAN STYLE="font-size: 80%">{<I>static (subtype)</I>}</SPAN> <A NAME="I3157"></A>A 
<I>static subtype</I> is either a <I>static scalar subtype</I> or a <I>static 
string subtype</I>. <SPAN STYLE="font-size: 80%">{<I>static (scalar subtype)</I>}</SPAN> 
<A NAME="I3158"></A>A static scalar subtype is an unconstrained scalar 
subtype whose type is not a descendant of a formal <SPAN class="delete2">scalar 
</SPAN>type, or a constrained scalar subtype formed by imposing a compatible 
static constraint on a static scalar subtype. <SPAN STYLE="font-size: 80%">{<I>static 
(string subtype)</I>}</SPAN> <A NAME="I3159"></A>A static string subtype 
is an unconstrained string subtype whose index subtype and component 
subtype are static<SPAN class="delete2">&nbsp;(and whose type is not a descendant 
of a formal array type)</SPAN>, or a constrained string subtype formed 
by imposing a compatible static constraint on a static string subtype. 
In any case, the subtype of a generic formal object of mode <B>in out</B>, 
and the result subtype of a generic formal function, are not static. 
</DIV>
<DIV Class="paranum">26.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>String subtypes are the 
only composite subtypes that can be static.&nbsp;</DIV>
<DIV Class="paranum">26.b</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><B>Reason:&nbsp;</B>The 
part about generic formal objects of mode <B>in out</B> is necessary 
because the subtype of the formal is not required to have anything to 
do with the subtype of the actual. For example:&nbsp;</DIV>
<DIV Class="paranum">26.c</DIV>
<DIV Class="SmallExamples"><B>subtype</B>&nbsp;Int10&nbsp;<B>is</B>&nbsp;Integer&nbsp;<B>range</B>&nbsp;1..10;</DIV>
<DIV Class="paranum">26.d</DIV>
<DIV Class="SmallExamples"><B>generic</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;F&nbsp;:&nbsp;<B>in</B>&nbsp;<B>out</B>&nbsp;Int10;<BR>
<B>procedure</B>&nbsp;G;</DIV>
<DIV Class="paranum">26.e</DIV>
<DIV Class="SmallExamples"><B>procedure</B>&nbsp;G&nbsp;<B>is</B><BR>
<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>case</B>&nbsp;F&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>when</B>&nbsp;1..10&nbsp;=&gt;&nbsp;<B>null</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;Illegal!</I></SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;<B>case</B>;<BR>
<B>end</B>&nbsp;G;</DIV>
<DIV Class="paranum">26.f</DIV>
<DIV Class="SmallExamples">X&nbsp;:&nbsp;Integer&nbsp;<B>range</B>&nbsp;1..20;<BR>
<B>procedure</B>&nbsp;I&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;G(F&nbsp;=&gt;&nbsp;X);&nbsp;--<SPAN Class="roman"><I>&nbsp;OK.</I></SPAN></DIV>
<DIV Class="paranum">26.g</DIV>
<DIV Class="Annotations">The <SPAN Class="swiss"><A HREF="AA-5-4.html#S0140">case_statement</A></SPAN> 
is illegal, because the subtype of F is not static, so the choices have 
to cover all values of Integer, not just those in the range 1..10. A 
similar issue arises for generic formal functions, now that function 
calls are object names.&nbsp;</DIV>
<DIV Class="paranum">27</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em"><SPAN STYLE="font-size: 80%">{<I>static 
(constraint)</I>}</SPAN> <A NAME="I3160"></A>The different kinds of <I>static 
constraint</I> are defined as follows:&nbsp;</DIV>
<DIV Class="paranum">28</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>A null constraint is always static;</LI></UL>
<DIV Class="paranum">29</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN STYLE="font-size: 80%">{<I>static 
(range constraint)</I>}</SPAN> <A NAME="I3161"></A><SPAN STYLE="font-size: 80%">{<I>static 
(digits constraint)</I>}</SPAN> <A NAME="I3162"></A><SPAN STYLE="font-size: 80%">{<I>static 
(delta constraint)</I>}</SPAN> <A NAME="I3163"></A>A scalar constraint 
is static if it has no <SPAN Class="swiss"><A HREF="AA-3-5.html#S0036">range_constraint</A></SPAN>, 
or one with a static range;</LI></UL>
<DIV Class="paranum">30</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN STYLE="font-size: 80%">{<I>static 
(index constraint)</I>}</SPAN> <A NAME="I3164"></A>An index constraint 
is static if each <SPAN Class="swiss"><A HREF="AA-3-6-1.html#S0058">discrete_range</A></SPAN> 
is static, and each index subtype of the corresponding array type is 
static;</LI></UL>
<DIV Class="paranum">31</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN STYLE="font-size: 80%">{<I>static 
(discriminant constraint)</I>}</SPAN> <A NAME="I3165"></A>A discriminant 
constraint is static if each <SPAN Class="swiss"><A HREF="AA-4-4.html#S0115">expression</A></SPAN> 
of the constraint is static, and the subtype of each discriminant is 
static.&nbsp;</LI></UL>
<DIV Class="paranum">31.1/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00311.TXT">AI95-00311-01</A></I>} 
<SPAN class="insert2">In any case, the constraint of the first subtype 
of a scalar formal type is neither static nor null.</SPAN></DIV>
<DIV Class="paranum">32</DIV>
<DIV Class="Normal"><SPAN STYLE="font-size: 80%">{<I>statically (constrained)</I>}</SPAN> 
<A NAME="I3166"></A>A subtype is <I>statically constrained</I> if it 
is constrained, and its constraint is static. An object is <I>statically 
constrained</I> if its nominal subtype is statically constrained, or 
if it is a static string constant.&nbsp;</DIV>

<H4 Class="centered">Legality Rules</H4>
<DIV Class="paranum">33</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">A static expression 
is evaluated at compile time except when it is part of the right operand 
of a static short-circuit control form whose value is determined by its 
left operand. This evaluation is performed exactly, without performing 
Overflow_Checks. For a static expression that is evaluated:&nbsp;</DIV>
<DIV Class="paranum">34</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>The expression is illegal if its evaluation 
fails a language-defined check other than Overflow_Check.</LI></UL>
<DIV Class="paranum">35/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00269.TXT">AI95-00269-01</A></I>} 
If the expression is not part of a larger static expression<SPAN class="insert2">&nbsp;and the expression is expected to be of a single specific type</SPAN>, 
then its value shall be within the base range of its expected type. Otherwise, 
the value may be arbitrarily large or small.&nbsp;</LI></UL>
<DIV Class="paranum">35.a/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Ramification:&nbsp;</B></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00269.TXT">AI95-00269-01</A></I>} 
<SPAN class="insert2">If the expression is expected to be of a universal 
type, or of &ldquo;any integer type&rdquo;, there are no limits on the 
value of the expression.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">36/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00269.TXT">AI95-00269-01</A></I>} 
If the expression is of type <I>universal_real</I> and its expected type 
is a decimal fixed point type, then its value shall be a multiple of 
the <I>small</I> of the decimal type.<SPAN class="insert2">&nbsp;This restriction 
does not apply if the expected type is a descendant of a formal scalar 
type (or a corresponding actual type in an instance).</SPAN>&nbsp;</LI></UL>
<DIV Class="paranum">36.a</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>This means that a <SPAN Class="swiss"><A HREF="AA-2-4.html#S0006">numeric_literal</A></SPAN> 
for a decimal type cannot have &ldquo;extra&rdquo; significant digits. 
</DIV>
<DIV Class="paranum">36.b/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Reason:&nbsp;</B></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00269.TXT">AI95-00269-01</A></I>} 
<SPAN class="insert2">The small is not known for a generic formal type, 
so we have to exclude formal types from this check.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">37/2</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00269.TXT">AI95-00269-01</A></I>} 
<SPAN class="insert2"><SPAN STYLE="font-size: 80%">{<I>generic contract 
issue</I> [partial]}</SPAN> <A NAME="I3167"></A>In addition to the places 
where Legality Rules normally apply (see <A HREF="AA-12-3.html">12.3</A>), 
the above restrictions also apply in the private part of an instance 
of a generic unit.</SPAN><SPAN class="delete2">&nbsp;The last two restrictions 
above do not apply if the expected type is a descendant of a formal scalar 
type (or a corresponding actual type in an instance).</SPAN></DIV>
<DIV Class="paranum">37.a</DIV>
<DIV Class="Annotations"><B>Discussion:&nbsp;</B>Values outside the base range 
are not permitted when crossing from the &ldquo;static&rdquo; domain 
to the &ldquo;dynamic&rdquo; domain. This rule is designed to enhance 
portability of programs containing static expressions. Note that this 
rule applies to the exact value, not the value after any rounding or 
truncation. (See below for the rounding and truncation requirements.)</DIV>
<DIV Class="paranum">37.b</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em">Short-circuit 
control forms are a special case:&nbsp;</DIV>
<DIV Class="paranum">37.c</DIV>
<DIV Class="SmallExamples">N:&nbsp;<B>constant</B>&nbsp;:=&nbsp;0.0;<BR>
X:&nbsp;<B>constant</B>&nbsp;Boolean&nbsp;:=&nbsp;(N&nbsp;=&nbsp;0.0)&nbsp;<B>or</B>&nbsp;<B>else</B>&nbsp;(1.0/N&nbsp;&gt;&nbsp;0.5);&nbsp;--<SPAN Class="roman"><I>&nbsp;Static.</I></SPAN></DIV>
<DIV Class="paranum">37.d</DIV>
<DIV Class="Annotations">The declaration of X is legal, since the divide-by-zero 
part of the expression is not evaluated. X is a static constant equal 
to True.</DIV>
<DIV Class="paranum">37.e/2</DIV>
<DIV Class="Annotations"><SPAN class="delete2"><B>Ramification:&nbsp;</B></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00269.TXT">AI95-00269-01</A></I>} 
<SPAN class="delete2">There is no requirement to recheck these rules 
in an instance; the base range check will generally be performed at run 
time anyway.</SPAN>&nbsp;</DIV>

<H4 Class="centered">Implementation Requirements</H4>
<DIV Class="paranum">38/2</DIV>
<DIV Class="Normal">&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00268.TXT">AI95-00268-01</A></I>} 
{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00269.TXT">AI95-00269-01</A></I>} 
For a real static expression that is not part of a larger static expression, 
and whose expected type is not a descendant of a formal <SPAN class="delete2">scalar 
</SPAN>type, the implementation shall round or truncate the value (according 
to the Machine_Rounds attribute of the expected type) to the nearest 
machine number of the expected type; if the value is exactly half-way 
between two machine numbers, <SPAN class="insert2">the</SPAN><SPAN class="delete2">&nbsp;any</SPAN> 
rounding <SPAN class="delete2">shall be&nbsp;</SPAN>performed <SPAN class="insert2">is 
implementation-defined</SPAN><SPAN class="delete2">&nbsp;away from zero</SPAN>. 
If the expected type is a descendant of a formal <SPAN class="delete2">scalar 
</SPAN>type, <SPAN class="insert2">or if the static expression appears 
in the body of an instance of a generic unit and the corresponding expression 
is nonstatic in the corresponding generic body, then</SPAN> no special 
rounding or truncating is required &mdash; normal accuracy rules apply 
(see <A HREF="AA-G.html">Annex G</A>).&nbsp;</DIV>
<DIV Class="paranum">38.a.1/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Implementation defined: 
</B></SPAN><SPAN class="insert2">Rounding of real static expressions 
which are exactly half-way between two machine numbers.</SPAN></DIV>
<DIV Class="paranum">38.a/2</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00268.TXT">AI95-00268-01</A></I>} 
Discarding extended precision enhances portability by ensuring that the 
value of a static constant of a real type is always a machine number 
of the type. <SPAN class="delete2">Deterministic rounding of exact halves 
also enhances portability.</SPAN></DIV>
<DIV Class="paranum">38.b</DIV>
<DIV Class="Annotations">When the expected type is a descendant of a 
formal floating point type, extended precision (beyond that of the machine 
numbers) can be retained when evaluating a static expression, to ease 
code sharing for generic instantiations. For similar reasons, normal 
(nondeterministic) rounding or truncating rules apply for descendants 
of a formal fixed point type.</DIV>
<DIV Class="paranum">38.b.1/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00269.TXT">AI95-00269-01</A></I>} 
<SPAN class="insert2">There is no requirement for exact evaluation or 
special rounding in an instance body (unless the expression is static 
in the generic body). This eliminates a potential contract issue where 
the exact value of a static expression depends on the actual parameters 
(which could then affect the legality of other code).</SPAN>&nbsp;</DIV>
<DIV Class="paranum">38.c</DIV>
<DIV Class="Annotations"><B>Implementation Note:&nbsp;</B>Note that the implementation 
of static expressions has to keep track of plus and minus zero for a 
type whose Signed_Zeros attribute is True.</DIV>
<DIV Class="paranum">38.d/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00100.TXT">AI95-00100-01</A></I>} 
Note that the only <SPAN class="insert2">machine numbers</SPAN><SPAN class="delete2">&nbsp;values</SPAN> 
of a fixed point type are the multiples of the small, so a static conversion 
to a fixed-point type, or division by an integer, must do truncation 
to a multiple of small. It is not correct for the implementation to do 
all static calculations in infinite precision.</DIV>

<H4 Class="centered">Implementation Advice</H4>
<DIV Class="paranum">38.1/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00268.TXT">AI95-00268-01</A></I>} 
<SPAN class="insert2">For a real static expression that is not part of 
a larger static expression, and whose expected type is not a descendant 
of a formal type, the rounding should be the same as the default rounding 
for the target system.</SPAN>&nbsp;</DIV>
<DIV Class="paranum">38.e/2</DIV>
<DIV Class="Annotations"><SPAN class="insert2"><B>Implementation Advice: 
</B></SPAN><SPAN class="insert2">For a real static expression with a 
non-formal type that is not part of a larger static expression should 
be rounded the same as the target system.</SPAN></DIV>
<DIV Class="NotesHeader">NOTES</DIV>
<DIV Class="paranum">39</DIV>
<DIV Class="Notes">28&nbsp;&nbsp;An expression can be static even if 
it occurs in a context where staticness is not required.&nbsp;</DIV>
<DIV Class="paranum">39.a</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><B>Ramification: 
</B>For example:&nbsp;</DIV>
<DIV Class="paranum">39.b</DIV>
<DIV Class="SmallExamples">X&nbsp;:&nbsp;Float&nbsp;:=&nbsp;Float'(1.0E+400)&nbsp;+&nbsp;1.0&nbsp;-&nbsp;Float'(1.0E+400);</DIV>
<DIV Class="paranum">39.c</DIV>
<DIV Class="Annotations">The expression is static, which means that the 
value of X must be exactly 1.0, independent of the accuracy or range 
of the run-time floating point implementation.</DIV>
<DIV Class="paranum">39.d</DIV>
<DIV Class="Annotations">The following kinds of expressions are never 
static: <SPAN Class="swiss"><A HREF="AA-4-1.html#S0094">explicit_dereference</A></SPAN>, 
<SPAN Class="swiss"><A HREF="AA-4-1-1.html#S0096">indexed_component</A></SPAN>, 
<SPAN Class="swiss"><A HREF="AA-4-1-2.html#S0097">slice</A></SPAN>, <B>null</B>, 
<SPAN Class="swiss"><A HREF="AA-4-3.html#S0104">aggregate</A></SPAN>, 
<SPAN Class="swiss"><A HREF="AA-4-8.html#S0129">allocator</A></SPAN>. 
</DIV>
<DIV Class="paranum">40</DIV>
<DIV Class="Notes">29&nbsp;&nbsp;A static (or run-time) <SPAN Class="swiss"><A HREF="AA-4-6.html#S0127">type_conversion</A></SPAN> 
from a real type to an integer type performs rounding. If the operand 
value is exactly half-way between two integers, the rounding is performed 
away from zero.&nbsp;</DIV>
<DIV Class="paranum">40.a</DIV>
<DIV Class="Annotations"><B>Reason:&nbsp;</B>We specify this for portability. 
The reason for not choosing round-to-nearest-even, for example, is that 
this method is easier to undo.&nbsp;</DIV>
<DIV Class="paranum">40.b</DIV>
<DIV Class="Annotations"><B>Ramification:&nbsp;</B>The attribute Truncation 
(see <A HREF="AA-A-5-3.html">A.5.3</A>) can be used to perform a (static) 
truncation prior to conversion, to prevent rounding.&nbsp;</DIV>
<DIV Class="paranum">40.c</DIV>
<DIV Class="Annotations"><B>Implementation Note:&nbsp;</B>The value of the 
literal 0E999999999999999999999999999999999999999999999 is zero. The 
implementation must take care to evaluate such literals properly.</DIV>

<H4 Class="centered">Examples</H4>
<DIV Class="paranum">41</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em"><I>Examples of static 
expressions:</I>&nbsp;</DIV>
<DIV Class="paranum">42</DIV>
<DIV Class="Examples">1&nbsp;+&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><I>--&nbsp;2</I></SPAN><BR>
<B>abs</B>(-10)*3&nbsp;&nbsp;<SPAN Class="roman"><I>--&nbsp;30</I></SPAN></DIV>
<DIV Class="paranum">43</DIV>
<DIV Class="Examples">Kilo&nbsp;:&nbsp;<B>constant</B>&nbsp;:=&nbsp;1000;<BR>
Mega&nbsp;:&nbsp;<B>constant</B>&nbsp;:=&nbsp;Kilo*Kilo;&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><I>--&nbsp;1_000_000</I></SPAN><BR>
Long&nbsp;:&nbsp;<B>constant</B>&nbsp;:=&nbsp;Float'Digits*2;</DIV>
<DIV Class="paranum">44</DIV>
<DIV Class="Examples">Half_Pi&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;<B>constant</B>&nbsp;:=&nbsp;Pi/2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN Class="roman"><I>--&nbsp;see&nbsp;<A HREF="AA-3-3-2.html">3.3.2</A></I></SPAN><BR>
Deg_To_Rad&nbsp;:&nbsp;<B>constant</B>&nbsp;:=&nbsp;Half_Pi/90;<BR>
Rad_To_Deg&nbsp;:&nbsp;<B>constant</B>&nbsp;:=&nbsp;1.0/Deg_To_Rad;&nbsp;<SPAN Class="roman"><I>--&nbsp;equivalent&nbsp;to&nbsp;1.0/((3.14159_26536/2)/90)</I></SPAN></DIV>

<H4 Class="centered">Extensions to Ada 83</H4>
<DIV Class="paranum">44.a</DIV>
<DIV Class="Annotations">{<I>extensions to Ada 83</I>} <A NAME="I3168"></A>The 
rules for static expressions and static subtypes are generalized to allow 
more kinds of compile-time-known expressions to be used where compile-time-known 
values are required, as follows:&nbsp;</DIV>
<DIV Class="paranum">44.b</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>Membership tests and short-circuit 
control forms may appear in a static expression.</LI></UL>
<DIV Class="paranum">44.c</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>The bounds and length of statically 
constrained array objects or subtypes are static.</LI></UL>
<DIV Class="paranum">44.d</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>The Range attribute of a statically 
constrained array subtype or object gives a static range.</LI></UL>
<DIV Class="paranum">44.e</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>A <SPAN Class="swiss"><A HREF="AA-4-6.html#S0127">type_conversion</A></SPAN> 
is static if the <SPAN Class="swiss"><A HREF="AA-3-2-2.html#S0028">subtype_mark</A></SPAN> 
denotes a static scalar subtype and the operand is a static expression.</LI></UL>
<DIV Class="paranum">44.f</DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC>All numeric literals are now 
static, even if the expected type is a formal scalar type. This is useful 
in <SPAN Class="swiss"><A HREF="AA-5-4.html#S0140">case_statement</A></SPAN>s 
and <SPAN Class="swiss"><A HREF="AA-3-8-1.html#S0071">variant_part</A></SPAN>s, 
which both now allow a value of a formal scalar type to control the selection, 
to ease conversion of a package into a generic package. Similarly, named 
array aggregates are also permitted for array types with an index type 
that is a formal scalar type.&nbsp;</LI></UL>
<DIV Class="paranum">44.g</DIV>
<DIV Class="Annotations">The rules for the evaluation of static expressions 
are revised to require exact evaluation at compile time, and force a 
machine number result when crossing from the static realm to the dynamic 
realm, to enhance portability and predictability. Exact evaluation is 
not required for descendants of a formal scalar type, to simplify generic 
code sharing and to avoid generic contract model problems.</DIV>
<DIV Class="paranum">44.h</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em">Static expressions 
are legal even if an intermediate in the expression goes outside the 
base range of the type. Therefore, the following will succeed in Ada 
95, whereas it might raise an exception in Ada 83:&nbsp;</DIV>
<DIV Class="paranum">44.i</DIV>
<DIV Class="SmallExamples"><B>type</B>&nbsp;Short_Int&nbsp;<B>is</B>&nbsp;<B>range</B>&nbsp;-32_768&nbsp;..&nbsp;32_767;<BR>
I&nbsp;:&nbsp;Short_Int&nbsp;:=&nbsp;-32_768;</DIV>
<DIV Class="paranum">44.j</DIV>
<DIV Class="Annotations">This might raise an exception in Ada 83 because 
&quot;32_768&quot; is out of range, even though &quot;&ndash;32_768&quot; 
is not. In Ada 95, this will always succeed.</DIV>
<DIV Class="paranum">44.k</DIV>
<DIV Class="Annotations">Certain expressions involving string operations 
(in particular concatenation and membership tests) are considered static 
in Ada 95.</DIV>
<DIV Class="paranum">44.l</DIV>
<DIV Class="Annotations">The reason for this change is to simplify the 
rule requiring compile-time-known string expressions as the link name 
in an interfacing pragma, and to simplify the preelaborability rules. 
</DIV>

<H4 Class="centered">Incompatibilities With Ada 83</H4>
<DIV Class="paranum">44.m</DIV>
<DIV Class="Annotations">{<I>incompatibilities with Ada 83</I>} <A NAME="I3169"></A>An 
Ada 83 program that uses an out-of-range static value is illegal in Ada 
95, unless the expression is part of a larger static expression, or the 
expression is not evaluated due to being on the right-hand side of a 
short-circuit control form.&nbsp;</DIV>

<H4 Class="centered">Wording Changes from Ada 83</H4>
<DIV Class="paranum">44.n</DIV>
<DIV Class="Annotations">This clause (and <A HREF="AA-4-5-5.html">4.5.5</A>, 
&ldquo;<A HREF="AA-4-5-5.html">Multiplying Operators</A>&rdquo;) subsumes 
the RM83 section on Universal Expressions.</DIV>
<DIV Class="paranum">44.o</DIV>
<DIV Class="Annotations">The existence of static string expressions necessitated 
changing the definition of static subtype to include string subtypes. 
Most occurrences of &quot;static subtype&quot; have been changed to &quot;static 
scalar subtype&quot;, in order to preserve the effect of the Ada 83 rules. 
This has the added benefit of clarifying the difference between &quot;static 
subtype&quot; and &quot;statically constrained subtype&quot;, which has 
been a source of confusion. In cases where we allow static string subtypes, 
we explicitly use phrases like &quot;static string subtype&quot; or &quot;static 
(scalar or string) subtype&quot;, in order to clarify the meaning for 
those who have gotten used to the Ada 83 terminology.</DIV>
<DIV Class="paranum">44.p</DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em">In Ada 83, an 
expression was considered nonstatic if it raised an exception. Thus, 
for example:&nbsp;</DIV>
<DIV Class="paranum">44.q</DIV>
<DIV Class="SmallExamples">Bad:&nbsp;<B>constant</B>&nbsp;:=&nbsp;1/0;&nbsp;--<SPAN Class="roman"><I>&nbsp;Illegal!</I></SPAN></DIV>
<DIV Class="paranum">44.r</DIV>
<DIV Class="Annotations">was illegal because 1/0 was not static. In Ada 
95, the above example is still illegal, but for a different reason: 1/0 
is static, but there's a separate rule forbidding the exception raising.</DIV>

<H4 Class="centered">Inconsistencies With Ada 95</H4>
<DIV Class="paranum">44.s/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00268.TXT">AI95-00268-01</A></I>} 
<SPAN class="insert2">{<I>inconsistencies with Ada 95</I>} <A NAME="I3170"></A><B>Amendment 
Correction:</B> Rounding of static real expressions is implementation-defined 
in Ada 2005, while it was specified as away from zero in (original) Ada 
95. This could make subtle differences in programs. However, the original 
Ada 95 rule required rounding that (probably) differed from the target 
processor, thus creating anomalies where the value of a static expression 
was required to be different than the same expression evaluated at run-time.</SPAN> 
</DIV>

<H4 Class="centered">Wording Changes from Ada 95</H4>
<DIV Class="paranum">44.t/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00263.TXT">AI95-00263-01</A></I>} 
<SPAN class="insert2"></SPAN>{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00268.TXT">AI95-00268-01</A></I>} 
<SPAN class="insert2">The Ada 95 wording that defined static subtypes 
unintentionally failed to exclude formal derived types that happen to 
be scalar (these aren't formal scalar types); and had a parenthetical 
remark excluding formal string types - but that was neither necessary 
nor parenthetical (it didn't follow from other wording). This issue also 
applies to the rounding rules for real static expressions.</SPAN></DIV>
<DIV Class="paranum">44.u/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00269.TXT">AI95-00269-01</A></I>} 
<SPAN class="insert2">Ada 95 didn't clearly define the bounds of a value 
of a static expression for universal types and for &quot;any integer/float/fixed 
type&quot;. We also make it clear that we do not intend exact evaluation 
of static expressions in an instance body if the expressions aren't static 
in the generic body.</SPAN></DIV>
<DIV Class="paranum">44.v/2</DIV>
<DIV Class="Annotations">{<I><A HREF="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00311.TXT">AI95-00311-01</A></I>} 
<SPAN class="insert2">We clarify that the first subtype of a scalar formal 
type has a nonstatic, non-null constraint.</SPAN>&nbsp;</DIV>

<HR>
<DIV Style="margin-top: 0.0em; margin-bottom: 0.6em"><A HREF="AA-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-4-8.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="AA-4-9-1.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<DIV Style="margin-top:0.0em"><IMG SRC="AE_logo.gif" height=100 width=113 align=right ALT="Ada-Europe">
<SPAN Style="font-size: 125%">Sponsored by <SPAN Style="font-size: 125%"><A HREF="http://www.ada-europe.org/"><B>Ada-Europe</B></A></SPAN></SPAN></DIV>
</BODY>
</HTML>
