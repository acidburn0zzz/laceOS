<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Derived Types and Classes</TITLE>
    <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    H4.centered {text-align: center}
    SPAN.swiss {font-family: Arial, Helvetica, sans-serif; font-size: 92%}
    SPAN.roman {font-family: "Times New Roman", Times, serif}
    DIV.paranum {float: left; font-family: Arial, Helvetica, sans-serif; font-size: 64%; width: 2.8em; margin-left: -0.4em; margin-right: -3.0em; margin-top: 0.2em}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    DIV.Normal {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 1.2em; margin-bottom: 0.6em}
    DIV.Notes {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em; margin-bottom: 0.6em}
    DIV.NotesHeader {font-family: "Times New Roman", Times, serif; font-size: 80%; line-height: 122%; margin-left: 3.7em}
    DIV.SyntaxIndented {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-bottom: 0.4em}
    DIV.Examples {font-family: "Courier New", monospace; font-size: 90%; line-height: 122%; margin-left: 3.4em; margin-bottom: 0.6em}
    UL.Bulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 3.2em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.NestedBulleted {font-family: "Times New Roman", Times, serif; line-height: 122%; margin-left: 5.2em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#000080" VLINK="#330033" ALINK="#0000FF">
<DIV><SPAN Style="font-size:200%; color: rgb(0,0,153)"><B>Ada Reference Manual</B></SPAN> &mdash; <A HREF="RM-TTL.html"><B>Legal Information</B></A></DIV>
<DIV Style="margin-top: 0.6em; margin-bottom: 0.0em"><A HREF="RM-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RM-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RM-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RM-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RM-3-3-2.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RM-3-4-1.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<HR>
<H1>3.4 Derived Types and Classes</H1>
<DIV Class="paranum">1/2</DIV>
<DIV Class="Normal"><A NAME="I1481"></A>A <SPAN Class="swiss"><A HREF="RM-3-4.html#S0035">derived_type_definition</A></SPAN> 
defines a <I>derived type</I> (and its first subtype) whose characteristics 
are <I>derived</I> from those of a parent type, and possibly from progenitor 
types. <A NAME="I1482"></A></DIV>
<DIV Class="paranum">1.1/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;<A NAME="I1483"></A><A NAME="I1484"></A>A <I>class 
of types</I> is a set of types that is closed under derivation; that 
is, if the parent or a progenitor type of a derived type belongs to a 
class, then so does the derived type. By saying that a particular group 
of types forms a class, we are saying that all derivatives of a type 
in the set inherit the characteristics that define that set. The more 
general term <I>category of types</I> is used for a set of types whose 
defining characteristics are not necessarily inherited by derivatives; 
for example, limited, abstract, and interface are all categories of types, 
but not classes of types.</DIV>

<H4 Class="centered">Syntax</H4>
<DIV Class="paranum">2/2</DIV>
<DIV Class="SyntaxIndented"><SPAN Class="swiss">derived_type_definition</SPAN><A NAME="I1485"></A><A NAME="S0035"></A><SPAN Class="swiss">&nbsp;::=&nbsp;</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;[<B>abstract</B>]&nbsp;[<B>limited</B>]&nbsp;<B>new</B>&nbsp;<I>parent_</I><A NAME="I1486"></A><SPAN Class="swiss"><A HREF="RM-3-2-2.html#S0027">subtype_indication</A></SPAN>&nbsp;[[<B>and</B>&nbsp;<A NAME="I1487"></A><SPAN Class="swiss"><A HREF="RM-3-9-4.html#S0078">interface_list</A></SPAN>]&nbsp;<A NAME="I1488"></A><SPAN Class="swiss"><A HREF="RM-3-9-1.html#S0075">record_extension_part</A></SPAN>]</DIV>

<H4 Class="centered">Legality Rules</H4>
<DIV Class="paranum">3/2</DIV>
<DIV Class="Normal"><A NAME="I1489"></A><A NAME="I1490"></A>The <I>parent_</I><SPAN Class="swiss"><A HREF="RM-3-2-2.html#S0027">subtype_indication</A></SPAN> 
defines the <I>parent subtype</I>; its type is the <I>parent type</I>. 
The <SPAN Class="swiss"><A HREF="RM-3-9-4.html#S0078">interface_list</A></SPAN> 
defines the progenitor types (see <A HREF="RM-3-9-4.html">3.9.4</A>). 
A derived type has one parent type and zero or more progenitor types.</DIV>
<DIV Class="paranum">4</DIV>
<DIV Class="Normal">A type shall be completely defined (see <A HREF="RM-3-11-1.html">3.11.1</A>) 
prior to being specified as the parent type in a <SPAN Class="swiss"><A HREF="RM-3-4.html#S0035">derived_type_definition</A></SPAN> 
&mdash; the <SPAN Class="swiss"><A HREF="RM-3-2-1.html#S0024">full_type_declaration</A></SPAN>s 
for the parent type and any of its subcomponents have to precede the 
<SPAN Class="swiss"><A HREF="RM-3-4.html#S0035">derived_type_definition</A></SPAN>. 
</DIV>
<DIV Class="paranum">5/2</DIV>
<DIV Class="Normal"><A NAME="I1491"></A>If there is a <SPAN Class="swiss"><A HREF="RM-3-9-1.html#S0075">record_extension_part</A></SPAN>, 
the derived type is called a <I>record extension</I> of the parent type. 
A <SPAN Class="swiss"><A HREF="RM-3-9-1.html#S0075">record_extension_part</A></SPAN> 
shall be provided if and only if the parent type is a tagged type. An 
<SPAN Class="swiss"><A HREF="RM-3-9-4.html#S0078">interface_list</A></SPAN> 
shall be provided only if the parent type is a tagged type.&nbsp;</DIV>
<DIV Class="paranum">5.1/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;If the reserved word <B>limited</B> appears in 
a <SPAN Class="swiss"><A HREF="RM-3-4.html#S0035">derived_type_definition</A></SPAN>, 
the parent type shall be a limited type.&nbsp;</DIV>

<H4 Class="centered">Static Semantics</H4>
<DIV Class="paranum">6</DIV>
<DIV Class="Normal"><A NAME="I1492"></A><A NAME="I1493"></A>The first 
subtype of the derived type is unconstrained if a <SPAN Class="swiss"><A HREF="RM-3-7.html#S0061">known_discriminant_part</A></SPAN> 
is provided in the declaration of the derived type, or if the parent 
subtype is unconstrained. <A NAME="I1494"></A>Otherwise, the constraint 
of the first subtype <I>corresponds</I> to that of the parent subtype 
in the following sense: it is the same as that of the parent subtype 
except that for a range constraint (implicit or explicit), the value 
of each bound of its range is replaced by the corresponding value of 
the derived type.&nbsp;</DIV>
<DIV Class="paranum">6.1/2</DIV>
<DIV Class="Normal">&nbsp;&nbsp;The first subtype of the derived type excludes 
null (see <A HREF="RM-3-10.html">3.10</A>) if and only if the parent 
subtype excludes null.</DIV>
<DIV Class="paranum">7</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">The characteristics 
of the derived type are defined as follows:&nbsp;</DIV>
<DIV Class="paranum">8/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>If the parent type or a progenitor 
type belongs to a class of types, then the derived type also belongs 
to that class. The following sets of types, as well as any higher-level 
sets composed from them, are classes in this sense, and hence the characteristics 
defining these classes are inherited by derived types from their parent 
or progenitor types: signed integer, modular integer, ordinary fixed, 
decimal fixed, floating point, enumeration, boolean, character, access-to-constant, 
general access-to-variable, pool-specific access-to-variable, access-to-subprogram, 
array, string, non-array composite, nonlimited, untagged record, tagged, 
task, protected, and synchronized tagged.&nbsp;</LI></UL>
<DIV Class="paranum">9</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>If the parent type is an elementary 
type or an array type, then the set of possible values of the derived 
type is a copy of the set of possible values of the parent type. For 
a scalar type, the base range of the derived type is the same as that 
of the parent type.&nbsp;</LI></UL>
<DIV Class="paranum">10</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>If the parent type is a composite 
type other than an array type, then the components, protected subprograms, 
and entries that are declared for the derived type are as follows:&nbsp;</LI></UL>
<DIV Class="paranum">11</DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>The discriminants specified 
by a new <SPAN Class="swiss"><A HREF="RM-3-7.html#S0061">known_discriminant_part</A></SPAN>, 
if there is one; otherwise, each discriminant of the parent type (implicitly 
declared in the same order with the same specifications) &mdash; <A NAME="I1495"></A><A NAME="I1496"></A>in 
the latter case, the discriminants are said to be <I>inherited</I>, or 
if unknown in the parent, are also unknown in the derived type;</LI></UL>
<DIV Class="paranum">12</DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>Each nondiscriminant component, 
entry, and protected subprogram of the parent type, implicitly declared 
in the same order with the same declarations; <A NAME="I1497"></A><A NAME="I1498"></A><A NAME="I1499"></A>these 
components, entries, and protected subprograms are said to be <I>inherited</I>; 
</LI></UL>
<DIV Class="paranum">13</DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>Each component declared in a 
<SPAN Class="swiss"><A HREF="RM-3-9-1.html#S0075">record_extension_part</A></SPAN>, 
if any.&nbsp;</LI></UL>
<DIV Class="paranum">14</DIV>
<UL Class="Bulleted">Declarations of components, protected subprograms, 
and entries, whether implicit or explicit, occur immediately within the 
declarative region of the type, in the order indicated above, following 
the parent <SPAN Class="swiss"><A HREF="RM-3-2-2.html#S0027">subtype_indication</A></SPAN>. 
</UL>
<DIV Class="paranum">15/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><SPAN STYLE="font-size: 80%"><I>This 
paragraph was deleted.</I></SPAN></LI></UL>
<DIV Class="paranum">16</DIV>
<UL Class="Bulleted"><LI TYPE=DISC>For each predefined operator of the 
parent type, there is a corresponding predefined operator of the derived 
type.&nbsp;</LI></UL>
<DIV Class="paranum">17/2</DIV>
<UL Class="Bulleted"><LI TYPE=DISC><A NAME="I1500"></A>For each user-defined 
primitive subprogram (other than a user-defined equality operator &mdash; 
see below) of the parent type or of a progenitor type that already exists 
at the place of the <SPAN Class="swiss"><A HREF="RM-3-4.html#S0035">derived_type_definition</A></SPAN>, 
there exists a corresponding <I>inherited</I> primitive subprogram of 
the derived type with the same defining name. <A NAME="I1501"></A>Primitive 
user-defined equality operators of the parent type and any progenitor 
types are also inherited by the derived type, except when the derived 
type is a nonlimited record extension, and the inherited operator would 
have a profile that is type conformant with the profile of the corresponding 
predefined equality operator; in this case, the user-defined equality 
operator is not inherited, but is rather incorporated into the implementation 
of the predefined equality operator of the record extension (see <A HREF="RM-4-5-2.html">4.5.2</A>). 
<A NAME="I1502"></A></LI></UL>
<DIV Class="paranum">18/2</DIV>
<UL Class="Bulleted">The profile of an inherited subprogram (including 
an inherited enumeration literal) is obtained from the profile of the 
corresponding (user-defined) primitive subprogram of the parent or progenitor 
type, after systematic replacement of each subtype of its profile (see 
<A HREF="RM-6-1.html">6.1</A>) that is of the parent or progenitor type 
with a <I>corresponding subtype</I> of the derived type. <A NAME="I1503"></A>For 
a given subtype of the parent or progenitor type, the corresponding subtype 
of the derived type is defined as follows:&nbsp;</UL>
<DIV Class="paranum">19</DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>If the declaration of the derived 
type has neither a <SPAN Class="swiss"><A HREF="RM-3-7.html#S0061">known_discriminant_part</A></SPAN> 
nor a <SPAN Class="swiss"><A HREF="RM-3-9-1.html#S0075">record_extension_part</A></SPAN>, 
then the corresponding subtype has a constraint that corresponds (as 
defined above for the first subtype of the derived type) to that of the 
given subtype.</LI></UL>
<DIV Class="paranum">20</DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>If the derived type is a record 
extension, then the corresponding subtype is the first subtype of the 
derived type.</LI></UL>
<DIV Class="paranum">21</DIV>
<UL Class="NestedBulleted"><LI TYPE=DISC>If the derived type has a new 
<SPAN Class="swiss"><A HREF="RM-3-7.html#S0061">known_discriminant_part</A></SPAN> 
but is not a record extension, then the corresponding subtype is constrained 
to those values that when converted to the parent type belong to the 
given subtype (see <A HREF="RM-4-6.html">4.6</A>). <A NAME="I1504"></A></LI></UL>
<DIV Class="paranum">22/2</DIV>
<UL Class="Bulleted">The same formal parameters have <SPAN Class="swiss"><A HREF="RM-3-7.html#S0063">default_expression</A></SPAN>s 
in the profile of the inherited subprogram. Any type mismatch due to 
the systematic replacement of the parent or progenitor type by the derived 
type is handled as part of the normal type conversion associated with 
parameter passing &mdash; see <A HREF="RM-6-4-1.html">6.4.1</A>.&nbsp;</UL>
<DIV Class="paranum">23/2</DIV>
<DIV Class="Normal">&nbsp;If a primitive subprogram of the parent or progenitor 
type is visible at the place of the <SPAN Class="swiss"><A HREF="RM-3-4.html#S0035">derived_type_definition</A></SPAN>, 
then the corresponding inherited subprogram is implicitly declared immediately 
after the <SPAN Class="swiss"><A HREF="RM-3-4.html#S0035">derived_type_definition</A></SPAN>. 
Otherwise, the inherited subprogram is implicitly declared later or not 
at all, as explained in <A HREF="RM-7-3-1.html">7.3.1</A>.</DIV>
<DIV Class="paranum">24</DIV>
<DIV Class="Normal"><A NAME="I1505"></A>A derived type can also be defined 
by a <SPAN Class="swiss"><A HREF="RM-7-3.html#S0177">private_extension_declaration</A></SPAN> 
(see <A HREF="RM-7-3.html">7.3</A>) or a <SPAN Class="swiss"><A HREF="RM-12-5-1.html#S0265">formal_derived_type_definition</A></SPAN> 
(see <A HREF="RM-12-5-1.html">12.5.1</A>). Such a derived type is a partial 
view of the corresponding full or actual type.</DIV>
<DIV Class="paranum">25</DIV>
<DIV Class="Normal">All numeric types are derived types, in that they 
are implicitly derived from a corresponding root numeric type (see <A HREF="RM-3-5-4.html">3.5.4</A> 
and <A HREF="RM-3-5-6.html">3.5.6</A>).</DIV>

<H4 Class="centered">Dynamic Semantics</H4>
<DIV Class="paranum">26</DIV>
<DIV Class="Normal"><A NAME="I1506"></A>The elaboration of a <SPAN Class="swiss"><A HREF="RM-3-4.html#S0035">derived_type_definition</A></SPAN> 
creates the derived type and its first subtype, and consists of the elaboration 
of the <SPAN Class="swiss"><A HREF="RM-3-2-2.html#S0027">subtype_indication</A></SPAN> 
and the <SPAN Class="swiss"><A HREF="RM-3-9-1.html#S0075">record_extension_part</A></SPAN>, 
if any. If the <SPAN Class="swiss"><A HREF="RM-3-2-2.html#S0027">subtype_indication</A></SPAN> 
depends on a discriminant, then only those expressions that do not depend 
on a discriminant are evaluated.&nbsp;</DIV>
<DIV Class="paranum">27/2</DIV>
<DIV Class="Normal">&nbsp;<A NAME="I1507"></A>For the execution of a call 
on an inherited subprogram, a call on the corresponding primitive subprogram 
of the parent or progenitor type is performed; the normal conversion 
of each actual parameter to the subtype of the corresponding formal parameter 
(see <A HREF="RM-6-4-1.html">6.4.1</A>) performs any necessary type conversion 
as well. If the result type of the inherited subprogram is the derived 
type, the result of calling the subprogram of the parent or progenitor 
is converted to the derived type, or in the case of a null extension, 
extended to the derived type using the equivalent of an <SPAN Class="swiss"><A HREF="RM-4-3-2.html#S0109">extension_aggregate</A></SPAN> 
with the original result as the <SPAN Class="swiss"><A HREF="RM-4-3-2.html#S0110">ancestor_part</A></SPAN> 
and <B>null record</B> as the <SPAN Class="swiss"><A HREF="RM-4-3-1.html#S0106">record_component_association_list</A></SPAN>. 
<A NAME="I1508"></A></DIV>
<DIV Class="NotesHeader">NOTES</DIV>
<DIV Class="paranum">28</DIV>
<DIV Class="Notes">10&nbsp;&nbsp;<A NAME="I1509"></A>Classes are closed 
under derivation &mdash; any class that contains a type also contains 
its derivatives. Operations available for a given class of types are 
available for the derived types in that class.</DIV>
<DIV Class="paranum">29</DIV>
<DIV Class="Notes">11&nbsp;&nbsp;Evaluating an inherited enumeration 
literal is equivalent to evaluating the corresponding enumeration literal 
of the parent type, and then converting the result to the derived type. 
This follows from their equivalence to parameterless functions. <A NAME="I1510"></A></DIV>
<DIV Class="paranum">30</DIV>
<DIV Class="Notes">12&nbsp;&nbsp;A generic subprogram is not a subprogram, 
and hence cannot be a primitive subprogram and cannot be inherited by 
a derived type. On the other hand, an instance of a generic subprogram 
can be a primitive subprogram, and hence can be inherited.</DIV>
<DIV Class="paranum">31</DIV>
<DIV Class="Notes">13&nbsp;&nbsp;If the parent type is an access type, 
then the parent and the derived type share the same storage pool; there 
is a <B>null</B> access value for the derived type and it is the implicit 
initial value for the type. See <A HREF="RM-3-10.html">3.10</A>.</DIV>
<DIV Class="paranum">32</DIV>
<DIV Class="Notes">14&nbsp;&nbsp;If the parent type is a boolean type, 
the predefined relational operators of the derived type deliver a result 
of the predefined type Boolean (see <A HREF="RM-4-5-2.html">4.5.2</A>). 
If the parent type is an integer type, the right operand of the predefined 
exponentiation operator is of the predefined type Integer (see <A HREF="RM-4-5-6.html">4.5.6</A>).</DIV>
<DIV Class="paranum">33</DIV>
<DIV Class="Notes">15&nbsp;&nbsp;Any discriminants of the parent type 
are either all inherited, or completely replaced with a new set of discriminants.</DIV>
<DIV Class="paranum">34</DIV>
<DIV Class="Notes">16&nbsp;&nbsp;For an inherited subprogram, the subtype 
of a formal parameter of the derived type need not have any value in 
common with the first subtype of the derived type.&nbsp;</DIV>
<DIV Class="paranum">35</DIV>
<DIV Class="Notes">17&nbsp;&nbsp;If the reserved word <B>abstract</B> 
is given in the declaration of a type, the type is abstract (see <A HREF="RM-3-9-3.html">3.9.3</A>).</DIV>
<DIV Class="paranum">35.1/2</DIV>
<DIV Class="Notes">18&nbsp;&nbsp;An interface type that has a progenitor 
type &ldquo;is derived from&rdquo; that type. A <SPAN Class="swiss"><A HREF="RM-3-4.html#S0035">derived_type_definition</A></SPAN>, 
however, never defines an interface type.</DIV>
<DIV Class="paranum">35.2/2</DIV>
<DIV Class="Notes">19&nbsp;&nbsp;It is illegal for the parent type of 
a <SPAN Class="swiss"><A HREF="RM-3-4.html#S0035">derived_type_definition</A></SPAN> 
to be a synchronized tagged type.&nbsp;</DIV>

<H4 Class="centered">Examples</H4>
<DIV Class="paranum">36</DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em"><I>Examples of derived 
type declarations:</I>&nbsp;</DIV>
<DIV Class="paranum">37</DIV>
<DIV Class="Examples"><B>type</B>&nbsp;Local_Coordinate&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Coordinate;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;&nbsp;two&nbsp;different&nbsp;types</I></SPAN><BR>
<B>type</B>&nbsp;Midweek&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Day&nbsp;<B>range</B>&nbsp;Tue&nbsp;..&nbsp;Thu;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;&nbsp;see&nbsp;<A HREF="RM-3-5-1.html">3.5.1</A></I></SPAN><BR>
<B>type</B>&nbsp;Counter&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Positive;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;&nbsp;same&nbsp;range&nbsp;as&nbsp;Positive&nbsp;</I></SPAN></DIV>
<DIV Class="paranum">38</DIV>
<DIV Class="Examples"><B>type</B>&nbsp;Special_Key&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Key_Manager.Key;&nbsp;&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;&nbsp;see&nbsp;<A HREF="RM-7-3-1.html">7.3.1</A></I></SPAN><BR>
&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;the&nbsp;inherited&nbsp;subprograms&nbsp;have&nbsp;the&nbsp;following&nbsp;specifications:&nbsp;</I></SPAN><BR>
&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;Get_Key(K&nbsp;:&nbsp;out&nbsp;Special_Key);</I></SPAN><BR>
&nbsp;&nbsp;--<SPAN Class="roman"><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;&quot;&lt;&quot;(X,Y&nbsp;:&nbsp;Special_Key)&nbsp;return&nbsp;Boolean;</I></SPAN></DIV>

<HR>
<DIV Style="margin-top: 0.0em; margin-bottom: 0.6em"><A HREF="RM-TOC.html"><IMG SRC="cont.gif" ALT="Contents" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RM-0-5.html"><IMG SRC="index.gif" ALT="Index" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RM-STDS.html"><IMG SRC="lib.gif" ALT="References" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RM-SRCH.html"><IMG SRC="find.gif" ALT="Search" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RM-3-3-2.html"><IMG SRC="prev.gif" ALT="Previous" BORDER=0></A>&nbsp;
&nbsp;<A HREF="RM-3-4-1.html"><IMG SRC="next.gif" ALT="Next" BORDER=0></A>&nbsp;
</DIV>
<DIV Style="margin-top:0.0em"><IMG SRC="AE_logo.gif" height=100 width=113 align=right ALT="Ada-Europe">
<SPAN Style="vertical-align: middle">Sponsored by <SPAN Style="font-size: 125%"><A HREF="http://www.ada-europe.org/"><B>Ada-Europe</B></A></SPAN></SPAN></DIV>
</BODY>
</HTML>
