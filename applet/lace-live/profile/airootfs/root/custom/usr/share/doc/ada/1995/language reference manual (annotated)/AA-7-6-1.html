<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Completion and Finalization</TITLE>
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    DIV.paranum {position: absolute; font-family: Arial, Helvetica, sans-serif; left: 0.5em; top: auto}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    DIV.Normal {font-family: "Times New Roman", Times, serif; margin-bottom: 0.6em}
    DIV.Wide {font-family: "Times New Roman", Times, serif; margin-top: 0.6em; margin-bottom: 0.6em}
    DIV.Annotations {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-bottom: 0.6em}
    DIV.WideAnnotations {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-top: 0.6em; margin-bottom: 0.6em}
    DIV.Index {font-family: "Times New Roman", Times, serif}
    DIV.SyntaxSummary {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-bottom: 0.4em}
    DIV.Notes {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-bottom: 0.6em}
    DIV.NotesHeader {font-family: "Times New Roman", Times, serif; margin-left: 2.0em}
    DIV.SyntaxIndented {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-bottom: 0.4em}
    DIV.Indented {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-bottom: 0.6em}
    DIV.CodeIndented {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-bottom: 0.6em}
    DIV.SmallIndented {font-family: "Times New Roman", Times, serif; margin-left:  10.0em; margin-bottom: 0.6em}
    DIV.SmallCodeIndented {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-bottom: 0.6em}
    DIV.Examples {font-family: "Courier New", monospace; margin-left: 2.0em; margin-bottom: 0.6em}
    DIV.SmallExamples {font-family: "Courier New", monospace; font-size: 80%; margin-left: 7.5em; margin-bottom: 0.6em}
    DIV.IndentedExamples {font-family: "Courier New", monospace; margin-left: 8.0em; margin-bottom: 0.6em}
    DIV.SmallIndentedExamples {font-family: "Courier New", monospace; font-size: 80%; margin-left:  15.0em; margin-bottom: 0.6em}
    UL.Bulleted {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.SmallBulleted {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.NestedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-right: 4.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.SmallNestedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-right: 8.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.IndentedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-right: 8.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.CodeIndentedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.CodeIndentedNestedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-right: 8.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.SyntaxIndentedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-right: 4.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.NotesBulleted {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-right: 4.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.NotesNestedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    DL.Hanging {font-family: "Times New Roman", Times, serif; margin-top: 0em; margin-bottom: 0.6em}
    DD.Hanging {margin-left: 6.0em}
    DL.IndentedHanging {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-top: 0em; margin-bottom: 0.6em}
    DD.IndentedHanging {margin-left: 2.0em}
    DL.HangingInBulleted {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    DD.HangingInBulleted {margin-left: 4.0em}
    DL.SmallHanging {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-top: 0em; margin-bottom: 0.6em}
    DD.SmallHanging {margin-left: 7.5em}
    DL.SmallIndentedHanging {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-top: 0em; margin-bottom: 0.6em}
    DD.SmallIndentedHanging {margin-left: 2.0em}
    DL.SmallHangingInBulleted {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    DD.SmallHangingInBulleted {margin-left: 5.0em}
    DL.Enumerated {font-family: "Times New Roman", Times, serif; margin-right: 0.0em; margin-top: 0em; margin-bottom: 0.5em}
    DD.Enumerated {margin-left: 2.0em}
    DL.SmallEnumerated {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-right: 4.0em; margin-top: 0em; margin-bottom: 0.5em}
    DD.SmallEnumerated {margin-left: 2.5em}
    DL.NestedEnumerated {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    DL.SmallNestedEnumerated {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">
<P><A HREF="AA-TOC.html">Contents</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-0-29.html">Index</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-SRCH.html">Search</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-7-6.html">Previous</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-8.html">Next</A></P>
<HR>
<H1> 7.6.1 Completion and Finalization</H1>
<DIV Class="Paranum"><FONT SIZE=-2>1</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;[This subclause defines <I>completion</I> and
<I>leaving</I> of the execution of constructs and entities. A <I>master</I>
is the execution of a construct that includes finalization of local objects
after it is complete (and after waiting for any local tasks -- see <A HREF="AA-9-3.html">9.3</A>),
but before leaving. Other constructs and entities are left immediately
upon completion. <FONT SIZE="-1">{<I>cleanup: See finalization</I>}</FONT>
<A NAME="I3298"></A><FONT SIZE="-1">{<I>destructor: See finalization</I>}</FONT>
<A NAME="I3299"></A>]</DIV>

<H4 ALIGN=CENTER>Dynamic Semantics</H4>
<DIV Class="Paranum"><FONT SIZE=-2>2</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>completion and leaving (completed
and left)</I>}</FONT> <A NAME="I3300"></A><FONT SIZE="-1">{<I>completion
(run-time concept)</I>}</FONT> <A NAME="I3301"></A>The execution of a
construct or entity is <I>complete</I> when the end of that execution
has been reached, or when a transfer of control (see <A HREF="AA-5-1.html">5.1</A>)
causes it to be abandoned. <FONT SIZE="-1">{<I>normal completion</I>}</FONT>
<A NAME="I3302"></A><FONT SIZE="-1">{<I>completion (normal)</I>}</FONT>
<A NAME="I3303"></A><FONT SIZE="-1">{<I>abnormal completion</I>}</FONT>
<A NAME="I3304"></A><FONT SIZE="-1">{<I>completion (abnormal)</I>}</FONT>
<A NAME="I3305"></A>Completion due to reaching the end of execution,
or due to the transfer of control of an <FONT FACE="Arial, Helvetica">exit_</FONT>,
<FONT FACE="Arial, Helvetica">return_</FONT>, <FONT FACE="Arial, Helvetica">goto_</FONT>,
or <FONT FACE="Arial, Helvetica">requeue_statement</FONT> or of the selection
of a <FONT FACE="Arial, Helvetica">terminate_alternative</FONT> is <I>normal
completion</I>. Completion is <I>abnormal</I> otherwise [-- when control
is transferred out of a construct due to abort or the raising of an exception].
</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>2.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Discussion: </B>Don't confuse
the run-time concept of completion with the compile-time concept of completion
defined in <A HREF="AA-3-11-1.html">3.11.1</A>. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>3</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>leaving</I>}</FONT> <A NAME="I3306"></A><FONT SIZE="-1">{<I>left</I>}</FONT>
<A NAME="I3307"></A>After execution of a construct or entity is complete,
it is <I>left</I>, meaning that execution continues with the next action,
as defined for the execution that is taking place. <FONT SIZE="-1">{<I>master</I>}</FONT>
<A NAME="I3308"></A>Leaving an execution happens immediately after its
completion, except in the case of a <I>master</I>: the execution of a
<FONT FACE="Arial, Helvetica">task_body</FONT>, a <FONT FACE="Arial, Helvetica">block_statement</FONT>,
a <FONT FACE="Arial, Helvetica">subprogram_body</FONT>, an <FONT FACE="Arial, Helvetica">entry_body</FONT>,
or an <FONT FACE="Arial, Helvetica">accept_statement</FONT>. A master
is finalized after it is complete, and before it is left.</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>3.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Reason: </B>Note that although
an <FONT FACE="Arial, Helvetica">accept_statement</FONT> has no <FONT FACE="Arial, Helvetica">declarative_part</FONT>,
it can call functions and evaluate <FONT FACE="Arial, Helvetica">aggregate</FONT>s,
possibly causing anonymous controlled objects to be created, and we don't
want those objects to escape outside the rendezvous. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>4</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>finalization (of a master)</I>}</FONT>
<A NAME="I3309"></A>For the <I>finalization</I> of a master, dependent
tasks are first awaited, as explained in <A HREF="AA-9-3.html">9.3</A>.
Then each object whose accessibility level is the same as that of the
master is finalized if the object was successfully initialized and still
exists. [These actions are performed whether the master is left by reaching
the last statement or via a transfer of control.] When a transfer of
control causes completion of an execution, each included master is finalized
in order, from innermost outward. </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>4.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>As explained
in <A HREF="AA-3-10-2.html">3.10.2</A>, the set of objects with the same
accessibility level as that of the master includes objects declared immediately
within the master, objects declared in nested packages, objects created
by <FONT FACE="Arial, Helvetica">allocator</FONT>s (if the ultimate ancestor
access type is declared in one of those places) and subcomponents of
all of these things. If an object was already finalized by Unchecked_Deallocation,
then it is not finalized again when the master is left.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>4.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">Note that any object whose accessibility
level is deeper than that of the master would no longer exist; those
objects would have been finalized by some inner master. Thus, after leaving
a master, the only objects yet to be finalized are those whose accessibility
level is less deep than that of the master.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>4.c</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>To be honest: </B>Subcomponents
of objects due to be finalized are not finalized by the finalization
of the master; they are finalized by the finalization of the containing
object. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>4.d</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Reason: </B>We need to finalize
subcomponents of objects even if the containing object is not going to
get finalized because it was not fully initialized. But if the containing
object is finalized, we don't want to require repeated finalization of
the subcomponents, as might normally be implied by the recursion in finalization
of a master and the recursion in finalization of an object. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>4.e</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>To be honest: </B>Formally,
completion and leaving refer to executions of constructs or entities.
However, the standard sometimes (informally) refers to the constructs
or entities whose executions are being completed. Thus, for example,
``the <FONT FACE="Arial, Helvetica">subprogram_call</FONT> or task is
complete'' really means ``<I>the execution of</I> the <FONT FACE="Arial, Helvetica">subprogram_call</FONT>
or task is complete.'' </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>5</FONT></DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>finalization
(of an object)</I> [distributed]}</FONT> <A NAME="I3310"></A>For the
<I>finalization</I> of an object: </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>6</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC>If the object is of an elementary
type, finalization has no effect;</LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>7</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC>If the object is of a controlled type,
the Finalize procedure is called;</LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>8</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC>If the object is of a protected type,
the actions defined in <A HREF="AA-9-4.html">9.4</A> are performed;</LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>9</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC>If the object is of a composite type,
then after performing the above actions, if any, every component of the
object is finalized in an arbitrary order, except as follows: if the
object has a component with an access discriminant constrained by a per-object
expression, this component is finalized before any components that do
not have such discriminants; for an object with several components with
such a discriminant, they are finalized in the reverse of the order of
their <FONT FACE="Arial, Helvetica">component_declaration</FONT>s. </LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>9.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Reason: </B>This allows the
finalization of a component with an access discriminant to refer to other
components of the enclosing object prior to their being finalized. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>10</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>execution (instance of Unchecked_Deallocation)</I>
[partial]}</FONT> <A NAME="I3311"></A>Immediately before an instance
of Unchecked_Deallocation reclaims the storage of an object, the object
is finalized. [If an instance of Unchecked_Deallocation is never applied
to an object created by an <FONT FACE="Arial, Helvetica">allocator</FONT>,
the object will still exist when the corresponding master completes,
and it will be finalized then.]</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>11</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;The order in which the finalization of a master
performs finalization of objects is as follows: Objects created by declarations
in the master are finalized in the reverse order of their creation. For
objects that were created by <FONT FACE="Arial, Helvetica">allocator</FONT>s
for an access type whose ultimate ancestor is declared in the master,
this rule is applied as though each such object that still exists had
been created in an arbitrary order at the first freezing point (see <A HREF="AA-13-14.html">13.14</A>)
of the ultimate ancestor type. </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>11.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Reason: </B>Note that we
talk about the type of the <FONT FACE="Arial, Helvetica">allocator</FONT>
here. There may be access values of a (general) access type pointing
at objects created by <FONT FACE="Arial, Helvetica">allocator</FONT>s
for some other type; these are not finalized at this point.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>11.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">The freezing point of the ultimate
ancestor access type is chosen because before that point, pool elements
cannot be created, and after that point, access values designating (parts
of) the pool elements can be created. This is also the point after which
the pool object cannot have been declared. We don't want to finalize
the pool elements until after anything finalizing objects that contain
access values designating them. Nor do we want to finalize pool elements
after finalizing the pool object itself. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>11.c</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>Finalization
of allocated objects is done according to the (ultimate ancestor) <FONT FACE="Arial, Helvetica">allocator</FONT>
type, not according to the storage pool in which they are allocated.
Pool finalization might reclaim storage (see <A HREF="AA-13-11.html">13.11</A>,
``<A HREF="AA-13-11.html">Storage Management</A>''), but has nothing
(directly) to do with finalization of the pool elements.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>11.d</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">Note that finalization is done
only for objects that still exist; if an instance of Unchecked_Deallocation
has already gotten rid of a given pool element, that pool element will
not be finalized when the master is left.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>11.e</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">Note that a deferred constant
declaration does not create the constant; the full constant declaration
creates it. Therefore, the order of finalization depends on where the
full constant declaration occurs, not the deferred constant declaration.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>11.f</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">An imported object is not created
by its declaration. It is neither initialized nor finalized. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>11.g</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Implementation Note: </B>An
implementation has to ensure that the storage for an object is not reclaimed
when references to the object are still possible (unless, of course,
the user explicitly requests reclamation via an instance of Unchecked_Deallocation).
This implies, in general, that objects cannot be deallocated one by one
as they are finalized; a subsequent finalization might reference an object
that has been finalized, and that object had better be in its (well-defined)
finalized state. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>12</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>execution (assignment_statement)</I>
[partial]}</FONT> <A NAME="I3312"></A>The target of an assignment statement
is finalized before copying in the new value, as explained in <A HREF="AA-7-6.html">7.6</A>.</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>13/1</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I><A HREF="defect1.html#8652/0021">8652/0021</A></I>}
<U>If the <FONT FACE="Arial, Helvetica">object_name</FONT> in an <FONT FACE="Arial, Helvetica">object_renaming_declaration</FONT>,
or the actual parameter for a generic formal <B>in out</B> parameter
in a <FONT FACE="Arial, Helvetica">generic_instantiation</FONT>, denotes
any part of an anonymous object created by a function call, the anonymous
object is not finalized until after it is no longer accessible via any
name. Otherwise, an</U> <S>The</S> anonymous object<S>s</S> created by
<U>a </U> function <U>call or</U> <S>calls and</S> by <U>an </U> <FONT FACE="Arial, Helvetica">aggregate</FONT><U>
is</U> <S>s are</S> finalized no later than the end of the innermost
enclosing <FONT FACE="Arial, Helvetica">declarative_item</FONT> or <FONT FACE="Arial, Helvetica">statement</FONT>;
if that is a <FONT FACE="Arial, Helvetica">compound_statement</FONT>,
<U>the object is</U> <S>they are</S> finalized before starting the execution
of any <FONT FACE="Arial, Helvetica">statement</FONT> within the <FONT FACE="Arial, Helvetica">compound_statement</FONT>.
</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>13.a</FONT></DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><FONT SIZE="-1"><B>To
be honest: </B>This is not to be construed as permission to call Finalize
asynchronously with respect to normal user code. For example, </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>13.b</FONT></DIV>
<DIV Class="SmallExamples"><TT><B>declare</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;:&nbsp;Some_Controlled_Type&nbsp;:=&nbsp;F(G(...));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;--<I>&nbsp;The&nbsp;anonymous&nbsp;objects&nbsp;created&nbsp;for&nbsp;F&nbsp;and&nbsp;G&nbsp;are&nbsp;finalized</I><BR>
&nbsp;&nbsp;&nbsp;&nbsp;--<I>&nbsp;no&nbsp;later&nbsp;than&nbsp;this&nbsp;point.</I><BR>
&nbsp;&nbsp;&nbsp;&nbsp;Y&nbsp;:&nbsp;...<BR>
<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;...<BR>
<B>end</B>;</TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>13.c</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">The anonymous object for G should
not be finalized at some random point in the middle of the body of F,
because F might manipulate the same data structures as the Finalize operation,
resulting in erroneous access to shared variables. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>13.d</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Reason: </B>It might be quite
inconvenient for the implementation to defer finalization of the anonymous
object for G until after copying the value of F into X, especially if
the size of the result is not known at the call site. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>13.1/1</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I><A HREF="defect1.html#8652/0023">8652/0023</A></I>}
<U>If a transfer of control or raising of an exception occurs prior to
performing a finalization of an anonymous object, the anonymous object
is finalized as part of the finalizations due to be performed for the
object's innermost enclosing master.</U> </DIV>

<H4 ALIGN=CENTER>Bounded (Run-Time) Errors</H4>
<DIV Class="Paranum"><FONT SIZE=-2>14/1</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I><A HREF="defect1.html#8652/0023">8652/0023</A></I>}
<FONT SIZE="-1">{<I>bounded error (cause)</I> [partial]}</FONT> <A NAME="I3313"></A>It
is a bounded error for a call on Finalize or Adjust <U>that occurs as
part of object finalization or assignment </U> to propagate an exception.
The possible consequences depend on what action invoked the Finalize
or Adjust operation: </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>14.a</FONT></DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><FONT SIZE="-1"><B>Ramification:
</B>It is not a bounded error for Initialize to propagate an exception.
If Initialize propagates an exception, then no further calls on Initialize
are performed, and those components that have already been initialized
(either explicitly or by default) are finalized in the usual way.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>14.a.1/1</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">{<I><A HREF="defect1.html#8652/0023">8652/0023</A></I>}
<U>It also is not a bounded error for an explicit call to Finalize or
Adjust to propagate an exception. We do not want implementations to have
to treat explicit calls to these routines specially.</U>  </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>15</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC><FONT SIZE="-1">{<I>Program_Error
(raised by failure of run-time check)</I>}</FONT> <A NAME="I3314"></A>For
a Finalize invoked as part of an <FONT FACE="Arial, Helvetica">assignment_statement</FONT>,
Program_Error is raised at that point.</LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>16/1</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="defect1.html#8652/0024">8652/0024</A></I>}
<U>For an Adjust invoked as part of the initialization of a controlled
object, other adjustments due to be performed might or might not be performed,
and then Program_Error is raised. During its propagation, finalization
might or might not be applied to objects whose Adjust failed.</U>  <FONT SIZE="-1">{<I>Program_Error
(raised by failure of run-time check)</I>}</FONT> <A NAME="I3315"></A>For
an Adjust invoked as part of an assignment <U>statement</U> <S>operation</S>,
any other adjustments due to be performed are performed, and then Program_Error
is raised. </LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>16.a.1/1</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Reason: </B>{<I><A HREF="defect1.html#8652/0024">8652/0024</A></I>}
<U>In the case of assignments that are part of initialization, there
is no need to complete all adjustments if one propagates an exception,
as the object will immediately be finalized. So long as a subcomponent
is not going to be finalized, it need not be adjusted, even if it is
initialized as part of an enclosing composite assignment operation for
which some adjustments are performed. However, there is no harm in an
implementation making additional Adjust calls (as long as any additional
components that are adjusted are also finalized), so we allow the implementation
flexibility here. On the other hand, for an assignment statement, it
is important that all adjustments be performed, even if one fails, because
all controlled subcomponents are going to be finalized.</U>  </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>16.a.2/1</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>{<I><A HREF="defect1.html#8652/0024">8652/0024</A></I>}
<U>Even if an Adjust invoked as part of the initialization of a controlled
object propagates an exception, objects whose initialization (including
any Adjust or Initialize calls) successfully completed will be finalized.
The permission above only applies to objects whose Adjust failed. Objects
for which Adjust was never even invoked must not be finalized.</U>  </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>17</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC><FONT SIZE="-1">{<I>Program_Error
(raised by failure of run-time check)</I>}</FONT> <A NAME="I3316"></A>For
a Finalize invoked as part of a call on an instance of Unchecked_Deallocation,
any other finalizations due to be performed are performed, and then Program_Error
is raised. </LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>17.a.1/1</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Discussion: </B>{<I><A HREF="defect2.html#8652/0104">8652/0104</A></I>}
<U>The standard does not specify if storage is recovered in this case.
If storage is not recovered (and the object continues to exist), Finalize
may be called on the object again (when the <FONT FACE="Arial, Helvetica">allocator</FONT>'s
master is finalized).</U>  </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>17.1/1</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="defect1.html#8652/0023">8652/0023</A></I>}
<U><FONT SIZE="-1">{<I>Program_Error (raised by failure of run-time check)</I>}</FONT>
<A NAME="I3317"></A>For a Finalize invoked as part of the finalization
of the anonymous object created by a function call or <FONT FACE="Arial, Helvetica">aggregate</FONT>,
any other finalizations due to be performed are performed, and then Program_Error
is raised.</U> </LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>17.2/1</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC>{<I><A HREF="defect1.html#8652/0023">8652/0023</A></I>}
<U><FONT SIZE="-1">{<I>Program_Error (raised by failure of run-time check)</I>}</FONT>
<A NAME="I3318"></A>For a Finalize invoked due to reaching the end of
the execution of a master, any other finalizations associated with the
master are performed, and Program_Error is raised immediately after leaving
the master.</U> </LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>18</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC><FONT SIZE="-1">{<I>Program_Error
(raised by failure of run-time check)</I>}</FONT> <A NAME="I3319"></A>For
a Finalize invoked by the transfer of control of an <FONT FACE="Arial, Helvetica">exit_</FONT>,
<FONT FACE="Arial, Helvetica">return_</FONT>, <FONT FACE="Arial, Helvetica">goto_</FONT>,
or <FONT FACE="Arial, Helvetica">requeue_statement</FONT>, Program_Error
is raised no earlier than after the finalization of the master being
finalized when the exception occurred, and no later than the point where
normal execution would have continued. Any other finalizations due to
be performed up to that point are performed before raising Program_Error.
</LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>18.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>For example,
upon leaving a <FONT FACE="Arial, Helvetica">block_statement</FONT> due
to a <FONT FACE="Arial, Helvetica">goto_statement</FONT>, the Program_Error
would be raised at the point of the target statement denoted by the label,
or else in some more dynamically nested place, but not so nested as to
allow an <FONT FACE="Arial, Helvetica">exception_handler</FONT> that
has visibility upon the finalized object to handle it. For example, </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>18.b</FONT></DIV>
<DIV Class="SmallExamples"><TT><B>procedure</B>&nbsp;Main&nbsp;<B>is</B><BR>
<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;The_Label&gt;&gt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Outer_Block_Statement&nbsp;:&nbsp;<B>declare</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;:&nbsp;Some_Controlled_Type;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Inner_Block_Statement&nbsp;:&nbsp;<B>declare</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y&nbsp;:&nbsp;Some_Controlled_Type;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Z&nbsp;:&nbsp;Some_Controlled_Type;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>goto</B>&nbsp;The_Label;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>exception</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>when</B>&nbsp;Program_Error&nbsp;=&gt;&nbsp;...&nbsp;--<I>&nbsp;Handler&nbsp;number&nbsp;1.</I><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>end</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>exception</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>when</B>&nbsp;Program_Error&nbsp;=&gt;&nbsp;...&nbsp;--<I>&nbsp;Handler&nbsp;number&nbsp;2.</I><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>end</B>;<BR>
<B>exception</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>when</B>&nbsp;Program_Error&nbsp;=&gt;&nbsp;...&nbsp;--<I>&nbsp;Handler&nbsp;number&nbsp;3.</I><BR>
<B>end</B>&nbsp;Main;</TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>18.c</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">The <FONT FACE="Arial, Helvetica">goto_statement</FONT>
will first cause Finalize(Y) to be called. Suppose that Finalize(Y) propagates
an exception. Program_Error will be raised after leaving Inner_Block_Statement,
but before leaving Main. Thus, handler number 1 cannot handle this Program_Error;
it will be handled either by handler number 2 or handler number 3. If
it is handled by handler number 2, then Finalize(Z) will be done before
executing the handler. If it is handled by handler number 3, then Finalize(Z)
and Finalize(X) will both be done before executing the handler. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>19</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC>For a Finalize invoked by a transfer
of control that is due to raising an exception, any other finalizations
due to be performed for the same master are performed; Program_Error
is raised immediately after leaving the master. </LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>19.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>If, in
the above example, the <FONT FACE="Arial, Helvetica">goto_statement</FONT>
were replaced by a <FONT FACE="Arial, Helvetica">raise_statement</FONT>,
then the Program_Error would be handled by handler number 2, and Finalize(Z)
would be done before executing the handler. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>19.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Reason: </B>We considered
treating this case in the same way as the others, but that would render
certain <FONT FACE="Arial, Helvetica">exception_handler</FONT>s useless.
For example, suppose the only <FONT FACE="Arial, Helvetica">exception_handler</FONT>
is one for <B>others</B> in the main subprogram. If some deeply nested
call raises an exception, causing some Finalize operation to be called,
which then raises an exception, then normal execution ``would have continued''
at the beginning of the <FONT FACE="Arial, Helvetica">exception_handler</FONT>.
Raising Program_Error at that point would cause that handler's code to
be skipped. One would need two nested <FONT FACE="Arial, Helvetica">exception_handler</FONT>s
to be sure of catching such cases!</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>19.c</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">On the other hand, the <FONT FACE="Arial, Helvetica">exception_handler</FONT>
for a given master should not be allowed to handle exceptions raised
during finalization of that master. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>20</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC>For a Finalize invoked by a transfer
of control due to an abort or selection of a terminate alternative, the
exception is ignored; any other finalizations due to be performed are
performed. </LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>20.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>This case
includes an asynchronous transfer of control. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>20.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>To be honest: </B>{<I>Program_Error
(raised by failure of run-time check)</I>} <A NAME="I3320"></A>This violates
the general principle that it is always possible for a bounded error
to raise Program_Error (see <A HREF="AA-1-1-5.html">1.1.5</A>, ``<A HREF="AA-1-1-5.html">Classification
of Errors</A>''). </FONT></DIV>
<DIV Class="NotesHeader"><FONT SIZE="-1">NOTES</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>21</FONT></DIV>
<DIV Class="Notes"><FONT SIZE="-1">18&nbsp;&nbsp;The rules of Section
10 imply that immediately prior to partition termination, Finalize operations
are applied to library-level controlled objects (including those created
by <FONT FACE="Arial, Helvetica">allocator</FONT>s of library-level access
types, except those already finalized). This occurs after waiting for
library-level tasks to terminate. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>21.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Discussion: </B>We considered
defining a pragma that would apply to a controlled type that would suppress
Finalize operations for library-level objects of the type upon partition
termination. This would be useful for types whose finalization actions
consist of simply reclaiming global heap storage, when this is already
provided automatically by the environment upon program termination. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>22</FONT></DIV>
<DIV Class="Notes"><FONT SIZE="-1">19&nbsp;&nbsp;A constant is only constant
between its initialization and finalization. Both initialization and
finalization are allowed to change the value of a constant.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>23</FONT></DIV>
<DIV Class="Notes"><FONT SIZE="-1">20&nbsp;&nbsp;Abort is deferred during
certain operations related to controlled types, as explained in <A HREF="AA-9-8.html">9.8</A>.
Those rules prevent an abort from causing a controlled object to be left
in an ill-defined state.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>24</FONT></DIV>
<DIV Class="Notes"><FONT SIZE="-1">21&nbsp;&nbsp;The Finalize procedure
is called upon finalization of a controlled object, even if Finalize
was called earlier, either explicitly or as part of an assignment; hence,
if a controlled type is visibly controlled (implying that its Finalize
primitive is directly callable), or is nonlimited (implying that assignment
is allowed), its Finalize procedure should be designed to have no ill
effect if it is applied a second time to the same object. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>24.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Discussion: </B>Or equivalently,
a Finalize procedure should be ``idempotent''; applying it twice to the
same object should be equivalent to applying it once. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>24.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Reason: </B>A user-written
Finalize procedure should be idempotent since it can be called explicitly
by a client (at least if the type is &quot;visibly&quot; controlled).
Also, Finalize is used implicitly as part of the <FONT FACE="Arial, Helvetica">assignment_statement</FONT>
if the type is nonlimited, and an abort is permitted to disrupt an <FONT FACE="Arial, Helvetica">assignment_statement</FONT>
between finalizing the left-hand side and assigning the new value to
it (an abort is not permitted to disrupt an assignment operation between
copying in the new value and adjusting it). </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>24.c</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Discussion: </B>Either Initialize
or Adjust, but not both, is applied to (almost) every controlled object
when it is created: Initialize is done when no initial value is assigned
to the object, whereas Adjust is done as part of assigning the initial
value. The one exception is the anonymous object created by an <FONT FACE="Arial, Helvetica">aggregate</FONT>;
Initialize is not applied to the <FONT FACE="Arial, Helvetica">aggregate</FONT>
as a whole, nor is the value of the <FONT FACE="Arial, Helvetica">aggregate</FONT>
adjusted.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>24.d</FONT></DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><FONT SIZE="-1">{<I>assignment
operation (list of uses)</I>} <A NAME="I3321"></A>All of the following
use the assignment operation, and thus perform value adjustment: </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>24.e</FONT></DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC><FONT SIZE="-1">the <FONT FACE="Arial, Helvetica">assignment_statement</FONT>
(see <A HREF="AA-5-2.html">5.2</A>);</FONT></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>24.f</FONT></DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC><FONT SIZE="-1">explicit initialization
of a stand-alone object (see <A HREF="AA-3-3-1.html">3.3.1</A>) or of
a pool element (see <A HREF="AA-4-8.html">4.8</A>);</FONT></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>24.g</FONT></DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC><FONT SIZE="-1">default initialization
of a component of a stand-alone object or pool element (in this case,
the value of each component is assigned, and therefore adjusted, but
the value of the object as a whole is not adjusted);</FONT></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>24.h</FONT></DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC><FONT SIZE="-1">function return,
when the result type is not a return-by-reference type (see <A HREF="AA-6-5.html">6.5</A>);
(adjustment of the result happens before finalization of the function;
values of return-by-reference types are not adjusted);</FONT></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>24.i</FONT></DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC><FONT SIZE="-1">predefined operators
(although the only one that matters is concatenation; see <A HREF="AA-4-5-3.html">4.5.3</A>);</FONT></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>24.j</FONT></DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC><FONT SIZE="-1">generic formal
objects of mode <B>in</B> (see <A HREF="AA-12-4.html">12.4</A>); these
are defined in terms of <FONT FACE="Arial, Helvetica">constant_declaration</FONT>s;
and</FONT></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>24.k</FONT></DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC><FONT SIZE="-1"><FONT FACE="Arial, Helvetica">aggregate</FONT>s
(see <A HREF="AA-4-3.html">4.3</A>) (in this case, the value of each
component, and the parent part, for an <FONT FACE="Arial, Helvetica">extension_aggregate</FONT>,
is assigned, and therefore adjusted, but the value of the <FONT FACE="Arial, Helvetica">aggregate</FONT>
as a whole is not adjusted; neither is Initialize called); </FONT></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>24.l</FONT></DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><FONT SIZE="-1">The
following also use the assignment operation, but adjustment never does
anything interesting in these cases: </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>24.m</FONT></DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC><FONT SIZE="-1">By-copy parameter
passing uses the assignment operation (see <A HREF="AA-6-4-1.html">6.4.1</A>),
but controlled objects are always passed by reference, so the assignment
operation never does anything interesting in this case. If we were to
allow by-copy parameter passing for controlled objects, we would need
to make sure that the actual is finalized before doing the copy back
for [<B>in</B>] <B>out</B> parameters. The finalization of the parameter
itself needs to happen after the copy back (if any), similar to the finalization
of an anonymous function return object or <FONT FACE="Arial, Helvetica">aggregate</FONT>
object.</FONT></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>24.n</FONT></DIV>
<UL Class="SmallBulleted"><LI TYPE=DISC><FONT SIZE="-1"><B>For</B> loops
use the assignment operation (see <A HREF="AA-5-5.html">5.5</A>), but
since the type of the loop parameter is never controlled, nothing interesting
happens there, either. </FONT></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>24.o</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">Because Controlled and Limited_Controlled
are library-level tagged types, all controlled types will be library-level
types, because of the accessibility rules (see <A HREF="AA-3-10-2.html">3.10.2</A>
and <A HREF="AA-3-9-1.html">3.9.1</A>). This ensures that the Finalize
operations may be applied without providing any ``display'' or ``static-link.''
This simplifies finalization as a result of garbage collection, abort,
and asynchronous transfer of control.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>24.p</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">Finalization of the parts of
a protected object are not done as protected actions. It is possible
(in pathological cases) to create tasks during finalization that access
these parts in parallel with the finalization itself. This is an erroneous
use of shared variables. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>24.q</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Implementation Note: </B>One
implementation technique for finalization is to chain the controlled
objects together on a per-task list. When leaving a master, the list
can be walked up to a marked place. The links needed to implement the
list can be declared (privately) in types Controlled and Limited_Controlled,
so they will be inherited by all controlled types.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>24.r</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">Another implementation technique,
which we refer to as the ``PC-map'' approach essentially implies inserting
exception handlers at various places, and finalizing objects based on
where the exception was raised.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>24.s</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">{<I>PC-map approach to finalization</I>}
<A NAME="I3322"></A>{<I>program-counter-map approach to finalization</I>}
<A NAME="I3323"></A>The PC-map approach is for the compiler/linker to
create a map of code addresses; when an exception is raised, or abort
occurs, the map can be consulted to see where the task was executing,
and what finalization needs to be performed. This approach was given
in the Ada 83 Rationale as a possible implementation strategy for exception
handling -- the map is consulted to determine which exception handler
applies.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>24.t</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">If the PC-map approach is used,
the implementation must take care in the case of arrays. The generated
code will generally contain a loop to initialize an array. If an exception
is raised part way through the array, the components that have been initialized
must be finalized, and the others must not be finalized.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>24.u</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">It is our intention that both
of these implementation methods should be possible. </FONT></DIV>

<H4 ALIGN=CENTER>Wording Changes from Ada 83</H4>
<DIV Class="Paranum"><FONT SIZE=-2>24.v</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">Finalization depends on the
concepts of completion and leaving, and on the concept of a master. Therefore,
we have moved the definitions of these concepts here, from where they
used to be in Section 9. These concepts also needed to be generalized
somewhat. Task waiting is closely related to user-defined finalization;
the rules here refer to the task-waiting rules of Section 9. </FONT></DIV>

<HR>
<P><A HREF="AA-TOC.html">Contents</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-0-29.html">Index</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-SRCH.html">Search</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-7-6.html">Previous</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-8.html">Next</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-TTL.html">Legal</A></P>
</BODY>
</HTML>
