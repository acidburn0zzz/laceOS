<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Formal Private and Derived Types</TITLE>
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    DIV.paranum {position: absolute; font-family: Arial, Helvetica, sans-serif; left: 0.5em; top: auto}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    DIV.Normal {font-family: "Times New Roman", Times, serif; margin-bottom: 0.6em}
    DIV.Wide {font-family: "Times New Roman", Times, serif; margin-top: 0.6em; margin-bottom: 0.6em}
    DIV.Annotations {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-bottom: 0.6em}
    DIV.WideAnnotations {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-top: 0.6em; margin-bottom: 0.6em}
    DIV.Index {font-family: "Times New Roman", Times, serif}
    DIV.SyntaxSummary {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-bottom: 0.4em}
    DIV.Notes {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-bottom: 0.6em}
    DIV.NotesHeader {font-family: "Times New Roman", Times, serif; margin-left: 2.0em}
    DIV.SyntaxIndented {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-bottom: 0.4em}
    DIV.Indented {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-bottom: 0.6em}
    DIV.CodeIndented {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-bottom: 0.6em}
    DIV.SmallIndented {font-family: "Times New Roman", Times, serif; margin-left:  10.0em; margin-bottom: 0.6em}
    DIV.SmallCodeIndented {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-bottom: 0.6em}
    DIV.Examples {font-family: "Courier New", monospace; margin-left: 2.0em; margin-bottom: 0.6em}
    DIV.SmallExamples {font-family: "Courier New", monospace; font-size: 80%; margin-left: 7.5em; margin-bottom: 0.6em}
    DIV.IndentedExamples {font-family: "Courier New", monospace; margin-left: 8.0em; margin-bottom: 0.6em}
    DIV.SmallIndentedExamples {font-family: "Courier New", monospace; font-size: 80%; margin-left:  15.0em; margin-bottom: 0.6em}
    UL.Bulleted {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.SmallBulleted {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.NestedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-right: 4.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.SmallNestedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-right: 8.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.IndentedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-right: 8.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.CodeIndentedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.CodeIndentedNestedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-right: 8.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.SyntaxIndentedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-right: 4.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.NotesBulleted {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-right: 4.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.NotesNestedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    DL.Hanging {font-family: "Times New Roman", Times, serif; margin-top: 0em; margin-bottom: 0.6em}
    DD.Hanging {margin-left: 6.0em}
    DL.IndentedHanging {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-top: 0em; margin-bottom: 0.6em}
    DD.IndentedHanging {margin-left: 2.0em}
    DL.HangingInBulleted {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    DD.HangingInBulleted {margin-left: 4.0em}
    DL.SmallHanging {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-top: 0em; margin-bottom: 0.6em}
    DD.SmallHanging {margin-left: 7.5em}
    DL.SmallIndentedHanging {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-top: 0em; margin-bottom: 0.6em}
    DD.SmallIndentedHanging {margin-left: 2.0em}
    DL.SmallHangingInBulleted {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    DD.SmallHangingInBulleted {margin-left: 5.0em}
    DL.Enumerated {font-family: "Times New Roman", Times, serif; margin-right: 0.0em; margin-top: 0em; margin-bottom: 0.5em}
    DD.Enumerated {margin-left: 2.0em}
    DL.SmallEnumerated {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-right: 4.0em; margin-top: 0em; margin-bottom: 0.5em}
    DD.SmallEnumerated {margin-left: 2.5em}
    DL.NestedEnumerated {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    DL.SmallNestedEnumerated {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">
<P><A HREF="AA-TOC.html">Contents</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-0-29.html">Index</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-SRCH.html">Search</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-12-5.html">Previous</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-12-5-2.html">Next</A></P>
<HR>
<H1> 12.5.1 Formal Private and Derived Types</H1>
<DIV Class="Paranum"><FONT SIZE=-2>1</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;[The class determined for a formal private type
can be either limited or nonlimited, and either tagged or untagged; no
more specific class is known for such a type. The class determined for
a formal derived type is the derivation class rooted at the ancestor
type.] </DIV>

<H4 ALIGN=CENTER>Syntax</H4>
<DIV Class="Paranum"><FONT SIZE=-2>2</FONT></DIV>
<DIV Class="SyntaxIndented"><FONT FACE="Arial, Helvetica">formal_private_type_definition</FONT><FONT FACE="Arial, Helvetica"><A NAME="I4288"></A>
::= </FONT>[[<B>abstract</B>]&nbsp;<B>tagged</B>]&nbsp;[<B>limited</B>]&nbsp;<B>private</B></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>3</FONT></DIV>
<DIV Class="SyntaxIndented"><FONT FACE="Arial, Helvetica">formal_derived_type_definition</FONT><FONT FACE="Arial, Helvetica"><A NAME="I4289"></A>
::= </FONT>[<B>abstract</B>]&nbsp;<B>new</B>&nbsp;<A NAME="I4290"></A><FONT FACE="Arial, Helvetica">subtype_mark</FONT>&nbsp;[<B>with</B>&nbsp;<B>private</B>]</DIV>

<H4 ALIGN=CENTER>Legality Rules</H4>
<DIV Class="Paranum"><FONT SIZE=-2>4</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;If a generic formal type declaration has a <FONT FACE="Arial, Helvetica">known_discriminant_part</FONT>,
then it shall not include a <FONT FACE="Arial, Helvetica">default_expression</FONT>
for a discriminant. </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>4.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>Consequently,
a generic formal subtype with a <FONT FACE="Arial, Helvetica">known_discriminant_part</FONT>
is an indefinite subtype, so the declaration of a stand-alone variable
has to provide a constraint on such a subtype, either explicitly, or
by its initial value. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>5</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>ancestor subtype (of a formal
derived type)</I>}</FONT> <A NAME="I4291"></A>The <I>ancestor subtype</I>
of a formal derived type is the subtype denoted by the <FONT FACE="Arial, Helvetica">subtype_mark</FONT>
of the <FONT FACE="Arial, Helvetica">formal_derived_type_definition</FONT>.
For a formal derived type declaration, the reserved words <B>with private</B>
shall appear if and only if the ancestor type is a tagged type; in this
case the formal derived type is a private extension of the ancestor type
and the ancestor shall not be a class-wide type. [Similarly, the optional
reserved word <B>abstract</B> shall appear only if the ancestor type
is a tagged type]. </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>5.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Reason: </B>We use the term
``ancestor'' here instead of ``parent'' because the actual can be any
descendant of the ancestor, not necessarily a direct descendant. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>6</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;If the formal subtype is definite, then the actual
subtype shall also be definite. </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>6.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>On the
other hand, for an indefinite formal subtype, the actual can be either
definite or indefinite. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>7</FONT></DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;&nbsp;&nbsp;For a generic formal
derived type with no <FONT FACE="Arial, Helvetica">discriminant_part</FONT>:
</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>8</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC>If the ancestor subtype is constrained,
the actual subtype shall be constrained, and shall be statically compatible
with the ancestor; </LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>8.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>In other
words, any constraint on the ancestor subtype is considered part of the
``contract.'' </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>9</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC>If the ancestor subtype is an unconstrained
access or composite subtype, the actual subtype shall be unconstrained.
</LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>9.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Reason: </B>This rule ensures
that if a composite constraint is allowed on the formal, one is also
allowed on the actual. If the ancestor subtype is an unconstrained scalar
subtype, the actual is allowed to be constrained, since a scalar constraint
does not cause further constraints to be illegal. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>10</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC>If the ancestor subtype is an unconstrained
discriminated subtype, then the actual shall have the same number of
discriminants, and each discriminant of the actual shall correspond to
a discriminant of the ancestor, in the sense of <A HREF="AA-3-7.html">3.7</A>.</LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>10.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Reason: </B>This ensures
that if a discriminant constraint is given on the formal subtype, the
corresponding constraint in the instance will make sense, without additional
run-time checks. This is not necessary for arrays, since the bounds cannot
be overridden in a type extension. An <FONT FACE="Arial, Helvetica">unknown_discriminant_part</FONT>
may be used to relax these matching requirements. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>11</FONT></DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;&nbsp;&nbsp;&nbsp;The declaration
of a formal derived type shall not have a <FONT FACE="Arial, Helvetica">known_discriminant_part</FONT>.
For a generic formal private type with a <FONT FACE="Arial, Helvetica">known_discriminant_part</FONT>:
</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>12</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC>The actual type shall be a type with
the same number of discriminants.</LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>13</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC>The actual subtype shall be unconstrained.</LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>14</FONT></DIV>
<UL Class="Bulleted"><LI TYPE=DISC>The subtype of each discriminant of
the actual type shall statically match the subtype of the corresponding
discriminant of the formal type. <FONT SIZE="-1">{<I>statically matching
(required)</I> [partial]}</FONT> <A NAME="I4292"></A></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>14.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Reason: </B>We considered
defining the first and third rule to be called ``subtype conformance''
for <FONT FACE="Arial, Helvetica">discriminant_parts</FONT>. We rejected
that idea, because it would require implicit (inherited) <FONT FACE="Arial, Helvetica">discriminant_parts</FONT>,
which seemed like too much mechanism. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>15</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;[For a generic formal type with an <FONT FACE="Arial, Helvetica">unknown_discriminant_part</FONT>,
the actual may, but need not, have discriminants, and may be definite
or indefinite.]</DIV>

<H4 ALIGN=CENTER>Static Semantics</H4>
<DIV Class="Paranum"><FONT SIZE=-2>16</FONT></DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;&nbsp;&nbsp;&nbsp;The class determined
for a formal private type is as follows: </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>17</FONT></DIV>
<DIV Class="SyntaxIndented"><I>Type&nbsp;Definition</I>&nbsp;&nbsp;<I>Determined&nbsp;Class</I><BR>
<BR>
<B>limited&nbsp;private</B>&nbsp;&nbsp;the&nbsp;class&nbsp;of&nbsp;all&nbsp;types<BR>
<B>private</B>&nbsp;&nbsp;the&nbsp;class&nbsp;of&nbsp;all&nbsp;nonlimited&nbsp;types<BR>
<B>tagged&nbsp;limited&nbsp;private</B>&nbsp;&nbsp;the&nbsp;class&nbsp;of&nbsp;all&nbsp;tagged&nbsp;types<BR>
<B>tagged&nbsp;private</B>&nbsp;&nbsp;the&nbsp;class&nbsp;of&nbsp;all&nbsp;nonlimited&nbsp;tagged&nbsp;types</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>18</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;[The presence of the reserved word <B>abstract</B>
determines whether the actual type may be abstract.]</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>19</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;A formal private or derived type is a private
or derived type, respectively. A formal derived tagged type is a private
extension. [A formal private or derived type is abstract if the reserved
word <B>abstract</B> appears in its declaration.]</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>20</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;If the ancestor type is a composite type that
is not an array type, the formal type inherits components from the ancestor
type (including discriminants if a new <FONT FACE="Arial, Helvetica">discriminant_part</FONT>
is not specified), as for a derived type defined by a <FONT FACE="Arial, Helvetica">derived_type_definition</FONT>
(see <A HREF="AA-3-4.html">3.4</A>).</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>21/1</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I><A HREF="defect1.html#8652/0038">8652/0038</A></I>}
For a formal derived type, the predefined operators and inherited user-defined
subprograms are determined by the ancestor type, and are implicitly declared
at the earliest place, if any, within the immediate scope of the formal
type, where the corresponding primitive subprogram of the ancestor is
visible (see <A HREF="AA-7-3-1.html">7.3.1</A>). In an instance, the
copy of such an implicit declaration declares a view of the corresponding
primitive subprogram of the ancestor<U> of the formal derived type</U> ,
even if this primitive has been overridden for the actual type. <U>When
the ancestor of the formal derived type is itself a formal type, the
copy of the implicit declaration declares a view of the corresponding
copied operation of the ancestor.</U>  [In the case of a formal private
extension, however, the tag of the formal type is that of the actual
type, so if the tag in a call is statically determined to be that of
the formal type, the body executed will be that corresponding to the
actual type.] </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>21.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>The above
rule defining the properties of primitive subprograms in an instance
applies even if the subprogram has been overridden or hidden for the
actual type. This rule is necessary for untagged types, because their
primitive subprograms might have been overridden by operations that are
not subtype-conformant with the operations defined for the class. For
tagged types, the rule still applies, but the primitive subprograms will
dispatch to the appropriate implementation based on the type and tag
of the operands. Even for tagged types, the formal parameter names and
<FONT FACE="Arial, Helvetica">default_expression</FONT>s are determined
by those of the primitive subprograms of the specified ancestor type.
</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>22/1</FONT></DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For a <U><FONT FACE="Arial, Helvetica">prefix</FONT></U> <S>prefix</S>
S that denotes a formal indefinite subtype, the following attribute is
defined: </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>23</FONT></DIV>
<DL Class="Hanging"><DT>&nbsp;&nbsp;&nbsp;&nbsp;S'Definite<DD Class="Hanging">
<A NAME="I4293"></A><A NAME="I4294"></A>S'Definite yields True if the
actual subtype corresponding to S is definite; otherwise it yields False.
The value of this attribute is of the predefined type Boolean. </DL>
<DIV Class="Paranum"><FONT SIZE=-2>23.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Discussion: </B>Whether an
actual subtype is definite or indefinite may have a major effect on the
algorithm used in a generic. For example, in a generic I/O package, whether
to use fixed-length or variable-length records could depend on whether
the actual is definite or indefinite. This attribute is essentially a
replacement for the Constrained attribute which is now considered obsolete.
</FONT></DIV>
<DIV Class="NotesHeader"><FONT SIZE="-1">NOTES</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>24</FONT></DIV>
<DIV Class="Notes" Style="margin-bottom: 0.4em"><FONT SIZE="-1">9&nbsp;&nbsp;In
accordance with the general rule that the actual type shall belong to
the class determined for the formal (see <A HREF="AA-12-5.html">12.5</A>,
``<A HREF="AA-12-5.html">Formal Types</A>''): </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>25</FONT></DIV>
<UL Class="NotesBulleted"><LI TYPE=DISC><FONT SIZE="-1">If the formal
type is nonlimited, then so shall be the actual;</FONT></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>26</FONT></DIV>
<UL Class="NotesBulleted"><LI TYPE=DISC><FONT SIZE="-1">For a formal
derived type, the actual shall be in the class rooted at the ancestor
subtype. </FONT></LI></UL>
<DIV Class="Paranum"><FONT SIZE=-2>27</FONT></DIV>
<DIV Class="Notes"><FONT SIZE="-1">10&nbsp;&nbsp;[The actual type can
be abstract only if the formal type is abstract (see <A HREF="AA-3-9-3.html">3.9.3</A>).]
</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>27.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Reason: </B>This is necessary
to avoid contract model problems, since one or more of its primitive
subprograms are abstract; it is forbidden to create objects of the type,
or to declare functions returning the type. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>27.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>On the
other hand, it is OK to pass a non-abstract actual to an abstract formal
-- <B>abstract</B> on the formal indicates that the actual might be abstract.
</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>28</FONT></DIV>
<DIV Class="Notes"><FONT SIZE="-1">11&nbsp;&nbsp;If the formal has a
<FONT FACE="Arial, Helvetica">discriminant_part</FONT>, the actual can
be either definite or indefinite. Otherwise, the actual has to be definite.
</FONT></DIV>

<H4 ALIGN=CENTER>Incompatibilities With Ada 83</H4>
<DIV Class="Paranum"><FONT SIZE=-2>28.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">{<I>incompatibilities with Ada
83</I>} <A NAME="I4295"></A>Ada 83 does not have <FONT FACE="Arial, Helvetica">unknown_discriminant_part</FONT>s,
so it allows indefinite subtypes to be passed to definite formals, and
applies a legality rule to the instance body. This is a contract model
violation. Ada 95 disallows such cases at the point of the instantiation.
The workaround is to add (&lt;&gt;) as the <FONT FACE="Arial, Helvetica">discriminant_part</FONT>
of any formal subtype if it is intended to be used with indefinite actuals.
If that's the intent, then there can't be anything in the generic body
that would require a definite subtype.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>28.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">The check for discriminant subtype
matching is changed from a run-time check to a compile-time check. </FONT></DIV>

<HR>
<P><A HREF="AA-TOC.html">Contents</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-0-29.html">Index</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-SRCH.html">Search</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-12-5.html">Previous</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-12-5-2.html">Next</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-TTL.html">Legal</A></P>
</BODY>
</HTML>
