<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
    <TITLE>Private Types and Private Extensions</TITLE>
    <META NAME="Author" CONTENT="JTC1/SC22/WG9/ARG, by Randall Brukardt, ARG Editor">
    <META NAME="GENERATOR" CONTENT="Arm_Form.Exe, Ada Reference Manual generator">
    <STYLE type="text/css">
    DIV.paranum {position: absolute; font-family: Arial, Helvetica, sans-serif; left: 0.5em; top: auto}
    TT {font-family: "Courier New", monospace}
    DT {display: compact}
    DIV.Normal {font-family: "Times New Roman", Times, serif; margin-bottom: 0.6em}
    DIV.Wide {font-family: "Times New Roman", Times, serif; margin-top: 0.6em; margin-bottom: 0.6em}
    DIV.Annotations {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-bottom: 0.6em}
    DIV.WideAnnotations {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-top: 0.6em; margin-bottom: 0.6em}
    DIV.Index {font-family: "Times New Roman", Times, serif}
    DIV.SyntaxSummary {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-bottom: 0.4em}
    DIV.Notes {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-bottom: 0.6em}
    DIV.NotesHeader {font-family: "Times New Roman", Times, serif; margin-left: 2.0em}
    DIV.SyntaxIndented {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-bottom: 0.4em}
    DIV.Indented {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-bottom: 0.6em}
    DIV.CodeIndented {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-bottom: 0.6em}
    DIV.SmallIndented {font-family: "Times New Roman", Times, serif; margin-left:  10.0em; margin-bottom: 0.6em}
    DIV.SmallCodeIndented {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-bottom: 0.6em}
    DIV.Examples {font-family: "Courier New", monospace; margin-left: 2.0em; margin-bottom: 0.6em}
    DIV.SmallExamples {font-family: "Courier New", monospace; font-size: 80%; margin-left: 7.5em; margin-bottom: 0.6em}
    DIV.IndentedExamples {font-family: "Courier New", monospace; margin-left: 8.0em; margin-bottom: 0.6em}
    DIV.SmallIndentedExamples {font-family: "Courier New", monospace; font-size: 80%; margin-left:  15.0em; margin-bottom: 0.6em}
    UL.Bulleted {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.SmallBulleted {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.NestedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-right: 4.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.SmallNestedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-right: 8.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.IndentedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-right: 8.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.CodeIndentedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.CodeIndentedNestedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-right: 8.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.SyntaxIndentedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-right: 4.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.NotesBulleted {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-right: 4.0em; margin-top: 0em; margin-bottom: 0.5em}
    UL.NotesNestedBulleted {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    DL.Hanging {font-family: "Times New Roman", Times, serif; margin-top: 0em; margin-bottom: 0.6em}
    DD.Hanging {margin-left: 6.0em}
    DL.IndentedHanging {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-top: 0em; margin-bottom: 0.6em}
    DD.IndentedHanging {margin-left: 2.0em}
    DL.HangingInBulleted {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    DD.HangingInBulleted {margin-left: 4.0em}
    DL.SmallHanging {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-top: 0em; margin-bottom: 0.6em}
    DD.SmallHanging {margin-left: 7.5em}
    DL.SmallIndentedHanging {font-family: "Times New Roman", Times, serif; margin-left: 8.0em; margin-top: 0em; margin-bottom: 0.6em}
    DD.SmallIndentedHanging {margin-left: 2.0em}
    DL.SmallHangingInBulleted {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    DD.SmallHangingInBulleted {margin-left: 5.0em}
    DL.Enumerated {font-family: "Times New Roman", Times, serif; margin-right: 0.0em; margin-top: 0em; margin-bottom: 0.5em}
    DD.Enumerated {margin-left: 2.0em}
    DL.SmallEnumerated {font-family: "Times New Roman", Times, serif; margin-left: 4.0em; margin-right: 4.0em; margin-top: 0em; margin-bottom: 0.5em}
    DD.SmallEnumerated {margin-left: 2.5em}
    DL.NestedEnumerated {font-family: "Times New Roman", Times, serif; margin-left: 2.0em; margin-right: 2.0em; margin-top: 0em; margin-bottom: 0.5em}
    DL.SmallNestedEnumerated {font-family: "Times New Roman", Times, serif; margin-left: 6.0em; margin-right: 6.0em; margin-top: 0em; margin-bottom: 0.5em}
    </STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFF0" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">
<P><A HREF="AA-TOC.html">Contents</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-0-29.html">Index</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-SRCH.html">Search</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-7-2.html">Previous</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-7-3-1.html">Next</A></P>
<HR>
<H1> 7.3 Private Types and Private Extensions</H1>
<DIV Class="Paranum"><FONT SIZE=-2>1</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;[The declaration (in the visible part of a package)
of a type as a private type or private extension serves to separate the
characteristics that can be used directly by outside program units (that
is, the logical properties) from other characteristics whose direct use
is confined to the package (the details of the definition of the type
itself). See <A HREF="AA-3-9-1.html">3.9.1</A> for an overview of type
extensions. <FONT SIZE="-1">{<I>private types and private extensions</I>}</FONT>
<A NAME="I3217"></A><FONT SIZE="-1">{<I>information hiding: See private
types and private extensions</I>}</FONT> <A NAME="I3218"></A><FONT SIZE="-1">{<I>opaque
type: See private types and private extensions</I>}</FONT> <A NAME="I3219"></A><FONT SIZE="-1">{<I>abstract
data type (ADT): See private types and private extensions</I>}</FONT>
<A NAME="I3220"></A><FONT SIZE="-1">{<I>ADT (abstract data type): See
private types and private extensions</I>}</FONT> <A NAME="I3221"></A>]</DIV>

<H4 ALIGN=CENTER>Language Design Principles</H4>
<DIV Class="Paranum"><FONT SIZE=-2>1.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">A private (untagged) type can
be thought of as a record type with the type of its single (hidden) component
being the full view.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>1.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">A private tagged type can be
thought of as a private extension of an anonymous parent with no components.
The only dispatching operation of the parent is equality (although the
Size attribute, and, if nonlimited, assignment are allowed, and those
will presumably be implemented in terms of dispatching). </FONT></DIV>

<H4 ALIGN=CENTER>Syntax</H4>
<DIV Class="Paranum"><FONT SIZE=-2>2</FONT></DIV>
<DIV Class="SyntaxIndented"><FONT FACE="Arial, Helvetica">private_type_declaration</FONT><FONT FACE="Arial, Helvetica"><A NAME="I3222"></A>
::= </FONT><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;<A NAME="I3223"></A><FONT FACE="Arial, Helvetica">defining_identifier</FONT>&nbsp;[<A NAME="I3224"></A><FONT FACE="Arial, Helvetica">discriminant_part</FONT>]&nbsp;<B>is</B>&nbsp;[[<B>abstract</B>]&nbsp;<B>tagged</B>]&nbsp;[<B>limited</B>]&nbsp;<B>private</B>;</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>3</FONT></DIV>
<DIV Class="SyntaxIndented"><FONT FACE="Arial, Helvetica">private_extension_declaration</FONT><FONT FACE="Arial, Helvetica"><A NAME="I3225"></A>
::= </FONT><BR>
&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;<A NAME="I3226"></A><FONT FACE="Arial, Helvetica">defining_identifier</FONT>&nbsp;[<A NAME="I3227"></A><FONT FACE="Arial, Helvetica">discriminant_part</FONT>]&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<B>abstract</B>]&nbsp;<B>new</B>&nbsp;<I>ancestor_</I><A NAME="I3228"></A><FONT FACE="Arial, Helvetica">subtype_indication</FONT>&nbsp;<B>with&nbsp;private</B>;</DIV>

<H4 ALIGN=CENTER>Legality Rules</H4>
<DIV Class="Paranum"><FONT SIZE=-2>4</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>partial view (of a type)</I>}</FONT>
<A NAME="I3229"></A><FONT SIZE="-1">{<I>requires a completion (declaration
of a partial view)</I> [partial]}</FONT> <A NAME="I3230"></A>A <FONT FACE="Arial, Helvetica">private_type_declaration</FONT>
or <FONT FACE="Arial, Helvetica">private_extension_declaration</FONT>
declares a <I>partial view</I> of the type; such a declaration is allowed
only as a <FONT FACE="Arial, Helvetica">declarative_item</FONT> of the
visible part of a package, and it requires a completion, which shall
be a <FONT FACE="Arial, Helvetica">full_type_declaration</FONT> that
occurs as a <FONT FACE="Arial, Helvetica">declarative_item</FONT> of
the private part of the package. <FONT SIZE="-1">{<I>full view (of a
type)</I>}</FONT> <A NAME="I3231"></A>The view of the type declared by
the <FONT FACE="Arial, Helvetica">full_type_declaration</FONT> is called
the <I>full view</I>. A generic formal private type or a generic formal
private extension is also a partial view. </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>4.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>To be honest: </B>A private
type can also be completed by a <FONT FACE="Arial, Helvetica">pragma</FONT>
Import, if supported by an implementation. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>4.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Reason: </B>We originally
used the term ``private view,'' but this was easily confused with the
view provided <I>from</I> the private part, namely the full view. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>5</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;[A type shall be completely defined before it
is frozen (see <A HREF="AA-3-11-1.html">3.11.1</A> and <A HREF="AA-13-14.html">13.14</A>).
Thus, neither the declaration of a variable of a partial view of a type,
nor the creation by an <FONT FACE="Arial, Helvetica">allocator</FONT>
of an object of the partial view are allowed before the full declaration
of the type. Similarly, before the full declaration, the name of the
partial view cannot be used in a <FONT FACE="Arial, Helvetica">generic_instantiation</FONT>
or in a representation item.] </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>5.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Proof: </B>This rule is stated
officially in <A HREF="AA-3-11-1.html">3.11.1</A>, ``<A HREF="AA-3-11-1.html">Completions
of Declarations</A>''. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>6</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;[A private type is limited if its declaration
includes the reserved word <B>limited</B>; a private extension is limited
if its ancestor type is limited.] If the partial view is nonlimited,
then the full view shall be nonlimited. If a tagged partial view is limited,
then the full view shall be limited. [On the other hand, if an untagged
partial view is limited, the full view may be limited or nonlimited.]</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>7</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;If the partial view is tagged, then the full view
shall be tagged. [On the other hand, if the partial view is untagged,
then the full view may be tagged or untagged.] In the case where the
partial view is untagged and the full view is tagged, no derivatives
of the partial view are allowed within the immediate scope of the partial
view; [derivatives of the full view are allowed.] </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>7.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>Note that
deriving from a partial view within its immediate scope can only occur
in a package that is a child of the one where the partial view is declared.
The rule implies that in the visible part of a public child package,
it is impossible to derive from an untagged private type declared in
the visible part of the parent package in the case where the full view
of the parent type turns out to be tagged. We considered a model in which
the derived type was implicitly redeclared at the earliest place within
its immediate scope where characteristics needed to be added. However,
we rejected that model, because (1) it would imply that (for an untagged
type) subprograms explicitly declared after the derived type could be
inherited, and (2) to make this model work for composite types as well,
several implicit redeclarations would be needed, since new characteristics
can become visible one by one; that seemed like too much mechanism. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>7.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Discussion: </B>The rule
for tagged partial views is redundant for partial views that are private
extensions, since all extensions of a given ancestor tagged type are
tagged, and limited if the ancestor is limited. We phrase this rule partially
redundantly to keep its structure parallel with the other rules. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>7.c</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>To be honest: </B>This rule
is checked in a generic unit, rather than using the ``assume the best''
or ``assume the worst'' method. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>7.d</FONT></DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><FONT SIZE="-1"><B>Reason:
</B>Tagged limited private types have certain capabilities that are incompatible
with having assignment for the full view of the type. In particular,
tagged limited private types can be extended with access discriminants
and components of a limited type, which works only because assignment
is not allowed. Consider the following example: </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>7.e</FONT></DIV>
<DIV Class="SmallExamples"><TT><B>package</B>&nbsp;P1&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T1&nbsp;<B>is</B>&nbsp;<B>tagged</B>&nbsp;<B>limited</B>&nbsp;<B>private</B>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Foo(X&nbsp;:&nbsp;<B>in</B>&nbsp;T1'Class);<BR>
<B>private</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T1&nbsp;<B>is</B>&nbsp;<B>tagged</B>&nbsp;<B>null</B>&nbsp;<B>record</B>;&nbsp;--<I>&nbsp;Illegal!</I><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<I>&nbsp;This&nbsp;should&nbsp;say&nbsp;``<B>tagged&nbsp;limited&nbsp;null&nbsp;record</B>''.</I><BR>
<B>end</B>&nbsp;P1;</TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>7.f/1</FONT></DIV>
<DIV Class="SmallExamples"><TT><B>package</B>&nbsp;<B>body</B>&nbsp;P1&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;A&nbsp;<B>is</B>&nbsp;<B>access</B>&nbsp;T1'Class;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Global&nbsp;:&nbsp;A;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>procedure</B>&nbsp;Foo(X&nbsp;:&nbsp;<B>in</B>&nbsp;T1'Class)&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Global&nbsp;:=&nbsp;<B>new</B>&nbsp;T1'Class'(X);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<I>&nbsp;This&nbsp;would&nbsp;be&nbsp;illegal&nbsp;if&nbsp;the&nbsp;full&nbsp;view&nbsp;of</I><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<I>&nbsp;T1&nbsp;were&nbsp;limited,&nbsp;like&nbsp;it's&nbsp;supposed&nbsp;to&nbsp;be.</I><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;<U>Foo</U> <S>A</S>;<BR>
<B>end</B>&nbsp;P1;</TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>7.g</FONT></DIV>
<DIV Class="SmallExamples"><TT><B>with</B>&nbsp;P1;<BR>
<B>package</B>&nbsp;P2&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T2(D&nbsp;:&nbsp;<B>access</B>&nbsp;Integer)&nbsp;--<I>&nbsp;Trouble!</I><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;P1.T1&nbsp;<B>with</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>record</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;My_Task&nbsp;:&nbsp;Some_Task_Type;&nbsp;--<I>&nbsp;More&nbsp;trouble!</I><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;<B>record</B>;<BR>
<B>end</B>&nbsp;P2;</TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>7.h/1</FONT></DIV>
<DIV Class="SmallExamples"><TT><B>with</B>&nbsp;P1;<BR>
<B>with</B>&nbsp;P2;<BR>
<B>procedure</B>&nbsp;Main&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;Local&nbsp;:&nbsp;<B>aliased</B>&nbsp;Integer;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Y&nbsp;:&nbsp;P2.T2(<U>D</U> <S>A</S>&nbsp;=&gt;&nbsp;Local'Access);<BR>
<B>begin</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;P1.Foo(Y);<BR>
<B>end</B>&nbsp;Main;<BR>
&nbsp;&nbsp;</TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>7.i</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">If the above example were legal,
we would have succeeded in making an access value that points to Main.Local
after Main has been left, and we would also have succeeded in doing an
assignment of a task object, both of which are supposed to be no-no's.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>7.j</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">This rule is not needed for
private extensions, because they inherit their limitedness from their
ancestor, and there is a separate rule forbidding limited components
of the corresponding record extension if the parent is nonlimited. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>7.k</FONT></DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><FONT SIZE="-1"><B>Ramification:
</B>A type derived from an untagged private type is untagged, even if
the full view of the parent is tagged, and even at places that can see
the parent: </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>7.l</FONT></DIV>
<DIV Class="SmallExamples"><TT><B>package</B>&nbsp;P&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Parent&nbsp;<B>is</B>&nbsp;<B>private</B>;<BR>
<B>private</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Parent&nbsp;<B>is</B>&nbsp;<B>tagged</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>record</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X:&nbsp;Integer;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;<B>record</B>;<BR>
<B>end</B>&nbsp;P;</TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>7.m/1</FONT></DIV>
<DIV Class="SmallExamples"><TT><U><B>with</B>&nbsp;P;<BR>
</U> <B>package</B>&nbsp;Q&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;<U>P.</U> Parent;<BR>
<B>end</B>&nbsp;Q;</TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>7.n</FONT></DIV>
<DIV Class="SmallExamples"><TT><B>with</B>&nbsp;Q;&nbsp;<B>use</B>&nbsp;Q;<BR>
<B>package</B>&nbsp;<B>body</B>&nbsp;P&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;T'Class&nbsp;...&nbsp;--<I>&nbsp;Illegal!</I><BR>
&nbsp;&nbsp;&nbsp;&nbsp;Object:&nbsp;T;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;Object.X&nbsp;...&nbsp;--<I>&nbsp;Illegal!</I><BR>
&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;Parent(Object).X&nbsp;...&nbsp;--<I>&nbsp;OK.</I><BR>
<B>end</B>&nbsp;P;</TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>7.o</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">The declaration of T declares
an untagged view. This view is always untagged, so T'Class is illegal,
it would be illegal to extend T, and so forth. The component name X is
never visible for this view, although the component is still there --
one can get one's hands on it via a <FONT FACE="Arial, Helvetica">type_conversion</FONT>.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>8</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>ancestor subtype (of a private_extension_declaration)</I>}</FONT>
<A NAME="I3232"></A>The <I>ancestor subtype</I> of a <FONT FACE="Arial, Helvetica">private_extension_declaration</FONT>
is the subtype defined by the <I>ancestor_</I><FONT FACE="Arial, Helvetica">subtype_indication</FONT>;
the ancestor type shall be a specific tagged type. The full view of a
private extension shall be derived (directly or indirectly) from the
ancestor type. In addition to the places where Legality Rules normally
apply (see <A HREF="AA-12-3.html">12.3</A>), the requirement that the
ancestor be specific applies also in the private part of an instance
of a generic unit. </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>8.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Reason: </B>This rule allows
the full view to be defined through several intermediate derivations,
possibly from a series of types produced by <FONT FACE="Arial, Helvetica">generic_instantiation</FONT>s.
</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>9</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;If the declaration of a partial view includes
a <FONT FACE="Arial, Helvetica">known_discriminant_part</FONT>, then
the <FONT FACE="Arial, Helvetica">full_type_declaration</FONT> shall
have a fully conforming [(explicit)] <FONT FACE="Arial, Helvetica">known_discriminant_part</FONT>
[(see <A HREF="AA-6-3-1.html">6.3.1</A>, ``<A HREF="AA-6-3-1.html">Conformance
Rules</A>'')]. <FONT SIZE="-1">{<I>full conformance (required)</I>}</FONT>
<A NAME="I3233"></A>[The ancestor subtype may be unconstrained; the parent
subtype of the full view is required to be constrained (see <A HREF="AA-3-7.html">3.7</A>).]
</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>9.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Discussion: </B>If the ancestor
subtype has discriminants, then it is usually best to make it unconstrained.
</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>9.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>If the
partial view has a <FONT FACE="Arial, Helvetica">known_discriminant_part</FONT>,
then the full view has to be a composite, non-array type, since only
such types may have known discriminants. Also, the full view cannot inherit
the discriminants in this case; the <FONT FACE="Arial, Helvetica">known_discriminant_part</FONT>
has to be explicit.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>9.c</FONT></DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><FONT SIZE="-1">That
is, the following is illegal: </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>9.d</FONT></DIV>
<DIV Class="SmallExamples"><TT><B>package</B>&nbsp;P&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T(D&nbsp;:&nbsp;Integer)&nbsp;<B>is</B>&nbsp;<B>private</B>;<BR>
<B>private</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Some_Other_Type;&nbsp;--<I>&nbsp;Illegal!</I><BR>
<B>end</B>&nbsp;P;<BR>
&nbsp;&nbsp;</TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>9.e</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">even if Some_Other_Type has
an integer discriminant called D.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>9.f</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">It is a ramification of this
and other rules that in order for a tagged type to privately inherit
unconstrained discriminants, the private type declaration has to have
an <FONT FACE="Arial, Helvetica">unknown_discriminant_part</FONT>. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>10</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;If a private extension inherits known discriminants
from the ancestor subtype, then the full view shall also inherit its
discriminants from the ancestor subtype, and the parent subtype of the
full view shall be constrained if and only if the ancestor subtype is
constrained. </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>10.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Reason: </B>The first part
ensures that the full view has the same discriminants as the partial
view. The second part ensures that if the partial view is unconstrained,
then the full view is also unconstrained; otherwise, a client might constrain
the partial view in a way that conflicts with the constraint on the full
view. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>11</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;[If a partial view has unknown discriminants,
then the <FONT FACE="Arial, Helvetica">full_type_declaration</FONT> may
define a definite or an indefinite subtype, with or without discriminants.]</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>12</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;If a partial view has neither known nor unknown
discriminants, then the <FONT FACE="Arial, Helvetica">full_type_declaration</FONT>
shall define a definite subtype.</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>13</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;If the ancestor subtype of a private extension
has constrained discriminants, then the parent subtype of the full view
shall impose a statically matching constraint on those discriminants.
<FONT SIZE="-1">{<I>statically matching (required)</I> [partial]}</FONT>
<A NAME="I3234"></A></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>13.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Ramification: </B>If the
parent type of the full view is not the ancestor type, but is rather
some descendant thereof, the constraint on the discriminants of the parent
type might come from the declaration of some intermediate type in the
derivation chain between the ancestor type and the parent type. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>13.b</FONT></DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><FONT SIZE="-1"><B>Reason:
</B>This prevents the following: </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>13.c</FONT></DIV>
<DIV Class="SmallExamples"><TT><B>package</B>&nbsp;P&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T2&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;T1(Discrim&nbsp;=&gt;&nbsp;3)&nbsp;<B>with</B>&nbsp;<B>private</B>;<BR>
<B>private</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;T2&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;T1(Discrim&nbsp;=&gt;&nbsp;999)&nbsp;--<I>&nbsp;Illegal!</I><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>with</B>&nbsp;<B>record</B>&nbsp;...;<BR>
<B>end</B>&nbsp;P;</TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>13.d</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">The constraints in this example
do not statically match.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>13.e</FONT></DIV>
<DIV Class="Annotations" Style="margin-bottom: 0.4em"><FONT SIZE="-1">If
the constraint on the parent subtype of the full view depends on discriminants
of the full view, then the ancestor subtype has to be unconstrained:
</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>13.f</FONT></DIV>
<DIV Class="SmallExamples"><TT><B>type</B>&nbsp;One_Discrim(A:&nbsp;Integer)&nbsp;<B>is</B>&nbsp;<B>tagged</B>&nbsp;...;<BR>
...<BR>
<B>package</B>&nbsp;P&nbsp;<B>is</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Two_Discrims(B:&nbsp;Boolean;&nbsp;C:&nbsp;Integer)&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;One_Discrim&nbsp;<B>with</B>&nbsp;<B>private</B>;<BR>
<B>private</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<B>type</B>&nbsp;Two_Discrims(B:&nbsp;Boolean;&nbsp;C:&nbsp;Integer)&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;One_Discrim(A&nbsp;=&gt;&nbsp;C)&nbsp;<B>with</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>record</B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>end</B>&nbsp;<B>record</B>;<BR>
<B>end</B>&nbsp;P;</TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>13.g</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">The above example would be illegal
if the private extension said ``is new One_Discrim(A =&gt; C);'', because
then the constraints would not statically match. (Constraints that depend
on discriminants are not static.)</FONT></DIV>

<H4 ALIGN=CENTER>Static Semantics</H4>
<DIV Class="Paranum"><FONT SIZE=-2>14</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>private type</I> [partial]}</FONT>
<A NAME="I3235"></A>A <FONT FACE="Arial, Helvetica">private_type_declaration</FONT>
declares a private type and its first subtype. <FONT SIZE="-1">{<I>private
extension</I> [partial]}</FONT> <A NAME="I3236"></A>Similarly, a <FONT FACE="Arial, Helvetica">private_extension_declaration</FONT>
declares a private extension and its first subtype. </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>14.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Discussion: </B>{<I>package-private
type</I>} <A NAME="I3237"></A>A <I>package-private type</I> is one declared
by a <FONT FACE="Arial, Helvetica">private_type_declaration</FONT>; that
is, a private type other than a generic formal private type. {<I>package-private
extension</I>} <A NAME="I3238"></A>Similarly, a <I>package-private extension</I>
is one declared by a <FONT FACE="Arial, Helvetica">private_extension_declaration</FONT>.
These terms are not used in the RM95 version of this document. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>15</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;A declaration of a partial view and the corresponding
<FONT FACE="Arial, Helvetica">full_type_declaration</FONT> define two
views of a single type. The declaration of a partial view together with
the visible part define the operations that are available to outside
program units; the declaration of the full view together with the private
part define other operations whose direct use is possible only within
the declarative region of the package itself. <FONT SIZE="-1">{<I>characteristics</I>}</FONT>
<A NAME="I3239"></A>Moreover, within the scope of the declaration of
the full view, the <I>characteristics</I> of the type are determined
by the full view; in particular, within its scope, the full view determines
the classes that include the type, which components, entries, and protected
subprograms are visible, what attributes and other predefined operations
are allowed, and whether the first subtype is static. See <A HREF="AA-7-3-1.html">7.3.1</A>.</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>16</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;A private extension inherits components (including
discriminants unless there is a new <FONT FACE="Arial, Helvetica">discriminant_part</FONT>
specified) and user-defined primitive subprograms from its ancestor type,
in the same way that a record extension inherits components and user-defined
primitive subprograms from its parent type (see <A HREF="AA-3-4.html">3.4</A>).
</DIV>
<DIV Class="Paranum"><FONT SIZE=-2>16.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>To be honest: </B>If an operation
of the parent type is abstract, then the abstractness of the inherited
operation is different for nonabstract record extensions than for nonabstract
private extensions (see <A HREF="AA-3-9-3.html">3.9.3</A>). </FONT></DIV>

<H4 ALIGN=CENTER>Dynamic Semantics</H4>
<DIV Class="Paranum"><FONT SIZE=-2>17</FONT></DIV>
<DIV Class="Normal">&nbsp;&nbsp;&nbsp;&nbsp;<FONT SIZE="-1">{<I>elaboration (private_type_declaration)</I>
[partial]}</FONT> <A NAME="I3240"></A>The elaboration of a <FONT FACE="Arial, Helvetica">private_type_declaration</FONT>
creates a partial view of a type. <FONT SIZE="-1">{<I>elaboration (private_extension_declaration)</I>
[partial]}</FONT> <A NAME="I3241"></A>The elaboration of a <FONT FACE="Arial, Helvetica">private_extension_declaration</FONT>
elaborates the <I>ancestor_</I><FONT FACE="Arial, Helvetica">subtype_indication</FONT>,
and creates a partial view of a type. </DIV>
<DIV Class="NotesHeader"><FONT SIZE="-1">NOTES</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>18</FONT></DIV>
<DIV Class="Notes"><FONT SIZE="-1">5&nbsp;&nbsp;The partial view of a
type as declared by a <FONT FACE="Arial, Helvetica">private_type_declaration</FONT>
is defined to be a composite view (in <A HREF="AA-3-2.html">3.2</A>).
The full view of the type might or might not be composite. A private
extension is also composite, as is its full view.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>19</FONT></DIV>
<DIV Class="Notes"><FONT SIZE="-1">6&nbsp;&nbsp;Declaring a private type
with an <FONT FACE="Arial, Helvetica">unknown_discriminant_part</FONT>
is a way of preventing clients from creating uninitialized objects of
the type; they are then forced to initialize each object by calling some
operation declared in the visible part of the package. If such a type
is also limited, then no objects of the type can be declared outside
the scope of the <FONT FACE="Arial, Helvetica">full_type_declaration</FONT>,
restricting all object creation to the package defining the type. This
allows complete control over all storage allocation for the type. Objects
of such a type can still be passed as parameters, however. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>19.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1"><B>Discussion: </B>{<I>generic
contract/private type contract analogy</I>} <A NAME="I3242"></A>Packages
with private types are analogous to generic packages with formal private
types, as follows: The declaration of a package-private type is like
the declaration of a formal private type. The visible part of the package
is like the generic formal part; these both specify a contract (that
is, a set of operations and other things available for the private type).
The private part of the package is like an instantiation of the generic;
they both give a <FONT FACE="Arial, Helvetica">full_type_declaration</FONT>
that specifies implementation details of the private type. The clients
of the package are like the body of the generic; usage of the private
type in these places is restricted to the operations defined by the contract.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>19.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">In other words, being inside
the package is like being outside the generic, and being outside the
package is like being inside the generic; a generic is like an ``inside-out''
package.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>19.c</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">This analogy also works for
private extensions in the same inside-out way.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>19.d</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">Many of the legality rules are
defined with this analogy in mind. See, for example, the rules relating
to operations of [formal] derived types.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>19.e</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">The completion rules for a private
type are intentionally quite similar to the matching rules for a generic
formal private type.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>19.f</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">This analogy breaks down in
one respect: a generic actual subtype is a subtype, whereas the full
view for a private type is always a new type. (We considered allowing
the completion of a <FONT FACE="Arial, Helvetica">private_type_declaration</FONT>
to be a <FONT FACE="Arial, Helvetica">subtype_declaration</FONT>, but
the semantics just won't work.) This difference is behind the fact that
a generic actual type can be class-wide, whereas the completion of a
private type always declares a specific type. </FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>20</FONT></DIV>
<DIV Class="Notes"><FONT SIZE="-1">7&nbsp;&nbsp;The ancestor type specified
in a <FONT FACE="Arial, Helvetica">private_extension_declaration</FONT>
and the parent type specified in the corresponding declaration of a record
extension given in the private part need not be the same -- the parent
type of the full view can be any descendant of the ancestor type. In
this case, for a primitive subprogram that is inherited from the ancestor
type and not overridden, the formal parameter names and default expressions
(if any) come from the corresponding primitive subprogram of the specified
ancestor type, while the body comes from the corresponding primitive
subprogram of the parent type of the full view. See <A HREF="AA-3-9-2.html">3.9.2</A>.
</FONT></DIV>

<H4 ALIGN=CENTER>Examples</H4>
<DIV Class="Paranum"><FONT SIZE=-2>21</FONT></DIV>
<DIV Class="Normal" Style="margin-bottom: 0.4em">&nbsp;&nbsp;&nbsp;&nbsp;<I>Examples of
private type declarations:</I> </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>22</FONT></DIV>
<DIV Class="Examples"><TT><B>type</B>&nbsp;Key&nbsp;<B>is</B>&nbsp;<B>private</B>;<BR>
<B>type</B>&nbsp;File_Name&nbsp;<B>is</B>&nbsp;<B>limited</B>&nbsp;<B>private</B>;</TT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>23</FONT></DIV>
<DIV Class="Wide" Style="margin-bottom: 0.4em">&nbsp;&nbsp;&nbsp;&nbsp;<I>Example of a private
extension declaration:</I> </DIV>
<DIV Class="Paranum"><FONT SIZE=-2>24</FONT></DIV>
<DIV Class="Examples"><TT><B>type</B>&nbsp;List&nbsp;<B>is</B>&nbsp;<B>new</B>&nbsp;Ada.Finalization.Controlled&nbsp;<B>with</B>&nbsp;<B>private</B>;</TT></DIV>

<H4 ALIGN=CENTER>Extensions to Ada 83</H4>
<DIV Class="Paranum"><FONT SIZE=-2>24.a</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">{<I>extensions to Ada 83</I>}
<A NAME="I3243"></A>The syntax for a <FONT FACE="Arial, Helvetica">private_type_declaration</FONT>
is augmented to allow the reserved word <B>tagged</B>.</FONT></DIV>
<DIV Class="Paranum"><FONT SIZE=-2>24.b</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">In Ada 83, a private type without
discriminants cannot be completed with a type with discriminants. Ada
95 allows the full view to have discriminants, so long as they have defaults
(that is, so long as the first subtype is definite). This change is made
for uniformity with generics, and because the rule as stated is simpler
and easier to remember than the Ada 83 rule. In the original version
of Ada 83, the same restriction applied to generic formal private types.
However, the restriction was removed by the ARG for generics. In order
to maintain the ``generic contract/private type contract analogy'' discussed
above, we have to apply the same rule to package-private types. Note
that a private untagged type without discriminants can be completed with
a tagged type with discriminants only if the full view is constrained,
because discriminants of tagged types cannot have defaults. </FONT></DIV>

<H4 ALIGN=CENTER>Wording Changes from Ada 83</H4>
<DIV Class="Paranum"><FONT SIZE=-2>24.c</FONT></DIV>
<DIV Class="Annotations"><FONT SIZE="-1">RM83-7.4.1(4), ``Within the
specification of the package that declares a private type and before
the end of the corresponding full type declaration, a restriction applies....'',
is subsumed (and corrected) by the rule that a type shall be completely
defined before it is frozen, and the rule that the parent type of a derived
type declaration shall be completely defined, unless the derived type
is a private extension. </FONT></DIV>

<HR>
<P><A HREF="AA-TOC.html">Contents</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-0-29.html">Index</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-SRCH.html">Search</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-7-2.html">Previous</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-7-3-1.html">Next</A>&nbsp;&nbsp;&nbsp;<A HREF="AA-TTL.html">Legal</A></P>
</BODY>
</HTML>
