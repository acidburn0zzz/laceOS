<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML><HEAD>
<TITLE>Ada 83 LRM, Sec 6.4: Subprogram Calls</TITLE>
</HEAD><BODY>
<hr><a href="ada_lrm.html"><IMG SRC="adass.gif" align=LEFT hspace=6 vspace=6 alt="Lady Ada"></a><H1>Ada '83 Language Reference Manual</H1>
<h6><a href="ada_legal.html">Copyright</a> 1980, 1982, 1983 owned by the United States Government. Direct reproduction and usage requests to the <a href="mailto://adainfo@sw-eng.falls-church.va.us">Ada Information Clearinghouse</a>.</h6>
<br clear=LEFT>
<hr>

<H2><A NAME="6.4">6.4</A>.  Subprogram Calls  </H2>
<A HREF="lrm-06-03.html#6.3"><img src="lrm-prev.gif" alt="[PREVIOUS]"></A><A HREF="lrm-06.html#6"><img src="lrm-up.gif" alt="[UP]"></A><A HREF="lrm-06-05.html#6.5"><img src="lrm-next.gif" alt="[NEXT]"></A>
<P>
A  subprogram call is either a procedure call statement or a function call;
it invokes the execution of the corresponding subprogram  body.   The  call
specifies  the  association  of  the actual parameters, if any, with formal
parameters of the subprogram. 
<pre>
    procedure_call_statement ::=
        procedure_name [actual_parameter_part]; 

    function_call ::=
        function_name [actual_parameter_part] 

    actual_parameter_part ::=
        (parameter_association {, parameter_association}) 

    parameter_association ::=
       [formal_parameter =&gt;] actual_parameter 

    formal_parameter ::= parameter_simple_name 

    actual_parameter ::=
       expression | variable_name | type_mark(variable_name)  
</pre>
<P>
Each  parameter  association  associates  an  actual   parameter   with   a
corresponding  formal  parameter.   A  parameter  association is said to be
named if the formal parameter is named explicitly;  it is otherwise said to
be  positional.   For  a  positional  association,  the  actual   parameter
corresponds  to  the  formal parameter with the same position in the formal
part. 
<P>
Named associations can be given in any order, but if  both  positional  and
named  associations are used in the same call, positional associations must
occur first, at their normal position.  Hence once a named  association  is
used, the rest of the call must use only named associations. 
<P>
For  each  formal parameter of a subprogram, a subprogram call must specify
exactly one corresponding  actual  parameter.   This  actual  parameter  is
specified either explicitly, by a parameter association, or, in the absence
of such an association, by a default expression (see <a href="#6.4.2">6.4.2</a>). 
<P>
The parameter associations of a subprogram call are evaluated in some order
that  is not defined by the language.  Similarly, the language rules do not
define in which order the values of in out or  out  parameters  are  copied
back into the corresponding actual parameters (when this is done). 
<P>
Examples of procedure calls: 
<pre>
  TRAVERSE_TREE;                                               --  see <a href="lrm-06-01.html#6.1">6.1</a>
  TABLE_MANAGER.INSERT(E);                                     --  see <a href="lrm-07-05.html#7.5">7.5</a>
  PRINT_HEADER(128, TITLE, TRUE);                              --  see <a href="lrm-06-01.html#6.1">6.1</a>

  SWITCH(FROM =&gt; X, TO =&gt; NEXT);                               --  see <a href="lrm-06-01.html#6.1">6.1</a>
  PRINT_HEADER(128, HEADER =&gt; TITLE, CENTER =&gt; TRUE            --  see <a href="lrm-06-01.html#6.1">6.1</a>
  PRINT_HEADER(HEADER =&gt; TITLE, CENTER =&gt; TRUE, PAGES =&gt; 128); --  see <a href="lrm-06-01.html#6.1">6.1</a>
</pre>
<P>
Examples of function calls: 
<pre>
    DOT_PRODUCT(U, V)   --  see <a href="lrm-06-01.html#6.1">6.1</a> and <a href="lrm-06-05.html#6.5">6.5</a> 
    CLOCK               --  see <a href="lrm-09-06.html#9.6">9.6</a>                                                   
</pre>
<P>
<b>References:</b>   <A HREF="lrm-06-01.html#6.1">default expression for a formal parameter</A>,
<A HREF="lrm-01-06.html#1.6">erroneous</A>,
<A HREF="lrm-04-04.html#4.4">expression</A>,
<A HREF="lrm-06-01.html#6.1">formal parameter</A>,
<A HREF="lrm-06-01.html#6.1">formal part</A>,
<A HREF="lrm-04-01.html#4.1">name</A>,
<A HREF="lrm-04-01.html#4.1">simple name</A>,
<A HREF="lrm-06.html#6">subprogram</A>,
<A HREF="lrm-03-03.html#3.3.2">type mark</A>,
<A HREF="lrm-03-02.html#3.2.1">variable</A>.
<P>
<b>Rationale references:</b> 
<a href="http://archive.adaic.com/standards/83rat/html/ratl-08-02.html#8.2">8.2&nbsp;Parameter Modes</a>,
<a href="http://archive.adaic.com/standards/83rat/html/ratl-08-03.html#8.3">8.3&nbsp;Parameter Passing Notations</a>,
<a href="http://archive.adaic.com/standards/83rat/html/ratl-08-04.html#8.4">8.4&nbsp;Function Subprograms</a>
<p>
<b>Style Guide references:</b> 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-02-01.html#2.1.1">2.1.1&nbsp;Horizontal Spacing</a>, 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-04-01.html#4.1.3">4.1.3&nbsp;Functions</a>, 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-05-02.html#5.2.2">5.2.2&nbsp;Named Association</a>, 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-05-06.html#5.6.6">5.6.6&nbsp;Recursion and Iteration Bounds</a>, 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-05-09.html#5.9.3">5.9.3&nbsp;Dependence on Parameter Passing Mechanism</a>
<p>
<b>Sub-topics:</b>
<ul>
<li><A HREF="#6.4.1">6.4.1</A> Parameter Associations  
<li><A HREF="#6.4.2">6.4.2</A> Default Parameters  
</ul>
<H3><A NAME="6.4.1">6.4.1</A>.  Parameter Associations  </H3>
<A HREF="#6.4"><img src="lrm-up.gif" alt="[UP]"></A><A HREF="#6.4.2"><img src="lrm-next.gif" alt="[NEXT]"></A>
<P>
Each  actual  parameter must have the same type as the corresponding formal
parameter. 
<P>
An actual parameter associated with a formal parameter of mode in  must  be
an expression;  it is evaluated before the call. 
<P>
An  actual  parameter  associated with a formal parameter of mode in out or
out must be either the name of a  variable,  or  of  the  form  of  a  type
conversion  whose  argument is the name of a variable.  In either case, for
the mode in out, the variable must not be a formal parameter of mode out or
a subcomponent thereof.  For an actual parameter that has  the  form  of  a
type conversion, the type mark must conform (see <a href="lrm-06-03.html#6.3.1">6.3.1</a>) to the type mark of
he formal parameter;  the allowed operand and target types are the same as
for type conversions (see <a href="lrm-04-06.html#4.6">4.6</a>). 
<P>
The  variable  name  given for an actual parameter of mode in out or out is
evaluated before the call.  If the actual parameter has the form of a  type
conversion,  then  before  the  call,  for  a parameter of mode in out, the
variable is converted to the specified type;  after (normal) completion  of
the  subprogram  body,  for  a  parameter of mode in out or out, the formal
parameter is converted back  to  the  type  of  the  variable.   (The  type
specified in the conversion must be that of the formal parameter.) 
<P>
The  following constraint checks are performed for parameters of scalar and
access types: 
<ul>
<li>Before the call:  for a parameter of mode in or in out, it is  checked
that  the  value of the actual parameter belongs to the subtype of the
formal parameter. 
<li>After (normal) completion of the subprogram body:  for a parameter  of
mode  in  out  or  out,  it  is  checked  that the value of the formal
parameter belongs to the subtype of the actual variable.  In the  case
of  a  type conversion, the value of the formal parameter is converted
back and the check applies to the result of the conversion. 
</ul>
<P>
In each of the above cases, the execution of the program  is  erroneous  if
the checked value is undefined. 
<P>
For  other  types,  for  all  modes, a check is made before the call as for
scalar and access types;  no check is made upon return. 
<P>
The exception CONSTRAINT_ERROR is raised at the  place  of  the  subprogram
call if either of these checks fails.   
<P>
Note: 
<P>
For array types and for types with discriminants, the check before the call
is  sufficient (a check upon return would be redundant) if the type mark of
the formal parameter denotes a constrained  subtype,  since  neither  array
bounds nor discriminants can then vary.                                                   
<P>
If this type mark denotes an unconstrained array type, the formal parameter
is constrained with the bounds of the corresponding actual parameter and no
check  (neither  before  the  call  nor upon return) is needed (see <a href="lrm-03-06.html#3.6.1">3.6.1</a>).
Similarly, no check is needed if the type  mark  denotes  an  unconstrained
type  with  discriminants,  since  the formal parameter is then constrained   
exactly as the corresponding actual parameter (see <a href="lrm-03-07.html#3.7.1">3.7.1</a>). 
<P>
<b>References:</b>  <A HREF="#6.4">actual parameter</A>,
<A HREF="lrm-03-06.html#3.6">array bound</A>,
<A HREF="lrm-03-06.html#3.6">array type</A>,
<A HREF="#6.4">call of a subprogram</A>,
<A HREF="lrm-06-03.html#6.3.1">conform</A>,
<A HREF="lrm-03-03.html#3.3">constrained subtype</A>,
<A HREF="lrm-03-03.html#3.3">constraint</A>,
<A HREF="lrm-11-01.html#11.1">constraint_error   exception</A>,
<A HREF="lrm-03-07.html#3.7.1">discriminant</A>,
<A HREF="lrm-01-06.html#1.6">erroneous</A>,
<A HREF="lrm-04-05.html#4.5">evaluation</A>,
<A HREF="lrm-04-01.html#4.1">evaluation of a name</A>,
<A HREF="lrm-04-04.html#4.4">expression</A>,
<A HREF="lrm-06-01.html#6.1">formal  parameter</A>,
<A HREF="lrm-06-01.html#6.1">mode</A>,
<A HREF="lrm-04-01.html#4.1">name</A>,
<A HREF="#6.4">parameter association</A>,
<A HREF="lrm-03-03.html#3.3">subtype</A>,
<A HREF="lrm-03-03.html#3.3">type</A>,
<A HREF="lrm-04-06.html#4.6">type conversion</A>,
<A HREF="lrm-03-03.html#3.3.2">type  mark</A>,
<A HREF="lrm-03-06.html#3.6">unconstrained  array  type</A>,
<A HREF="lrm-03-07.html#3.7.1">unconstrained   type  with  discriminants</A>,
<A HREF="lrm-03-02.html#3.2.1">undefined  value</A>,
<A HREF="lrm-03-02.html#3.2.1">variable</A>.
<P>
<b>Style Guide references:</b> 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-05-02.html#5.2.2">5.2.2&nbsp;Named Association</a>, 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-05-09.html#5.9.8">5.9.8&nbsp;Incorrect Order Dependencies</a>

<H3><A NAME="6.4.2">6.4.2</A>.  Default Parameters  </H3>
<A HREF="#6.4.1"><img src="lrm-prev.gif" alt="[PREVIOUS]"></A><A HREF="#6.4"><img src="lrm-up.gif" alt="[UP]"></A>
<P>
If a parameter specification includes a default expression for a  parameter
of  mode  in,  then  corresponding  subprogram  calls  need  not  include a
parameter association for the parameter.  If  a  parameter  association  is
thus  omitted from a call, then the rest of the call, following any initial
positional associations, must use only named associations. 
<P>
For any omitted parameter association, the default expression is  evaluated
before  the  call  and  the  resulting  value is used as an implicit actual
parameter. 
<P>
Examples of procedures with default values: 
<pre>
    procedure ACTIVATE(PROCESS : in PROCESS_NAME;
                       AFTER   : in PROCESS_NAME := NO_PROCESS;
                       WAIT    : in DURATION := 0.0;
                       PRIOR   : in BOOLEAN := FALSE); 

    procedure PAIR(LEFT, RIGHT : PERSON_NAME := new PERSON); 
</pre>
<P>
Examples of their calls: 
<pre>
    ACTIVATE(X);
    ACTIVATE(X, AFTER =&gt; Y);
    ACTIVATE(X, WAIT =&gt; 60.0, PRIOR =&gt; TRUE);
    ACTIVATE(X, Y, 10.0, FALSE); 

    PAIR;
    PAIR(LEFT =&gt; new PERSON, RIGHT =&gt; new PERSON);
</pre>
<P>
Note: 
<P>
If a default expression is used for two or more parameters  in  a  multiple
parameter  specification, the default expression is evaluated once for each  
omitted parameter.  Hence in the above examples, the two calls of PAIR  are
equivalent. 
<P>
<b>References:</b>   <A HREF="#6.4.1">actual  parameter</A>,
<A HREF="lrm-06-01.html#6.1">default  expression  for  a formal parameter</A>,
<A HREF="lrm-04-05.html#4.5">evaluation</A>,
<A HREF="lrm-06-01.html#6.1">formal  parameter</A>,
<A HREF="lrm-06-01.html#6.1">mode</A>,
<A HREF="#6.4">named parameter   association</A>,
<A HREF="#6.4">parameter   association</A>,
<A HREF="lrm-06-01.html#6.1">parameter specification</A>,
<A HREF="#6.4">positional parameter association</A>,
<A HREF="#6.4">subprogram  call</A>.
<P>

<b>Style Guide references:</b> 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-05-02.html#5.2.2">5.2.2&nbsp;Named Association</a>, 
<A HREF="http://archive.adaic.com/docs/style-guide/83style/html/sty-05-02.html#5.2.3">5.2.3&nbsp;Default Parameters</a>
<p>

<A HREF="lrm-IDX.html"><img src="lrm-idx.gif" alt="[INDEX]"></A><A HREF="lrm-TOC.html"><img src="lrm-toc.gif" alt="[CONTENTS]"></A>

<hr>
<address><a href="http://sw-eng.falls-church.va.us/AdaIC/"><IMG SRC="small_adaic_logo.gif" ALT="[Ada Information Clearinghouse]"></a><p>
Address any questions or comments to
<A HREF="mailto://adainfo@sw-eng.falls-church.va.us">adainfo@sw-eng.falls-church.va.us</A>.</address>
</BODY></HTML>
