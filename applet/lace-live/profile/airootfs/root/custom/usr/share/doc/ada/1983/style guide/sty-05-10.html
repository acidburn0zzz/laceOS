<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML><HEAD>
<TITLE>Ada '83 Quality and Style, Sec 5.10: Chapter 5 Summary
</TITLE>
</HEAD><BODY>

<a href="http://sw-eng.falls-church.va.us/AdaIC/"><IMG SRC="small_adaic_logo.gif" ALT="[Ada Information Clearinghouse]"></a>
<hr>
<H1>Ada '83 Quality and Style:</h1>
<h2>Guidelines for Professional Programmers</H2>
<h6><a href="sty-00.html">Copyright</a> 1989, 1991,1992
<a href="http://software.org/">Software Productivity Consortium, Inc.</a>, Herndon, Virginia.</h6>
<hr>
<H2>CHAPTER 5: Programming Practices</H2>

<H3><a name="5.10">Chapter 5 Summary</a></H3>

<center><TABLE BORDER CELLPADDING=6>
   <TR>
      <TD>
<b><font size=+1>In this section...</font><br>
<a href="#5.10.1">5.1 optional parts of the syntax</a><BR>
<a href="#5.10.2">5.2 parameter lists</a><BR>
<a href="#5.10.3">5.3 types</a><BR>
<a href="#5.10.4">5.4 data structures</a><BR>
<a href="#5.10.5">5.5 expressions</a><BR>
<a href="#5.10.6">5.6 statements</a><BR>
<a href="#5.10.7">5.7 visibility</a><BR>
<a href="#5.10.8">5.8 using exceptions</a><BR>
<a href="#5.10.9">5.9 erroneous execution</a><BR>
</b>
     </TD>
   </TR>
</TABLE></center>


<H4><a name="5.10.1">5.1 optional parts of the syntax</a></H4>
<UL>
<li>Associate names with loops when they are nested. 
<li>Associate names with blocks when they are nested. 
<li>Use loop names on all exit statements from nested loops. 
<li>Include the simple name at the end of a package specification and body. 
<li>Include the simple name at the end of a task specification and body. 
<li>Include the simple name at the end of an accept statement. 
<li>Include the designator at the end of a subprogram body.  
</UL>

<H4><a name="5.10.2">5.2 parameter lists</a></H4>
<UL>
<li>Name formal parameters descriptively to reduce the need for comments. 
<li>Use named parameter association in calls of infrequently used  
subprograms or entries with many formal parameters. 
<li>Use named association when instantiating generics. 
<li>Use named association for clarification when the actual parameter is  
any literal or expression. 
<li>Use named association when supplying a nondefault value to an optional  parameter. 
<li>Provide default parameters to allow for occasional, special use of  
widely used subprograms or entries. 
<li>Place default parameters at the end of the formal parameter list. 
<li>Consider providing default values to new parameters added to an  
existing subprogram. 
<li>Show the mode indication of all procedure and entry parameters. 
<li>Use <CODE>in out</CODE> only when the parameter is both read from and updated. 
</UL>

<H4><a name="5.10.3">5.3 types</a></H4>
<UL>
<li>Use existing types as building blocks by deriving new types from them. 
<li>Use range constraints on subtypes. 
<li>Define new types, especially derived types, to include the largest set  of possible values, including boundary values. 
<li> Constrain the ranges of derived types with subtypes, excluding 
boundary values. 
<li>Avoid anonymous types. 
<li>Use anonymous types for array variables when no suitable type exists  
and the array will not be referenced as a whole. 
<li>Use limited private types in preference to private types.  
<li>Use private types in preference to nonprivate types. 
<li>Explicitly export needed operations rather than easing restrictions. 
</UL>

<H4><a name="5.10.4">5.4 data structures</a></H4>
<UL>
<li>Use records to group heterogeneous but related data. 
<li>Consider records to map to I/O device data. 
<li>Record structures should not always be flat. Factor out common parts. 
<li>For a large record structure, group related components into smaller  
subrecords. 
<li>For nested records, pick element names that read well when inner  
elements are referenced. 
<li>Differentiate between static and dynamic data. Use dynamically  
allocated objects with caution. 
<li>Use dynamically allocated data structures only when it is necessary to  create and destroy them dynamically or to be able to reference them by  
different names. 
<li>Do not drop pointers to undeallocated objects. 
<li>Do not leave dangling references to deallocated objects. 
<li>Initialize all access variables and components within a record. 
<li>Do not rely on memory deallocation. 
<li>Deallocate explicitly. 
<li>Use length clauses to specify total allocation size. 
<li>Provide handlers for <CODE>Storage_Error</CODE>. 
</UL>

<H4><a name="5.10.5">5.5 expressions</a></H4>
<UL>
<li>Use <CODE>'First</CODE> or <CODE>'Last</CODE> instead of numeric literals to represent the first  or last values of a range. 
<li>Use the type or subtype name of the range instead of <CODE>'First .. 'Last</CODE>. 
<li>Use array attributes <CODE>'First</CODE>, <CODE>'Last</CODE>, or <CODE>'Length</CODE> instead of numeric  
literals for accessing arrays. 
<li> Use the <CODE>'Range</CODE> of the array instead of the name of the index subtype 
to express a range. 
<li>Use <CODE>'Range</CODE> instead of <CODE>'first .. 'Last</CODE> to express a range. 
<li>Use parentheses to specify the order of subexpression evaluation to  
clarify expressions. 
<li>Use parentheses to specify the order of evaluation for subexpressions  
whose correctness depends on left to right evaluation. 
<li>Avoid names and constructs that rely on the use of negatives. 
<li>Choose names of flags so they represent states that can be used in  
positive form. 
<li>Use short-circuit forms of the logical operators. 
<li>Use <CODE>&lt;=</CODE> and <CODE>&gt;=</CODE> in relational expressions with real operands instead of  <CODE>=</CODE>. 
</UL>

<H4><a name="5.10.6">5.6 statements</a></H4>
<UL>
<li>Minimize the depth of nested expressions. 
<li>Minimize the depth of nested control structures. 
<li>Try simplification heuristics. 
<li>Use slices rather than a loop to copy part of an array. 
<li>Never use an <CODE>others</CODE> choice in a case statement. 
<li>Do not use ranges of enumeration literals in case statements. 
<li>Use for loops whenever possible. 
<li> Use while loops when the number of iterations cannot be calculated 
before entering the loop, but a simple continuation condition can be applied 
at the top of the loop. 
<li>Use plain loops with exit statements for more complex situations. 
<li>Avoid exit statements in while and for loops. 
<li>Minimize the number of ways to exit a loop. 
<li>Use exit statements to enhance the readability of loop termination  
code. 
<li>Use <CODE>exit when ...</CODE> rather than <CODE>if ... then exit</CODE> whenever possible. 
<li>Review exit statement placement. 
<li>Consider specifying bounds on loops. 
<li>Consider specifying bounds on recursion. 
<li>Do not use goto statements. 
<li>Minimize the number of returns from a subprogram. 
<li>Highlight returns with comments or white space to keep them from being  lost in other code.  
<li>Use blocks to localize the scope of declarations. 
<li>Use blocks to perform local renaming. 
<li>Use blocks to define local exception handlers. 
<li>Use an aggregate instead of a sequence of assignments to assign values  to all components of a record. 
<li> Use an aggregate instead of a temporary variable when building a 
record to pass as an actual parameter. 
<li>Use positional association only when there is a conventional ordering  
of the arguments. 
</UL>

<H4><a name="5.10.7">5.7 visibility</a></H4>
<UL>
<li>Minimize using the <CODE>use</CODE> clause. 
<li>Consider using the <CODE>use</CODE> clause in the following situations:
<UL TYPE=square>
<li>Infix operators are needed 
<li>Standard packages are needed and no ambiguous references are introduced 
<li>References to enumeration literals are needed 
</UL>
<li>Consider the <CODE>renames</CODE> clause to avoid the <CODE>use</CODE> clause. 
<li>Localize the effect of all <CODE>use</CODE> clauses. 
<li>Rename a long, fully qualified name to reduce the complexity if it  
becomes unwieldy (<a href="sty-03-01.html#3.1.4">Guideline 3.1.4</a>). 
<li>Rename declarations for visibility purposes rather than using the <CODE>use</CODE>  
clause, especially for infix operators (<a href="sty-05-07.html#5.7.1">Guideline 5.7.1</a>). 
<li> Rename parts when interfacing to reusable components originally 
written with nondescriptive or inapplicable nomenclature. 
<li>Use a project-wide standard list of abbreviations to rename common 
packages. 
<li>Limit overloading to widely used subprograms that perform similar  
actions on arguments of different types. 
<li>Preserve the conventional meaning of overloaded operators. 
<li>Use <CODE>&quot;+&quot;</CODE> to identify adding, joining, increasing, and enhancing kinds of functions.  
<li>Use <CODE>&quot;-&quot;</CODE>; to identify subtraction, separation, decreasing, and depleting kinds of functions. 
<li>Do not depend on the definition of equality provided by private types. 
<li>When overloading the equality operator for limited private types,  
maintain the properties of an algebraic equivalence relation. 
</UL>

<H4><a name="5.10.8">5.8 using exceptions</a></H4>
<UL>
<li>Avoid causing exceptions to be raised when it is easy and efficient to  do so. 
<li>Provide handlers for exceptions which cannot be avoided. 
<li>Use exception handlers to enhance readability by separating fault  
handling from normal execution. 
<li>Do not use exceptions and exception handlers as goto statements. 
<li>Use caution when programming handlers for <CODE>others</CODE>. 
<li>Provide a handler for <CODE>others</CODE> in suitable frames to protect against  unexpected exceptions being propagated without bound, especially in safety  critical systems. 
<li>Use <CODE>others</CODE> only to catch exceptions you cannot enumerate explicitly,  preferably only to flag a potential abort. 
<li>Avoid using <CODE>others</CODE> during development. 
<li>Handle all exceptions, both user and predefined. 
<li> For every exception that might be raised, provide a handler in 
suitable frames to protect against undesired propagation outside the abstraction. 
<li>Do not rely on being able to identify the fault raising predefined or  
implementation-defined exceptions. 
<li>Use blocks to associate localized sections of code with their own  
exception handlers. 
</UL>

<H4><a name="5.10.9">5.9 erroneous execution</a></H4>
<UL>
<li>Use <CODE>Unchecked_Conversion</CODE> only with the utmost care.  
<li>Ensure the value resulting from <CODE>Unchecked_Conversion</CODE> is in range. 
<li>Isolate the use of <CODE>Unchecked_Conversion</CODE> in package bodies. 
<li>Isolate the use of <CODE>Unchecked_Deallocation</CODE> in package bodies. 
<li>Do not write code whose correct execution depends on the particular  
parameter passing mechanism used by an implementation. 
<li> Use address clauses to map variables and entries to the hardware 
device or memory, not to model the FORTRAN &quot;equivalence&quot; feature. 
<li>Do not suppress exception checks during development. 
<li>Minimize suppression of exception checks during operation. 
<li>If necessary, introduce blocks that encompass the smallest range of  
statements that can safely have exception checking removed. 
<li>Initialize all objects prior to use. 
<li>Ensure elaboration of an entity before using it. 
<li>Use function calls in declarations cautiously. 
<li>Ensure that values obtained from <CODE>Direct_IO</CODE> and <CODE>Sequential_IO</CODE> are in  
range. 
<li>Avoid depending on the order in which certain constructs in Ada are  
evaluated. 
</UL>
<hr>
<A HREF="index.html">Back to document index</A>
</BODY></HTML>
